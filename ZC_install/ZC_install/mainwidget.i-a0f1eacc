#line 1 "G:/vs2013wk-station/ZC_install/ZC_install/mainwidget.cpp"
#line 1 "<built-in>"
#line 1 "<built-in>"
#line 176 "<built-in>"
#line 1 "<command line>"
#line 1 "<built-in>"
#line 1 "G:/vs2013wk-station/ZC_install/ZC_install/mainwidget.cpp"
#line 1 "./mainwidget.h"



#line 1 "./common.h"
#line 4 "./mainwidget.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QCoreApplication"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcoreapplication.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcoreapplication.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stddef.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stddef.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 67 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\sal.h"
#line 2381 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\sal.h"
extern "C" {
#line 2987 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\sal.h"
}



#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\ConcurrencySal.h"
#line 22 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\ConcurrencySal.h"
extern "C" {
#line 354 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\ConcurrencySal.h"
}
#line 2990 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\sal.h"
#line 67 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"





#pragma pack(push,8)


#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vadefs.h"
#line 28 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vadefs.h"
#pragma pack(push,8)


extern "C" {
#line 50 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vadefs.h"
typedef __w64 unsigned int uintptr_t;
#line 59 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vadefs.h"
typedef char * va_list;
#line 141 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vadefs.h"
}


#pragma pack(pop)
#line 74 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"



extern "C" {
#line 496 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
typedef __w64 unsigned int size_t;






typedef size_t rsize_t;
#line 512 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
typedef __w64 int intptr_t;
#line 530 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
typedef __w64 int ptrdiff_t;
#line 541 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#line 563 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
typedef int errno_t;



typedef __w64 long __time32_t;




typedef __int64 __time64_t;







typedef __time64_t time_t;
#line 637 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
 __declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
 __declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);


__declspec(dllimport) __declspec(noreturn)
void __cdecl _invoke_watson( const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);
#line 2072 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;


typedef struct localerefcount {
        char *locale;
        wchar_t *wlocale;
        int *refcount;
        int *wrefcount;
} locrefcount;

typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned int lc_time_cp;
        locrefcount lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
        wchar_t * locale_name[6];
} threadlocinfo;




}
#line 2148 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#pragma pack(pop)
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stddef.h"



extern "C" {
#line 36 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stddef.h"
namespace std { typedef decltype(__nullptr) nullptr_t; }
using ::std::nullptr_t;





__declspec(dllimport) extern int * __cdecl _errno(void);


errno_t __cdecl _set_errno( int _Value);
errno_t __cdecl _get_errno( int * _Value);
#line 69 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stddef.h"
__declspec(dllimport) extern unsigned long __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);


}
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 59 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qconfig.h"
#line 59 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfeatures.h"
#line 60 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 76 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsystemdetection.h"
#line 76 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qprocessordetection.h"
#line 77 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcompilerdetection.h"
#line 846 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcompilerdetection.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\utility"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstddef"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
#line 21 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 21 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits.h"
#line 17 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 17 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits.h"
#line 22 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"






#pragma pack(push,8)


extern "C" {
#line 52 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
typedef int (__cdecl * _onexit_t)(void);
#line 75 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
typedef struct _div_t {
        int quot;
        int rem;
} div_t;

typedef struct _ldiv_t {
        long quot;
        long rem;
} ldiv_t;

typedef struct _lldiv_t {
        long long quot;
        long long rem;
} lldiv_t;
#line 102 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
#pragma pack(4)
typedef struct {
    unsigned char ld[10];
} _LDOUBLE;
#pragma pack()
#line 122 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
typedef struct {
        double x;
} _CRT_DOUBLE;

typedef struct {
    float f;
} _CRT_FLOAT;





typedef struct {



        long double x;
} _LONGDOUBLE;



#pragma pack(4)
typedef struct {
    unsigned char ld12[12];
} _LDBL12;
#pragma pack()
#line 170 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
__declspec(dllimport) extern int __mb_cur_max;




__declspec(dllimport) int __cdecl ___mb_cur_max_func(void);
__declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t);
#line 215 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
typedef void (__cdecl *_purecall_handler)(void);


__declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler( _purecall_handler _Handler);
__declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(void);



extern "C++"
{





}




typedef void (__cdecl *_invalid_parameter_handler)(const wchar_t *, const wchar_t *, const wchar_t *, unsigned int, uintptr_t);


__declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler( _invalid_parameter_handler _Handler);
__declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);
#line 252 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
__declspec(dllimport) unsigned long * __cdecl __doserrno(void);


errno_t __cdecl _set_doserrno( unsigned long _Value);
errno_t __cdecl _get_doserrno( unsigned long * _Value);


__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char ** __cdecl __sys_errlist(void);


__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int * __cdecl __sys_nerr(void);





__declspec(dllimport) int * __cdecl __p___argc(void);
__declspec(dllimport) char *** __cdecl __p___argv(void);
__declspec(dllimport) wchar_t *** __cdecl __p___wargv(void);
__declspec(dllimport) char *** __cdecl __p__environ(void);
__declspec(dllimport) wchar_t *** __cdecl __p__wenviron(void);


__declspec(dllimport) char ** __cdecl __p__pgmptr(void);
__declspec(dllimport) wchar_t ** __cdecl __p__wpgmptr(void);
#line 288 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
__declspec(dllimport) extern int __argc;
__declspec(dllimport) extern char ** __argv;
__declspec(dllimport) extern wchar_t ** __wargv;
#line 306 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
__declspec(dllimport) extern char ** _environ;
__declspec(dllimport) extern wchar_t ** _wenviron;



__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern char * _pgmptr;
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern wchar_t * _wpgmptr;
#line 339 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
errno_t __cdecl _get_pgmptr( char ** _Value);
errno_t __cdecl _get_wpgmptr( wchar_t ** _Value);





__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) extern int _fmode;






__declspec(dllimport) errno_t __cdecl _set_fmode( int _Mode);
__declspec(dllimport) errno_t __cdecl _get_fmode( int * _PMode);






extern "C++"
{
template <typename _CountofType, size_t _SizeOfArray>
char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

}
#line 376 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
__declspec(dllimport) __declspec(noreturn) void __cdecl exit( int _Code);

__declspec(dllimport) __declspec(noreturn) void __cdecl _exit( int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);


__declspec(dllimport) unsigned int __cdecl _set_abort_behavior( unsigned int _Flags, unsigned int _Mask);

int __cdecl abs( int _X);
long __cdecl labs( long _X);
long long __cdecl llabs( long long _X);

        __int64 __cdecl _abs64(__int64);
#line 426 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
        int __cdecl atexit(void (__cdecl *)(void));

               __declspec(dllimport) double __cdecl atof( const char *_String);
               __declspec(dllimport) double __cdecl _atof_l( const char *_String, _locale_t _Locale);
               __declspec(dllimport) int __cdecl atoi( const char *_Str);
               __declspec(dllimport) int __cdecl _atoi_l( const char *_Str, _locale_t _Locale);
               __declspec(dllimport) long __cdecl atol( const char *_Str);
               __declspec(dllimport) long __cdecl _atol_l( const char *_Str, _locale_t _Locale);
               __declspec(dllimport) long long __cdecl atoll( const char *_Str);
               __declspec(dllimport) long long __cdecl _atoll_l( const char *_Str, _locale_t _Locale);



               __declspec(dllimport) void * __cdecl bsearch_s( const void * _Key, const void * _Base,
             rsize_t _NumOfElements, rsize_t _SizeOfElements,
             int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context);

               __declspec(dllimport) void * __cdecl bsearch( const void * _Key, const void * _Base,
             size_t _NumOfElements, size_t _SizeOfElements,
             int (__cdecl * _PtFuncCompare)(const void *, const void *));


__declspec(dllimport) void __cdecl qsort_s( void * _Base,
             rsize_t _NumOfElements, rsize_t _SizeOfElements,
             int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void *_Context);

__declspec(dllimport) void __cdecl qsort( void * _Base,
             size_t _NumOfElements, size_t _SizeOfElements,
             int (__cdecl * _PtFuncCompare)(const void *, const void *));

                       unsigned short __cdecl _byteswap_ushort( unsigned short _Short);
                       unsigned long __cdecl _byteswap_ulong ( unsigned long _Long);
                       unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64 _Int64);
               __declspec(dllimport) div_t __cdecl div( int _Numerator, int _Denominator);


               __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl getenv( const char * _VarName);

                   __declspec(dllimport) errno_t __cdecl getenv_s( size_t * _ReturnSize, char * _DstBuf, rsize_t _DstSize, const char * _VarName);

extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(size_t * _ReturnSize, char (&_Dest)[_Size], const char * _VarName) throw() { return getenv_s(_ReturnSize, _Dest, _Size, _VarName); } }





                   __declspec(dllimport) errno_t __cdecl _dupenv_s( char **_PBuffer, size_t * _PBufferSizeInBytes, const char * _VarName);






                   __declspec(dllimport) errno_t __cdecl _itoa_s( int _Value, char * _DstBuf, size_t _Size, int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itoa_s(int _Value, char (&_Dest)[_Size], int _Radix) throw() { return _itoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _itoa(int _Value, char *_Dest, int _Radix);
                   __declspec(dllimport) errno_t __cdecl _i64toa_s( __int64 _Val, char * _DstBuf, size_t _Size, int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _i64toa( __int64 _Val, char * _DstBuf, int _Radix);
                   __declspec(dllimport) errno_t __cdecl _ui64toa_s( unsigned __int64 _Val, char * _DstBuf, size_t _Size, int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _ui64toa( unsigned __int64 _Val, char * _DstBuf, int _Radix);
               __declspec(dllimport) __int64 __cdecl _atoi64( const char * _String);
               __declspec(dllimport) __int64 __cdecl _atoi64_l( const char * _String, _locale_t _Locale);
               __declspec(dllimport) __int64 __cdecl _strtoi64( const char * _String, char ** _EndPtr, int _Radix);
               __declspec(dllimport) __int64 __cdecl _strtoi64_l( const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale);
               __declspec(dllimport) unsigned __int64 __cdecl _strtoui64( const char * _String, char ** _EndPtr, int _Radix);
               __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l( const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale);
               __declspec(dllimport) ldiv_t __cdecl ldiv( long _Numerator, long _Denominator);
               __declspec(dllimport) lldiv_t __cdecl lldiv( long long _Numerator, long long _Denominator);

extern "C++"
{
    inline long abs(long _X) throw()
    {
        return labs(_X);
    }
    inline long long abs(long long _X) throw()
    {
        return llabs(_X);
    }
    inline ldiv_t div(long _A1, long _A2) throw()
    {
        return ldiv(_A1, _A2);
    }
    inline lldiv_t div(long long _A1, long long _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}

                   __declspec(dllimport) errno_t __cdecl _ltoa_s( long _Val, char * _DstBuf, size_t _Size, int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(long _Value, char (&_Dest)[_Size], int _Radix) throw() { return _ltoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ltoa(long _Value, char *_Dest, int _Radix);
               __declspec(dllimport) int __cdecl mblen( const char * _Ch, size_t _MaxCount);
               __declspec(dllimport) int __cdecl _mblen_l( const char * _Ch, size_t _MaxCount, _locale_t _Locale);
               __declspec(dllimport) size_t __cdecl _mbstrlen( const char * _Str);
               __declspec(dllimport) size_t __cdecl _mbstrlen_l( const char *_Str, _locale_t _Locale);
               __declspec(dllimport) size_t __cdecl _mbstrnlen( const char *_Str, size_t _MaxCount);
               __declspec(dllimport) size_t __cdecl _mbstrnlen_l( const char *_Str, size_t _MaxCount, _locale_t _Locale);
__declspec(dllimport) int __cdecl mbtowc( wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes);
__declspec(dllimport) int __cdecl _mbtowc_l( wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale);
                   __declspec(dllimport) errno_t __cdecl mbstowcs_s( size_t * _PtNumOfCharConverted, wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount );
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(size_t * _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], const char * _Source, size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest, const char * _Source, size_t _MaxCount);

                   __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l( size_t * _PtNumOfCharConverted, wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(size_t * _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], const char * _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l( wchar_t *_Dest, const char * _Source, size_t _MaxCount, _locale_t _Locale);

               __declspec(dllimport) int __cdecl rand(void);




                   __declspec(dllimport) int __cdecl _set_error_mode( int _Mode);

__declspec(dllimport) void __cdecl srand( unsigned int _Seed);
               __declspec(dllimport) double __cdecl strtod( const char * _Str, char ** _EndPtr);
               __declspec(dllimport) double __cdecl _strtod_l( const char * _Str, char ** _EndPtr, _locale_t _Locale);
               __declspec(dllimport) long __cdecl strtol( const char * _Str, char ** _EndPtr, int _Radix );
               __declspec(dllimport) long __cdecl _strtol_l( const char *_Str, char **_EndPtr, int _Radix, _locale_t _Locale);
               __declspec(dllimport) long long __cdecl strtoll( const char * _Str, char ** _EndPtr, int _Radix );
               __declspec(dllimport) long long __cdecl _strtoll_l( const char * _Str, char ** _EndPtr, int _Radix, _locale_t _Locale );
               __declspec(dllimport) unsigned long __cdecl strtoul( const char * _Str, char ** _EndPtr, int _Radix);
               __declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * _Str, char **_EndPtr, int _Radix, _locale_t _Locale);
               __declspec(dllimport) unsigned long long __cdecl strtoull( const char * _Str, char ** _EndPtr, int _Radix);
               __declspec(dllimport) unsigned long long __cdecl _strtoull_l( const char * _Str, char ** _EndPtr, int _Radix, _locale_t _Locale);
               __declspec(dllimport) long double __cdecl strtold( const char * _Str, char ** _EndPtr);
               __declspec(dllimport) long double __cdecl _strtold_l( const char * _Str, char ** _EndPtr, _locale_t _Locale);
               __declspec(dllimport) float __cdecl strtof( const char * _Str, char ** _EndPtr);
               __declspec(dllimport) float __cdecl _strtof_l( const char * _Str, char ** _EndPtr, _locale_t _Locale);




__declspec(dllimport) int __cdecl system( const char * _Command);



                   __declspec(dllimport) errno_t __cdecl _ultoa_s( unsigned long _Val, char * _DstBuf, size_t _Size, int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(unsigned long _Value, char (&_Dest)[_Size], int _Radix) throw() { return _ultoa_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _ultoa(unsigned long _Value, char *_Dest, int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl wctomb( char * _MbCh, wchar_t _WCh);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) int __cdecl _wctomb_l( char * _MbCh, wchar_t _WCh, _locale_t _Locale);

                   __declspec(dllimport) errno_t __cdecl wctomb_s( int * _SizeConverted, char * _MbCh, rsize_t _SizeInBytes, wchar_t _WCh);

                   __declspec(dllimport) errno_t __cdecl _wctomb_s_l( int * _SizeConverted, char * _MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale);
                   __declspec(dllimport) errno_t __cdecl wcstombs_s( size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const wchar_t * _Src, size_t _MaxCountInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(size_t * _PtNumOfCharConverted, char (&_Dest)[_Size], const wchar_t * _Source, size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest, const wchar_t * _Source, size_t _MaxCount);
                   __declspec(dllimport) errno_t __cdecl _wcstombs_s_l( size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const wchar_t * _Src, size_t _MaxCountInBytes, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(size_t * _PtNumOfCharConverted, char (&_Dest)[_Size], const wchar_t * _Source, size_t _MaxCount, _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l( char *_Dest, const wchar_t * _Source, size_t _MaxCount, _locale_t _Locale);
#line 640 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
                                                                       __declspec(dllimport) __declspec(noalias) __declspec(restrict) void * __cdecl calloc( size_t _Count, size_t _Size);
__declspec(dllimport) __declspec(noalias) void __cdecl free( void * _Memory);
                                                                __declspec(dllimport) __declspec(noalias) __declspec(restrict) void * __cdecl malloc( size_t _Size);

                                                                   __declspec(dllimport) __declspec(noalias) __declspec(restrict) void * __cdecl realloc( void * _Memory, size_t _NewSize);

                                                                       __declspec(dllimport) __declspec(noalias) __declspec(restrict) void * __cdecl _recalloc( void * _Memory, size_t _Count, size_t _Size);
__declspec(dllimport) __declspec(noalias) void __cdecl _aligned_free( void * _Memory);
                                                                __declspec(dllimport) __declspec(noalias) __declspec(restrict) void * __cdecl _aligned_malloc( size_t _Size, size_t _Alignment);
                                                                __declspec(dllimport) __declspec(noalias) __declspec(restrict) void * __cdecl _aligned_offset_malloc( size_t _Size, size_t _Alignment, size_t _Offset);

                                                                   __declspec(dllimport) __declspec(noalias) __declspec(restrict) void * __cdecl _aligned_realloc( void * _Memory, size_t _NewSize, size_t _Alignment);

                                                                       __declspec(dllimport) __declspec(noalias) __declspec(restrict) void * __cdecl _aligned_recalloc( void * _Memory, size_t _Count, size_t _Size, size_t _Alignment);

                                                                   __declspec(dllimport) __declspec(noalias) __declspec(restrict) void * __cdecl _aligned_offset_realloc( void * _Memory, size_t _NewSize, size_t _Alignment, size_t _Offset);

                                                                       __declspec(dllimport) __declspec(noalias) __declspec(restrict) void * __cdecl _aligned_offset_recalloc( void * _Memory, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset);
               __declspec(dllimport) size_t __cdecl _aligned_msize( void * _Memory, size_t _Alignment, size_t _Offset);
#line 685 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
                   __declspec(dllimport) errno_t __cdecl _itow_s ( int _Val, wchar_t * _DstBuf, size_t _SizeInWords, int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(int _Value, wchar_t (&_Dest)[_Size], int _Radix) throw() { return _itow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _itow(int _Value, wchar_t *_Dest, int _Radix);
                   __declspec(dllimport) errno_t __cdecl _ltow_s ( long _Val, wchar_t * _DstBuf, size_t _SizeInWords, int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(long _Value, wchar_t (&_Dest)[_Size], int _Radix) throw() { return _ltow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _ltow(long _Value, wchar_t *_Dest, int _Radix);
                   __declspec(dllimport) errno_t __cdecl _ultow_s ( unsigned long _Val, wchar_t * _DstBuf, size_t _SizeInWords, int _Radix);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(unsigned long _Value, wchar_t (&_Dest)[_Size], int _Radix) throw() { return _ultow_s(_Value, _Dest, _Size, _Radix); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _ultow(unsigned long _Value, wchar_t *_Dest, int _Radix);
               __declspec(dllimport) double __cdecl wcstod( const wchar_t * _Str, wchar_t ** _EndPtr);
               __declspec(dllimport) double __cdecl _wcstod_l( const wchar_t *_Str, wchar_t ** _EndPtr, _locale_t _Locale);
               __declspec(dllimport) long __cdecl wcstol( const wchar_t *_Str, wchar_t ** _EndPtr, int _Radix);
               __declspec(dllimport) long __cdecl _wcstol_l( const wchar_t *_Str, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
               __declspec(dllimport) long long __cdecl wcstoll( const wchar_t *_Str, wchar_t **_EndPtr, int _Radix);
               __declspec(dllimport) long long __cdecl _wcstoll_l( const wchar_t *_Str, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
               __declspec(dllimport) unsigned long __cdecl wcstoul( const wchar_t *_Str, wchar_t ** _EndPtr, int _Radix);
               __declspec(dllimport) unsigned long __cdecl _wcstoul_l( const wchar_t *_Str, wchar_t **_EndPtr, int _Radix, _locale_t _Locale);
               __declspec(dllimport) unsigned long long __cdecl wcstoull( const wchar_t *_Str, wchar_t ** _EndPtr, int _Radix);
               __declspec(dllimport) unsigned long long __cdecl _wcstoull_l( const wchar_t *_Str, wchar_t ** _EndPtr, int _Radix, _locale_t _Locale);
               __declspec(dllimport) long double __cdecl wcstold( const wchar_t * _Str, wchar_t ** _EndPtr);
               __declspec(dllimport) long double __cdecl _wcstold_l( const wchar_t * _Str, wchar_t ** _EndPtr, _locale_t _Locale);
               __declspec(dllimport) float __cdecl wcstof( const wchar_t * _Str, wchar_t ** _EndPtr);
               __declspec(dllimport) float __cdecl _wcstof_l( const wchar_t * _Str, wchar_t ** _EndPtr, _locale_t _Locale);



               __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _wgetenv( const wchar_t * _VarName);
                   __declspec(dllimport) errno_t __cdecl _wgetenv_s( size_t * _ReturnSize, wchar_t * _DstBuf, size_t _DstSizeInWords, const wchar_t * _VarName);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wgetenv_s(size_t * _ReturnSize, wchar_t (&_Dest)[_Size], const wchar_t * _VarName) throw() { return _wgetenv_s(_ReturnSize, _Dest, _Size, _VarName); } }






                   __declspec(dllimport) errno_t __cdecl _wdupenv_s( wchar_t **_Buffer, size_t *_BufferSizeInWords, const wchar_t *_VarName);







__declspec(dllimport) int __cdecl _wsystem( const wchar_t * _Command);




               __declspec(dllimport) double __cdecl _wtof( const wchar_t *_Str);
               __declspec(dllimport) double __cdecl _wtof_l( const wchar_t *_Str, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _wtoi( const wchar_t *_Str);
               __declspec(dllimport) int __cdecl _wtoi_l( const wchar_t *_Str, _locale_t _Locale);
               __declspec(dllimport) long __cdecl _wtol( const wchar_t *_Str);
               __declspec(dllimport) long __cdecl _wtol_l( const wchar_t *_Str, _locale_t _Locale);
               __declspec(dllimport) long long __cdecl _wtoll( const wchar_t *_Str);
               __declspec(dllimport) long long __cdecl _wtoll_l( const wchar_t *_Str, _locale_t _Locale);

                   __declspec(dllimport) errno_t __cdecl _i64tow_s( __int64 _Val, wchar_t * _DstBuf, size_t _SizeInWords, int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _i64tow( __int64 _Val, wchar_t * _DstBuf, int _Radix);
                   __declspec(dllimport) errno_t __cdecl _ui64tow_s( unsigned __int64 _Val, wchar_t * _DstBuf, size_t _SizeInWords, int _Radix);
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) wchar_t * __cdecl _ui64tow( unsigned __int64 _Val, wchar_t * _DstBuf, int _Radix);
               __declspec(dllimport) __int64 __cdecl _wtoi64( const wchar_t *_Str);
               __declspec(dllimport) __int64 __cdecl _wtoi64_l( const wchar_t *_Str, _locale_t _Locale);
               __declspec(dllimport) __int64 __cdecl _wcstoi64( const wchar_t * _Str, wchar_t ** _EndPtr, int _Radix);
               __declspec(dllimport) __int64 __cdecl _wcstoi64_l( const wchar_t * _Str, wchar_t ** _EndPtr, int _Radix, _locale_t _Locale);
               __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64( const wchar_t * _Str, wchar_t ** _EndPtr, int _Radix);
               __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l( const wchar_t *_Str , wchar_t ** _EndPtr, int _Radix, _locale_t _Locale);
#line 770 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
               __declspec(dllimport) char * __cdecl _fullpath( char * _FullPath, const char * _Path, size_t _SizeInBytes);







                   __declspec(dllimport) errno_t __cdecl _ecvt_s( char * _DstBuf, size_t _Size, double _Val, int _NumOfDights, int * _PtDec, int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Dest)[_Size], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign) throw() { return _ecvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
               __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _ecvt( double _Val, int _NumOfDigits, int * _PtDec, int * _PtSign);
                   __declspec(dllimport) errno_t __cdecl _fcvt_s( char * _DstBuf, size_t _Size, double _Val, int _NumOfDec, int * _PtDec, int * _PtSign);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _fcvt_s(char (&_Dest)[_Size], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign) throw() { return _fcvt_s(_Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign); } }
               __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _fcvt( double _Val, int _NumOfDec, int * _PtDec, int * _PtSign);
__declspec(dllimport) errno_t __cdecl _gcvt_s( char * _DstBuf, size_t _Size, double _Val, int _NumOfDigits);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _gcvt_s(char (&_Dest)[_Size], double _Value, int _NumOfDigits) throw() { return _gcvt_s(_Dest, _Size, _Value, _NumOfDigits); } }
__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _gcvt( double _Val, int _NumOfDigits, char * _DstBuf);

               __declspec(dllimport) int __cdecl _atodbl( _CRT_DOUBLE * _Result, char * _Str);
               __declspec(dllimport) int __cdecl _atoldbl( _LDOUBLE * _Result, char * _Str);
               __declspec(dllimport) int __cdecl _atoflt( _CRT_FLOAT * _Result, const char * _Str);
               __declspec(dllimport) int __cdecl _atodbl_l( _CRT_DOUBLE * _Result, char * _Str, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _atoldbl_l( _LDOUBLE * _Result, char * _Str, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _atoflt_l( _CRT_FLOAT * _Result, const char * _Str, _locale_t _Locale);
                       unsigned long __cdecl _lrotl( unsigned long _Val, int _Shift);
                       unsigned long __cdecl _lrotr( unsigned long _Val, int _Shift);
                   __declspec(dllimport) errno_t __cdecl _makepath_s( char * _PathResult, size_t _SizeInWords, const char * _Drive, const char * _Dir, const char * _Filename,
                   const char * _Ext);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Path)[_Size], const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext) throw() { return _makepath_s(_Path, _Size, _Drive, _Dir, _Filename, _Ext); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _makepath( char *_Path, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext);
#line 826 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
        _onexit_t __cdecl _onexit( _onexit_t _Func);




__declspec(dllimport) void __cdecl perror( const char * _ErrMsg);


#pragma warning(push)
#pragma warning(disable: 6540)


 __declspec(dllimport) int __cdecl _putenv( const char * _EnvString);
                   __declspec(dllimport) errno_t __cdecl _putenv_s( const char * _Name, const char * _Value);


        unsigned int __cdecl _rotl( unsigned int _Val, int _Shift);
        unsigned __int64 __cdecl _rotl64( unsigned __int64 _Val, int _Shift);
        unsigned int __cdecl _rotr( unsigned int _Val, int _Shift);
        unsigned __int64 __cdecl _rotr64( unsigned __int64 _Val, int _Shift);
#pragma warning(pop)


__declspec(dllimport) errno_t __cdecl _searchenv_s( const char * _Filename, const char * _EnvVar, char * _ResultPath, size_t _SizeInBytes);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(const char * _Filename, const char * _EnvVar, char (&_ResultPath)[_Size]) throw() { return _searchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _searchenv(const char * _Filename, const char * _EnvVar, char *_ResultPath);


__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _splitpath( const char * _FullPath, char * _Drive, char * _Dir, char * _Filename, char * _Ext);
                   __declspec(dllimport) errno_t __cdecl _splitpath_s( const char * _FullPath,
                                               char * _Drive, size_t _DriveSize,
                                             char * _Dir, size_t _DirSize,
                                                  char * _Filename, size_t _FilenameSize,
                                             char * _Ext, size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s( const char *_Dest, char (&_Drive)[_DriveSize], char (&_Dir)[_DirSize], char (&_Name)[_NameSize], char (&_Ext)[_ExtSize]) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }

__declspec(dllimport) void __cdecl _swab( char * _Buf1, char * _Buf2, int _SizeInBytes);
#line 873 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
               __declspec(dllimport) wchar_t * __cdecl _wfullpath( wchar_t * _FullPath, const wchar_t * _Path, size_t _SizeInWords);





                   __declspec(dllimport) errno_t __cdecl _wmakepath_s( wchar_t * _PathResult, size_t _SIZE, const wchar_t * _Drive, const wchar_t * _Dir, const wchar_t * _Filename,
                   const wchar_t * _Ext);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_ResultPath)[_Size], const wchar_t * _Drive, const wchar_t * _Dir, const wchar_t * _Filename, const wchar_t * _Ext) throw() { return _wmakepath_s(_ResultPath, _Size, _Drive, _Dir, _Filename, _Ext); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath( wchar_t *_ResultPath, const wchar_t * _Drive, const wchar_t * _Dir, const wchar_t * _Filename, const wchar_t * _Ext);


__declspec(dllimport) void __cdecl _wperror( const wchar_t * _ErrMsg);



               __declspec(dllimport) int __cdecl _wputenv( const wchar_t * _EnvString);
                   __declspec(dllimport) errno_t __cdecl _wputenv_s( const wchar_t * _Name, const wchar_t * _Value);
__declspec(dllimport) errno_t __cdecl _wsearchenv_s( const wchar_t * _Filename, const wchar_t * _EnvVar, wchar_t * _ResultPath, size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(const wchar_t * _Filename, const wchar_t * _EnvVar, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv(const wchar_t * _Filename, const wchar_t * _EnvVar, wchar_t *_ResultPath);


__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl _wsplitpath( const wchar_t * _FullPath, wchar_t * _Drive, wchar_t * _Dir, wchar_t * _Filename, wchar_t * _Ext);
__declspec(dllimport) errno_t __cdecl _wsplitpath_s( const wchar_t * _FullPath,
                                               wchar_t * _Drive, size_t _DriveSize,
                                             wchar_t * _Dir, size_t _DirSize,
                                                  wchar_t * _Filename, size_t _FilenameSize,
                                             wchar_t * _Ext, size_t _ExtSize);
extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s( const wchar_t *_Path, wchar_t (&_Drive)[_DriveSize], wchar_t (&_Dir)[_DirSize], wchar_t (&_Name)[_NameSize], wchar_t (&_Ext)[_ExtSize]) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }






__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetErrorMode" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode( int _Mode);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Beep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _beep( unsigned _Frequency, unsigned _Duration);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Sleep" " instead. See online help for details.")) __declspec(dllimport) void __cdecl _sleep( unsigned long _Duration);
#line 932 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4141)
 __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl ecvt( double _Val, int _NumOfDigits, int * _PtDec, int * _PtSign);
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl fcvt( double _Val, int _NumOfDec, int * _PtDec, int * _PtSign);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl gcvt( double _Val, int _NumOfDigits, char * _DstBuf);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl itoa( int _Val, char * _DstBuf, int _Radix);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl ltoa( long _Val, char * _DstBuf, int _Radix);


               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_putenv" ". See online help for details.")) __declspec(dllimport) int __cdecl putenv( const char * _EnvString);


__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_swab" ". See online help for details.")) __declspec(dllimport) void __cdecl swab( char * _Buf1, char * _Buf2, int _SizeInBytes);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl ultoa( unsigned long _Val, char * _Dstbuf, int _Radix);
#pragma warning(pop)
_onexit_t __cdecl onexit( _onexit_t _Func);





}



#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstddef"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstddef"




#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"






#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xkeycheck.h"
#line 7 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 8 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"


#pragma pack(push,8)
#line 205 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
#pragma detect_mismatch("_MSC_VER", "1800")



#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")








#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")
#line 367 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\use_ansi.h"
#line 57 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\use_ansi.h"
#pragma comment(lib, "msvcprt" "" "")
#line 367 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
#line 568 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
namespace std {
typedef bool _Bool;
}
#line 586 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
typedef __int64 _Longlong;
typedef unsigned __int64 _ULonglong;
#line 605 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
typedef unsigned short char16_t;
typedef unsigned int char32_t;
#line 619 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
namespace std {
enum _Uninitialized
 {
 _Noinit
 };



#pragma warning(push)
#pragma warning(disable: 4412)
class __declspec(dllimport) _Lockit
 {
public:
#line 652 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
 __thiscall _Lockit();
 explicit __thiscall _Lockit(int);
 __thiscall ~_Lockit() throw ();


    static void __cdecl _Lockit_ctor(int);
    static void __cdecl _Lockit_dtor(int);

private:
    static void __cdecl _Lockit_ctor(_Lockit *);
    static void __cdecl _Lockit_ctor(_Lockit *, int);
    static void __cdecl _Lockit_dtor(_Lockit *);

public:
                    _Lockit(const _Lockit&) = delete;
 _Lockit& operator=(const _Lockit&) = delete;

private:
 int _Locktype;
#line 685 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
 };
#line 772 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
class __declspec(dllimport) _Init_locks
 {
public:
#line 788 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
    __thiscall _Init_locks();
 __thiscall ~_Init_locks() throw ();


private:
    static void __cdecl _Init_locks_ctor(_Init_locks *);
    static void __cdecl _Init_locks_dtor(_Init_locks *);
#line 805 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
 };

#pragma warning(pop)
}
#line 817 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\yvals.h"
__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));

typedef int _Mbstatet;
typedef unsigned long _Uint32t;








#pragma pack(pop)
#line 5 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstddef"
#line 17 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstddef"
namespace std {
using :: ptrdiff_t; using :: size_t;
}



namespace std {
typedef double max_align_t;
}
#line 7 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstddef"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\initializer_list"







#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

template<class _Elem>
 class initializer_list
 {
public:
 typedef _Elem value_type;
 typedef const _Elem& reference;
 typedef const _Elem& const_reference;
 typedef size_t size_type;

 typedef const _Elem* iterator;
 typedef const _Elem* const_iterator;

 initializer_list() throw ()
  : _First(0), _Last(0)
  {
  }

 initializer_list(const _Elem *_First_arg,
  const _Elem *_Last_arg) throw ()
  : _First(_First_arg), _Last(_Last_arg)
  {
  }

 const _Elem *begin() const throw ()
  {
  return (_First);
  }

 const _Elem *end() const throw ()
  {
  return (_Last);
  }

 size_t size() const throw ()
  {
  return ((size_t)(_Last - _First));
  }

private:
 const _Elem *_First;
 const _Elem *_Last;
 };


template<class _Elem> inline
 const _Elem *begin(initializer_list<_Elem> _Ilist) throw ()
 {
 return (_Ilist.begin());
 }


template<class _Elem> inline
 const _Elem *end(initializer_list<_Elem> _Ilist) throw ()
 {
 return (_Ilist.end());
 }
}


#pragma warning(pop)
#pragma pack(pop)
#line 8 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstddef"


#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtr1common"







#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

template<class _T1,
 class _Ret>
 struct unary_function;


template<class _T1,
 class _T2,
 class _Ret>
 struct binary_function;


struct _Nil
 {
 };
static _Nil _Nil_obj;


template<class _Ty,
 _Ty _Val>
 struct integral_constant
 {
 static const _Ty value = _Val;

 typedef _Ty value_type;
 typedef integral_constant<_Ty, _Val> type;

 operator value_type() const
  {
  return (value);
  }
 };

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;


template<bool>
 struct _Cat_base
  : false_type
 {
 };

template<>
 struct _Cat_base<true>
  : true_type
 {
 };


template<bool _Test,
 class _Ty = void>
 struct enable_if
 {
 };

template<class _Ty>
 struct enable_if<true, _Ty>
 {
 typedef _Ty type;
 };


template<bool _Test,
 class _Ty1,
 class _Ty2>
 struct conditional
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct conditional<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };


template<class _Ty1, class _Ty2>
 struct is_same
  : false_type
 {
 };

template<class _Ty1>
 struct is_same<_Ty1, _Ty1>
  : true_type
 {
 };


template<class _Ty>
 struct remove_const
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_const<const _Ty>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_const<const _Ty[]>
 {
 typedef _Ty type[];
 };

template<class _Ty, unsigned int _Nx>
 struct remove_const<const _Ty[_Nx]>
 {
 typedef _Ty type[_Nx];
 };


template<class _Ty>
 struct remove_volatile
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_volatile<volatile _Ty>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_volatile<volatile _Ty[]>
 {
 typedef _Ty type[];
 };

template<class _Ty, unsigned int _Nx>
 struct remove_volatile<volatile _Ty[_Nx]>
 {
 typedef _Ty type[_Nx];
 };


template<class _Ty>
 struct remove_cv
 {
 typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
  type;
 };


template<class _Ty>
 struct _Is_integral
  : false_type
 {
 };

template<>
 struct _Is_integral<bool>
  : true_type
 {
 };

template<>
 struct _Is_integral<char>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned char>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed char>
  : true_type
 {
 };


template<>
 struct _Is_integral<wchar_t>
  : true_type
 {
 };


template<>
 struct _Is_integral<unsigned short>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed short>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned int>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed int>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned long>
  : true_type
 {
 };

template<>
 struct _Is_integral<signed long>
  : true_type
 {
 };
#line 253 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtr1common"
template<>
 struct _Is_integral<__int64>
  : true_type
 {
 };

template<>
 struct _Is_integral<unsigned __int64>
  : true_type
 {
 };



template<class _Ty>
 struct is_integral
  : _Is_integral<typename remove_cv<_Ty>::type>
 {
 };


template<class _Ty>
 struct _Is_floating_point
  : false_type
 {
 };

template<>
 struct _Is_floating_point<float>
  : true_type
 {
 };

template<>
 struct _Is_floating_point<double>
  : true_type
 {
 };

template<>
 struct _Is_floating_point<long double>
  : true_type
 {
 };


template<class _Ty>
 struct is_floating_point
  : _Is_floating_point<typename remove_cv<_Ty>::type>
 {
 };

template<class _Ty>
 struct _Is_numeric
  : _Cat_base<is_integral<_Ty>::value
   || is_floating_point<_Ty>::value>
 {
 };


template<class _Ty>
 struct remove_reference
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_reference<_Ty&&>
 {
 typedef _Ty type;
 };


template<class _Tgt,
 class _Src>
 struct _Copy_cv
 {
 typedef typename remove_reference<_Tgt>::type _Tgtx;
 typedef _Tgtx& type;
 };

template<class _Tgt,
 class _Src>
 struct _Copy_cv<_Tgt, const _Src>
 {
 typedef typename remove_reference<_Tgt>::type _Tgtx;
 typedef const _Tgtx& type;
 };

template<class _Tgt,
 class _Src>
 struct _Copy_cv<_Tgt, volatile _Src>
 {
 typedef typename remove_reference<_Tgt>::type _Tgtx;
 typedef volatile _Tgtx& type;
 };

template<class _Tgt,
 class _Src>
 struct _Copy_cv<_Tgt, const volatile _Src>
 {
 typedef typename remove_reference<_Tgt>::type _Tgtx;
 typedef const volatile _Tgtx& type;
 };

template<class _Tgt,
 class _Src>
 struct _Copy_cv<_Tgt, _Src&>
 {
 typedef typename _Copy_cv<_Tgt, _Src>::type type;
 };


struct _Wrap_int
 {
 _Wrap_int(int)
  {
  }
 };

template<class _Ty>
 struct _Identity
 {
 typedef _Ty type;
 };
#line 419 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtr1common"
template<class _Ty>
 struct _Has_result_type
  { template<class _Uty> static auto _Fn(int, _Identity<typename _Uty::result_type> * = 0, _Identity<typename _Uty::result_type> * = 0, _Identity<typename _Uty::result_type> * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };
}

#pragma warning(pop)
#pragma pack(pop)
#line 10 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstddef"


#pragma pack(push,8)
#pragma warning(push, 3)
#line 23 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstddef"
namespace std {
#line 90 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstddef"
template<class _Ty> inline
 _Ty *addressof(_Ty& _Val) throw ()
 {
 return (reinterpret_cast<_Ty *>(
  (&const_cast<char&>(
  reinterpret_cast<const volatile char&>(_Val)))));
 }



template<bool,
 class _Ty1,
 class _Ty2>
 struct _If
 {
 typedef _Ty2 type;
 };

template<class _Ty1,
 class _Ty2>
 struct _If<true, _Ty1, _Ty2>
 {
 typedef _Ty1 type;
 };

template<class _Ty>
 struct _Always_false
 {
 static const bool value = false;
 };



template<class _Arg,
 class _Result>
 struct unary_function
 {
 typedef _Arg argument_type;
 typedef _Result result_type;
 };


template<class _Arg1,
 class _Arg2,
 class _Result>
 struct binary_function
 {
 typedef _Arg1 first_argument_type;
 typedef _Arg2 second_argument_type;
 typedef _Result result_type;
 };


template<class _Ty = void>
 struct plus
  : public binary_function<_Ty, _Ty, _Ty>
 {
 _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left + _Right);
  }
 };


template<class _Ty = void>
 struct minus
  : public binary_function<_Ty, _Ty, _Ty>
 {
 _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left - _Right);
  }
 };


template<class _Ty = void>
 struct multiplies
  : public binary_function<_Ty, _Ty, _Ty>
 {
 _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left * _Right);
  }
 };


template<class _Ty = void>
 struct equal_to
  : public binary_function<_Ty, _Ty, bool>
 {
 bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left == _Right);
  }
 };


template<class _Ty = void>
 struct less
  : public binary_function<_Ty, _Ty, bool>
 {
 bool operator()(const _Ty& _Left, const _Ty& _Right) const
  {
  return (_Left < _Right);
  }
 };


template<>
 struct plus<void>
 {
 template<class _Ty1,
  class _Ty2>
  auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   + static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct minus<void>
 {
 template<class _Ty1,
  class _Ty2>
  auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   - static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct multiplies<void>
 {
 template<class _Ty1,
  class _Ty2>
  auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   * static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct equal_to<void>
 {
 template<class _Ty1,
  class _Ty2>
  auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   == static_cast<_Ty2&&>(_Right));
  }
 };


template<>
 struct less<void>
 {
 template<class _Ty1,
  class _Ty2>
  auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
  -> decltype(static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right))
  {
  return (static_cast<_Ty1&&>(_Left)
   < static_cast<_Ty2&&>(_Right));
  }
 };


}



namespace std {

inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
 {






 static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
 const size_t _FNV_offset_basis = 2166136261U;
 const size_t _FNV_prime = 16777619U;


 size_t _Val = _FNV_offset_basis;
 for (size_t _Next = 0; _Next < _Count; ++_Next)
  {
  _Val ^= (size_t)_First[_Next];
  _Val *= _FNV_prime;
  }






 static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");


 return (_Val);
 }


template<class _Kty>
 struct _Bitwise_hash
  : public unary_function<_Kty, size_t>
 {
 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
  }
 };


template<class _Kty>
 struct hash
  : public _Bitwise_hash<_Kty>
 {
 static const bool _Value = __is_enum(_Kty);
 static_assert(_Value,
  "The C++ Standard doesn't provide a hash for this type.");
 };
template<>
 struct hash<bool>
  : public _Bitwise_hash<bool>
 {
 };

template<>
 struct hash<char>
  : public _Bitwise_hash<char>
 {
 };

template<>
 struct hash<signed char>
  : public _Bitwise_hash<signed char>
 {
 };

template<>
 struct hash<unsigned char>
  : public _Bitwise_hash<unsigned char>
 {
 };
#line 369 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstddef"
template<>
 struct hash<wchar_t>
  : public _Bitwise_hash<wchar_t>
 {
 };


template<>
 struct hash<short>
  : public _Bitwise_hash<short>
 {
 };

template<>
 struct hash<unsigned short>
  : public _Bitwise_hash<unsigned short>
 {
 };

template<>
 struct hash<int>
  : public _Bitwise_hash<int>
 {
 };

template<>
 struct hash<unsigned int>
  : public _Bitwise_hash<unsigned int>
 {
 };

template<>
 struct hash<long>
  : public _Bitwise_hash<long>
 {
 };

template<>
 struct hash<unsigned long>
  : public _Bitwise_hash<unsigned long>
 {
 };

template<>
 struct hash<long long>
  : public _Bitwise_hash<long long>
 {
 };

template<>
 struct hash<unsigned long long>
  : public _Bitwise_hash<unsigned long long>
 {
 };

template<>
 struct hash<float>
  : public _Bitwise_hash<float>
 {
 typedef float _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<double>
  : public _Bitwise_hash<double>
 {
 typedef double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<>
 struct hash<long double>
  : public _Bitwise_hash<long double>
 {
 typedef long double _Kty;
 typedef _Bitwise_hash<_Kty> _Mybase;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Mybase::operator()(
   _Keyval == 0 ? 0 : _Keyval));
  }
 };

template<class _Ty>
 struct hash<_Ty *>
  : public _Bitwise_hash<_Ty *>
 {
 };
}


namespace std {
namespace tr1 {
using ::std:: hash;
}
}
#line 568 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstddef"
#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\utility"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\iosfwd"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstdio"
#line 13 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstdio"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"






#pragma pack(push,8)


extern "C" {
#line 63 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
struct _iobuf {
        char *_ptr;
        int _cnt;
        char *_base;
        int _flag;
        int _file;
        int _charbuf;
        int _bufsiz;
        char *_tmpfname;
        };
typedef struct _iobuf FILE;
#line 137 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
__declspec(dllimport) FILE * __cdecl __iob_func(void);






typedef __int64 fpos_t;
#line 175 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
               __declspec(dllimport) int __cdecl _filbuf( FILE * _File );
                   __declspec(dllimport) int __cdecl _flsbuf( int _Ch, FILE * _File);

               __declspec(dllimport) FILE * __cdecl _fsopen( const char * _Filename, const char * _Mode, int _ShFlag);

__declspec(dllimport) void __cdecl clearerr( FILE * _File);

                   __declspec(dllimport) errno_t __cdecl clearerr_s( FILE * _File );

                   __declspec(dllimport) int __cdecl fclose( FILE * _File);
                   __declspec(dllimport) int __cdecl _fcloseall(void);

               __declspec(dllimport) FILE * __cdecl _fdopen( int _FileHandle, const char * _Mode);

               __declspec(dllimport) int __cdecl feof( FILE * _File);
               __declspec(dllimport) int __cdecl ferror( FILE * _File);
                   __declspec(dllimport) int __cdecl fflush( FILE * _File);
                   __declspec(dllimport) int __cdecl fgetc( FILE * _File);
                   __declspec(dllimport) int __cdecl _fgetchar(void);
                   __declspec(dllimport) int __cdecl fgetpos( FILE * _File , fpos_t * _Pos);
                   __declspec(dllimport) char * __cdecl fgets( char * _Buf, int _MaxCount, FILE * _File);

               __declspec(dllimport) int __cdecl _fileno( FILE * _File);






               __declspec(dllimport) char * __cdecl _tempnam( const char * _DirName, const char * _FilePrefix);





                   __declspec(dllimport) int __cdecl _flushall(void);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl fopen( const char * _Filename, const char * _Mode);

                   __declspec(dllimport) errno_t __cdecl fopen_s( FILE ** _File, const char * _Filename, const char * _Mode);

                   __declspec(dllimport) int __cdecl fprintf( FILE * _File, const char * _Format, ...);

                   __declspec(dllimport) int __cdecl fprintf_s( FILE * _File, const char * _Format, ...);

                   __declspec(dllimport) int __cdecl fputc( int _Ch, FILE * _File);
                   __declspec(dllimport) int __cdecl _fputchar( int _Ch);
                   __declspec(dllimport) int __cdecl fputs( const char * _Str, FILE * _File);
                   __declspec(dllimport) size_t __cdecl fread( void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);

                   __declspec(dllimport) size_t __cdecl fread_s( void * _DstBuf, size_t _DstSize, size_t _ElementSize, size_t _Count, FILE * _File);

               __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl freopen( const char * _Filename, const char * _Mode, FILE * _File);

                   __declspec(dllimport) errno_t __cdecl freopen_s( FILE ** _File, const char * _Filename, const char * _Mode, FILE * _OldFile);

               __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl fscanf( FILE * _File, const char * _Format, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _fscanf_l( FILE * _File, const char * _Format, _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable: 6530)

 __declspec(dllimport) int __cdecl fscanf_s( FILE * _File, const char * _Format, ...);

                   __declspec(dllimport) int __cdecl _fscanf_s_l( FILE * _File, const char * _Format, _locale_t _Locale, ...);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl fsetpos( FILE * _File, const fpos_t * _Pos);
                   __declspec(dllimport) int __cdecl fseek( FILE * _File, long _Offset, int _Origin);
               __declspec(dllimport) long __cdecl ftell( FILE * _File);

                   __declspec(dllimport) int __cdecl _fseeki64( FILE * _File, __int64 _Offset, int _Origin);
               __declspec(dllimport) __int64 __cdecl _ftelli64( FILE * _File);

                   __declspec(dllimport) size_t __cdecl fwrite( const void * _Str, size_t _Size, size_t _Count, FILE * _File);
               __declspec(dllimport) int __cdecl getc( FILE * _File);
               __declspec(dllimport) int __cdecl getchar(void);
               __declspec(dllimport) int __cdecl _getmaxstdio(void);

__declspec(dllimport) char * __cdecl gets_s( char * _Buf, rsize_t _Size);

extern "C++" { template <size_t _Size> inline char * __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "gets_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl gets( char *_Buffer);
               int __cdecl _getw( FILE * _File);





                   __declspec(dllimport) int __cdecl _pclose( FILE * _File);
               __declspec(dllimport) FILE * __cdecl _popen( const char * _Command, const char * _Mode);

                   __declspec(dllimport) int __cdecl printf( const char * _Format, ...);

                   __declspec(dllimport) int __cdecl printf_s( const char * _Format, ...);

                   __declspec(dllimport) int __cdecl putc( int _Ch, FILE * _File);
                   __declspec(dllimport) int __cdecl putchar( int _Ch);
                   __declspec(dllimport) int __cdecl puts( const char * _Str);
                   __declspec(dllimport) int __cdecl _putw( int _Word, FILE * _File);


__declspec(dllimport) int __cdecl remove( const char * _Filename);
               __declspec(dllimport) int __cdecl rename( const char * _OldFilename, const char * _NewFilename);
__declspec(dllimport) int __cdecl _unlink( const char * _Filename);

__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_unlink" ". See online help for details.")) __declspec(dllimport) int __cdecl unlink( const char * _Filename);


__declspec(dllimport) void __cdecl rewind( FILE * _File);
                   __declspec(dllimport) int __cdecl _rmtmp(void);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl scanf( const char * _Format, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _scanf_l( const char * _Format, _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable: 6530)

 __declspec(dllimport) int __cdecl scanf_s( const char * _Format, ...);

                   __declspec(dllimport) int __cdecl _scanf_s_l( const char * _Format, _locale_t _Locale, ...);
#pragma warning(pop)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) void __cdecl setbuf( FILE * _File, char * _Buffer);
                   __declspec(dllimport) int __cdecl _setmaxstdio( int _Max);
                   __declspec(dllimport) unsigned int __cdecl _set_output_format( unsigned int _Format);
                   __declspec(dllimport) unsigned int __cdecl _get_output_format(void);
                   __declspec(dllimport) int __cdecl setvbuf( FILE * _File, char * _Buf, int _Mode, size_t _Size);
                   __declspec(dllimport) int __cdecl _snprintf_s( char * _DstBuf, size_t _SizeInBytes, size_t _MaxCount, const char * _Format, ...);
extern "C++" {
#line 298 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(push)
#line 298 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
;
#line 298 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(disable: 4793)
#line 298 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
; template <size_t _Size> inline int __cdecl _snprintf_s(char (&_Dest)[_Size], size_t _MaxCount, const char * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _ArgList); }
#line 298 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(pop)
#line 298 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
; }

                   __declspec(dllimport) int __cdecl sprintf_s( char * _DstBuf, size_t _SizeInBytes, const char * _Format, ...);

extern "C++" {
#line 302 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(push)
#line 302 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
;
#line 302 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(disable: 4793)
#line 302 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
; template <size_t _Size> inline int __cdecl sprintf_s(char (&_Dest)[_Size], const char * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vsprintf_s(_Dest, _Size, _Format, _ArgList); }
#line 302 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(pop)
#line 302 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
; }
               __declspec(dllimport) int __cdecl _scprintf( const char * _Format, ...);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl sscanf( const char * _Src, const char * _Format, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _sscanf_l( const char * _Src, const char * _Format, _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable: 6530)

 __declspec(dllimport) int __cdecl sscanf_s( const char * _Src, const char * _Format, ...);

                   __declspec(dllimport) int __cdecl _sscanf_s_l( const char * _Src, const char * _Format, _locale_t _Locale, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snscanf( const char * _Src, size_t _MaxCount, const char * _Format, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snscanf_l( const char * _Src, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _snscanf_s( const char * _Src, size_t _MaxCount, const char * _Format, ...);
                   __declspec(dllimport) int __cdecl _snscanf_s_l( const char * _Src, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...);
#pragma warning(pop)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl tmpfile(void);

                   __declspec(dllimport) errno_t __cdecl tmpfile_s( FILE ** _File);
                   __declspec(dllimport) errno_t __cdecl tmpnam_s( char * _Buf, rsize_t _Size);

extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(char (&_Buf)[_Size]) throw() { return tmpnam_s(_Buf, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl tmpnam( char *_Buffer);
                   __declspec(dllimport) int __cdecl ungetc( int _Ch, FILE * _File);
                   __declspec(dllimport) int __cdecl vfprintf( FILE * _File, const char * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl vfscanf( FILE * _File, const char * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl vfprintf_s( FILE * _File, const char * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl vfscanf_s( FILE * _File, const char * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl vprintf( const char * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl vscanf( const char * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl vprintf_s( const char * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl vscanf_s( const char * _Format, va_list _ArgList);

                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl vsnprintf( char * _DstBuf, size_t _MaxCount, const char * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl vsnprintf_s( char * _DstBuf, size_t _DstSize, size_t _MaxCount, const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsnprintf_s(char (&_Dest)[_Size], size_t _MaxCount, const char * _Format, va_list _Args) throw() { return vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }

                   __declspec(dllimport) int __cdecl _vsnprintf_s( char * _DstBuf, size_t _SizeInBytes, size_t _MaxCount, const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnprintf_s(char (&_Dest)[_Size], size_t _MaxCount, const char * _Format, va_list _Args) throw() { return _vsnprintf_s(_Dest, _Size, _MaxCount, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable: 4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snprintf( char *_Dest, size_t _Count, const char * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf( char *_Dest, size_t _Count, const char * _Format, va_list _Args);
#pragma warning(pop)

__declspec(dllimport) int __cdecl vsprintf_s( char * _DstBuf, size_t _SizeInBytes, const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsprintf_s(char (&_Dest)[_Size], const char * _Format, va_list _Args) throw() { return vsprintf_s(_Dest, _Size, _Format, _Args); } }
                   __declspec(dllimport) int __cdecl vsscanf_s(const char * _Src, const char * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(const char (&_Src)[_Size], const char * _Format, va_list _Args) throw() { return vsscanf_s(_Src, _Size, _Format, _Args); } }

#pragma warning(push)
#pragma warning(disable: 4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl sprintf( char *_Dest, const char * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl vsprintf( char *_Dest, const char * _Format, va_list _Args);
                   __declspec(dllimport) int __cdecl vsscanf(const char * _srcBuf, const char * _Format, va_list _ArgList);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl _vscprintf( const char * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _snprintf_c( char * _DstBuf, size_t _MaxCount, const char * _Format, ...);
                   __declspec(dllimport) int __cdecl _vsnprintf_c( char *_DstBuf, size_t _MaxCount, const char * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl _fprintf_p( FILE * _File, const char * _Format, ...);
                   __declspec(dllimport) int __cdecl _printf_p( const char * _Format, ...);
                   __declspec(dllimport) int __cdecl _sprintf_p( char * _Dst, size_t _MaxCount, const char * _Format, ...);
                   __declspec(dllimport) int __cdecl _vfprintf_p( FILE * _File, const char * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vprintf_p( const char * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vsprintf_p( char * _Dst, size_t _MaxCount, const char * _Format, va_list _ArgList);
               __declspec(dllimport) int __cdecl _scprintf_p( const char * _Format, ...);
               __declspec(dllimport) int __cdecl _vscprintf_p( const char * _Format, va_list _ArgList);
__declspec(dllimport) int __cdecl _set_printf_count_output( int _Value);
__declspec(dllimport) int __cdecl _get_printf_count_output(void);

                   __declspec(dllimport) int __cdecl _printf_l( const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _printf_p_l( const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _printf_s_l( const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _vprintf_l( const char * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vprintf_p_l( const char * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vprintf_s_l( const char * _Format, _locale_t _Locale, va_list _ArgList);

                   __declspec(dllimport) int __cdecl _fprintf_l( FILE * _File, const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _fprintf_p_l( FILE * _File, const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _fprintf_s_l( FILE * _File, const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _vfprintf_l( FILE * _File, const char * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vfprintf_p_l( FILE * _File, const char * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vfprintf_s_l( FILE * _File, const char * _Format, _locale_t _Locale, va_list _ArgList);

                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _sprintf_l( char * _DstBuf, const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _sprintf_p_l( char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _sprintf_s_l( char * _DstBuf, size_t _DstSize, const char * _Format, _locale_t _Locale, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsprintf_l( char * _DstBuf, const char * _Format, _locale_t, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vsprintf_p_l( char * _DstBuf, size_t _MaxCount, const char* _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vsprintf_s_l( char * _DstBuf, size_t _DstSize, const char * _Format, _locale_t _Locale, va_list _ArgList);

                   __declspec(dllimport) int __cdecl _scprintf_l( const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _scprintf_p_l( const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _vscprintf_l( const char * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vscprintf_p_l( const char * _Format, _locale_t _Locale, va_list _ArgList);

                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snprintf_l( char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _snprintf_c_l( char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _snprintf_s_l( char * _DstBuf, size_t _DstSize, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnprintf_l( char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vsnprintf_c_l( char * _DstBuf, size_t _MaxCount, const char *, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vsnprintf_s_l( char * _DstBuf, size_t _DstSize, size_t _MaxCount, const char* _Format, _locale_t _Locale, va_list _ArgList);
#line 415 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
               __declspec(dllimport) FILE * __cdecl _wfsopen( const wchar_t * _Filename, const wchar_t * _Mode, int _ShFlag);

                   __declspec(dllimport) wint_t __cdecl fgetwc( FILE * _File);
                   __declspec(dllimport) wint_t __cdecl _fgetwchar(void);
                   __declspec(dllimport) wint_t __cdecl fputwc( wchar_t _Ch, FILE * _File);
                   __declspec(dllimport) wint_t __cdecl _fputwchar( wchar_t _Ch);
               __declspec(dllimport) wint_t __cdecl getwc( FILE * _File);
               __declspec(dllimport) wint_t __cdecl getwchar(void);
                   __declspec(dllimport) wint_t __cdecl putwc( wchar_t _Ch, FILE * _File);
                   __declspec(dllimport) wint_t __cdecl putwchar( wchar_t _Ch);
                   __declspec(dllimport) wint_t __cdecl ungetwc( wint_t _Ch, FILE * _File);

                   __declspec(dllimport) wchar_t * __cdecl fgetws( wchar_t * _Dst, int _SizeInWords, FILE * _File);
                   __declspec(dllimport) int __cdecl fputws( const wchar_t * _Str, FILE * _File);
                   __declspec(dllimport) wchar_t * __cdecl _getws_s( wchar_t * _Str, size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline wchar_t * __cdecl _getws_s(wchar_t (&_String)[_Size]) throw() { return _getws_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_getws_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _getws( wchar_t *_String);
                   __declspec(dllimport) int __cdecl _putws( const wchar_t * _Str);

                   __declspec(dllimport) int __cdecl fwprintf( FILE * _File, const wchar_t * _Format, ...);

                   __declspec(dllimport) int __cdecl fwprintf_s( FILE * _File, const wchar_t * _Format, ...);

                   __declspec(dllimport) int __cdecl wprintf( const wchar_t * _Format, ...);

                   __declspec(dllimport) int __cdecl wprintf_s( const wchar_t * _Format, ...);

               __declspec(dllimport) int __cdecl _scwprintf( const wchar_t * _Format, ...);
                   __declspec(dllimport) int __cdecl vfwprintf( FILE * _File, const wchar_t * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl vfwscanf( FILE * _File, const wchar_t * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl vfwprintf_s( FILE * _File, const wchar_t * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl vfwscanf_s( FILE * _File, const wchar_t * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl vwprintf( const wchar_t * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl vwscanf( const wchar_t * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl vwprintf_s( const wchar_t * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl vwscanf_s( const wchar_t * _Format, va_list _ArgList);



__declspec(dllimport) int __cdecl swprintf_s( wchar_t * _Dst, size_t _SizeInWords, const wchar_t * _Format, ...);

extern "C++" {
#line 459 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(push)
#line 459 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
;
#line 459 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(disable: 4793)
#line 459 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
; template <size_t _Size> inline int __cdecl swprintf_s(wchar_t (&_Dest)[_Size], const wchar_t * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return vswprintf_s(_Dest, _Size, _Format, _ArgList); }
#line 459 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(pop)
#line 459 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
; }

__declspec(dllimport) int __cdecl vswprintf_s( wchar_t * _Dst, size_t _SizeInWords, const wchar_t * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl vswscanf_s(const wchar_t * _Src, const wchar_t * _Format, va_list _ArgList);

extern "C++" { template <size_t _Size> inline int __cdecl vswprintf_s(wchar_t (&_Dest)[_Size], const wchar_t * _Format, va_list _Args) throw() { return vswprintf_s(_Dest, _Size, _Format, _Args); } }
extern "C++" { template <size_t _Size> inline int __cdecl vswscanf_s(wchar_t (&_Dest)[_Size], const wchar_t * _Format, va_list _Args) throw() { return vswscanf_s(_Dest, _Size, _Format, _Args); } }
                   __declspec(dllimport) int __cdecl vswscanf(const wchar_t * _srcBuf, const wchar_t * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl _swprintf_c( wchar_t * _DstBuf, size_t _SizeInWords, const wchar_t * _Format, ...);
                   __declspec(dllimport) int __cdecl _vswprintf_c( wchar_t * _DstBuf, size_t _SizeInWords, const wchar_t * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl _snwprintf_s( wchar_t * _DstBuf, size_t _SizeInWords, size_t _MaxCount, const wchar_t * _Format, ...);
extern "C++" {
#line 472 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(push)
#line 472 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
;
#line 472 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(disable: 4793)
#line 472 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
; template <size_t _Size> inline int __cdecl _snwprintf_s(wchar_t (&_Dest)[_Size], size_t _Count, const wchar_t * _Format, ...) throw() { va_list _ArgList; ( _ArgList = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) ); return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _ArgList); }
#line 472 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(pop)
#line 472 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
; }
                   __declspec(dllimport) int __cdecl _vsnwprintf_s( wchar_t * _DstBuf, size_t _SizeInWords, size_t _MaxCount, const wchar_t * _Format, va_list _ArgList);
extern "C++" { template <size_t _Size> inline int __cdecl _vsnwprintf_s(wchar_t (&_Dest)[_Size], size_t _Count, const wchar_t * _Format, va_list _Args) throw() { return _vsnwprintf_s(_Dest, _Size, _Count, _Format, _Args); } }
#pragma warning(push)
#pragma warning(disable: 4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf( wchar_t *_Dest, size_t _Count, const wchar_t * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf( wchar_t *_Dest, size_t _Count, const wchar_t * _Format, va_list _Args);
#pragma warning(pop)

 __declspec(dllimport) int __cdecl _fwprintf_p( FILE * _File, const wchar_t * _Format, ...);
                   __declspec(dllimport) int __cdecl _wprintf_p( const wchar_t * _Format, ...);
                   __declspec(dllimport) int __cdecl _vfwprintf_p( FILE * _File, const wchar_t * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vwprintf_p( const wchar_t * _Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _swprintf_p( wchar_t * _DstBuf, size_t _MaxCount, const wchar_t * _Format, ...);
                   __declspec(dllimport) int __cdecl _vswprintf_p( wchar_t * _DstBuf, size_t _MaxCount, const wchar_t * _Format, va_list _ArgList);
               __declspec(dllimport) int __cdecl _scwprintf_p( const wchar_t * _Format, ...);
               __declspec(dllimport) int __cdecl _vscwprintf_p( const wchar_t * _Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl _wprintf_l( const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _wprintf_p_l( const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _wprintf_s_l( const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _vwprintf_l( const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vwprintf_p_l( const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vwprintf_s_l( const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);

                   __declspec(dllimport) int __cdecl _fwprintf_l( FILE * _File, const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _fwprintf_p_l( FILE * _File, const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _fwprintf_s_l( FILE * _File, const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _vfwprintf_l( FILE * _File, const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vfwprintf_p_l( FILE * _File, const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vfwprintf_s_l( FILE * _File, const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);

                   __declspec(dllimport) int __cdecl _swprintf_c_l( wchar_t * _DstBuf, size_t _MaxCount, const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _swprintf_p_l( wchar_t * _DstBuf, size_t _MaxCount, const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _swprintf_s_l( wchar_t * _DstBuf, size_t _DstSize, const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _vswprintf_c_l( wchar_t * _DstBuf, size_t _MaxCount, const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vswprintf_p_l( wchar_t * _DstBuf, size_t _MaxCount, const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vswprintf_s_l( wchar_t * _DstBuf, size_t _DstSize, const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);

               __declspec(dllimport) int __cdecl _scwprintf_l( const wchar_t * _Format, _locale_t _Locale, ...);
               __declspec(dllimport) int __cdecl _scwprintf_p_l( const wchar_t * _Format, _locale_t _Locale, ...);
               __declspec(dllimport) int __cdecl _vscwprintf_p_l( const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);

                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwprintf_l( wchar_t * _DstBuf, size_t _MaxCount, const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _snwprintf_s_l( wchar_t * _DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _vsnwprintf_l( wchar_t * _DstBuf, size_t _MaxCount, const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vsnwprintf_s_l( wchar_t * _DstBuf, size_t _DstSize, size_t _MaxCount, const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);
#line 531 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#pragma warning(push)
#pragma warning(disable: 4141 4996 4793)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf( wchar_t *_Dest, const wchar_t * _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf( wchar_t *_Dest, const wchar_t * _Format, va_list _Args);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l( wchar_t *_Dest, const wchar_t * _Format, _locale_t _Plocinfo, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l( wchar_t *_Dest, const wchar_t * _Format, _locale_t _Plocinfo, va_list _Args);
#pragma warning(pop)



#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\swprintf.inl"
#line 34 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\swprintf.inl"
#pragma warning(push)
#pragma warning(disable: 4793 4412)
static __inline int swprintf( wchar_t * _String, size_t _Count, const wchar_t * _Format, ...)
{
    va_list _Arglist;
    int _Ret;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable: 4412)
static __inline int __cdecl vswprintf( wchar_t * _String, size_t _Count, const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap);
}
#pragma warning(pop)




#pragma warning(push)
#pragma warning(disable: 4793 4412)
static __inline int _swprintf_l( wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    int _Ret;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    _Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable: 4412)
static __inline int __cdecl _vswprintf_l( wchar_t * _String, size_t _Count, const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap);
}
#pragma warning(pop)


#pragma warning(push)
#pragma warning(disable: 4996)

#pragma warning(push)
#pragma warning(disable: 4793 4141)
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int swprintf( wchar_t * _String, const wchar_t * _Format, ...)
{
    va_list _Arglist;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Format) ) + ( (sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    int _Ret = _vswprintf(_String, _Format, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable: 4141)
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int __cdecl vswprintf( wchar_t * _String, const wchar_t * _Format, va_list _Ap)
{
    return _vswprintf(_String, _Format, _Ap);
}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable: 4793 4141)
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int _swprintf_l( wchar_t * _String, const wchar_t * _Format, _locale_t _Plocinfo, ...)
{
    va_list _Arglist;
    ( _Arglist = (va_list)( &reinterpret_cast<const char &>(_Plocinfo) ) + ( (sizeof(_Plocinfo) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist);
    ( _Arglist = (va_list)0 );
    return _Ret;
}
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable: 4141)
extern "C++" __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Microsoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __inline int __cdecl _vswprintf_l( wchar_t * _String, const wchar_t * _Format, _locale_t _Plocinfo, va_list _Ap)
{
    return __vswprintf_l(_String, _Format, _Plocinfo, _Ap);
}
#pragma warning(pop)

#pragma warning(pop)
#line 538 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
#line 555 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
               __declspec(dllimport) wchar_t * __cdecl _wtempnam( const wchar_t * _Directory, const wchar_t * _FilePrefix);





               __declspec(dllimport) int __cdecl _vscwprintf( const wchar_t * _Format, va_list _ArgList);
               __declspec(dllimport) int __cdecl _vscwprintf_l( const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl fwscanf( FILE * _File, const wchar_t * _Format, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _fwscanf_l( FILE * _File, const wchar_t * _Format, _locale_t _Locale, ...);
#pragma warning(push)
#pragma warning(disable: 6530)

 __declspec(dllimport) int __cdecl fwscanf_s( FILE * _File, const wchar_t * _Format, ...);

                   __declspec(dllimport) int __cdecl _fwscanf_s_l( FILE * _File, const wchar_t * _Format, _locale_t _Locale, ...);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl swscanf( const wchar_t * _Src, const wchar_t * _Format, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _swscanf_l( const wchar_t * _Src, const wchar_t * _Format, _locale_t _Locale, ...);

                   __declspec(dllimport) int __cdecl swscanf_s( const wchar_t *_Src, const wchar_t * _Format, ...);

                   __declspec(dllimport) int __cdecl _swscanf_s_l( const wchar_t * _Src, const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwscanf( const wchar_t * _Src, size_t _MaxCount, const wchar_t * _Format, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _snwscanf_l( const wchar_t * _Src, size_t _MaxCount, const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _snwscanf_s( const wchar_t * _Src, size_t _MaxCount, const wchar_t * _Format, ...);
                   __declspec(dllimport) int __cdecl _snwscanf_s_l( const wchar_t * _Src, size_t _MaxCount, const wchar_t * _Format, _locale_t _Locale, ...);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl wscanf( const wchar_t * _Format, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wscanf_l( const wchar_t * _Format, _locale_t _Locale, ...);

                   __declspec(dllimport) int __cdecl wscanf_s( const wchar_t * _Format, ...);

                   __declspec(dllimport) int __cdecl _wscanf_s_l( const wchar_t * _Format, _locale_t _Locale, ...);
#pragma warning(pop)

 __declspec(dllimport) FILE * __cdecl _wfdopen( int _FileHandle , const wchar_t * _Mode);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl _wfopen( const wchar_t * _Filename, const wchar_t * _Mode);
                   __declspec(dllimport) errno_t __cdecl _wfopen_s( FILE ** _File, const wchar_t * _Filename, const wchar_t * _Mode);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) FILE * __cdecl _wfreopen( const wchar_t * _Filename, const wchar_t * _Mode, FILE * _OldFile);
                   __declspec(dllimport) errno_t __cdecl _wfreopen_s( FILE ** _File, const wchar_t * _Filename, const wchar_t * _Mode, FILE * _OldFile);






               __declspec(dllimport) FILE * __cdecl _wpopen( const wchar_t *_Command, const wchar_t * _Mode);

__declspec(dllimport) int __cdecl _wremove( const wchar_t * _Filename);
                   __declspec(dllimport) errno_t __cdecl _wtmpnam_s( wchar_t * _DstBuf, size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wtmpnam( wchar_t *_Buffer);

                   __declspec(dllimport) wint_t __cdecl _fgetwc_nolock( FILE * _File);
                   __declspec(dllimport) wint_t __cdecl _fputwc_nolock( wchar_t _Ch, FILE * _File);
                   __declspec(dllimport) wint_t __cdecl _ungetwc_nolock( wint_t _Ch, FILE * _File);
#line 621 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
inline wint_t __cdecl getwchar()
        {return (fgetwc((&__iob_func()[0]))); }
inline wint_t __cdecl putwchar( wchar_t _C)
        {return (fputwc(_C, (&__iob_func()[1]))); }
#line 670 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
__declspec(dllimport) void __cdecl _lock_file( FILE * _File);
__declspec(dllimport) void __cdecl _unlock_file( FILE * _File);

                   __declspec(dllimport) int __cdecl _fclose_nolock( FILE * _File);
                   __declspec(dllimport) int __cdecl _fflush_nolock( FILE * _File);
                   __declspec(dllimport) size_t __cdecl _fread_nolock( void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);
                   __declspec(dllimport) size_t __cdecl _fread_nolock_s( void * _DstBuf, size_t _DstSize, size_t _ElementSize, size_t _Count, FILE * _File);
                   __declspec(dllimport) int __cdecl _fseek_nolock( FILE * _File, long _Offset, int _Origin);
               __declspec(dllimport) long __cdecl _ftell_nolock( FILE * _File);
                   __declspec(dllimport) int __cdecl _fseeki64_nolock( FILE * _File, __int64 _Offset, int _Origin);
               __declspec(dllimport) __int64 __cdecl _ftelli64_nolock( FILE * _File);
                   __declspec(dllimport) size_t __cdecl _fwrite_nolock( const void * _DstBuf, size_t _Size, size_t _Count, FILE * _File);
                   __declspec(dllimport) int __cdecl _ungetc_nolock( int _Ch, FILE * _File);
#line 709 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdio.h"
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_tempnam" ". See online help for details.")) __declspec(dllimport) char * __cdecl tempnam( const char * _Directory, const char * _FilePrefix);





                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int __cdecl fcloseall(void);
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fdopen" ". See online help for details.")) __declspec(dllimport) FILE * __cdecl fdopen( int _FileHandle, const char * _Format);
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fgetchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fgetchar(void);
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fileno" ". See online help for details.")) __declspec(dllimport) int __cdecl fileno( FILE * _File);
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_flushall" ". See online help for details.")) __declspec(dllimport) int __cdecl flushall(void);
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_fputchar" ". See online help for details.")) __declspec(dllimport) int __cdecl fputchar( int _Ch);
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_getw" ". See online help for details.")) __declspec(dllimport) int __cdecl getw( FILE * _File);
                   __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_putw" ". See online help for details.")) __declspec(dllimport) int __cdecl putw( int _Ch, FILE * _File);
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_rmtmp" ". See online help for details.")) __declspec(dllimport) int __cdecl rmtmp(void);




}


#pragma pack(pop)
#line 13 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstdio"
#line 32 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstdio"
typedef FILE _iobuf;


namespace std {
using :: _iobuf; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: gets; using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf; using :: tmpfile; using :: tmpnam;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

                            using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
}
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\iosfwd"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstring"
#line 13 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstring"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string.h"



extern "C" {
#line 47 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string.h"
__declspec(dllimport) void * __cdecl _memccpy( void * _Dst, const void * _Src, int _Val, size_t _MaxCount);
               __declspec(dllimport) const void * __cdecl memchr( const void * _Buf , int _Val, size_t _MaxCount);
               __declspec(dllimport) int __cdecl _memicmp( const void * _Buf1, const void * _Buf2, size_t _Size);
               __declspec(dllimport) int __cdecl _memicmp_l( const void * _Buf1, const void * _Buf2, size_t _Size, _locale_t _Locale);
               int __cdecl memcmp( const void * _Buf1, const void * _Buf2, size_t _Size);



void * __cdecl memcpy( void * _Dst, const void * _Src, size_t _Size);

__declspec(dllimport) errno_t __cdecl memcpy_s( void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount);
#line 94 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string.h"
        void * __cdecl memset( void * _Dst, int _Val, size_t _Size);



__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_memccpy" ". See online help for details.")) __declspec(dllimport) void * __cdecl memccpy( void * _Dst, const void * _Src, int _Val, size_t _Size);
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_memicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl memicmp( const void * _Buf1, const void * _Buf2, size_t _Size);





                   __declspec(dllimport) errno_t __cdecl _strset_s( char * _Dst, size_t _DstSize, int _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(char (&_Dest)[_Size], int _Value) throw() { return _strset_s(_Dest, _Size, _Value); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl _strset( char *_Dest, int _Value);

                   __declspec(dllimport) errno_t __cdecl strcpy_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src);

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(char (&_Dest)[_Size], const char * _Source) throw() { return strcpy_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl strcpy( char *_Dest, const char * _Source);

                   __declspec(dllimport) errno_t __cdecl strcat_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src);

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Dest)[_Size], const char * _Source) throw() { return strcat_s(_Dest, _Size, _Source); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) char * __cdecl strcat( char *_Dest, const char * _Source);

               int __cdecl strcmp( const char * _Str1, const char * _Str2);
               size_t __cdecl strlen( const char * _Str);
               __declspec(dllimport)


size_t __cdecl strnlen( const char * _Str, size_t _MaxCount);

               static __inline


size_t __cdecl strnlen_s( const char * _Str, size_t _MaxCount)
{
    return (_Str==0) ? 0 : strnlen(_Str, _MaxCount);
}


                   __declspec(dllimport) errno_t __cdecl memmove_s( void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount);


__declspec(dllimport) void * __cdecl memmove( void * _Dst, const void * _Src, size_t _Size);






               __declspec(dllimport) char * __cdecl _strdup( const char * _Src);





               __declspec(dllimport) const char * __cdecl strchr( const char * _Str, int _Val);
               __declspec(dllimport) int __cdecl _stricmp( const char * _Str1, const char * _Str2);
               __declspec(dllimport) int __cdecl _strcmpi( const char * _Str1, const char * _Str2);
               __declspec(dllimport) int __cdecl _stricmp_l( const char * _Str1, const char * _Str2, _locale_t _Locale);
               __declspec(dllimport) int __cdecl strcoll( const char * _Str1, const char * _Str2);
               __declspec(dllimport) int __cdecl _strcoll_l( const char * _Str1, const char * _Str2, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _stricoll( const char * _Str1, const char * _Str2);
               __declspec(dllimport) int __cdecl _stricoll_l( const char * _Str1, const char * _Str2, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _strncoll ( const char * _Str1, const char * _Str2, size_t _MaxCount);
               __declspec(dllimport) int __cdecl _strncoll_l( const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _strnicoll ( const char * _Str1, const char * _Str2, size_t _MaxCount);
               __declspec(dllimport) int __cdecl _strnicoll_l( const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale);
               __declspec(dllimport) size_t __cdecl strcspn( const char * _Str, const char * _Control);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strerror( const char * _ErrMsg);
                   __declspec(dllimport) errno_t __cdecl _strerror_s( char * _Buf, size_t _SizeInBytes, const char * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size], const char * _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strerror( int);

                   __declspec(dllimport) errno_t __cdecl strerror_s( char * _Buf, size_t _SizeInBytes, int _ErrNum);

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size], int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
                   __declspec(dllimport) errno_t __cdecl _strlwr_s( char * _Str, size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strlwr( char *_String);
                   __declspec(dllimport) errno_t __cdecl _strlwr_s_l( char * _Str, size_t _Size, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strlwr_l( char *_String, _locale_t _Locale);

                   __declspec(dllimport) errno_t __cdecl strncat_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src, rsize_t _MaxCount);

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(char (&_Dest)[_Size], const char * _Source, size_t _Count) throw() { return strncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable: 6059)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strncat( char *_Dest, const char * _Source, size_t _Count);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl strncmp( const char * _Str1, const char * _Str2, size_t _MaxCount);
               __declspec(dllimport) int __cdecl _strnicmp( const char * _Str1, const char * _Str2, size_t _MaxCount);
               __declspec(dllimport) int __cdecl _strnicmp_l( const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale);

                   __declspec(dllimport) errno_t __cdecl strncpy_s( char * _Dst, rsize_t _SizeInBytes, const char * _Src, rsize_t _MaxCount);

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Dest)[_Size], const char * _Source, size_t _Count) throw() { return strncpy_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strncpy( char *_Dest, const char * _Source, size_t _Count);
                   __declspec(dllimport) errno_t __cdecl _strnset_s( char * _Str, size_t _SizeInBytes, int _Val, size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(char (&_Dest)[_Size], int _Val, size_t _Count) throw() { return _strnset_s(_Dest, _Size, _Val, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strnset( char *_Dest, int _Val, size_t _Count);
               __declspec(dllimport) const char * __cdecl strpbrk( const char * _Str, const char * _Control);
               __declspec(dllimport) const char * __cdecl strrchr( const char * _Str, int _Ch);
__declspec(dllimport) char * __cdecl _strrev( char * _Str);
               __declspec(dllimport) size_t __cdecl strspn( const char * _Str, const char * _Control);
                               __declspec(dllimport) const char * __cdecl strstr( const char * _Str, const char * _SubStr);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl strtok( char * _Str, const char * _Delim);

               __declspec(dllimport) char * __cdecl strtok_s( char * _Str, const char * _Delim, char ** _Context);

                   __declspec(dllimport) errno_t __cdecl _strupr_s( char * _Str, size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strupr( char *_String);
                   __declspec(dllimport) errno_t __cdecl _strupr_s_l( char * _Str, size_t _Size, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(char (&_String)[_Size], _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) char * __cdecl _strupr_l( char *_String, _locale_t _Locale);
                   __declspec(dllimport) size_t __cdecl strxfrm ( char * _Dst, const char * _Src, size_t _MaxCount);
                   __declspec(dllimport) size_t __cdecl _strxfrm_l( char * _Dst, const char * _Src, size_t _MaxCount, _locale_t _Locale);


extern "C++" {


               inline char * __cdecl strchr( char * _Str, int _Ch)
        { return (char*)strchr((const char*)_Str, _Ch); }
               inline char * __cdecl strpbrk( char * _Str, const char * _Control)
        { return (char*)strpbrk((const char*)_Str, _Control); }
               inline char * __cdecl strrchr( char * _Str, int _Ch)
        { return (char*)strrchr((const char*)_Str, _Ch); }
                               inline char * __cdecl strstr( char * _Str, const char * _SubStr)
        { return (char*)strstr((const char*)_Str, _SubStr); }



               inline void * __cdecl memchr( void * _Pv, int _C, size_t _N)
        { return (void*)memchr((const void*)_Pv, _C, _N); }

}
#line 245 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string.h"
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strdup" ". See online help for details.")) __declspec(dllimport) char * __cdecl strdup( const char * _Src);






               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strcmpi" ". See online help for details.")) __declspec(dllimport) int __cdecl strcmpi( const char * _Str1, const char * _Str2);
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_stricmp" ". See online help for details.")) __declspec(dllimport) int __cdecl stricmp( const char * _Str1, const char * _Str2);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strlwr" ". See online help for details.")) __declspec(dllimport) char * __cdecl strlwr( char * _Str);
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strnicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl strnicmp( const char * _Str1, const char * _Str, size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strnset" ". See online help for details.")) __declspec(dllimport) char * __cdecl strnset( char * _Str, int _Val, size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strrev" ". See online help for details.")) __declspec(dllimport) char * __cdecl strrev( char * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strset" ". See online help for details.")) char * __cdecl strset( char * _Str, int _Val);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_strupr" ". See online help for details.")) __declspec(dllimport) char * __cdecl strupr( char * _Str);
#line 273 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string.h"
               __declspec(dllimport) wchar_t * __cdecl _wcsdup( const wchar_t * _Str);






                   __declspec(dllimport) errno_t __cdecl wcscat_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src);

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Dest)[_Size], const wchar_t * _Source) throw() { return wcscat_s(_Dest, _Size, _Source); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcscat( wchar_t *_Dest, const wchar_t * _Source);



__declspec(dllimport) const wchar_t * __cdecl wcschr( const wchar_t * _Str, wchar_t _Ch);
               __declspec(dllimport) int __cdecl wcscmp( const wchar_t * _Str1, const wchar_t * _Str2);

                   __declspec(dllimport) errno_t __cdecl wcscpy_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src);

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Dest)[_Size], const wchar_t * _Source) throw() { return wcscpy_s(_Dest, _Size, _Source); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcscpy( wchar_t *_Dest, const wchar_t * _Source);
               __declspec(dllimport) size_t __cdecl wcscspn( const wchar_t * _Str, const wchar_t * _Control);
               __declspec(dllimport) size_t __cdecl wcslen( const wchar_t * _Str);
               __declspec(dllimport)


size_t __cdecl wcsnlen( const wchar_t * _Src, size_t _MaxCount);

               static __inline


size_t __cdecl wcsnlen_s( const wchar_t * _Src, size_t _MaxCount)
{
    return (_Src == 0) ? 0 : wcsnlen(_Src, _MaxCount);
}


                   __declspec(dllimport) errno_t __cdecl wcsncat_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src, rsize_t _MaxCount);

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(wchar_t (&_Dest)[_Size], const wchar_t * _Source, size_t _Count) throw() { return wcsncat_s(_Dest, _Size, _Source, _Count); } }
#pragma warning(push)
#pragma warning(disable: 6059)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsncat( wchar_t *_Dest, const wchar_t * _Source, size_t _Count);
#pragma warning(pop)
 __declspec(dllimport) int __cdecl wcsncmp( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);

                   __declspec(dllimport) errno_t __cdecl wcsncpy_s( wchar_t * _Dst, rsize_t _SizeInWords, const wchar_t * _Src, rsize_t _MaxCount);

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Dest)[_Size], const wchar_t * _Source, size_t _Count) throw() { return wcsncpy_s(_Dest, _Size, _Source, _Count); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsncpy( wchar_t *_Dest, const wchar_t * _Source, size_t _Count);
               __declspec(dllimport) const wchar_t * __cdecl wcspbrk( const wchar_t * _Str, const wchar_t * _Control);
               __declspec(dllimport) const wchar_t * __cdecl wcsrchr( const wchar_t * _Str, wchar_t _Ch);
               __declspec(dllimport) size_t __cdecl wcsspn( const wchar_t * _Str, const wchar_t * _Control);


__declspec(dllimport) const wchar_t * __cdecl wcsstr( const wchar_t * _Str, const wchar_t * _SubStr);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcstok( wchar_t * _Str, const wchar_t * _Delim);

               __declspec(dllimport) wchar_t * __cdecl wcstok_s( wchar_t * _Str, const wchar_t * _Delim, wchar_t ** _Context);

               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcserror( int _ErrNum);
                   __declspec(dllimport) errno_t __cdecl _wcserror_s( wchar_t * _Buf, size_t _SizeInWords, int _ErrNum);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl __wcserror( const wchar_t * _Str);
                   __declspec(dllimport) errno_t __cdecl __wcserror_s( wchar_t * _Buffer, size_t _SizeInWords, const wchar_t * _ErrMsg);
extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size], const wchar_t * _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }

               __declspec(dllimport) int __cdecl _wcsicmp( const wchar_t * _Str1, const wchar_t * _Str2);
               __declspec(dllimport) int __cdecl _wcsicmp_l( const wchar_t * _Str1, const wchar_t * _Str2, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _wcsnicmp( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
               __declspec(dllimport) int __cdecl _wcsnicmp_l( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale);
                   __declspec(dllimport) errno_t __cdecl _wcsnset_s( wchar_t * _Dst, size_t _SizeInWords, wchar_t _Val, size_t _MaxCount);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(wchar_t (&_Dst)[_Size], wchar_t _Val, size_t _MaxCount) throw() { return _wcsnset_s(_Dst, _Size, _Val, _MaxCount); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsnset( wchar_t *_Str, wchar_t _Val, size_t _MaxCount);
__declspec(dllimport) wchar_t * __cdecl _wcsrev( wchar_t * _Str);
                   __declspec(dllimport) errno_t __cdecl _wcsset_s( wchar_t * _Dst, size_t _SizeInWords, wchar_t _Value);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(wchar_t (&_Str)[_Size], wchar_t _Val) throw() { return _wcsset_s(_Str, _Size, _Val); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsset( wchar_t *_Str, wchar_t _Val);

                   __declspec(dllimport) errno_t __cdecl _wcslwr_s( wchar_t * _Str, size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcslwr( wchar_t *_String);
                   __declspec(dllimport) errno_t __cdecl _wcslwr_s_l( wchar_t * _Str, size_t _SizeInWords, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcslwr_l( wchar_t *_String, _locale_t _Locale);
                   __declspec(dllimport) errno_t __cdecl _wcsupr_s( wchar_t * _Str, size_t _Size);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsupr( wchar_t *_String);
                   __declspec(dllimport) errno_t __cdecl _wcsupr_s_l( wchar_t * _Str, size_t _Size, _locale_t _Locale);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wcsupr_l( wchar_t *_String, _locale_t _Locale);
                   __declspec(dllimport) size_t __cdecl wcsxfrm( wchar_t * _Dst, const wchar_t * _Src, size_t _MaxCount);
                   __declspec(dllimport) size_t __cdecl _wcsxfrm_l( wchar_t * _Dst, const wchar_t *_Src, size_t _MaxCount, _locale_t _Locale);
               __declspec(dllimport) int __cdecl wcscoll( const wchar_t * _Str1, const wchar_t * _Str2);
               __declspec(dllimport) int __cdecl _wcscoll_l( const wchar_t * _Str1, const wchar_t * _Str2, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _wcsicoll( const wchar_t * _Str1, const wchar_t * _Str2);
               __declspec(dllimport) int __cdecl _wcsicoll_l( const wchar_t * _Str1, const wchar_t *_Str2, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _wcsncoll( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
               __declspec(dllimport) int __cdecl _wcsncoll_l( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale);
               __declspec(dllimport) int __cdecl _wcsnicoll( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
               __declspec(dllimport) int __cdecl _wcsnicoll_l( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale);




extern "C++" {


        inline wchar_t * __cdecl wcschr( wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcschr((const wchar_t *)_Str, _Ch)); }
               inline wchar_t * __cdecl wcspbrk( wchar_t *_Str, const wchar_t *_Control)
        {return ((wchar_t *)wcspbrk((const wchar_t *)_Str, _Control)); }
               inline wchar_t * __cdecl wcsrchr( wchar_t *_Str, wchar_t _Ch)
        {return ((wchar_t *)wcsrchr((const wchar_t *)_Str, _Ch)); }


        inline wchar_t * __cdecl wcsstr( wchar_t *_Str, const wchar_t *_SubStr)
        {return ((wchar_t *)wcsstr((const wchar_t *)_Str, _SubStr)); }
}
#line 403 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string.h"
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsdup" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsdup( const wchar_t * _Str);
#line 413 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string.h"
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicmp( const wchar_t * _Str1, const wchar_t * _Str2);
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsnicmp" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsnicmp( const wchar_t * _Str1, const wchar_t * _Str2, size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsnset" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsnset( wchar_t * _Str, wchar_t _Val, size_t _MaxCount);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsrev" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsrev( wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsset" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsset( wchar_t * _Str, wchar_t _Val);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcslwr" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcslwr( wchar_t * _Str);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsupr" ". See online help for details.")) __declspec(dllimport) wchar_t * __cdecl wcsupr( wchar_t * _Str);
               __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_wcsicoll" ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicoll( const wchar_t * _Str1, const wchar_t * _Str2);
#line 434 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string.h"
}
#line 13 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstring"




namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
#line 7 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\iosfwd"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cwchar"
#line 13 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cwchar"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
#line 23 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 23 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"


#pragma pack(push,8)


extern "C" {
#line 93 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
typedef unsigned long _fsize_t;





struct _wfinddata32_t {
        unsigned attrib;
        __time32_t time_create;
        __time32_t time_access;
        __time32_t time_write;
        _fsize_t size;
        wchar_t name[260];
};

struct _wfinddata32i64_t {
        unsigned attrib;
        __time32_t time_create;
        __time32_t time_access;
        __time32_t time_write;
        __int64 size;
        wchar_t name[260];
};

struct _wfinddata64i32_t {
        unsigned attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        _fsize_t size;
        wchar_t name[260];
};

struct _wfinddata64_t {
        unsigned attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        __int64 size;
        wchar_t name[260];
};
#line 199 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
__declspec(dllimport) const unsigned short * __cdecl __pctype_func(void);

__declspec(dllimport) extern const unsigned short *_pctype;
#line 212 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
__declspec(dllimport) extern const unsigned short _wctype[];
#line 222 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
__declspec(dllimport) const wctype_t * __cdecl __pwctype_func(void);

__declspec(dllimport) extern const wctype_t *_pwctype;
#line 254 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
               __declspec(dllimport) int __cdecl iswalpha( wint_t _C);
               __declspec(dllimport) int __cdecl _iswalpha_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswupper( wint_t _C);
               __declspec(dllimport) int __cdecl _iswupper_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswlower( wint_t _C);
               __declspec(dllimport) int __cdecl _iswlower_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswdigit( wint_t _C);
               __declspec(dllimport) int __cdecl _iswdigit_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswxdigit( wint_t _C);
               __declspec(dllimport) int __cdecl _iswxdigit_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswspace( wint_t _C);
               __declspec(dllimport) int __cdecl _iswspace_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswpunct( wint_t _C);
               __declspec(dllimport) int __cdecl _iswpunct_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswblank( wint_t _C);
               __declspec(dllimport) int __cdecl _iswblank_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswalnum( wint_t _C);
               __declspec(dllimport) int __cdecl _iswalnum_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswprint( wint_t _C);
               __declspec(dllimport) int __cdecl _iswprint_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswgraph( wint_t _C);
               __declspec(dllimport) int __cdecl _iswgraph_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswcntrl( wint_t _C);
               __declspec(dllimport) int __cdecl _iswcntrl_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswascii( wint_t _C);


               __declspec(dllimport) int __cdecl isleadbyte( int _C);
               __declspec(dllimport) int __cdecl _isleadbyte_l( int _C, _locale_t _Locale);


               __declspec(dllimport) wint_t __cdecl towupper( wint_t _C);
               __declspec(dllimport) wint_t __cdecl _towupper_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) wint_t __cdecl towlower( wint_t _C);
               __declspec(dllimport) wint_t __cdecl _towlower_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iswctype( wint_t _C, wctype_t _Type);
               __declspec(dllimport) int __cdecl _iswctype_l( wint_t _C, wctype_t _Type, _locale_t _Locale);

               __declspec(dllimport) int __cdecl __iswcsymf( wint_t _C);
               __declspec(dllimport) int __cdecl _iswcsymf_l( wint_t _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl __iswcsym( wint_t _C);
               __declspec(dllimport) int __cdecl _iswcsym_l( wint_t _C, _locale_t _Locale);


__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "iswctype" " instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype( wint_t _C, wctype_t _Type);
#line 318 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
                                 __declspec(dllimport) wchar_t * __cdecl _wgetcwd( wchar_t * _DstBuf, int _SizeInWords);
                                 __declspec(dllimport) wchar_t * __cdecl _wgetdcwd( int _Drive, wchar_t * _DstBuf, int _SizeInWords);







               __declspec(dllimport) int __cdecl _wchdir( const wchar_t * _Path);



               __declspec(dllimport) int __cdecl _wmkdir( const wchar_t * _Path);
               __declspec(dllimport) int __cdecl _wrmdir( const wchar_t * _Path);






               __declspec(dllimport) int __cdecl _waccess( const wchar_t * _Filename, int _AccessMode);
                   __declspec(dllimport) errno_t __cdecl _waccess_s( const wchar_t * _Filename, int _AccessMode);
               __declspec(dllimport) int __cdecl _wchmod( const wchar_t * _Filename, int _Mode);
               __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wcreat( const wchar_t * _Filename, int _PermissionMode);
               __declspec(dllimport) intptr_t __cdecl _wfindfirst32( const wchar_t * _Filename, struct _wfinddata32_t * _FindData);
               __declspec(dllimport) int __cdecl _wfindnext32( intptr_t _FindHandle, struct _wfinddata32_t * _FindData);
__declspec(dllimport) int __cdecl _wunlink( const wchar_t * _Filename);
               __declspec(dllimport) int __cdecl _wrename( const wchar_t * _OldFilename, const wchar_t * _NewFilename);
__declspec(dllimport) errno_t __cdecl _wmktemp_s( wchar_t * _TemplateName, size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wmktemp( wchar_t *_TemplateName);

               __declspec(dllimport) intptr_t __cdecl _wfindfirst32i64( const wchar_t * _Filename, struct _wfinddata32i64_t * _FindData);
               __declspec(dllimport) intptr_t __cdecl _wfindfirst64i32( const wchar_t * _Filename, struct _wfinddata64i32_t * _FindData);
               __declspec(dllimport) intptr_t __cdecl _wfindfirst64( const wchar_t * _Filename, struct _wfinddata64_t * _FindData);
               __declspec(dllimport) int __cdecl _wfindnext32i64( intptr_t _FindHandle, struct _wfinddata32i64_t * _FindData);
               __declspec(dllimport) int __cdecl _wfindnext64i32( intptr_t _FindHandle, struct _wfinddata64i32_t * _FindData);
               __declspec(dllimport) int __cdecl _wfindnext64( intptr_t _FindHandle, struct _wfinddata64_t * _FindData);

                   __declspec(dllimport) errno_t __cdecl _wsopen_s( int * _FileHandle, const wchar_t * _Filename, int _OpenFlag, int _ShareFlag, int _PermissionFlag);
#line 368 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wopen( const wchar_t * _Filename, int _OpenFlag, int _PermissionMode = 0);
extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _wsopen( const wchar_t * _Filename, int _OpenFlag, int _ShareFlag, int _PermissionMode = 0);
#line 380 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
                   __declspec(dllimport) wchar_t * __cdecl _wsetlocale( int _Category, const wchar_t * _Locale);
                   __declspec(dllimport) _locale_t __cdecl _wcreate_locale( int _Category, const wchar_t * _Locale);
#line 392 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
__declspec(dllimport) intptr_t __cdecl _wexecl( const wchar_t * _Filename, const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexecle( const wchar_t * _Filename, const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexeclp( const wchar_t * _Filename, const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexeclpe( const wchar_t * _Filename, const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wexecv( const wchar_t * _Filename, const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wexecve( const wchar_t * _Filename, const wchar_t * const * _ArgList,
                   const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wexecvp( const wchar_t * _Filename, const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wexecvpe( const wchar_t * _Filename, const wchar_t * const * _ArgList,
                   const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wspawnl( int _Mode, const wchar_t * _Filename, const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnle( int _Mode, const wchar_t * _Filename, const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnlp( int _Mode, const wchar_t * _Filename, const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnlpe( int _Mode, const wchar_t * _Filename, const wchar_t * _ArgList, ...);
__declspec(dllimport) intptr_t __cdecl _wspawnv( int _Mode, const wchar_t * _Filename, const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wspawnve( int _Mode, const wchar_t * _Filename, const wchar_t * const * _ArgList,
                   const wchar_t * const * _Env);
__declspec(dllimport) intptr_t __cdecl _wspawnvp( int _Mode, const wchar_t * _Filename, const wchar_t * const * _ArgList);
__declspec(dllimport) intptr_t __cdecl _wspawnvpe( int _Mode, const wchar_t * _Filename, const wchar_t * const * _ArgList,
                   const wchar_t * const * _Env);
#line 473 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
typedef unsigned short _ino_t;


typedef unsigned short ino_t;





typedef unsigned int _dev_t;


typedef unsigned int dev_t;





typedef long _off_t;


typedef long off_t;






struct _stat32 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };



struct stat {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
        };



struct _stat32i64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
        };

struct _stat64i32 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };

struct _stat64 {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
        };
#line 607 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
__declspec(dllimport) int __cdecl _wstat32( const wchar_t * _Name, struct _stat32 * _Stat);

__declspec(dllimport) int __cdecl _wstat32i64( const wchar_t * _Name, struct _stat32i64 * _Stat);
__declspec(dllimport) int __cdecl _wstat64i32( const wchar_t * _Name, struct _stat64i32 * _Stat);
__declspec(dllimport) int __cdecl _wstat64( const wchar_t * _Name, struct _stat64 * _Stat);
#line 627 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
                   __declspec(dllimport) errno_t __cdecl _cgetws_s( wchar_t * _Buffer, size_t _SizeInWords, size_t * _SizeRead);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _cgetws_s(wchar_t (&_Buffer)[_Size], size_t * _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_cgetws_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _cgetws( wchar_t *_Buffer);
               __declspec(dllimport) wint_t __cdecl _getwch(void);
               __declspec(dllimport) wint_t __cdecl _getwche(void);
               __declspec(dllimport) wint_t __cdecl _putwch(wchar_t _WCh);
               __declspec(dllimport) wint_t __cdecl _ungetwch(wint_t _WCh);
                   __declspec(dllimport) int __cdecl _cputws( const wchar_t * _String);
                   __declspec(dllimport) int __cdecl _cwprintf( const wchar_t * _Format, ...);
                   __declspec(dllimport) int __cdecl _cwprintf_s( const wchar_t * _Format, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _cwscanf( const wchar_t * _Format, ...);
                   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) int __cdecl _cwscanf_l( const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _cwscanf_s( const wchar_t * _Format, ...);
                   __declspec(dllimport) int __cdecl _cwscanf_s_l( const wchar_t * _Format, _locale_t _Locale, ...);
                   __declspec(dllimport) int __cdecl _vcwprintf( const wchar_t *_Format, va_list _ArgList);
                   __declspec(dllimport) int __cdecl _vcwprintf_s( const wchar_t *_Format, va_list _ArgList);

                   __declspec(dllimport) int __cdecl _cwprintf_p( const wchar_t * _Format, ...);
                   __declspec(dllimport) int __cdecl _vcwprintf_p( const wchar_t* _Format, va_list _ArgList);

__declspec(dllimport) int __cdecl _cwprintf_l( const wchar_t * _Format, _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _cwprintf_s_l( const wchar_t * _Format, _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf_l( const wchar_t *_Format, _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _vcwprintf_s_l( const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);
__declspec(dllimport) int __cdecl _cwprintf_p_l( const wchar_t * _Format, _locale_t _Locale, ...);
__declspec(dllimport) int __cdecl _vcwprintf_p_l( const wchar_t * _Format, _locale_t _Locale, va_list _ArgList);

                   wint_t __cdecl _putwch_nolock(wchar_t _WCh);
               wint_t __cdecl _getwch_nolock(void);
               wint_t __cdecl _getwche_nolock(void);
                   wint_t __cdecl _ungetwch_nolock(wint_t _WCh);
#line 1170 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"
struct tm {
        int tm_sec;
        int tm_min;
        int tm_hour;
        int tm_mday;
        int tm_mon;
        int tm_year;
        int tm_wday;
        int tm_yday;
        int tm_isdst;
        };







__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wasctime( const struct tm * _Tm);
__declspec(dllimport) errno_t __cdecl _wasctime_s( wchar_t *_Buf, size_t _SizeInWords, const struct tm * _Tm);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wasctime_s(wchar_t (&_Buffer)[_Size], const struct tm * _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wctime32( const __time32_t *_Time);
__declspec(dllimport) errno_t __cdecl _wctime32_s( wchar_t* _Buf, size_t _SizeInWords, const __time32_t * _Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(wchar_t (&_Buffer)[_Size], const __time32_t * _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }

__declspec(dllimport) size_t __cdecl wcsftime( wchar_t * _Buf, size_t _SizeInWords, const wchar_t * _Format, const struct tm * _Tm);
__declspec(dllimport) size_t __cdecl _wcsftime_l( wchar_t * _Buf, size_t _SizeInWords, const wchar_t *_Format, const struct tm *_Tm, _locale_t _Locale);

__declspec(dllimport) errno_t __cdecl _wstrdate_s( wchar_t * _Buf, size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wstrdate( wchar_t *_Buffer);

__declspec(dllimport) errno_t __cdecl _wstrtime_s( wchar_t * _Buf, size_t _SizeInWords);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wstrtime( wchar_t *_Buffer);

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) wchar_t * __cdecl _wctime64( const __time64_t * _Time);
__declspec(dllimport) errno_t __cdecl _wctime64_s( wchar_t* _Buf, size_t _SizeInWords, const __time64_t *_Time);
extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(wchar_t (&_Buffer)[_Size], const __time64_t * _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }



#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wtime.inl"
#line 27 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wtime.inl"
#pragma warning(push)
#pragma warning(disable: 4996)
#line 44 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wtime.inl"
static __inline wchar_t * __cdecl _wctime(const time_t * _Time)
{
#pragma warning(push)
#pragma warning(disable: 4996)
 return _wctime64(_Time);
#pragma warning(pop)
}

static __inline errno_t __cdecl _wctime_s( wchar_t *_Buffer, size_t _SizeInWords, const time_t * _Time)
{
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}


#pragma warning(pop)
#line 1212 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wchar.h"







typedef int mbstate_t;
typedef wchar_t _Wint_t;

__declspec(dllimport) wint_t __cdecl btowc(int);
__declspec(dllimport) size_t __cdecl mbrlen( const char * _Ch, size_t _SizeInBytes,
                                        mbstate_t * _State);
__declspec(dllimport) size_t __cdecl mbrtowc( wchar_t * _DstCh, const char * _SrcCh,
                                    size_t _SizeInBytes, mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl mbsrtowcs_s( size_t* _Retval, wchar_t * _Dst, size_t _Size, const char ** _PSrc, size_t _N, mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl mbsrtowcs_s(size_t * _Retval, wchar_t (&_Dest)[_Size], const char ** _PSource, size_t _Count, mbstate_t * _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest, const char ** _PSrc, size_t _Count, mbstate_t * _State);

__declspec(dllimport) errno_t __cdecl wcrtomb_s( size_t * _Retval, char * _Dst,
             size_t _SizeInBytes, wchar_t _Ch, mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcrtomb_s(size_t * _Retval, char (&_Dest)[_Size], wchar_t _Source, mbstate_t * _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb( char *_Dest, wchar_t _Source, mbstate_t * _State);
__declspec(dllimport) errno_t __cdecl wcsrtombs_s( size_t * _Retval, char * _Dst,
             size_t _SizeInBytes, const wchar_t ** _Src, size_t _Size, mbstate_t * _State);
extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsrtombs_s(size_t * _Retval, char (&_Dest)[_Size], const wchar_t ** _PSrc, size_t _Count, mbstate_t * _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs( char *_Dest, const wchar_t ** _PSource, size_t _Count, mbstate_t * _State);
__declspec(dllimport) int __cdecl wctob( wint_t _WCh);




__declspec(dllimport) void * __cdecl memmove( void * _Dst, const void * _Src, size_t _Size);



void * __cdecl memcpy( void * _Dst, const void * _Src, size_t _Size);

__declspec(dllimport) errno_t __cdecl memcpy_s( void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount);
__declspec(dllimport) errno_t __cdecl memmove_s( void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount);

__inline int __cdecl fwide( FILE * _F, int _M)
        {(void)_F; return (_M); }
__inline int __cdecl mbsinit( const mbstate_t *_P)
        {return (_P == 0 || *_P == 0); }
__inline const wchar_t * __cdecl wmemchr( const wchar_t *_S, wchar_t _C, size_t _N)
        {for (; 0 < _N; ++_S, --_N)
                if (*_S == _C)
                        return (const wchar_t *)(_S);
        return (0); }
__inline int __cdecl wmemcmp( const wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {for (; 0 < _N; ++_S1, ++_S2, --_N)
                if (*_S1 != *_S2)
                        return (*_S1 < *_S2 ? -1 : +1);
        return (0); }



__inline wchar_t * __cdecl wmemcpy( wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
#pragma warning(push)
#pragma warning(disable: 4996 6386)
 return (wchar_t *)memcpy(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning(pop)
 }

__inline wchar_t * __cdecl wmemmove( wchar_t *_S1, const wchar_t *_S2, size_t _N)
        {
#pragma warning(push)
#pragma warning(disable: 4996 6386)
#pragma warning(disable: 6387)

 return (wchar_t *)memmove(_S1, _S2, _N*sizeof(wchar_t));
#pragma warning(pop)
 }


errno_t __cdecl wmemcpy_s( wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N);
errno_t __cdecl wmemmove_s( wchar_t *_S1, rsize_t _N1, const wchar_t *_S2, rsize_t _N);




__inline wchar_t * __cdecl wmemset( wchar_t *_S, wchar_t _C, size_t _N)
        {
            wchar_t *_Su = _S;
            for (; 0 < _N; ++_Su, --_N)
            {
                *_Su = _C;
            }
            return (_S);
        }


extern "C++" {
inline wchar_t * __cdecl wmemchr( wchar_t *_S, wchar_t _C, size_t _N)
        { return (wchar_t *)wmemchr((const wchar_t *)_S, _C, _N); }
}




}


#pragma pack(pop)
#line 13 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cwchar"



typedef mbstate_t _Mbstatet;


namespace std {
using :: _Mbstatet;

using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
}
#line 8 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\iosfwd"



#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"
#line 15 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 15 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"





#pragma pack(push,8)
#line 35 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"
extern "C" {
#line 44 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"
typedef void *_HFILE;
#line 71 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"
typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);
typedef int (__cdecl * _CRT_REPORT_HOOKW)(int, wchar_t *, int *);
#line 103 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"
typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);
#line 164 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"
typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);







struct _CrtMemBlockHeader;
typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        size_t lCounts[5];
        size_t lSizes[5];
        size_t lHighWaterCount;
        size_t lTotalCount;
} _CrtMemState;
#line 1018 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"
}



extern "C++" {
#line 1035 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"
#pragma warning(suppress: 4985)
 void * __cdecl operator new[](size_t _Size);


                                               void * __cdecl operator new(
        size_t _Size,
        int,
        const char *,
        int
        );

#pragma warning(suppress: 4985)
 void * __cdecl operator new[](
        size_t _Size,
        int,
        const char *,
        int
        );

void __cdecl operator delete[](void *);
void __cdecl operator delete(void * _P, int, const char *, int);
void __cdecl operator delete[](void * _P, int, const char *, int);
#line 1113 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdbg.h"
}






#pragma pack(pop)
#line 11 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\iosfwd"


#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {


typedef _Longlong streamoff;
typedef _Longlong streamsize;
#line 31 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\iosfwd"
extern __declspec(dllimport) const streamoff _BADOFF;



template<class _Statetype>
 class fpos
 {
 typedef fpos<_Statetype> _Myt;

public:
                    fpos(streamoff _Off = 0)
  : _Myoff(_Off), _Fpos(0), _Mystate()
  {
  }

                    fpos(_Statetype _State, fpos_t _Fileposition)
  : _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
  {
  }

 _Statetype state() const
  {
  return (_Mystate);
  }

 void state(_Statetype _State)
  {
  _Mystate = _State;
  }

 fpos_t seekpos() const
  {
  return (_Fpos);
  }

                    operator streamoff() const
  {
  return ((streamoff)(_Myoff + ((long long)(_Fpos))));
  }

 streamoff operator-(const _Myt& _Right) const
  {
  return ((streamoff)*this - (streamoff)_Right);
  }

 _Myt& operator+=(streamoff _Off)
  {
  _Myoff += _Off;
  return (*this);
  }

 _Myt& operator-=(streamoff _Off)
  {
  _Myoff -= _Off;
  return (*this);
  }

 _Myt operator+(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myt operator-(streamoff _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }

 bool operator==(const _Myt& _Right) const
  {
  return ((streamoff)*this == (streamoff)_Right);
  }

 bool operator==(streamoff _Right) const
  {
  return ((streamoff)*this == _Right);
  }

 bool operator!=(const _Myt& _Right) const
  {
  return (!(*this == _Right));
  }

private:
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };






typedef fpos<_Mbstatet> streampos;

typedef streampos wstreampos;


template<class _Elem,
 class _Int_type>
 struct _Char_traits
 {
 typedef _Elem char_type;
 typedef _Int_type int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare(
                     const _Elem *_First1,
                     const _Elem *_First2, size_t _Count)
  {
  for (; 0 < _Count; --_Count, ++_First1, ++_First2)
   if (!eq(*_First1, *_First2))
    return (lt(*_First1, *_First2) ? -1 : +1);
  return (0);
  }

 static size_t __cdecl length( const _Elem *_First)
  {
  size_t _Count;
  for (_Count = 0; !eq(*_First, _Elem()); ++_First)
   ++_Count;
  return (_Count);
  }

 static _Elem *__cdecl copy(
                       _Elem *_First1,
                     const _Elem *_First2, size_t _Count)
  {
  _Elem *_Next = _First1;
  for (; 0 < _Count; --_Count, ++_Next, ++_First2)
   assign(*_Next, *_First2);
  return (_First1);
  }

 static _Elem *__cdecl _Copy_s(
                           _Elem *_First1, size_t _Dest_size,
                     const _Elem *_First2, size_t _Count)
  {
  { if (!(_Count <= _Dest_size)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); return (0); } };
  return (copy(_First1, _First2, _Count));
  }

 static const _Elem *__cdecl find(
                     const _Elem *_First,
  size_t _Count, const _Elem& _Ch)
  {
  for (; 0 < _Count; --_Count, ++_First)
   if (eq(*_First, _Ch))
    return (_First);
  return (0);
  }

 static _Elem *__cdecl move(
                       _Elem *_First1,
                     const _Elem *_First2, size_t _Count)
  {
  _Elem *_Next = _First1;
  if (_First2 < _Next && _Next < _First2 + _Count)
   for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
    assign(*--_Next, *--_First2);
  else
   for (; 0 < _Count; --_Count, ++_Next, ++_First2)
    assign(*_Next, *_First2);
  return (_First1);
  }

 static _Elem *__cdecl assign(
                       _Elem *_First,
  size_t _Count, _Elem _Ch)
  {
  _Elem *_Next = _First;
  for (; 0 < _Count; --_Count, ++_Next)
   assign(*_Next, _Ch);
  return (_First);
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
  {
  _Left = _Right;
  }

 static bool __cdecl eq(const _Elem& _Left,
  const _Elem& _Right) throw ()
  {
  return (_Left == _Right);
  }

 static bool __cdecl lt(const _Elem& _Left,
  const _Elem& _Right) throw ()
  {
  return (_Left < _Right);
  }

 static _Elem __cdecl to_char_type(
  const int_type& _Meta) throw ()
  {
  return ((_Elem)_Meta);
  }

 static int_type __cdecl to_int_type(
  const _Elem& _Ch) throw ()
  {
  return ((int_type)_Ch);
  }

 static bool __cdecl eq_int_type(const int_type& _Left,
  const int_type& _Right) throw ()
  {
  return (_Left == _Right);
  }

 static int_type __cdecl not_eof(
  const int_type& _Meta) throw ()
  {
  return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
  }

 static int_type __cdecl eof() throw ()
  {
  return ((int_type)(-1));
  }
 };


template<class _Elem>
 struct char_traits
  : public _Char_traits<_Elem, long>
 {
 };
#line 286 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\iosfwd"
template<>
 struct char_traits<wchar_t>
 {
 typedef wchar_t _Elem;
 typedef _Elem char_type;
 typedef wint_t int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : :: wmemcmp(_First1, _First2, _Count));
  }

 static size_t __cdecl length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : :: wcslen(_First));
  }

 static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemcpy(_First1, _First2, _Count));
  }

 static _Elem *__cdecl _Copy_s(
                               _Elem *_First1, size_t _Size_in_words,
                     const _Elem *_First2, size_t _Count)
  {
  if (0 < _Count)
   ::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
  return (_First1);
  }

 static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *):: wmemchr(_First, _Ch, _Count));
  }

 static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemmove(_First1, _First2, _Count));
  }

 static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: wmemset(_First, _Ch, _Count));
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
  {
  _Left = _Right;
  }

 static bool __cdecl eq(const _Elem& _Left,
  const _Elem& _Right) throw ()
  {
  return (_Left == _Right);
  }

 static bool __cdecl lt(const _Elem& _Left,
  const _Elem& _Right) throw ()
  {
  return (_Left < _Right);
  }

 static _Elem __cdecl to_char_type(
  const int_type& _Meta) throw ()
  {
  return (_Meta);
  }

 static int_type __cdecl to_int_type(
  const _Elem& _Ch) throw ()
  {
  return (_Ch);
  }

 static bool __cdecl eq_int_type(const int_type& _Left,
  const int_type& _Right) throw ()
  {
  return (_Left == _Right);
  }

 static int_type __cdecl not_eof(
  const int_type& _Meta) throw ()
  {
  return (_Meta != eof() ? _Meta : !eof());
  }

 static int_type __cdecl eof() throw ()
  {
  return ((wint_t)(0xFFFF));
  }
 };



template<>
 struct char_traits<unsigned short>
 {
 typedef unsigned short _Elem;
 typedef _Elem char_type;
 typedef wint_t int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : :: wmemcmp((const wchar_t *)_First1,
    (const wchar_t *)_First2, _Count));
  }

 static size_t __cdecl length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : :: wcslen((const wchar_t *)_First));
  }

 static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemcpy((wchar_t *)_First1,
    (const wchar_t *)_First2, _Count));
  }

 static _Elem *__cdecl _Copy_s(
                               _Elem *_First1, size_t _Size_in_words,
                     const _Elem *_First2, size_t _Count)
  {
  if (0 < _Count)
   ::wmemcpy_s(((wchar_t *)_First1), (_Size_in_words), ((const wchar_t *)_First2), (_Count));

  return (_First1);
  }

 static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *):: wmemchr((const wchar_t *)_First,
    _Ch, _Count));
  }

 static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: wmemmove((wchar_t *)_First1,
    (const wchar_t *)_First2, _Count));
  }

 static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: wmemset((wchar_t *)_First, _Ch, _Count));
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
  {
  _Left = _Right;
  }

 static bool __cdecl eq(const _Elem& _Left,
  const _Elem& _Right) throw ()
  {
  return (_Left == _Right);
  }

 static bool __cdecl lt(const _Elem& _Left,
  const _Elem& _Right) throw ()
  {
  return (_Left < _Right);
  }

 static _Elem __cdecl to_char_type(const int_type& _Meta) throw ()
  {
  return (_Meta);
  }

 static int_type __cdecl to_int_type(const _Elem& _Ch) throw ()
  {
  return (_Ch);
  }

 static bool __cdecl eq_int_type(const int_type& _Left,
  const int_type& _Right) throw ()
  {
  return (_Left == _Right);
  }

 static int_type __cdecl not_eof(const int_type& _Meta) throw ()
  {
  return (_Meta != eof() ? _Meta : !eof());
  }

 static int_type __cdecl eof() throw ()
  {
  return ((wint_t)(0xFFFF));
  }
 };



template<> struct char_traits<char>
 {
 typedef char _Elem;
 typedef _Elem char_type;
 typedef int int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? 0
   : :: memcmp(_First1, _First2, _Count));
  }

 static size_t __cdecl length(const _Elem *_First)
  {
  return (*_First == 0 ? 0
   : :: strlen(_First));
  }

 static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: memcpy(_First1, _First2, _Count));
  }

 static _Elem *__cdecl _Copy_s(
                               _Elem *_First1, size_t _Size_in_bytes,
                     const _Elem *_First2, size_t _Count)
  {
  if (0 < _Count)
   ::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
  return (_First1);
  }

 static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
  const _Elem& _Ch)
  {
  return (_Count == 0 ? (const _Elem *)0
   : (const _Elem *):: memchr(_First, _Ch, _Count));
  }

 static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
  size_t _Count)
  {
  return (_Count == 0 ? _First1
   : (_Elem *):: memmove(_First1, _First2, _Count));
  }

 static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
  _Elem _Ch)
  {
  return ((_Elem *):: memset(_First, _Ch, _Count));
  }

 static void __cdecl assign(_Elem& _Left, const _Elem& _Right) throw ()
  {
  _Left = _Right;
  }

 static bool __cdecl eq(const _Elem& _Left,
  const _Elem& _Right) throw ()
  {
  return (_Left == _Right);
  }

 static bool __cdecl lt(const _Elem& _Left,
  const _Elem& _Right) throw ()
  {
  return ((unsigned char)_Left < (unsigned char)_Right);
  }

 static _Elem __cdecl to_char_type(
  const int_type& _Meta) throw ()
  {
  return ((_Elem)_Meta);
  }

 static int_type __cdecl to_int_type(
  const _Elem& _Ch) throw ()
  {
  return ((unsigned char)_Ch);
  }

 static bool __cdecl eq_int_type(const int_type& _Left,
  const int_type& _Right) throw ()
  {
  return (_Left == _Right);
  }

 static int_type __cdecl not_eof(
  const int_type& _Meta) throw ()
  {
  return (_Meta != eof() ? _Meta : !eof());
  }

 static int_type __cdecl eof() throw ()
  {
  return ((-1));
  }
 };


template<class _Ty>
 class allocator;
class ios_base;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ios;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class istreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class ostreambuf_iterator;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_streambuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_istream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ostream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_iostream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringbuf;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_istringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_ostringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Alloc = allocator<_Elem> >
 class basic_stringstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_filebuf;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ifstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_ofstream;
template<class _Elem,
 class _Traits = char_traits<_Elem> >
 class basic_fstream;


template<class _Elem,
 class _InIt >
 class num_get;
template<class _Elem,
 class _OutIt >
 class num_put;
template<class _Elem>
 class collate;



typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
 allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
 allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
 allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
 allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;


typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
 wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
 allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;
#line 736 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\iosfwd"
typedef num_get<char, istreambuf_iterator<char, char_traits<char> > >
 numget;
typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >
 wnumget;
typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > >
 numput;
typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >
 wnumput;
typedef collate<char> ncollate;
typedef collate<wchar_t> wcollate;

}


#pragma warning(pop)
#pragma pack(pop)
#line 7 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\utility"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\type_traits"







#pragma pack(push,8)
#pragma warning(push, 3)


#pragma warning(disable: 4180 4296)
#line 66 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\type_traits"
namespace std {

template<class _Ty>
 struct _Ptr_traits
 {
 };

template<class _Ty>
 struct _Ptr_traits<_Ty *>
 {
 static const bool _Is_const = false;
 static const bool _Is_volatile = false;
 };

template<class _Ty>
 struct _Ptr_traits<const _Ty *>
 {
 static const bool _Is_const = true;
 static const bool _Is_volatile = false;
 };

template<class _Ty>
 struct _Ptr_traits<volatile _Ty *>
 {
 static const bool _Is_const = false;
 static const bool _Is_volatile = true;
 };

template<class _Ty>
 struct _Ptr_traits<const volatile _Ty *>
 {
 static const bool _Is_const = true;
 static const bool _Is_volatile = true;
 };

template<class _Ty>
 struct _Is_funptr
  : false_type
 {
 };

template<class _Ty>
 struct _Is_memfunptr
  : false_type
 {
 };
#line 121 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\type_traits"
template<class _Ret, class... _Types> struct _Is_funptr<_Ret (__cdecl *)(_Types...)> : true_type { }; template<class _Ret, class... _Types> struct _Is_funptr<_Ret (__stdcall *)(_Types...)> : true_type { }; template<class _Ret, class... _Types> struct _Is_funptr<_Ret (__fastcall *)(_Types...)> : true_type { };
#line 133 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\type_traits"
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) > : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) > : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) > : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) > : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile> : true_type { };


template<class _Ret,
 class... _Types>
 struct _Is_funptr<_Ret (*)(_Types..., ...)>
  : true_type
 {
 };
#line 152 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\type_traits"
template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> : true_type { }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> : true_type { };




template<class _Ty>
 struct add_const
 {
 typedef const _Ty type;
 };


template<class _Ty>
 struct add_volatile
 {
 typedef volatile _Ty type;
 };


template<class _Ty>
 struct add_cv
 {
 typedef const volatile _Ty type;
 };


template<class _Ty>
 struct add_reference
 {
 typedef _Ty& type;
 };
#line 191 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\type_traits"
template<> struct add_reference< void> { typedef void type; }; template<> struct add_reference<const void> { typedef const void type; }; template<> struct add_reference<volatile void> { typedef volatile void type; }; template<> struct add_reference<const volatile void> { typedef const volatile void type; };



template<class _Ty>
 struct add_lvalue_reference
 {
 typedef typename add_reference<_Ty>::type type;
 };



template<class _Ty>
 struct add_rvalue_reference
 {
 typedef _Ty&& type;
 };
#line 216 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\type_traits"
template<> struct add_rvalue_reference< void> { typedef void type; }; template<> struct add_rvalue_reference<const void> { typedef const void type; }; template<> struct add_rvalue_reference<volatile void> { typedef volatile void type; }; template<> struct add_rvalue_reference<const volatile void> { typedef const volatile void type; };



template<class _Ty>
 typename add_rvalue_reference<_Ty>::type
  declval() throw ();


template<class _Ty>
 struct remove_extent
 {
 typedef _Ty type;
 };

template<class _Ty, unsigned int _Ix>
 struct remove_extent<_Ty[_Ix]>
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct remove_extent<_Ty[]>
 {
 typedef _Ty type;
 };


template<class _Ty>
 struct remove_all_extents
 {
 typedef _Ty type;
 };

template<class _Ty, unsigned int _Ix>
 struct remove_all_extents<_Ty[_Ix]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };

template<class _Ty>
 struct remove_all_extents<_Ty[]>
 {
 typedef typename remove_all_extents<_Ty>::type type;
 };


template<class _Ty>
 struct remove_pointer
 {
 typedef _Ty type;
 };
#line 276 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\type_traits"
template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };



template<class _Ty>
 struct add_pointer
 {
 typedef typename remove_reference<_Ty>::type *type;
 };



template<class _Ty>
 struct _Is_void
  : false_type
 {
 };

template<>
 struct _Is_void<void>
  : true_type
 {
 };

template<class _Ty>
 struct is_void
  : _Is_void<typename remove_cv<_Ty>::type>
 {
 };


template<class _Ty>
 struct is_array
  : false_type
 {
 };

template<class _Ty, size_t _Nx>
 struct is_array<_Ty[_Nx]>
  : true_type
 {
 };

template<class _Ty>
 struct is_array<_Ty[]>
  : true_type
 {
 };


template<class _Ty>
 struct is_lvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_lvalue_reference<_Ty&>
  : true_type
 {
 };


template<class _Ty>
 struct is_rvalue_reference
  : false_type
 {
 };

template<class _Ty>
 struct is_rvalue_reference<_Ty&&>
  : true_type
 {
 };


template<class _Ty>
 struct is_reference
  : _Cat_base<is_lvalue_reference<_Ty>::value
  || is_rvalue_reference<_Ty>::value>
 {
 };



template<class _Ty>
 struct _Is_member_object_pointer
  : false_type
 {
 };

template<class _Ty1, class _Ty2>
 struct _Is_member_object_pointer<_Ty1 _Ty2::*>
  : _Cat_base<!_Is_memfunptr<_Ty1 _Ty2::*>::value>
 {
 };

template<class _Ty>
 struct is_member_object_pointer
  : _Is_member_object_pointer<typename remove_cv<_Ty>::type>
 {
 };


template<class _Ty>
 struct is_member_function_pointer
  : _Cat_base<_Is_memfunptr<typename remove_cv<_Ty>::type>::value>
 {
 };


template<class _Ty>
 struct _Is_pointer
  : false_type
 {
 };

template<class _Ty>
 struct _Is_pointer<_Ty *>
  : _Cat_base<!is_member_object_pointer<_Ty *>::value
  && !is_member_function_pointer<_Ty *>::value>
 {
 };

template<class _Ty>
 struct is_pointer
  : _Is_pointer<typename remove_cv<_Ty>::type>
 {
 };



template<class _Ty>
 struct _Is_nullptr_t
  : _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
 {
 };


template<class _Ty>
 struct is_union : _Cat_base<__is_union(_Ty)>
 {
 };


template<class _Ty>
 struct is_class : _Cat_base<__is_class(_Ty)>
 {
 };


template<class _Ty>
 struct is_function
  : _Cat_base<_Is_funptr<typename remove_cv<_Ty>::type *>::value>
 {
 };

template<class _Ty>
 struct is_function<_Ty&>
  : false_type
 {
 };

template<class _Ty>
 struct is_function<_Ty&&>
  : false_type
 {
 };


template<class _Ty>
 struct is_arithmetic
  : _Cat_base<is_integral<_Ty>::value
  || is_floating_point<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_fundamental
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_void<_Ty>::value
  || _Is_nullptr_t<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_object
  : _Cat_base<!is_function<_Ty>::value
  && !is_reference<_Ty>::value
  && !is_void<_Ty>::value>
 {
 };



template<class _From, class _To>
 struct is_convertible
  : _Cat_base<__is_convertible_to(_From, _To)>
 {
 };


template<class _Ty>
 struct is_enum
  : _Cat_base<__is_enum(_Ty)>
 {
 };


template<class _Ty>
 struct is_compound
  : _Cat_base<!is_fundamental<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_member_pointer
  : _Cat_base<is_member_object_pointer<_Ty>::value
  || is_member_function_pointer<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_scalar
  : _Cat_base<is_arithmetic<_Ty>::value
  || is_enum<_Ty>::value
  || is_pointer<_Ty>::value
  || is_member_pointer<_Ty>::value
  || _Is_nullptr_t<_Ty>::value>
 {
 };


template<class _Ty>
 struct is_const
  : _Cat_base<_Ptr_traits<_Ty *>::_Is_const
  && !is_function<_Ty>::value>
 {
 };

template<class _Ty, unsigned int _Nx>
 struct is_const<_Ty[_Nx]>
  : false_type
 {
 };

template<class _Ty, unsigned int _Nx>
 struct is_const<const _Ty[_Nx]>
  : true_type
 {
 };

template<class _Ty>
 struct is_const<_Ty&>
  : false_type
 {
 };

template<class _Ty>
 struct is_const<_Ty&&>
  : false_type
 {
 };


template<class _Ty>
 struct is_volatile
  : _Cat_base<_Ptr_traits<_Ty *>::_Is_volatile
  && !is_function<_Ty>::value>
 {
 };

template<class _Ty>
 struct is_volatile<_Ty&>
  : false_type
 {
 };

template<class _Ty>
 struct is_volatile<_Ty&&>
  : false_type
 {
 };


template<class _Ty>
 struct is_pod : _Cat_base<__is_pod(_Ty)>
 {
 };


template<class _Ty>
 struct is_empty : _Cat_base<__is_empty(_Ty)>
 {
 };


template<class _Ty>
 struct is_polymorphic : _Cat_base<__is_polymorphic(_Ty)>
 {
 };


template<class _Ty>
 struct is_abstract : _Cat_base<__is_abstract(_Ty)>
 {
 };


template<class _Ty>
 struct is_standard_layout : _Cat_base<__is_standard_layout(_Ty)>
 {
 };


template<class _Ty>
 struct is_literal_type : _Cat_base<__is_literal_type(_Ty)>
 {
 };


template<class _Ty>
 struct is_trivial : _Cat_base<__is_trivial(_Ty)>
 {
 };


template<class _Ty>
 struct has_virtual_destructor
  : _Cat_base<__has_virtual_destructor(_Ty)>
 {
 };





template<class _Ty,
 class... _Args>
 struct is_constructible
  : _Cat_base<__is_constructible(_Ty, _Args...)>
 {
 };




template<class _Ty>
 struct is_copy_constructible
  : is_constructible<
   _Ty,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct has_copy_constructor
  : is_copy_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct is_default_constructible
  : is_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_default_constructor
  : is_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct is_move_constructible
  : is_constructible<

   _Ty,

   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _Ty>
 struct has_move_constructor
  : is_move_constructible<_Ty>::type
 {
 };



template<class _To,
 class _From>
 struct _Is_assignable
 {
 template<class _Dest,
  class _Src>
  static auto _Fn(int)
   -> decltype((::std:: declval<_Dest>() = ::std:: declval<_Src>()),
    true_type());

 template<class _Dest,
  class _Src>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_To, _From>(0)) type;
 };

template<class _To,
 class _From>
 struct is_assignable
  : _Is_assignable<_To, _From>::type

 {
 };



template<class _Ty>
 struct is_copy_assignable
  : is_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct has_copy_assign
  : is_copy_assignable<_Ty>::type
 {
 };



template<class _Ty>
 struct is_move_assignable
  : is_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };

template<class _Ty>
 struct has_move_assign
  : is_move_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct is_destructible
  : _Cat_base<__is_destructible(_Ty)>
 {
 };





template<class _Ty,
 class... _Args>
 struct is_trivially_constructible
  : _Cat_base<__is_trivially_constructible(_Ty, _Args...)>
 {
 };



template<class _Ty>
 struct is_trivially_copy_constructible

  : is_trivially_constructible<
   _Ty,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type

 {
 };


template<class _Ty>
 struct is_trivially_copyable
  : is_trivially_copy_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_copy_constructor
  : is_trivially_copy_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct is_trivially_default_constructible
  : is_trivially_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_trivial_default_constructor
  : is_trivially_default_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct is_trivially_move_constructible

  : is_trivially_constructible<
   _Ty,
   typename add_rvalue_reference<_Ty>::type
  >::type

 {
 };


template<class _Ty>
 struct has_trivial_move_constructor
  : is_trivially_move_constructible<_Ty>::type
 {
 };


template<class _To,
 class _From>
 struct is_trivially_assignable

  : _Cat_base<__is_trivially_assignable(_To, _From)>

 {
 };


template<class _Ty>
 struct is_trivially_copy_assignable

  : is_trivially_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type

 {
 };


template<class _Ty>
 struct has_trivial_copy_assign
  : is_trivially_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct is_trivially_move_assignable

  : is_trivially_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_rvalue_reference<_Ty>::type
  >::type

 {
 };


template<class _Ty>
 struct has_trivial_move_assign
  : is_trivially_move_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct is_trivially_destructible
  : _Cat_base<__has_trivial_destructor(_Ty)>
 {
 };





template<class _Ty,
 class... _Args>
 struct is_nothrow_constructible
  : _Cat_base<__is_nothrow_constructible(_Ty, _Args...)>
 {
 };




template<class _Ty>
 struct is_nothrow_copy_constructible
  : is_nothrow_constructible<
   _Ty,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type
 {
 };


template<class _Ty>
 struct has_nothrow_copy_constructor

  : is_nothrow_copy_constructible<_Ty>::type

 {
 };


template<class _Ty>
 struct is_nothrow_default_constructible
  : is_nothrow_constructible<_Ty>::type
 {
 };


template<class _Ty>
 struct has_nothrow_default_constructor
  : is_nothrow_default_constructible<_Ty>::type
 {
 };



template<class _Ty>
 struct is_nothrow_move_constructible
  : is_nothrow_constructible<
   _Ty,
   typename add_rvalue_reference<_Ty>::type
  >::type
 {
 };


template<class _Ty>
 struct has_nothrow_move_constructor
  : is_nothrow_move_constructible<_Ty>::type
 {
 };


template<class _To,
 class _From>
 struct is_nothrow_assignable

  : _Cat_base<__is_nothrow_assignable(_To, _From)>

 {
 };


template<class _Ty>
 struct is_nothrow_copy_assignable

  : is_nothrow_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_lvalue_reference<
    typename add_const<_Ty>::type
   >::type
  >::type

 {
 };


template<class _Ty>
 struct has_nothrow_copy_assign
  : is_nothrow_copy_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct is_nothrow_move_assignable

  : is_nothrow_assignable<
   typename add_lvalue_reference<_Ty>::type,
   typename add_rvalue_reference<_Ty>::type
  >::type

 {
 };


template<class _Ty>
 struct has_nothrow_move_assign
  : is_nothrow_move_assignable<_Ty>::type
 {
 };


template<class _Ty>
 struct is_nothrow_destructible

  : _Cat_base<__is_nothrow_destructible(_Ty)>

 {
 };


template<class _Ty>
 struct has_trivial_constructor

  : is_trivially_default_constructible<_Ty>::type

 {
 };


template<class _Ty>
 struct has_trivial_copy

  : is_trivially_copy_constructible<_Ty>::type

 {
 };


template<class _Ty>
 struct has_trivial_assign

  : is_trivially_copy_assignable<_Ty>::type

 {
 };


template<class _Ty>
 struct has_trivial_destructor

  : is_trivially_destructible<_Ty>::type

 {
 };


template<class _Ty>
 struct has_nothrow_constructor

  : is_nothrow_default_constructible<_Ty>::type

 {
 };


template<class _Ty>
 struct has_nothrow_copy

  : is_nothrow_copy_constructible<_Ty>::type

 {
 };


template<class _Ty>
 struct has_nothrow_assign

  : is_nothrow_copy_assignable<_Ty>::type

 {
 };


template<class _Ty>
 struct _Has_signed_vals
  : _Cat_base<(typename remove_cv<_Ty>::type)(-1)
  < (typename remove_cv<_Ty>::type)(0)>
 {
 };

template<class _Ty>
 struct is_signed
  : _Cat_base<is_floating_point<_Ty>::value || (is_integral<_Ty>::value
  && _Has_signed_vals<
   typename _If<is_integral<_Ty>::value, _Ty, int>::type>::value)>
 {
 };


template<class _Ty>
 struct is_unsigned
  : _Cat_base<is_integral<_Ty>::value
  && !_Has_signed_vals<
   typename _If<is_integral<_Ty>::value, _Ty, int>::type>::value>
 {
 };


template<class _Ty>
 struct _Change_sign
 {
 static_assert(
  ((is_integral<_Ty>::value || is_enum<_Ty>::value)
   && !is_same<_Ty, bool>::value),
  "make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
  "cv-qualified) integral type or enumeration but not a bool type.");

 typedef
  typename _If<is_same<_Ty, signed char>::value
   || is_same<_Ty, unsigned char >::value, signed char,
  typename _If<is_same<_Ty, short >::value
   || is_same<_Ty, unsigned short >::value, short,
  typename _If<is_same<_Ty, int >::value
   || is_same<_Ty, unsigned int >::value, int,
  typename _If<is_same<_Ty, long >::value
   || is_same<_Ty, unsigned long >::value, long,
  typename _If<is_same<_Ty, long long >::value
   || is_same<_Ty, unsigned long long>::value, long long,
  typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
  typename _If<sizeof (_Ty) == sizeof (short ), short,
  typename _If<sizeof (_Ty) == sizeof (int ), int,
  typename _If<sizeof (_Ty) == sizeof (long ), long,
   long long
  >::type>::type>::type>::type>::type>::type>::type>::type>::type
   _Signed;

 typedef
  typename _If<is_same<_Signed, signed char>::value, unsigned char,
  typename _If<is_same<_Signed, short >::value, unsigned short,
  typename _If<is_same<_Signed, int >::value, unsigned int,
  typename _If<is_same<_Signed, long >::value, unsigned long,
   unsigned long long
  >::type>::type>::type>::type
   _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const _Ty>
 {
 typedef const typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<volatile _Ty>
 {
 typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };

template<class _Ty>
 struct _Change_sign<const volatile _Ty>
 {
 typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
 typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
 };


template<class _Ty>
 struct make_signed
 {
 typedef typename _Change_sign<_Ty>::_Signed type;
 };


template<class _Ty>
 struct make_unsigned
 {
 typedef typename _Change_sign<_Ty>::_Unsigned type;
 };



template<class _Ty>
 struct _Get_align
 {
 _Ty _Elt0;
 char _Elt1;
 _Ty _Elt2;

 _Get_align();
 ~_Get_align();
 };




template<class _Ty>
 struct alignment_of
  : integral_constant<size_t, (sizeof (_Get_align<typename remove_reference<_Ty>::type>) - 2 * sizeof (typename remove_reference<_Ty>::type))>
 {
 };






template<class _Ty,
 size_t _Len>
 union _Align_type
 {
 _Ty _Val;
 char _Pad[_Len];
 };

template<size_t _Len,
 size_t _Align,
 class _Ty,
 bool _Ok>
 struct _Aligned;

template<size_t _Len,
 size_t _Align,
 class _Ty>
 struct _Aligned<_Len, _Align, _Ty, true>
 {
 typedef _Align_type<_Ty, _Len> type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, double, false>
 {
 typedef _Align_type<max_align_t, _Len> type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, int, false>
 {
 typedef typename _Aligned<_Len, _Align, double, _Align <= alignment_of<double>::value>::type type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, short, false>
 {
 typedef typename _Aligned<_Len, _Align, int, _Align <= alignment_of<int>::value>::type type;
 };

template<size_t _Len,
 size_t _Align>
 struct _Aligned<_Len, _Align, char, false>
 {
 typedef typename _Aligned<_Len, _Align, short, _Align <= alignment_of<short>::value>::type type;
 };

template<size_t _Len,
 size_t _Align = alignment_of<max_align_t>::value>
 struct aligned_storage
 {
 typedef typename _Aligned<_Len, _Align, char, _Align <= alignment_of<char>::value>::type type;
 };





template<size_t... _Vals>
 struct _Maximum;

template<>
 struct _Maximum<>
 {
 static const size_t value = 0;
 };

template<size_t _Val>
 struct _Maximum<_Val>
 {
 static const size_t value = _Val;
 };

template<size_t _First,
 size_t _Second,
 size_t... _Rest>
 struct _Maximum<_First, _Second, _Rest...>
  : _Maximum<(_First < _Second ? _Second : _First), _Rest...>
 {
 };

template<size_t _Len,
 class... _Types>
 struct aligned_union
 {
 static const size_t _Max_len = _Maximum<
  _Len, sizeof(_Types)...>::value;
 static const size_t alignment_value = _Maximum<
  alignment_of<_Types>::value...>::value;
 typedef typename aligned_storage<_Max_len, alignment_value>::type type;
 };


template<class _Ty>
 struct underlying_type
 {
 typedef __underlying_type(_Ty) type;
 };


template<class _Ty>
 struct rank
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty, unsigned int _Ix>
 struct rank<_Ty[_Ix]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };

template<class _Ty>
 struct rank<_Ty[]>
  : integral_constant<size_t, rank<_Ty>::value + 1>
 {
 };


template<class _Ty, unsigned int _Nx>
 struct _Extent
  : integral_constant<size_t, 0>
 {
 };

template<class _Ty, unsigned int _Ix>
 struct _Extent<_Ty[_Ix], 0>
  : integral_constant<size_t, _Ix>
 {
 };

template<class _Ty, unsigned int _Nx, unsigned int _Ix>
 struct _Extent<_Ty[_Ix], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx>
 struct _Extent<_Ty[], _Nx>
  : _Extent<_Ty, _Nx - 1>
 {
 };

template<class _Ty, unsigned int _Nx = 0>
 struct extent
  : _Extent<_Ty, _Nx>
 {
 };


template<class _Base, class _Der>
 struct is_base_of : _Cat_base<__is_base_of(_Base, _Der)>
 {
 };


template<class _Ty>
 struct decay
 {
 typedef typename remove_reference<_Ty>::type _Ty1;

 typedef typename _If<is_array<_Ty1>::value,
  typename remove_extent<_Ty1>::type *,
  typename _If<is_function<_Ty1>::value,
   typename add_pointer<_Ty1>::type,
   typename remove_cv<_Ty1>::type>::type>::type type;
 };

namespace tr1 {
using ::std:: add_const;
using ::std:: add_cv;
using ::std:: add_pointer;
using ::std:: add_reference;
using ::std:: add_volatile;
using ::std:: aligned_storage;
using ::std:: alignment_of;
using ::std:: conditional;
using ::std:: decay;
using ::std:: enable_if;
using ::std:: extent;
using ::std:: false_type;
using ::std:: has_nothrow_assign;
using ::std:: has_nothrow_constructor;
using ::std:: has_nothrow_copy;
using ::std:: has_trivial_assign;
using ::std:: has_trivial_constructor;
using ::std:: has_trivial_copy;
using ::std:: has_trivial_destructor;
using ::std:: has_virtual_destructor;
using ::std:: integral_constant;
using ::std:: is_abstract;
using ::std:: is_arithmetic;
using ::std:: is_array;
using ::std:: is_base_of;
using ::std:: is_class;
using ::std:: is_compound;
using ::std:: is_const;
using ::std:: is_convertible;
using ::std:: is_empty;
using ::std:: is_enum;
using ::std:: is_floating_point;
using ::std:: is_function;
using ::std:: is_fundamental;
using ::std:: is_integral;
using ::std:: is_member_function_pointer;
using ::std:: is_member_object_pointer;
using ::std:: is_member_pointer;
using ::std:: is_object;
using ::std:: is_pod;
using ::std:: is_pointer;
using ::std:: is_polymorphic;
using ::std:: is_reference;
using ::std:: is_same;
using ::std:: is_scalar;
using ::std:: is_signed;
using ::std:: is_union;
using ::std:: is_unsigned;
using ::std:: is_void;
using ::std:: is_volatile;
using ::std:: make_signed;
using ::std:: make_unsigned;
using ::std:: rank;
using ::std:: remove_all_extents;
using ::std:: remove_const;
using ::std:: remove_cv;
using ::std:: remove_extent;
using ::std:: remove_pointer;
using ::std:: remove_reference;
using ::std:: remove_volatile;
using ::std:: true_type;
 }


template<class... _Ty>
 struct common_type;

template<class _Ty>
 struct common_type<_Ty>
 {
 typedef typename decay<_Ty>::type type;
 };

template<class _Ty0,
 class _Ty1>
 struct common_type<_Ty0, _Ty1>
 {
 typedef typename decay<
  decltype(_Always_false<_Ty0>::value
   ? ::std:: declval<_Ty0>()
   : ::std:: declval<_Ty1>())
 >::type type;
 };

template<class _Ty0,
 class _Ty1,
 class... _Ty>
 struct common_type<_Ty0, _Ty1, _Ty...>
 {
 typedef typename common_type<
  typename common_type<_Ty0, _Ty1>::type, _Ty...
 >::type type;
 };


template<size_t... _Indexes>
 struct _Arg_idx
 {
 };


template<class _Ty>
 class reference_wrapper;

template<class _Ty>
 struct _Unrefwrap_helper
 {
 typedef _Ty type;
 };

template<class _Ty>
 struct _Unrefwrap_helper<reference_wrapper<_Ty> >
 {
 typedef _Ty& type;
 };

template<class _Ty>
 struct _Unrefwrap
 {
 typedef typename decay<_Ty>::type _Ty1;
 typedef typename _Unrefwrap_helper<_Ty1>::type type;
 };


template<class _Ty>
 struct identity
 {
 typedef _Ty type;

 const _Ty& operator()(const _Ty& _Left) const
  {
  return (_Left);
  }
 };


template<class _Ty> inline
 _Ty&& forward(typename remove_reference<_Ty>::type& _Arg)
 {
 return (static_cast<_Ty&&>(_Arg));
 }

template<class _Ty> inline
 _Ty&& forward(typename remove_reference<_Ty>::type&& _Arg) throw ()
 {
 static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
 return (static_cast<_Ty&&>(_Arg));
 }


template<class _Ty> inline
 typename remove_reference<_Ty>::type&&
  move(_Ty&& _Arg) throw ()
 {
 return ((typename remove_reference<_Ty>::type&&)_Arg);
 }


template<class _Ty> inline
 typename remove_reference<_Ty>::type&&
  _Move(_Ty&& _Arg) throw ()
 {
 return ((typename remove_reference<_Ty>::type&&)_Arg);
 }


template<class _Ty> inline
 typename _If<!has_nothrow_move_constructor<_Ty>::value
  && has_copy_constructor<_Ty>::value,
   const _Ty&, _Ty&&>::type
 move_if_noexcept(_Ty& _Arg) throw ()
 {
 return (::std:: move(_Arg));
 }


template<class _Ty> inline
 typename decay<_Ty>::type _Decay_copy(_Ty&& _Arg)
 {
 return (::std:: forward<_Ty>(_Arg));
 }
}


#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xrefwrap"








#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4180)

namespace std {
template<class _Ty>
 class reference_wrapper;


template<class _Ret,
 class... _Types>
 struct _Fun_class_base
 {
 };

template<class _Ret,
 class _Farg0>
 struct _Fun_class_base<_Ret, _Farg0>
  : public unary_function<_Farg0, _Ret>
 {
 };

template<class _Ret,
 class _Farg0,
 class _Farg1>
 struct _Fun_class_base<_Ret, _Farg0, _Farg1>
  : public binary_function<_Farg0, _Farg1, _Ret>
 {
 };

template<class _Ret,
 class _Farg0,
 class _Farg1,
 class... _Types>
 struct _Fun_class_base<_Ret, _Farg0, _Farg1, _Types...>
 {
 };




template<class _Fty,
 class... _Args>
 struct _Result_of
 {
 typedef decltype(
  ::std:: declval<_Fty>()(::std:: declval<_Args>()...)) type;
 };
#line 74 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xrefwrap"
template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* )(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* )(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* )(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* )(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* )(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* )(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* )(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* )(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* )(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* )(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* )(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* )(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* )(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* )(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* )(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* )(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* const)(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* const)(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* const)(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* const)(_Mfargs...) , _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* const)(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* const)(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* const)(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* const)(_Mfargs...) const, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* const)(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* const)(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* const)(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* const)(_Mfargs...) volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__thiscall _Ty::* const)(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__cdecl _Ty::* const)(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__stdcall _Ty::* const)(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; }; template<class _Ret, class _Ty, class... _Mfargs, class _Obj, class... _Args> struct _Result_of<_Ret (__fastcall _Ty::* const)(_Mfargs...) const volatile, _Obj, _Args...> { typedef _Ret type; };


template<class _Ret,
 class _Ty,
 class _Obj,
 class... _Args>
 struct _Result_of<_Ret _Ty::*, _Obj, _Args...>
 {

 typedef typename _Copy_cv<_Ret,
  typename remove_pointer<
   typename remove_reference<_Obj>::type>::type>::type type;
 };

template<class _Ret,
 class _Ty,
 class _Obj,
 class... _Args>
 struct _Result_of<_Ret _Ty::*const, _Obj, _Args...>
 {

 typedef typename _Copy_cv<_Ret,
  typename remove_pointer<
   typename remove_reference<_Obj>::type>::type>::type const type;
 };

template<class _Fty>
 struct result_of;
#line 118 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xrefwrap"
template<class _Fty, class... _Args> struct result_of<_Fty __cdecl (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; }; template<class _Fty, class... _Args> struct result_of<reference_wrapper<_Fty> __cdecl (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; }; template<class _Fty, class... _Args> struct result_of<_Fty __stdcall (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; }; template<class _Fty, class... _Args> struct result_of<reference_wrapper<_Fty> __stdcall (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; }; template<class _Fty, class... _Args> struct result_of<_Fty __fastcall (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; }; template<class _Fty, class... _Args> struct result_of<reference_wrapper<_Fty> __fastcall (_Args...)> { typedef typename _Result_of<_Fty, _Args...>::type type; };






template<class _Ret,
 class _Arg0>
 struct _Pmd_caller
 {
 template<class _Pmd,
  class _Farg0>
  static _Ret& _Call_pmd(_Pmd _Pm, _Farg0&& _Fx0, true_type)
  {
  return ((_Ret&)(_Fx0.*_Pm));
  }

 template<class _Pmd,
  class _Farg0>
  static _Ret& _Call_pmd(_Pmd _Pm, _Farg0&& _Fx0, false_type)
  {
  return ((_Ret&)((*_Fx0).*_Pm));
  }

 template<class _Pmd,
  class _Farg0>
  static _Ret& _Apply_pmd(_Pmd _Pm, _Farg0&& _Fx0)
  {
  typedef typename remove_cv<
   typename remove_reference<_Arg0>::type>::type _Arg0_bare;
  typedef typename remove_cv<
   typename remove_reference<_Farg0>::type>::type _Farg0_bare;
  typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value
   || (is_base_of<_Arg0_bare, _Farg0_bare>::value
    && is_same<typename add_reference<_Farg0_bare>::type,
     _Farg0>::value)> _Is_obj;

  return (_Call_pmd<_Pmd, _Farg0>(_Pm,
   ::std:: forward<_Farg0>(_Fx0), _Is_obj()));
  }
 };


template<class _Ty,
 bool _Indirect>
 struct _Callable_base;

template<class _Ty>
 struct _Callable_base<_Ty, false>
 {
 enum {_EEN_INDIRECT = 0};
 typedef _Ty _MyTy;
 typedef const _Ty& _MyCnstTy;

 _Callable_base(const _Ty& _Val)
  : _Object(_Val)
  {
  }

 const _Ty& _Get() const
  {
  return (_Object);
  }

 _Ty& _Get()
  {
  return (_Object);
  }

 void _Reset(_Ty& _Val)
  {
  static_assert(_Always_false<_Ty>::value,
   "can't assign to reference_wrapper<T&>");
  }

private:
 _Callable_base& operator=(const _Callable_base&);

 _Ty _Object;
};

template<class _Ty>
 struct _Callable_base<_Ty, true>
 {

 enum {_EEN_INDIRECT = 1};
 typedef _Ty _MyTy;
 typedef _Ty& _MyCnstTy;

 _Callable_base(_Ty& _Val)
  : _Ptr(::std:: addressof(_Val))
  {
  }

 _MyCnstTy _Get() const
  {
  return (*_Ptr);
  }

 _Ty& _Get()
  {
  return (*_Ptr);
  }

 void _Reset(_Ty& _Val)
  {
  _Ptr = ::std:: addressof(_Val);
  }

private:
 _Ty *_Ptr;
};


template<class _Ty,
 class _Memty,
 bool _Indirect = false>
 struct _Callable_pmd
  : _Callable_base<_Ty, _Indirect>
 {
 _Callable_pmd(const _Callable_pmd& _Right)
  : _Callable_base<_Ty, _Indirect>(_Right._Get())
  {
  }

 _Callable_pmd(_Ty& _Val)
  : _Callable_base<_Ty, _Indirect>(_Val)
  {
  }

 template<class _Ret,
  class _Arg0>
  _Ret& _ApplyX(_Arg0&& _A0) const
  {
  return (_Pmd_caller<_Ret, _Memty>::
   _Apply_pmd(this->_Get(), ::std:: forward<_Arg0>(_A0)));
  }
 };


template<class _Ty,
 bool _Indirect = false>
 struct _Callable_obj
  : _Callable_base<_Ty, _Indirect>
 {
 typedef _Callable_base<_Ty, _Indirect> _Mybase;

 template<class _Ty2>
  _Callable_obj(_Ty2&& _Val)
  : _Mybase(::std:: forward<_Ty2>(_Val))
  {
  }

 template<class _Ret,
  class... _Types>
  _Ret _ApplyX(_Types&&... _Args) const
  {
  return (this->_Get()(::std:: forward<_Types>(_Args)...));
  }

 template<class _Ret,
  class... _Types>
  _Ret _ApplyX(_Types&&... _Args)
  {
  return (this->_Get()(::std:: forward<_Types>(_Args)...));
  }

 };



template<class _Ret,
 class _Arg0>
 struct _Pmf_caller
 {
 template<class _Pmf,
  class _Farg0,
  class... _Ftypes>
  static _Ret _Call_pmf(_Pmf _Pm, _Farg0&& _Fx0, true_type,
   _Ftypes&&... _Fargs)
  {
  typedef typename _Copy_cv<_Arg0, _Farg0>::type
   _Funobj_cv;
  return (((_Funobj_cv)_Fx0.*_Pm)(::std:: forward<_Ftypes>(_Fargs)...));
  }

 template<class _Pmf,
  class _Farg0,
  class... _Ftypes>
  static _Ret _Call_pmf(_Pmf _Pm, _Farg0&& _Fx0, false_type,
   _Ftypes&&... _Fargs)
  {
  return (((*_Fx0).*_Pm)(::std:: forward<_Ftypes>(_Fargs)...));
  }

 template<class _Pmf,
  class _Farg0,
  class... _Ftypes>
  static _Ret _Apply_pmf(_Pmf _Pm, _Farg0&& _Fx0,
   _Ftypes&&... _Fargs)
  {
  typedef typename remove_reference<_Arg0>::type _Arg0_bare0;
  typedef typename remove_cv<_Arg0_bare0>::type _Arg0_bare;
  typedef typename remove_reference<_Farg0>::type _Farg0_bare;
  typedef _Cat_base<is_same<_Arg0_bare, _Farg0_bare>::value
   || (is_base_of<_Arg0_bare, _Farg0_bare>::value
    && is_same<typename add_reference<_Farg0_bare>::type,
     _Farg0>::value)> _Is_obj;

  return (_Call_pmf<_Pmf, _Farg0&&, _Ftypes&&...>(_Pm,
   ::std:: forward<_Farg0>(_Fx0), _Is_obj(),
    ::std:: forward<_Ftypes>(_Fargs)...));
  }
 };



template<class _Ty,
 class _Memty,
 bool _Indirect = false>
 struct _Callable_pmf
  : _Callable_base<_Ty, _Indirect>
 {
 _Callable_pmf(const _Callable_pmf& _Right)
  : _Callable_base<_Ty, _Indirect>(_Right._Get())
  {
  }

 _Callable_pmf(_Ty& _Val)
  : _Callable_base<_Ty, _Indirect>(_Val)
  {
  }

 template<class _Ret,
  class... _Types>
  _Ret _ApplyX(_Types&&... _Args) const
  {
  return (_Pmf_caller<_Ret, _Memty>::
   _Apply_pmf(this->_Get(), ::std:: forward<_Types>(_Args)...));
  }

 };


template<class _Ty,
 bool _Indirect = false>
 struct _Callable_fun
  : _Callable_base<_Ty, _Indirect>
 {
 _Callable_fun(const _Callable_fun& _Right)
  : _Callable_base<_Ty, _Indirect>(_Right._Get())
  {
  }

 _Callable_fun(_Ty& _Val)
  : _Callable_base<_Ty, _Indirect>(_Val)
  {
  }

 template<class _Ret,
  class... _Types>
  _Ret _ApplyX(_Types&&... _Args) const
  {
  return (this->_Get()(::std:: forward<_Types>(_Args)...));
  }

 };


template<class _Callable>
 struct _Call_wrapper_base
 {
 typedef typename _Callable::_MyTy _MyTy;
 typedef typename _Callable::_MyCnstTy _MyCnstTy;

 _Call_wrapper_base(_MyTy& _Val)
  : _Callee(_Val)
  {
  }

 void _Reset(_MyTy& _Val)
  {
  _Callee._Reset(_Val);
  }

 _MyCnstTy _Get() const
  {
  return (_Callee._Get());
  }

 _MyCnstTy _Get()
  {
  return (_Callee._Get());
  }

 _Callable _Callee;
 };


template<class _Callable,
 bool _Is_abstract = false>
 struct _Call_wrapper
 : _Call_wrapper_base<_Callable>
 {
 typedef _Call_wrapper_base<_Callable> _Mybase;

 _Call_wrapper(typename _Call_wrapper_base<_Callable>::_MyTy& _Val)
  : _Call_wrapper_base<_Callable>(_Val)
  {
  }

 template<class... _Types>
  typename result_of<
   typename _Callable::_MyTy(_Types...)>::type
   operator()(_Types&&... _Args) const
  {
  typedef typename result_of<
   typename _Callable::_MyTy(_Types...)>::type _Ret;
  return (this->_Callee.template _ApplyX<_Ret>(
   ::std:: forward<_Types>(_Args)...));
  }

 };

template<class _Callable>
 struct _Call_wrapper<_Callable, true>
 : _Call_wrapper_base<_Callable>
 {
 typedef _Call_wrapper_base<_Callable> _Mybase;

 _Call_wrapper(typename _Call_wrapper_base<_Callable>::_MyTy& _Val)
  : _Call_wrapper_base<_Callable>(_Val)
  {
  }
 };


template<class _Ty>
 struct _Has_result_and_arg_type
  { template<class _Uty> static auto _Fn(int, _Identity<typename _Uty::argument_type> * = 0, _Identity<typename _Uty::result_type> * = 0, _Identity<typename _Uty::result_type> * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };


template<class _Ty>
 struct _Has_result_and_2arg_type
  { template<class _Uty> static auto _Fn(int, _Identity<typename _Uty::first_argument_type> * = 0, _Identity<typename _Uty::second_argument_type> * = 0, _Identity<typename _Uty::result_type> * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };


template<class _Ty,
 bool>
 struct _Refwrap_result0
 {
 typedef typename _Ty::result_type result_type;
 };

template<class _Ty>
 struct _Refwrap_result0<_Ty, false>
 {
 };


template<class _Ty,
 bool>
 struct _Refwrap_result1_helper
  : _Refwrap_result0<_Ty, _Has_result_type<_Ty>::type::value>
 {
 };

template<class _Ty>
 struct _Refwrap_result1_helper<_Ty, true>
  : unary_function<typename _Ty::argument_type,
   typename _Ty::result_type>
 {
 };


template<class _Ty,
 bool>
 struct _Refwrap_result1
  : _Refwrap_result0<_Ty, _Has_result_type<_Ty>::type::value>
 {
 };

template<class _Ty>
 struct _Refwrap_result1<_Ty, true>
  : _Refwrap_result1_helper<_Ty,
   is_base_of<unary_function<
    typename _Ty::argument_type,
    typename _Ty::result_type>, _Ty>::value>
 {
 };


template<class _Ty,
 bool>
 struct _Refwrap_result2_helper
  : _Refwrap_result1<_Ty, _Has_result_and_arg_type<_Ty>::type::value>
 {
 };

template<class _Ty>
 struct _Refwrap_result2_helper<_Ty, true>
  : binary_function<typename _Ty::first_argument_type,
   typename _Ty::second_argument_type,
   typename _Ty::result_type>,
  _Refwrap_result1<_Ty, _Has_result_and_arg_type<_Ty>::type::value>
 {
 };


template<class _Ty,
 bool>
 struct _Refwrap_result2
  : _Refwrap_result1<_Ty, _Has_result_and_arg_type<_Ty>::type::value>
 {
 };

template<class _Ty>
 struct _Refwrap_result2<_Ty, true>
  : _Refwrap_result2_helper<_Ty,
   is_base_of<binary_function<
    typename _Ty::first_argument_type,
    typename _Ty::second_argument_type,
    typename _Ty::result_type>, _Ty>::value>
 {
 };


template<class _Ty>
 struct _Refwrap_impl
  : _Call_wrapper<_Callable_obj<_Ty, true>,
   is_abstract<_Ty>::value>,
   _Refwrap_result2<_Ty, _Has_result_and_2arg_type<_Ty>::type::value>
 {
 _Refwrap_impl(_Ty& _Val)
  : _Call_wrapper<_Callable_obj<_Ty, true>,
   is_abstract<_Ty>::value>(_Val)
  {
  }
 };

template<class _Rx,
 class _Arg0>
 struct _Refwrap_impl<_Rx _Arg0::*>
  : _Call_wrapper<_Callable_pmd<_Rx _Arg0::*, _Arg0, false> >
 {
 typedef _Rx _Arg0::* _Fty;
 typedef _Rx result_type;

 _Refwrap_impl(_Fty& _Val)
  : _Call_wrapper<_Callable_pmd<_Fty, _Arg0, false> >(_Val)
  {
  }
 };

template<class _Rx,
 class _Arg0>
 struct _Refwrap_impl<_Rx _Arg0::*const>
  : _Call_wrapper<_Callable_pmd<_Rx _Arg0::*const, _Arg0, false> >
 {
 typedef _Rx _Arg0::*const _Fty;
 typedef _Rx result_type;
 _Refwrap_impl(_Fty& _Val)
  : _Call_wrapper<_Callable_pmd<_Fty, _Arg0, false> >(_Val)
  {
  }
 };
#line 603 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xrefwrap"
template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx __cdecl (_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_Types...), false> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__cdecl *_Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx __stdcall (_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__stdcall *)(_Types...), false> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__stdcall *_Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx __fastcall (_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__fastcall *)(_Types...), false> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__fastcall *_Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty _Val) : _Call_wrapper<_Callable_fun<_Fty, false> >(_Val) { } };
#line 623 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xrefwrap"
template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__cdecl *)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__cdecl * _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__stdcall *)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__stdcall *)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__stdcall * _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__fastcall *)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__fastcall *)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__fastcall * _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__cdecl *const)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__cdecl *const)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__cdecl *const _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__stdcall *const)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__stdcall *const)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__stdcall *const _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } }; template<class _Rx, class... _Types> struct _Refwrap_impl<_Rx(__fastcall *const)(_Types...)> : _Call_wrapper<_Callable_fun< _Rx(__fastcall *const)(_Types...), true> >, _Fun_class_base<_Rx, _Types...> { typedef _Rx(__fastcall *const _Fty)(_Types...); typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_fun<_Fty, true> >(_Val) { } };
#line 645 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xrefwrap"
template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* )(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* )(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* )(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* )(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* )(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* )(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* )(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* )(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* )(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* )(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* )(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* )(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* )(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* )(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* )(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* )(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* )(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* )(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* )(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* )(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* )(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* )(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* )(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* )(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* )(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* )(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* )(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* )(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* )(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* )(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* )(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* )(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* const)(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* const)(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* const _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* const)(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* const)(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* const _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* const)(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* const)(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* const _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* const)(_Types...) > : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* const)(_Types...) , _Arg0, true> >, _Fun_class_base<_Rx, _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* const _Fty)(_Types...) ; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* const)(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* const)(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* const _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* const)(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* const)(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* const _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* const)(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* const)(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* const _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* const)(_Types...) const> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* const)(_Types...) const, _Arg0, true> >, _Fun_class_base<_Rx, const _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* const _Fty)(_Types...) const; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* const)(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* const)(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* const _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* const)(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* const)(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* const _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* const)(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* const)(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* const _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* const)(_Types...) volatile> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* const)(_Types...) volatile, _Arg0, true> >, _Fun_class_base<_Rx, volatile _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* const _Fty)(_Types...) volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__thiscall _Arg0::* const)(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__thiscall _Arg0::* const)(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__thiscall _Arg0::* const _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__cdecl _Arg0::* const)(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__cdecl _Arg0::* const)(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__cdecl _Arg0::* const _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__stdcall _Arg0::* const)(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__stdcall _Arg0::* const)(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__stdcall _Arg0::* const _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } }; template<class _Rx, class _Arg0, class... _Types> struct _Refwrap_impl<_Rx(__fastcall _Arg0::* const)(_Types...) const volatile> : _Call_wrapper<_Callable_pmf< _Rx(__fastcall _Arg0::* const)(_Types...) const volatile, _Arg0, true> >, _Fun_class_base<_Rx, const volatile _Arg0 *, _Types...> { typedef _Rx(__fastcall _Arg0::* const _Fty)(_Types...) const volatile; typedef _Rx result_type; _Refwrap_impl(_Fty& _Val) : _Call_wrapper<_Callable_pmf<_Fty, _Arg0, true> >(_Val) { } };




template<class _Ty>
 class reference_wrapper
 : public _Refwrap_impl<_Ty>
 {
public:
 typedef reference_wrapper<_Ty> _Myt;
 typedef _Refwrap_impl<_Ty> _Mybase;
 typedef _Ty type;

 reference_wrapper(_Ty& _Val) throw ()
  : _Mybase(_Val)
  {
  }

 reference_wrapper(const _Myt& _Right) throw ()
  : _Mybase(_Right.get())
  {
  }

 _Myt& operator=(const _Myt& _Right) throw ()
  {
  this->_Reset(_Right.get());
  return (*this);
  }

 operator _Ty&() const throw ()
  {
  return (this->_Get());
  }

 _Ty& get() const throw ()
  {
  return (this->_Get());
  }

 reference_wrapper(_Ty&&) = delete;
 };


template<class _Ty>
 reference_wrapper<_Ty>
  ref(_Ty& _Val) throw ()
 {
 return (reference_wrapper<_Ty>(_Val));
 }

template<class _Ty>
 void ref(const _Ty&&) = delete;

template<class _Ty>
 reference_wrapper<_Ty>
  ref(reference_wrapper<_Ty> _Val) throw ()
 {
 return (_Val);
 }

template<class _Ty>
 reference_wrapper<const _Ty>
  cref(const _Ty& _Val) throw ()
 {
 return (reference_wrapper<const _Ty>(_Val));
 }

template<class _Ty>
 void cref(const _Ty&&) = delete;

template<class _Ty>
 reference_wrapper<const _Ty>
  cref(reference_wrapper<_Ty> _Val) throw ()
 {
 return (reference_wrapper<const _Ty>(_Val.get()));
 }

namespace tr1 {
using ::std:: cref;
using ::std:: ref;
using ::std:: reference_wrapper;
using ::std:: result_of;
 }
}


#pragma warning(pop)
#pragma pack(pop)
#line 1549 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\type_traits"


namespace std {

template<class _Ty>
 using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
 using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
 using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
 using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
 using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
 using add_cv_t = typename add_cv<_Ty>::type;

template<class _Ty>
 using remove_reference_t = typename remove_reference<_Ty>::type;

template<class _Ty>
 using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
 using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
 using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
 using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
 using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
 using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
 using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
 using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
 size_t _Align = alignment_of<max_align_t>::value>
 using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
 class... _Types>
 using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template<class _Ty>
 using decay_t = typename decay<_Ty>::type;

template<bool _Test,
 class _Ty = void>
 using enable_if_t = typename enable_if<_Test, _Ty>::type;

template<bool _Test,
 class _Ty1,
 class _Ty2>
 using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
 using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
 using underlying_type_t = typename underlying_type<_Ty>::type;

template<class _Ty>
 using result_of_t = typename result_of<_Ty>::type;
}


#pragma warning(pop)
#pragma pack(pop)
#line 8 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\utility"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4180 4512)

namespace std {

template<class _Ty> inline
 void swap(_Ty&, _Ty&)

                                             ;

template<class _FwdIt1,
 class _FwdIt2> inline
 void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
 {
 swap(*_Left, *_Right);
 }


template<class _Ty,
 size_t _Size> inline
 void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])

 {
 if (&_Left != &_Right)
  {
  _Ty *_First1 = _Left;
  _Ty *_Last1 = _First1 + _Size;
  _Ty *_First2 = _Right;
  for (; _First1 != _Last1; ++_First1, ++_First2)
   ::std:: iter_swap(_First1, _First2);
  }
 }

template<class _Ty> inline
 void swap(_Ty& _Left, _Ty& _Right)


 {
 _Ty _Tmp = _Move(_Left);
 _Left = _Move(_Right);
 _Right = _Move(_Tmp);
 }


template<class _Ty> inline
 void _Swap_adl(_Ty& _Left, _Ty& _Right)
 {
 swap(_Left, _Right);
 }


struct piecewise_construct_t
 {
 };

const piecewise_construct_t piecewise_construct =
 piecewise_construct_t();



template<class...>
 class tuple;


template<class _Ty1,
 class _Ty2>
 struct pair
 {
 typedef pair<_Ty1, _Ty2> _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;

 pair()
  : first(), second()
  {
  }

 pair(const _Ty1& _Val1, const _Ty2& _Val2)
  : first(_Val1), second(_Val2)
  {
  }

 template<class _Other1,
  class _Other2,
  class = typename enable_if<is_convertible<const _Other1&, _Ty1>::value
   && is_convertible<const _Other2&, _Ty2>::value,
   void>::type>
  pair(const pair<_Other1, _Other2>& _Right)
  : first(_Right.first), second(_Right.second)
  {
  }

 template<class _Other1,
  class _Other2>
  _Myt& operator=(const pair<_Other1, _Other2>& _Right)
  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }


 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   _Arg_idx<_Indexes1...>,
   _Arg_idx<_Indexes2...>);

 template<class... _Types1,
  class... _Types2> inline
  pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2)

                                                            ;


 template<class _Other1,
  class _Other2,
  class = typename enable_if<is_convertible<_Other1, _Ty1>::value
   && is_convertible<_Other2, _Ty2>::value,
   void>::type>
  pair(_Other1&& _Val1, _Other2&& _Val2)


  : first(::std:: forward<_Other1>(_Val1)),
    second(::std:: forward<_Other2>(_Val2))
  {
  }

 template<class _Other1,
  class _Other2,
  class = typename enable_if<is_convertible<_Other1, _Ty1>::value
   && is_convertible<_Other2, _Ty2>::value,
   void>::type>
  pair(pair<_Other1, _Other2>&& _Right)


  : first(::std:: forward<_Other1>(_Right.first)),
   second(::std:: forward<_Other2>(_Right.second))
  {
  }

 template<class _Other1,
  class _Other2>
  _Myt& operator=(pair<_Other1, _Other2>&& _Right)


  {
  first = ::std:: forward<_Other1>(_Right.first);
  second = ::std:: forward<_Other2>(_Right.second);
  return (*this);
  }

 _Myt& operator=(_Myt&& _Right)


  {
  first = ::std:: forward<_Ty1>(_Right.first);
  second = ::std:: forward<_Ty2>(_Right.second);
  return (*this);
  }

 void swap(_Myt& _Right)


  {
  if (this != &_Right)
   {
   _Swap_adl(first, _Right.first);
   _Swap_adl(second, _Right.second);
   }
  }

 _Myt& operator=(const _Myt& _Right)
  {
  first = _Right.first;
  second = _Right.second;
  return (*this);
  }

 _Ty1 first;
 _Ty2 second;
 };



template<class _Ty1,
 class _Ty2> inline
 void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)

 {
 _Left.swap(_Right);
 }

template<class _Ty1,
 class _Ty2> inline
 bool operator==(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first == _Right.first && _Left.second == _Right.second);
 }

template<class _Ty1,
 class _Ty2> inline
 bool operator!=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty1,
 class _Ty2> inline
 bool operator<(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Left.first < _Right.first ||
  (!(_Right.first < _Left.first) && _Left.second < _Right.second));
 }

template<class _Ty1,
 class _Ty2> inline
 bool operator>(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty1,
 class _Ty2> inline
 bool operator<=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty1,
 class _Ty2> inline
 bool operator>=(const pair<_Ty1, _Ty2>& _Left,
  const pair<_Ty1, _Ty2>& _Right)
 {
 return (!(_Left < _Right));
 }



template<class _Ty1,
 class _Ty2> inline
 pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type>
  make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
 {
 typedef pair<typename _Unrefwrap<_Ty1>::type,
  typename _Unrefwrap<_Ty2>::type> _Mypair;
 return (_Mypair(::std:: forward<_Ty1>(_Val1),
  ::std:: forward<_Ty2>(_Val2)));
 }


 namespace rel_ops
  {
template<class _Ty> inline
 bool operator!=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty> inline
 bool operator>(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty> inline
 bool operator<=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty> inline
 bool operator>=(const _Ty& _Left, const _Ty& _Right)
 {
 return (!(_Left < _Right));
 }
  }
}

namespace std {

template<class _Tuple>
 struct tuple_size
 {
 static_assert(_Always_false<_Tuple>::value,
  "The C++ Standard doesn't define tuple_size for this type.");
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_size<pair<_Ty1, _Ty2> >
 : integral_constant<size_t, 2>
 {
 };

template<class... _Types>
 struct tuple_size<tuple<_Types...> >
 : integral_constant<size_t, sizeof...(_Types)>
 {
 };


template<class _Tuple>
 struct tuple_size<const _Tuple>
 : tuple_size<_Tuple>
 {
 };

template<class _Tuple>
 struct tuple_size<volatile _Tuple>
 : tuple_size<_Tuple>
 {
 };

template<class _Tuple>
 struct tuple_size<const volatile _Tuple>
 : tuple_size<_Tuple>
 {
 };


template<size_t _Idx,
 class _Tuple>
 struct tuple_element;

template<int _Idx,
 class _Ty>
 struct _Pair_data;

template<class _Ty1,
 class _Ty2>
 struct _Pair_data<0, pair<_Ty1, _Ty2> >
 {
 typedef typename add_lvalue_reference<const _Ty1>::type _Ctype;
 typedef typename add_lvalue_reference<_Ty1>::type _Rtype;
 typedef typename add_rvalue_reference<_Ty1>::type _RRtype;

 static _Rtype _Val(pair<_Ty1, _Ty2>& _Pr)
  {
  return (_Pr.first);
  }

 static _Ctype _Val(const pair<_Ty1, _Ty2>& _Pr)
  {
  return (_Pr.first);
  }

 static _RRtype _Val(pair<_Ty1, _Ty2>&& _Pr)
  {
  return (::std:: forward<_Ty1>(_Pr.first));
  }
 };

template<class _Ty1,
 class _Ty2>
 struct _Pair_data<1, pair<_Ty1, _Ty2> >
 {
 typedef typename add_lvalue_reference<const _Ty2>::type _Ctype;
 typedef typename add_lvalue_reference<_Ty2>::type _Rtype;
 typedef typename add_rvalue_reference<_Ty2>::type _RRtype;

 static _Rtype _Val(pair<_Ty1, _Ty2>& _Pr)
  {
  return (_Pr.second);
  }

 static _Ctype _Val(const pair<_Ty1, _Ty2>& _Pr)
  {
  return (_Pr.second);
  }

 static _RRtype _Val(pair<_Ty1, _Ty2>&& _Pr)
  {
  return (::std:: forward<_Ty2>(_Pr.second));
  }
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<0, pair<_Ty1, _Ty2> >
 {
 typedef _Ty1 type;
 };

template<class _Ty1,
 class _Ty2>
 struct tuple_element<1, pair<_Ty1, _Ty2> >
 {
 typedef _Ty2 type;
 };

template<int _Idx,
 class _Ty1,
 class _Ty2> inline
 typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Rtype
  get(pair<_Ty1, _Ty2>& _Pr) throw ()
 {
 return (_Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Val(_Pr));
 }

template<int _Idx,
 class _Ty1,
 class _Ty2> inline
 typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Ctype
  get(const pair<_Ty1, _Ty2>& _Pr) throw ()
 {
 return (_Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Val(_Pr));
 }

template<int _Idx,
 class _Ty1,
 class _Ty2> inline
 typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_RRtype
  get(pair<_Ty1, _Ty2>&& _Pr) throw ()
 {
 typedef typename _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_RRtype
  _RRtype;
 return (::std:: forward<_RRtype>(
  _Pair_data<_Idx, pair<_Ty1, _Ty2> >::_Val(_Pr)));
 }
}

namespace std {
namespace tr1 {
using ::std:: get;
using ::std:: tuple_element;
using ::std:: tuple_size;
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 846 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcompilerdetection.h"
#line 78 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 89 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory0"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstdlib"
#line 17 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cstdlib"
namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;
using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;


using :: getenv;
using :: system;


using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;
}
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory0"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ymath.h"







#pragma pack(push,8)
#pragma warning(push, 3)






extern "C" {
#line 33 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ymath.h"
void __cdecl _Feraise(int);

typedef union
 {
 unsigned short _Word[8];
 float _Float;
 double _Double;
 long double _Long_double;
 } _Dconst;


__declspec(dllimport) double __cdecl _Cosh(double, double);
__declspec(dllimport) double __cdecl _Divide(double, double);
__declspec(dllimport) short __cdecl _Dtest(double *);
__declspec(dllimport) double __cdecl _Log(double, int);
__declspec(dllimport) double __cdecl _Recip(double);
__declspec(dllimport) double __cdecl _Sin(double, unsigned int);
__declspec(dllimport) double __cdecl _Sinx(double, unsigned int, int);
__declspec(dllimport) double __cdecl _Sinh(double, double);

__declspec(dllimport) short __cdecl _Exp(double *, double, short);
extern __declspec(dllimport) _Dconst _Denorm, _Hugeval, _Inf,
 _Nan, _Snan;


__declspec(dllimport) float __cdecl _FCosh(float, float);
__declspec(dllimport) float __cdecl _FDivide(float, float);
__declspec(dllimport) short __cdecl _FDtest(float *);
__declspec(dllimport) float __cdecl _FLog(float, int);
__declspec(dllimport) float __cdecl _FRecip(float);
__declspec(dllimport) float __cdecl _FSin(float, unsigned int);
__declspec(dllimport) float __cdecl _FSinx(float, unsigned int, int);
__declspec(dllimport) float __cdecl _FSinh(float, float);

__declspec(dllimport) short __cdecl _FExp(float *, float, short);
extern __declspec(dllimport) _Dconst _FDenorm, _FInf, _FNan, _FSnan;


__declspec(dllimport) long double __cdecl _LCosh(long double, long double);
__declspec(dllimport) long double __cdecl _LDivide(long double, long double);
__declspec(dllimport) short __cdecl _LDtest(long double *);
__declspec(dllimport) long double __cdecl _LLog(long double, int);
__declspec(dllimport) long double __cdecl _LRecip(long double);
__declspec(dllimport) long double __cdecl _LSin(long double, unsigned int);
__declspec(dllimport) long double __cdecl _LSinx(long double, unsigned int, int);
__declspec(dllimport) long double __cdecl _LSinh(long double, long double);

__declspec(dllimport) short __cdecl _LExp(long double *, long double, short);
extern __declspec(dllimport) _Dconst _LDenorm, _LInf, _LNan, _LSnan;



}




#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cfloat"






#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\float.h"
#line 21 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\float.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 21 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\float.h"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtwrn.h"
#line 17 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtwrn.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 17 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtwrn.h"
#line 22 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\float.h"
#line 38 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\float.h"
extern "C" {
#line 117 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\float.h"
                          __declspec(dllimport) unsigned int __cdecl _clearfp(void);
#pragma warning(push)
#pragma warning(disable: 4141)
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.")) __declspec(dllimport) unsigned int __cdecl _controlfp( unsigned int _NewValue, unsigned int _Mask);
#pragma warning(pop)
 __declspec(dllimport) void __cdecl _set_controlfp( unsigned int _NewValue, unsigned int _Mask);
                          __declspec(dllimport) errno_t __cdecl _controlfp_s( unsigned int *_CurrentState, unsigned int _NewValue, unsigned int _Mask);
                          __declspec(dllimport) unsigned int __cdecl _statusfp(void);
                          __declspec(dllimport) void __cdecl _fpreset(void);


                          __declspec(dllimport) void __cdecl _statusfp2( unsigned int *_X86_status, unsigned int *_SSE2_status);
#line 202 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\float.h"
                          __declspec(dllimport) unsigned int __cdecl _control87( unsigned int _NewValue, unsigned int _Mask);

                          __declspec(dllimport) int __cdecl __control87_2( unsigned int _NewValue, unsigned int _Mask,
                                            unsigned int* _X86_cw, unsigned int* _Sse2_cw);




               __declspec(dllimport) extern int * __cdecl __fpecode(void);
#line 241 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\float.h"
               __declspec(dllimport) double __cdecl _copysign( double _Number, double _Sign);
               __declspec(dllimport) double __cdecl _chgsign( double _X);
               __declspec(dllimport) double __cdecl _scalb( double _X, long _Y);
               __declspec(dllimport) double __cdecl _logb( double _X);
               __declspec(dllimport) double __cdecl _nextafter( double _X, double _Y);
               __declspec(dllimport) int __cdecl _finite( double _X);
               __declspec(dllimport) int __cdecl _isnan( double _X);
               __declspec(dllimport) int __cdecl _fpclass( double _X);
#line 274 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\float.h"
                          __declspec(dllimport) void __cdecl fpreset(void);
#line 339 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\float.h"
}
#line 7 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cfloat"
#line 7 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\climits"
#line 8 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cmath"
#line 16 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cmath"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
#line 18 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 18 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"






#pragma pack(push,8)


extern "C" {
#line 37 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
struct _exception {
        int type;
        char *name;
        double arg1;
        double arg2;
        double retval;
        } ;
#line 54 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
struct _complex {
        double x,y;
        } ;
#line 67 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
typedef float float_t;
typedef double double_t;
#line 90 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
__declspec(dllimport) extern double _HUGE;
#line 184 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
void __cdecl _fperrraise( int _Except);

short __declspec(dllimport) __cdecl _dclass( double _X);
short __declspec(dllimport) __cdecl _ldclass( long double _X);
short __declspec(dllimport) __cdecl _fdclass( float _X);

int __declspec(dllimport) __cdecl _dsign( double _X);
int __declspec(dllimport) __cdecl _ldsign( long double _X);
int __declspec(dllimport) __cdecl _fdsign( float _X);

int __declspec(dllimport) __cdecl _dpcomp( double _X, double _Y);
int __declspec(dllimport) __cdecl _ldpcomp( long double _X, long double _Y);
int __declspec(dllimport) __cdecl _fdpcomp( float _X, float _Y);

short __declspec(dllimport) __cdecl _dtest( double *_Px);
short __declspec(dllimport) __cdecl _ldtest( long double *_Px);
short __declspec(dllimport) __cdecl _fdtest( float *_Px);

short __declspec(dllimport) __cdecl _d_int( double *_Px, short _Xexp);
short __declspec(dllimport) __cdecl _ld_int( long double *_Px, short _Xexp);
short __declspec(dllimport) __cdecl _fd_int( float *_Px, short _Xexp);

short __declspec(dllimport) __cdecl _dscale( double *_Px, long _Lexp);
short __declspec(dllimport) __cdecl _ldscale( long double *_Px, long _Lexp);
short __declspec(dllimport) __cdecl _fdscale( float *_Px, long _Lexp);

short __declspec(dllimport) __cdecl _dunscale( short *_Pex, double *_Px);
short __declspec(dllimport) __cdecl _ldunscale( short *_Pex, long double *_Px);
short __declspec(dllimport) __cdecl _fdunscale( short *_Pex, float *_Px);

short __declspec(dllimport) __cdecl _dexp( double *_Px, double _Y, long _Eoff);
short __declspec(dllimport) __cdecl _ldexp( long double *_Px, long double _Y, long _Eoff);
short __declspec(dllimport) __cdecl _fdexp( float *_Px, float _Y, long _Eoff);

short __declspec(dllimport) __cdecl _dnorm( unsigned short *_Ps);
short __declspec(dllimport) __cdecl _fdnorm( unsigned short *_Ps);

double __cdecl _dpoly( double _X, const double *_Tab, int _N);
long double __cdecl _ldpoly( long double _X, const long double *_Tab, int _N);
float __cdecl _fdpoly( float _X, const float *_Tab, int _N);

double __declspec(dllimport) __cdecl _dlog( double _X, int _Baseflag);
long double __declspec(dllimport) __cdecl _ldlog( long double _X, int _Baseflag);
float __declspec(dllimport) __cdecl _fdlog( float _X, int _Baseflag);

double __declspec(dllimport) __cdecl _dsin( double _X, unsigned int _Qoff);
long double __declspec(dllimport) __cdecl _ldsin( long double _X, unsigned int _Qoff);
float __declspec(dllimport) __cdecl _fdsin( float _X, unsigned int _Qoff);


typedef union
{
    unsigned short _Sh[8];
    double _Val;
} _double_val;


typedef union
{
    unsigned short _Sh[8];
    float _Val;
} _float_val;


typedef union
{
    unsigned short _Sh[8];
    long double _Val;
} _ldouble_val;

typedef union
{
    unsigned short _Word[8];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C, _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double _Zero_C, _Xbig_C;
extern const float _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;
#line 302 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
extern "C++" {

inline __declspec(nothrow) int fpclassify(float _X)
{
    return (_fdtest(&_X));
}

inline __declspec(nothrow) int fpclassify(double _X)
{
    return (_dtest(&_X));
}

inline __declspec(nothrow) int fpclassify(long double _X)
{
    return (_ldtest(&_X));
}

inline __declspec(nothrow) bool signbit(float _X)
{
    return (_fdsign(_X) != 0);
}

inline __declspec(nothrow) bool signbit(double _X)
{
    return (_dsign(_X) != 0);
}

inline __declspec(nothrow) bool signbit(long double _X)
{
    return (_ldsign(_X) != 0);
}

inline __declspec(nothrow) int _fpcomp(float _X, float _Y)
{
    return (_fdpcomp(_X, _Y));
}

inline __declspec(nothrow) int _fpcomp(double _X, double _Y)
{
    return (_dpcomp(_X, _Y));
}

inline __declspec(nothrow) int _fpcomp(long double _X, long double _Y)
{
    return (_ldpcomp(_X, _Y));
}

template<class _Trc, class _Tre> struct _Combined_type
{
    typedef float _Type;
};

template<> struct _Combined_type<float, double>
{
    typedef double _Type;
};

template<> struct _Combined_type<float, long double>
{
    typedef long double _Type;
};

template<class _Ty, class _T2> struct _Real_widened
{
    typedef long double _Type;
};

template<> struct _Real_widened<float, float>
{
    typedef float _Type;
};

template<> struct _Real_widened<float, double>
{
    typedef double _Type;
};

template<> struct _Real_widened<double, float>
{
    typedef double _Type;
};

template<> struct _Real_widened<double, double>
{
    typedef double _Type;
};

template<class _Ty> struct _Real_type
{
    typedef double _Type;
};

template<> struct _Real_type<float>
{
    typedef float _Type;
};

template<> struct _Real_type<long double>
{
    typedef long double _Type;
};

template<class _T1, class _T2> inline __declspec(nothrow) int _fpcomp(_T1 _X, _T2 _Y)
{
    typedef typename _Combined_type<float,
        typename _Real_widened<
        typename _Real_type<_T1>::_Type,
        typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
    return (_fpcomp((_Tw)_X, (_Tw)_Y));
}

template<class _Ty> inline __declspec(nothrow) bool isfinite(_Ty _X)
{
    return (fpclassify(_X) <= 0);
}

template<class _Ty> inline __declspec(nothrow) bool isinf(_Ty _X)
{
    return (fpclassify(_X) == 1);
}

template<class _Ty> inline __declspec(nothrow) bool isnan(_Ty _X)
{
    return (fpclassify(_X) == 2);
}

template<class _Ty> inline __declspec(nothrow) bool isnormal(_Ty _X)
{
    return (fpclassify(_X) == (-1));
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool isgreater(_Ty1 _X, _Ty2 _Y)
{
    return ((_fpcomp(_X, _Y) & 4) != 0);
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool isgreaterequal(_Ty1 _X, _Ty2 _Y)
{
    return ((_fpcomp(_X, _Y) & (2 | 4)) != 0);
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool isless(_Ty1 _X, _Ty2 _Y)
{
    return ((_fpcomp(_X, _Y) & 1) != 0);
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool islessequal(_Ty1 _X, _Ty2 _Y)
{
    return ((_fpcomp(_X, _Y) & (1 | 2)) != 0);
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool islessgreater(_Ty1 _X, _Ty2 _Y)
{
    return ((_fpcomp(_X, _Y) & (1 | 4)) != 0);
}

template<class _Ty1, class _Ty2> inline __declspec(nothrow) bool isunordered(_Ty1 _X, _Ty2 _Y)
{
    return (_fpcomp(_X, _Y) == 0);
}

}






int __cdecl abs( int _X);
long __cdecl labs( long _X);
long long __cdecl llabs( long long _X);

double __cdecl acos( double _X);
__declspec(dllimport) double __cdecl acosh( double _X);
double __cdecl asin( double _X);
__declspec(dllimport) double __cdecl asinh( double _X);
double __cdecl atan( double _X);
__declspec(dllimport) double __cdecl atanh( double _X);
double __cdecl atan2( double _Y, double _X);

__declspec(dllimport) double __cdecl cbrt( double _X);
__declspec(dllimport) double __cdecl copysign( double _X, double _Y);
double __cdecl cos( double _X);
double __cdecl cosh( double _X);
__declspec(dllimport) double __cdecl erf( double _X);
__declspec(dllimport) double __cdecl erfc( double _X);
double __cdecl exp( double _X);
__declspec(dllimport) double __cdecl exp2( double _X);
__declspec(dllimport) double __cdecl expm1( double _X);
                   double __cdecl fabs( double _X);
__declspec(dllimport) double __cdecl fdim( double _X, double _Y);
__declspec(dllimport) double __cdecl fma( double _X, double _Y, double _Z);
__declspec(dllimport) double __cdecl fmax( double _X, double _Y);
__declspec(dllimport) double __cdecl fmin( double _X, double _Y);
double __cdecl fmod( double _X, double _Y);
__declspec(dllimport) int __cdecl ilogb( double _X);
__declspec(dllimport) double __cdecl lgamma( double _X);
__declspec(dllimport) long long __cdecl llrint( double _X);
__declspec(dllimport) long long __cdecl llround( double _X);
double __cdecl log( double _X);
double __cdecl log10( double _X);
__declspec(dllimport) double __cdecl log1p( double _X);
__declspec(dllimport) double __cdecl log2( double _X);
__declspec(dllimport) double __cdecl logb( double _X);
__declspec(dllimport) long __cdecl lrint( double _X);
__declspec(dllimport) long __cdecl lround( double _X);
__declspec(dllimport) double __cdecl nan( const char *);
__declspec(dllimport) double __cdecl nearbyint( double _X);
__declspec(dllimport) double __cdecl nextafter( double _X, double _Y);
__declspec(dllimport) double __cdecl nexttoward( double _X, long double _Y);
double __cdecl pow( double _X, double _Y);
__declspec(dllimport) double __cdecl remainder( double _X, double _Y);
__declspec(dllimport) double __cdecl remquo( double _X, double _Y, int *_Z);
__declspec(dllimport) double __cdecl rint( double _X);
__declspec(dllimport) double __cdecl round( double _X);
__declspec(dllimport) double __cdecl scalbln( double _X, long _Y);
__declspec(dllimport) double __cdecl scalbn( double _X, int _Y);
double __cdecl sin( double _X);
double __cdecl sinh( double _X);
                    double __cdecl sqrt( double _X);
double __cdecl tan( double _X);
double __cdecl tanh( double _X);
__declspec(dllimport) double __cdecl tgamma( double _X);
__declspec(dllimport) double __cdecl trunc( double _X);

               __declspec(dllimport) double __cdecl atof( const char *_String);
               __declspec(dllimport) double __cdecl _atof_l( const char *_String, _locale_t _Locale);

__declspec(dllimport) double __cdecl _cabs( struct _complex _Complex_value);
__declspec(dllimport) double __cdecl ceil( double _X);

               __declspec(dllimport) double __cdecl _chgsign ( double _X);
               __declspec(dllimport) double __cdecl _copysign ( double _Number, double _Sign);

__declspec(dllimport) double __cdecl floor( double _X);
__declspec(dllimport) double __cdecl frexp( double _X, int * _Y);
__declspec(dllimport) double __cdecl _hypot( double _X, double _Y);
__declspec(dllimport) double __cdecl _j0( double _X );
__declspec(dllimport) double __cdecl _j1( double _X );
__declspec(dllimport) double __cdecl _jn(int _X, double _Y);
__declspec(dllimport) double __cdecl ldexp( double _X, int _Y);




int __cdecl _matherr( struct _exception * _Except);


__declspec(dllimport) double __cdecl modf( double _X, double * _Y);
__declspec(dllimport) double __cdecl _y0( double _X);
__declspec(dllimport) double __cdecl _y1( double _X);
__declspec(dllimport) double __cdecl _yn( int _X, double _Y);

__inline double __cdecl hypot( double _X, double _Y)
{
    return _hypot(_X, _Y);
}


__declspec(dllimport) float __cdecl acoshf( float _X);
__declspec(dllimport) float __cdecl asinhf( float _X);
__declspec(dllimport) float __cdecl atanhf( float _X);
__declspec(dllimport) float __cdecl cbrtf( float _X);
__declspec(dllimport) float __cdecl _chgsignf( float _X);
__declspec(dllimport) float __cdecl copysignf( float _X, float _Y);
__declspec(dllimport) float __cdecl _copysignf( float _Number, float _Sign);
__declspec(dllimport) float __cdecl erff( float _X);
__declspec(dllimport) float __cdecl erfcf( float _X);
__declspec(dllimport) float __cdecl expm1f( float _X);
__declspec(dllimport) float __cdecl exp2f( float _X);
__declspec(dllimport) float __cdecl fdimf( float _X, float _Y);
__declspec(dllimport) float __cdecl fmaf( float _X, float _Y, float _Z);
__declspec(dllimport) float __cdecl fmaxf( float _X, float _Y);
__declspec(dllimport) float __cdecl fminf( float _X, float _Y);
__declspec(dllimport) float __cdecl _hypotf( float _X, float _Y);
__declspec(dllimport) int __cdecl ilogbf( float _X);
__declspec(dllimport) float __cdecl lgammaf( float _X);
__declspec(dllimport) long long __cdecl llrintf( float _X);
__declspec(dllimport) long long __cdecl llroundf( float _X);
__declspec(dllimport) float __cdecl log1pf( float _X);
__declspec(dllimport) float __cdecl log2f( float _X);
__declspec(dllimport) float __cdecl logbf( float _X);
__declspec(dllimport) long __cdecl lrintf( float _X);
__declspec(dllimport) long __cdecl lroundf( float _X);
__declspec(dllimport) float __cdecl nanf( const char *);
__declspec(dllimport) float __cdecl nearbyintf( float _X);
__declspec(dllimport) float __cdecl nextafterf( float _X, float _Y);
__declspec(dllimport) float __cdecl nexttowardf( float _X, long double _Y);
__declspec(dllimport) float __cdecl remainderf( float _X, float _Y);
__declspec(dllimport) float __cdecl remquof( float _X, float _Y, int *_Z);
__declspec(dllimport) float __cdecl rintf( float _X);
__declspec(dllimport) float __cdecl roundf( float _X);
__declspec(dllimport) float __cdecl scalblnf( float _X, long _Y);
__declspec(dllimport) float __cdecl scalbnf( float _X, int _Y);
__declspec(dllimport) float __cdecl tgammaf( float _X);
__declspec(dllimport) float __cdecl truncf( float _X);



__declspec(dllimport) int __cdecl _set_SSE2_enable( int _Flag);
#line 637 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
__inline float __cdecl acosf( float _X)
{
    return (float)acos(_X);
}

__inline float __cdecl asinf( float _X)
{
    return (float)asin(_X);
}

__inline float __cdecl atan2f( float _Y, float _X)
{
    return (float)atan2(_Y, _X);
}

__inline float __cdecl atanf( float _X)
{
    return (float)atan(_X);
}

__inline float __cdecl ceilf( float _X)
{
    return (float)ceil(_X);
}

__inline float __cdecl cosf( float _X)
{
    return (float)cos(_X);
}

__inline float __cdecl coshf( float _X)
{
    return (float)cosh(_X);
}

__inline float __cdecl expf( float _X)
{
    return (float)exp(_X);
}
#line 685 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
__inline float __cdecl fabsf( float _X)
{
    return (float)fabs(_X);
}
#line 699 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
__inline float __cdecl floorf( float _X)
{
    return (float)floor(_X);
}

__inline float __cdecl fmodf( float _X, float _Y)
{
    return (float)fmod(_X, _Y);
}



__inline float __cdecl frexpf( float _X, int *_Y)
{
    return (float)frexp(_X, _Y);
}

__inline float __cdecl hypotf( float _X, float _Y)
{
    return _hypotf(_X, _Y);
}

__inline float __cdecl ldexpf( float _X, int _Y)
{
    return (float)ldexp(_X, _Y);
}
#line 740 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
__inline float __cdecl log10f( float _X)
{
    return (float)log10(_X);
}

__inline float __cdecl logf( float _X)
{
    return (float)log(_X);
}

__inline float __cdecl modff( float _X, float *_Y)
{
    double _F, _I;
    _F = modf(_X, &_I);
    *_Y = (float)_I;
    return (float)_F;
}

__inline float __cdecl powf( float _X, float _Y)
{
    return (float)pow(_X, _Y);
}

__inline float __cdecl sinf( float _X)
{
    return (float)sin(_X);
}

__inline float __cdecl sinhf( float _X)
{
    return (float)sinh(_X);
}

__inline float __cdecl sqrtf( float _X)
{
    return (float)sqrt(_X);
}

__inline float __cdecl tanf( float _X)
{
    return (float)tan(_X);
}

__inline float __cdecl tanhf( float _X)
{
    return (float)tanh(_X);
}



__declspec(dllimport) long double __cdecl acoshl( long double _X);

__inline long double __cdecl acosl( long double _X)
{
    return acos((double)_X);
}

__declspec(dllimport) long double __cdecl asinhl( long double _X);

__inline long double __cdecl asinl( long double _X)
{
    return asin((double)_X);
}

__inline long double __cdecl atan2l( long double _Y, long double _X)
{
    return atan2((double)_Y, (double)_X);
}

__declspec(dllimport) long double __cdecl atanhl( long double _X);

__inline long double __cdecl atanl( long double _X)
{
    return atan((double)_X);
}

__declspec(dllimport) long double __cdecl cbrtl( long double _X);

__inline long double __cdecl ceill( long double _X)
{
    return ceil((double)_X);
}

__inline long double __cdecl _chgsignl( long double _X)
{
    return _chgsign((double)_X);
}

__declspec(dllimport) long double __cdecl copysignl( long double _X, long double _Y);

__inline long double __cdecl _copysignl( long double _X, long double _Y)
{
    return _copysign((double)_X, (double)_Y);
}

__inline long double __cdecl coshl( long double _X)
{
    return cosh((double)_X);
}

__inline long double __cdecl cosl( long double _X)
{
    return cos((double)_X);
}

__declspec(dllimport) long double __cdecl erfl( long double _X);
__declspec(dllimport) long double __cdecl erfcl( long double _X);

__inline long double __cdecl expl( long double _X)
{
    return exp((double)_X);
}

__declspec(dllimport) long double __cdecl exp2l( long double _X);
__declspec(dllimport) long double __cdecl expm1l( long double _X);

__inline long double __cdecl fabsl( long double _X)
{
    return fabs((double)_X);
}

__declspec(dllimport) long double __cdecl fdiml( long double _X, long double _Y);

__inline long double __cdecl floorl( long double _X)
{
    return floor((double)_X);
}

__declspec(dllimport) long double __cdecl fmal( long double _X, long double _Y, long double _Z);
__declspec(dllimport) long double __cdecl fmaxl( long double _X, long double _Y);
__declspec(dllimport) long double __cdecl fminl( long double _X, long double _Y);

__inline long double __cdecl fmodl( long double _X, long double _Y)
{
    return fmod((double)_X, (double)_Y);
}

__inline long double __cdecl frexpl( long double _X, int *_Y)
{
    return frexp((double)_X, _Y);
}

__declspec(dllimport) int __cdecl ilogbl( long double _X);

__inline long double __cdecl _hypotl( long double _X, long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

__inline long double __cdecl hypotl( long double _X, long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

__inline long double __cdecl ldexpl( long double _X, int _Y)
{
    return ldexp((double)_X, _Y);
}

__declspec(dllimport) long double __cdecl lgammal( long double _X);
__declspec(dllimport) long long __cdecl llrintl( long double _X);
__declspec(dllimport) long long __cdecl llroundl( long double _X);

__inline long double __cdecl logl( long double _X)
{
    return log((double)_X);
}

__inline long double __cdecl log10l( long double _X)
{
    return log10((double)_X);
}

__declspec(dllimport) long double __cdecl log1pl( long double _X);
__declspec(dllimport) long double __cdecl log2l( long double _X);
__declspec(dllimport) long double __cdecl logbl( long double _X);
__declspec(dllimport) long __cdecl lrintl( long double _X);
__declspec(dllimport) long __cdecl lroundl( long double _X);

__inline long double __cdecl modfl( long double _X, long double *_Y)
{
    double _F, _I;
    _F = modf((double)_X, &_I);
    *_Y = _I;
    return _F;
}
__declspec(dllimport) long double __cdecl nanl( const char *);
__declspec(dllimport) long double __cdecl nearbyintl( long double _X);
__declspec(dllimport) long double __cdecl nextafterl( long double _X, long double _Y);
__declspec(dllimport) long double __cdecl nexttowardl( long double _X, long double _Y);

__inline long double __cdecl powl( long double _X, long double _Y)
{
    return pow((double)_X, (double)_Y);
}

__declspec(dllimport) long double __cdecl remainderl( long double _X, long double _Y);
__declspec(dllimport) long double __cdecl remquol( long double _X, long double _Y, int *_Z);
__declspec(dllimport) long double __cdecl rintl( long double _X);
__declspec(dllimport) long double __cdecl roundl( long double _X);
__declspec(dllimport) long double __cdecl scalblnl( long double _X, long _Y);
__declspec(dllimport) long double __cdecl scalbnl( long double _X, int _Y);

__inline long double __cdecl sinhl( long double _X)
{
    return sinh((double)_X);
}

__inline long double __cdecl sinl( long double _X)
{
    return sin((double)_X);
}

__inline long double __cdecl sqrtl( long double _X)
{
    return sqrt((double)_X);
}

__inline long double __cdecl tanhl( long double _X)
{
    return tanh((double)_X);
}

__inline long double __cdecl tanl( long double _X)
{
    return tan((double)_X);
}

__declspec(dllimport) long double __cdecl tgammal( long double _X);
__declspec(dllimport) long double __cdecl truncl( long double _X);
#line 992 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
__declspec(dllimport) extern double HUGE;




__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_j0" ". See online help for details.")) __declspec(dllimport) double __cdecl j0( double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_j1" ". See online help for details.")) __declspec(dllimport) double __cdecl j1( double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_jn" ". See online help for details.")) __declspec(dllimport) double __cdecl jn( int _X, double _Y);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_y0" ". See online help for details.")) __declspec(dllimport) double __cdecl y0( double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_y1" ". See online help for details.")) __declspec(dllimport) double __cdecl y1( double _X);
__declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C++ conformant name: " "_yn" ". See online help for details.")) __declspec(dllimport) double __cdecl yn( int _X, double _Y);





}

extern "C++" {

template<class _Ty> inline
        _Ty _Pow_int(_Ty _X, int _Y) throw()
        {unsigned int _N;
        if (_Y >= 0)
                _N = (unsigned int)_Y;
        else
                _N = (unsigned int)(-_Y);
        for (_Ty _Z = _Ty(1); ; _X *= _X)
                {if ((_N & 1) != 0)
                        _Z *= _X;
                if ((_N >>= 1) == 0)
                        return (_Y < 0 ? _Ty(1) / _Z : _Z); }}

inline double __cdecl abs( double _X) throw()
        {return (fabs(_X)); }
inline double __cdecl pow( double _X, int _Y) throw()
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl abs( float _X) throw()
        {return (fabsf(_X)); }
inline float __cdecl acos( float _X) throw()
        {return (acosf(_X)); }
inline float __cdecl acosh( float _X) throw()
        {return (acoshf(_X)); }
inline float __cdecl asin( float _X) throw()
        {return (asinf(_X)); }
inline float __cdecl asinh( float _X) throw()
        {return (asinhf(_X)); }
inline float __cdecl atan( float _X) throw()
        {return (atanf(_X)); }
inline float __cdecl atanh( float _X) throw()
        {return (atanhf(_X)); }
inline float __cdecl atan2( float _Y, float _X) throw()
        {return (atan2f(_Y, _X)); }
inline float __cdecl cbrt( float _X) throw()
        {return (cbrtf(_X)); }
inline float __cdecl ceil( float _X) throw()
        {return (ceilf(_X)); }
inline float __cdecl copysign( float _X, float _Y) throw()
        {return (copysignf(_X, _Y)); }
inline float __cdecl cos( float _X) throw()
        {return (cosf(_X)); }
inline float __cdecl cosh( float _X) throw()
        {return (coshf(_X)); }
inline float __cdecl erf( float _X) throw()
        {return (erff(_X)); }
inline float __cdecl erfc( float _X) throw()
        {return (erfcf(_X)); }
inline float __cdecl exp( float _X) throw()
        {return (expf(_X)); }
inline float __cdecl exp2( float _X) throw()
        {return (exp2f(_X)); }
inline float __cdecl expm1( float _X) throw()
        {return (expm1f(_X)); }
inline float __cdecl fabs( float _X) throw()
        {return (fabsf(_X)); }
inline float __cdecl fdim( float _X, float _Y) throw()
        {return (fdimf(_X, _Y)); }
inline float __cdecl floor( float _X) throw()
        {return (floorf(_X)); }
inline float __cdecl fma( float _X, float _Y, float _Z) throw()
        {return (fmaf(_X, _Y, _Z)); }
inline float __cdecl fmax( float _X, float _Y) throw()
        {return (fmaxf(_X, _Y)); }
inline float __cdecl fmin( float _X, float _Y) throw()
        {return (fminf(_X, _Y)); }
inline float __cdecl fmod( float _X, float _Y) throw()
        {return (fmodf(_X, _Y)); }
inline float __cdecl frexp( float _X, int * _Y) throw()
        {return (frexpf(_X, _Y)); }
inline float __cdecl hypot( float _X, float _Y) throw()
        {return (hypotf(_X, _Y)); }
inline int __cdecl ilogb( float _X) throw()
        {return (ilogbf(_X)); }
inline float __cdecl ldexp( float _X, int _Y) throw()
        {return (ldexpf(_X, _Y)); }
inline float __cdecl lgamma( float _X) throw()
        {return (lgammaf(_X)); }
inline long long __cdecl llrint( float _X) throw()
        {return (llrintf(_X)); }
inline long long __cdecl llround( float _X) throw()
        {return (llroundf(_X)); }
inline float __cdecl log( float _X) throw()
        {return (logf(_X)); }
inline float __cdecl log10( float _X) throw()
        {return (log10f(_X)); }
inline float __cdecl log1p( float _X) throw()
        {return (log1pf(_X)); }
inline float __cdecl log2( float _X) throw()
        {return (log2f(_X)); }
inline float __cdecl logb( float _X) throw()
        {return (logbf(_X)); }
inline long __cdecl lrint( float _X) throw()
        {return (lrintf(_X)); }
inline long __cdecl lround( float _X) throw()
        {return (lroundf(_X)); }
inline float __cdecl modf( float _X, float * _Y) throw()
        {return (modff(_X, _Y)); }
inline float __cdecl nearbyint( float _X) throw()
        {return (nearbyintf(_X)); }
inline float __cdecl nextafter( float _X, float _Y) throw()
        {return (nextafterf(_X, _Y)); }
inline float __cdecl nexttoward( float _X, long double _Y) throw()
        {return (nexttowardf(_X, _Y)); }
inline float __cdecl pow( float _X, float _Y) throw()
        {return (powf(_X, _Y)); }
inline float __cdecl pow( float _X, int _Y) throw()
        {return (_Pow_int(_X, _Y)); }
inline float __cdecl remainder( float _X, float _Y) throw()
        {return (remainderf(_X, _Y)); }
inline float __cdecl remquo( float _X, float _Y, int *_Z) throw()
        {return (remquof(_X, _Y, _Z)); }
inline float __cdecl rint( float _X) throw()
        {return (rintf(_X)); }
inline float __cdecl round( float _X) throw()
        {return (roundf(_X)); }
inline float __cdecl scalbln( float _X, long _Y) throw()
        {return (scalblnf(_X, _Y)); }
inline float __cdecl scalbn( float _X, int _Y) throw()
        {return (scalbnf(_X, _Y)); }
inline float __cdecl sin( float _X) throw()
        {return (sinf(_X)); }
inline float __cdecl sinh( float _X) throw()
        {return (sinhf(_X)); }
inline float __cdecl sqrt( float _X) throw()
        {return (sqrtf(_X)); }
inline float __cdecl tan( float _X) throw()
        {return (tanf(_X)); }
inline float __cdecl tanh( float _X) throw()
        {return (tanhf(_X)); }
inline float __cdecl tgamma( float _X) throw()
        {return (tgammaf(_X)); }
inline float __cdecl trunc( float _X) throw()
        {return (truncf(_X)); }
inline long double __cdecl abs( long double _X) throw()
        {return (fabsl(_X)); }
inline long double __cdecl acos( long double _X) throw()
        {return (acosl(_X)); }
inline long double __cdecl acosh( long double _X) throw()
        {return (acoshl(_X)); }
inline long double __cdecl asin( long double _X) throw()
        {return (asinl(_X)); }
inline long double __cdecl asinh( long double _X) throw()
        {return (asinhl(_X)); }
inline long double __cdecl atan( long double _X) throw()
        {return (atanl(_X)); }
inline long double __cdecl atanh( long double _X) throw()
        {return (atanhl(_X)); }
inline long double __cdecl atan2( long double _Y, long double _X) throw()
        {return (atan2l(_Y, _X)); }
inline long double __cdecl cbrt( long double _X) throw()
        {return (cbrtl(_X)); }
inline long double __cdecl ceil( long double _X) throw()
        {return (ceill(_X)); }
inline long double __cdecl copysign( long double _X, long double _Y) throw()
        {return (copysignl(_X, _Y)); }
inline long double __cdecl cos( long double _X) throw()
        {return (cosl(_X)); }
inline long double __cdecl cosh( long double _X) throw()
        {return (coshl(_X)); }
inline long double __cdecl erf( long double _X) throw()
        {return (erfl(_X)); }
inline long double __cdecl erfc( long double _X) throw()
        {return (erfcl(_X)); }
inline long double __cdecl exp( long double _X) throw()
        {return (expl(_X)); }
inline long double __cdecl exp2( long double _X) throw()
        {return (exp2l(_X)); }
inline long double __cdecl expm1( long double _X) throw()
        {return (expm1l(_X)); }
inline long double __cdecl fabs( long double _X) throw()
        {return (fabsl(_X)); }
inline long double __cdecl fdim( long double _X, long double _Y) throw()
        {return (fdiml(_X, _Y)); }
inline long double __cdecl floor( long double _X) throw()
        {return (floorl(_X)); }
inline long double __cdecl fma( long double _X, long double _Y, long double _Z) throw()
        {return (fmal(_X, _Y, _Z)); }
inline long double __cdecl fmax( long double _X, long double _Y) throw()
        {return (fmaxl(_X, _Y)); }
inline long double __cdecl fmin( long double _X, long double _Y) throw()
        {return (fminl(_X, _Y)); }
inline long double __cdecl fmod( long double _X, long double _Y) throw()
        {return (fmodl(_X, _Y)); }
inline long double __cdecl frexp( long double _X, int * _Y) throw()
        {return (frexpl(_X, _Y)); }
inline long double __cdecl hypot( long double _X, long double _Y) throw()
        {return (hypotl(_X, _Y)); }
inline int __cdecl ilogb( long double _X) throw()
        {return (ilogbl(_X)); }
inline long double __cdecl ldexp( long double _X, int _Y) throw()
        {return (ldexpl(_X, _Y)); }
inline long double __cdecl lgamma( long double _X) throw()
        {return (lgammal(_X)); }
inline long long __cdecl llrint( long double _X) throw()
        {return (llrintl(_X)); }
inline long long __cdecl llround( long double _X) throw()
        {return (llroundl(_X)); }
inline long double __cdecl log( long double _X) throw()
        {return (logl(_X)); }
inline long double __cdecl log10( long double _X) throw()
        {return (log10l(_X)); }
inline long double __cdecl log1p( long double _X) throw()
        {return (log1pl(_X)); }
inline long double __cdecl log2( long double _X) throw()
        {return (log2l(_X)); }
inline long double __cdecl logb( long double _X) throw()
        {return (logbl(_X)); }
inline long __cdecl lrint( long double _X) throw()
        {return (lrintl(_X)); }
inline long __cdecl lround( long double _X) throw()
        {return (lroundl(_X)); }
inline long double __cdecl modf( long double _X, long double * _Y) throw()
        {return (modfl(_X, _Y)); }
inline long double __cdecl nearbyint( long double _X) throw()
        {return (nearbyintl(_X)); }
inline long double __cdecl nextafter( long double _X, long double _Y) throw()
        {return (nextafterl(_X, _Y)); }
inline long double __cdecl nexttoward( long double _X, long double _Y) throw()
        {return (nexttowardl(_X, _Y)); }
inline long double __cdecl pow( long double _X, long double _Y) throw()
        {return (powl(_X, _Y)); }
inline long double __cdecl pow( long double _X, int _Y) throw()
        {return (_Pow_int(_X, _Y)); }
inline long double __cdecl remainder( long double _X, long double _Y) throw()
        {return (remainderl(_X, _Y)); }
inline long double __cdecl remquo( long double _X, long double _Y, int *_Z) throw()
        {return (remquol(_X, _Y, _Z)); }
inline long double __cdecl rint( long double _X) throw()
        {return (rintl(_X)); }
inline long double __cdecl round( long double _X) throw()
        {return (roundl(_X)); }
inline long double __cdecl scalbln( long double _X, long _Y) throw()
        {return (scalblnl(_X, _Y)); }
inline long double __cdecl scalbn( long double _X, int _Y) throw()
        {return (scalbnl(_X, _Y)); }
inline long double __cdecl sin( long double _X) throw()
        {return (sinl(_X)); }
inline long double __cdecl sinh( long double _X) throw()
        {return (sinhl(_X)); }
inline long double __cdecl sqrt( long double _X) throw()
        {return (sqrtl(_X)); }
inline long double __cdecl tan( long double _X) throw()
        {return (tanl(_X)); }
inline long double __cdecl tanh( long double _X) throw()
        {return (tanhl(_X)); }
inline long double __cdecl tgamma( long double _X) throw()
        {return (tgammal(_X)); }
inline long double __cdecl trunc( long double _X) throw()
        {return (truncl(_X)); }

}


#pragma pack(pop)
#line 16 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cmath"


#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtgmath.h"
#line 10 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtgmath.h"
#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {
template<class _Ty>
 struct _Promote_to_float
 {
 typedef typename conditional<is_integral<_Ty>::value,
  double, _Ty>::type type;
 };

template<class _Ty1,
 class _Ty2>
 struct _Common_float_type
 {
 typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
 typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
 typedef typename conditional<is_same<_Ty1f, long double>::value
  || is_same<_Ty2f, long double>::value, long double,
  typename conditional<is_same<_Ty1f, double>::value
   || is_same<_Ty2f, double>::value, double,
   float>::type>::type type;
 };
}
#line 75 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtgmath.h"
extern "C" double __cdecl pow( double, double);
float __cdecl pow( float, float) throw ();
long double __cdecl pow( long double, long double) throw ();

template<class _Ty1,
 class _Ty2> inline
 typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value
  && ::std:: _Is_numeric<_Ty2>::value,
  typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
 pow(const _Ty1 _Left, const _Ty2 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (:: pow(type(_Left), type(_Right)));
 }


extern "C" double __cdecl acos( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C" double __cdecl asin( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C" double __cdecl atan( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C" double __cdecl atan2( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl ceil( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C" double __cdecl cos( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C" double __cdecl cosh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C" double __cdecl exp( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C" __declspec(dllimport) double __cdecl floor( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C" double __cdecl fmod( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl frexp( double, int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left, int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl ldexp( double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left, int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C" double __cdecl log( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C" double __cdecl log10( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C" double __cdecl sin( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C" double __cdecl sinh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C" double __cdecl sqrt( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C" double __cdecl tan( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C" double __cdecl tanh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }
#line 124 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtgmath.h"
inline float _Fma(float _Left, float _Middle, float _Right)
 {
 return (:: fmaf(_Left, _Middle, _Right));
 }

inline double _Fma(double _Left, double _Middle, double _Right)
 {
 return (:: fma(_Left, _Middle, _Right));
 }

inline long double _Fma(long double _Left, long double _Middle, long double _Right)
 {
 return (:: fmal(_Left, _Middle, _Right));
 }

template<class _Ty1,
 class _Ty2,
 class _Ty3> inline
 typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
 fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
 {
 typedef typename ::std:: _Common_float_type<_Ty1,
  typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
 return (_Fma((type)_Left, (type)_Middle, (type)_Right));
 }


inline float _Remquo(float _Left, float _Right, int *_Pquo)
 {
 return (:: remquof(_Left, _Right, _Pquo));
 }

inline double _Remquo(double _Left, double _Right, int *_Pquo)
 {
 return (:: remquo(_Left, _Right, _Pquo));
 }

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
 {
 return (:: remquol(_Left, _Right, _Pquo));
 }

template<class _Ty1,
 class _Ty2> inline
 typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
 remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
 {
 typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
 return (_Remquo((type)_Left, (type)_Right, _Pquo));
 }

extern "C" __declspec(dllimport) double __cdecl acosh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl asinh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl atanh( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl cbrt( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl copysign( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl erf( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl erfc( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl expm1( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl exp2( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }

extern "C" __declspec(dllimport) double __cdecl fdim( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C" __declspec(dllimport) double __cdecl fmax( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl fmin( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C" double __cdecl hypot( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) int __cdecl ilogb( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl lgamma( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C" __declspec(dllimport) long long __cdecl llrint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C" __declspec(dllimport) long long __cdecl llround( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl log1p( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl log2( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl logb( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C" __declspec(dllimport) long __cdecl lrint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C" __declspec(dllimport) long __cdecl lround( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl nearbyint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl nextafter( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C" __declspec(dllimport) double __cdecl nexttoward( double, long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left, long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl remainder( double, double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: _Is_numeric<_Ty1>::value && ::std:: _Is_numeric<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C" __declspec(dllimport) double __cdecl rint( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl round( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl scalbln( double, long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left, long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl scalbn( double, int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left, int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C" __declspec(dllimport) double __cdecl tgamma( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C" __declspec(dllimport) double __cdecl trunc( double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }




#pragma warning(pop)
#pragma pack(pop)
#line 18 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cmath"




namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2;
using :: hypot; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f;
using :: hypotf; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l;
using :: hypotl; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
}
#line 9 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits"




#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {
#line 30 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits"
typedef enum
 {
 denorm_indeterminate = -1,
 denorm_absent = 0,
 denorm_present = 1}
  float_denorm_style;


typedef enum
 {
 round_indeterminate = -1,
 round_toward_zero = 0,
 round_to_nearest = 1,
 round_toward_infinity = 2,
 round_toward_neg_infinity = 3}
  float_round_style;


struct _Num_base
 {
 static const float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
 static const bool has_denorm_loss = (bool)(false);
 static const bool has_infinity = (bool)(false);
 static const bool has_quiet_NaN = (bool)(false);
 static const bool has_signaling_NaN = (bool)(false);
 static const bool is_bounded = (bool)(false);
 static const bool is_exact = (bool)(false);
 static const bool is_iec559 = (bool)(false);
 static const bool is_integer = (bool)(false);
 static const bool is_modulo = (bool)(false);
 static const bool is_signed = (bool)(false);
 static const bool is_specialized = (bool)(false);
 static const bool tinyness_before = (bool)(false);
 static const bool traps = (bool)(false);
 static const float_round_style round_style = (float_round_style)(round_toward_zero);
 static const int digits = (int)(0);
 static const int digits10 = (int)(0);

 static const int max_digits10 = (int)(0);

 static const int max_exponent = (int)(0);
 static const int max_exponent10 = (int)(0);
 static const int min_exponent = (int)(0);
 static const int min_exponent10 = (int)(0);
 static const int radix = (int)(0);
 };


template<class _Ty>
 class numeric_limits
  : public _Num_base
 {
public:
 static _Ty (min)() throw ()
  {
  return (_Ty(0));
  }

 static _Ty (max)() throw ()
  {
  return (_Ty(0));
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (_Ty(0));
  }

 static _Ty round_error() throw ()
  {
  return (_Ty(0));
  }

 static _Ty denorm_min() throw ()
  {
  return (_Ty(0));
  }

 static _Ty infinity() throw ()
  {
  return (_Ty(0));
  }

 static _Ty quiet_NaN() throw ()
  {
  return (_Ty(0));
  }

 static _Ty signaling_NaN() throw ()
  {
  return (_Ty(0));
  }
 };

template<class _Ty>
 class numeric_limits<const _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };

template<class _Ty>
 class numeric_limits<const volatile _Ty>
  : public numeric_limits<_Ty>
 {
 };


struct _Num_int_base
 : public _Num_base
 {
 static const bool is_bounded = (bool)(true);
 static const bool is_exact = (bool)(true);
 static const bool is_integer = (bool)(true);
 static const bool is_modulo = (bool)(true);
 static const bool is_specialized = (bool)(true);
 static const int radix = (int)(2);
 };


struct _Num_float_base
 : public _Num_base
 {
 static const float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
 static const bool has_denorm_loss = (bool)(true);
 static const bool has_infinity = (bool)(true);
 static const bool has_quiet_NaN = (bool)(true);
 static const bool has_signaling_NaN = (bool)(true);
 static const bool is_bounded = (bool)(true);
 static const bool is_exact = (bool)(false);
 static const bool is_iec559 = (bool)(true);
 static const bool is_integer = (bool)(false);
 static const bool is_modulo = (bool)(false);
 static const bool is_signed = (bool)(true);
 static const bool is_specialized = (bool)(true);
 static const bool tinyness_before = (bool)(true);
 static const bool traps = (bool)(false);
 static const float_round_style round_style = (float_round_style)(round_to_nearest);
 static const int radix = (int)(2);
 };


template<> class numeric_limits<char>
 : public _Num_int_base
 {
public:
 typedef char _Ty;

 static _Ty (min)() throw ()
  {
  return ((-128));
  }

 static _Ty (max)() throw ()
  {
  return (127);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)((-128) != 0);
 static const int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
 static const int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<wchar_t>
 : public _Num_int_base
 {
public:
 typedef wchar_t _Ty;

 static _Ty (min)() throw ()
  {
  return ((_Ty)0x0000);
  }

 static _Ty (max)() throw ()
  {
  return ((_Ty)0xffff);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(0x0000 != 0);
 static const int digits = (int)(8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0));

 static const int digits10 = (int)((8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0)) * 301L / 1000);

 };


template<> class numeric_limits<_Bool>
 : public _Num_int_base
 {
public:
 typedef bool _Ty;

 static _Ty (min)() throw ()
  {
  return (false);
  }

 static _Ty (max)() throw ()
  {
  return (true);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_modulo = (bool)(false);
 static const bool is_signed = (bool)(false);
 static const int digits = (int)(1);
 static const int digits10 = (int)(0);
 };


template<> class numeric_limits<signed char>
 : public _Num_int_base
 {
public:
 typedef signed char _Ty;

 static _Ty (min)() throw ()
  {
  return ((-128));
  }

 static _Ty (max)() throw ()
  {
  return (127);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(true);
 static const int digits = (int)(8 - 1);
 static const int digits10 = (int)((8 - 1) * 301L / 1000);
 };


template<> class numeric_limits<unsigned char>
 : public _Num_int_base
 {
public:
 typedef unsigned char _Ty;

 static _Ty (min)() throw ()
  {
  return (0);
  }

 static _Ty (max)() throw ()
  {
  return (0xff);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(false);
 static const int digits = (int)(8);
 static const int digits10 = (int)(8 * 301L / 1000);
 };


template<> class numeric_limits<short>
 : public _Num_int_base
 {
public:
 typedef short _Ty;

 static _Ty (min)() throw ()
  {
  return ((-32768));
  }

 static _Ty (max)() throw ()
  {
  return (32767);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(true);
 static const int digits = (int)(8 * sizeof (short) - 1);
 static const int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);

 };



template<> class numeric_limits<unsigned short>
 : public _Num_int_base
 {
public:
 typedef unsigned short _Ty;

 static _Ty (min)() throw ()
  {
  return (0);
  }

 static _Ty (max)() throw ()
  {
  return (0xffff);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(false);
 static const int digits = (int)(8 * sizeof (unsigned short));
 static const int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);

 };
#line 649 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits"
template<> class numeric_limits<int>
 : public _Num_int_base
 {
public:
 typedef int _Ty;

 static _Ty (min)() throw ()
  {
  return ((-2147483647 - 1));
  }

 static _Ty (max)() throw ()
  {
  return (2147483647);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(true);
 static const int digits = (int)(8 * sizeof (int) - 1);
 static const int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned int>
 : public _Num_int_base
 {
public:
 typedef unsigned int _Ty;

 static _Ty (min)() throw ()
  {
  return (0);
  }

 static _Ty (max)() throw ()
  {
  return (0xffffffff);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(false);
 static const int digits = (int)(8 * sizeof (unsigned int));
 static const int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);

 };


template<> class numeric_limits<long>
 : public _Num_int_base
 {
public:
 typedef long _Ty;

 static _Ty (min)() throw ()
  {
  return ((-2147483647L - 1));
  }

 static _Ty (max)() throw ()
  {
  return (2147483647L);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(true);
 static const int digits = (int)(8 * sizeof (long) - 1);
 static const int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned long>
 : public _Num_int_base
 {
public:
 typedef unsigned long _Ty;

 static _Ty (min)() throw ()
  {
  return (0);
  }

 static _Ty (max)() throw ()
  {
  return (0xffffffffUL);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(false);
 static const int digits = (int)(8 * sizeof (unsigned long));
 static const int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);

 };
#line 942 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits"
template<> class numeric_limits<__int64>
 : public _Num_int_base
 {
public:
 typedef __int64 _Ty;

 static _Ty (min)() throw ()
  {
  return (-0x7fffffffffffffff - 1);
  }

 static _Ty (max)() throw ()
  {
  return (0x7fffffffffffffff);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(true);
 static const int digits = (int)(8 * sizeof (__int64) - 1);
 static const int digits10 = (int)((8 * sizeof (__int64) - 1) * 301L / 1000);

 };


template<> class numeric_limits<unsigned __int64>
 : public _Num_int_base
 {
public:
 typedef unsigned __int64 _Ty;

 static _Ty (min)() throw ()
  {
  return (0);
  }

 static _Ty (max)() throw ()
  {
  return (0xffffffffffffffff);
  }

 static _Ty lowest() throw ()
  {
  return ((min)());
  }

 static _Ty epsilon() throw ()
  {
  return (0);
  }

 static _Ty round_error() throw ()
  {
  return (0);
  }

 static _Ty denorm_min() throw ()
  {
  return (0);
  }

 static _Ty infinity() throw ()
  {
  return (0);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (0);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (0);
  }

 static const bool is_signed = (bool)(false);
 static const int digits = (int)(8 * sizeof (unsigned __int64));
 static const int digits10 = (int)(8 * sizeof (unsigned __int64) * 301L / 1000);

 };



template<> class numeric_limits<float>
 : public _Num_float_base
 {
public:
 typedef float _Ty;

 static _Ty (min)() throw ()
  {
  return (1.175494351e-38F);
  }

 static _Ty (max)() throw ()
  {
  return (3.402823466e+38F);
  }

 static _Ty lowest() throw ()
  {
  return (-(max)());
  }

 static _Ty epsilon() throw ()
  {
  return (1.192092896e-07F);
  }

 static _Ty round_error() throw ()
  {
  return (0.5);
  }

 static _Ty denorm_min() throw ()
  {
  return (:: _FDenorm._Float);
  }

 static _Ty infinity() throw ()
  {
  return (:: _FInf._Float);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (:: _FNan._Float);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (:: _FSnan._Float);
  }

 static const int digits = (int)(24);
 static const int digits10 = (int)(6);

 static const int max_digits10 = (int)(2 + 24 * 301L / 1000);

 static const int max_exponent = (int)((int)128);
 static const int max_exponent10 = (int)((int)38);
 static const int min_exponent = (int)((int)(-125));
 static const int min_exponent10 = (int)((int)(-37));
 };


template<> class numeric_limits<double>
 : public _Num_float_base
 {
public:
 typedef double _Ty;

 static _Ty (min)() throw ()
  {
  return (2.2250738585072014e-308);
  }

 static _Ty (max)() throw ()
  {
  return (1.7976931348623158e+308);
  }

 static _Ty lowest() throw ()
  {
  return (-(max)());
  }

 static _Ty epsilon() throw ()
  {
  return (2.2204460492503131e-016);
  }

 static _Ty round_error() throw ()
  {
  return (0.5);
  }

 static _Ty denorm_min() throw ()
  {
  return (:: _Denorm._Double);
  }

 static _Ty infinity() throw ()
  {
  return (:: _Inf._Double);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (:: _Nan._Double);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (:: _Snan._Double);
  }

 static const int digits = (int)(53);
 static const int digits10 = (int)(15);

 static const int max_digits10 = (int)(2 + 53 * 301L / 1000);

 static const int max_exponent = (int)((int)1024);
 static const int max_exponent10 = (int)((int)308);
 static const int min_exponent = (int)((int)(-1021));
 static const int min_exponent10 = (int)((int)(-307));
 };


template<> class numeric_limits<long double>
 : public _Num_float_base
 {
public:
 typedef long double _Ty;

 static _Ty (min)() throw ()
  {
  return (2.2250738585072014e-308);
  }

 static _Ty (max)() throw ()
  {
  return (1.7976931348623158e+308);
  }

 static _Ty lowest() throw ()
  {
  return (-(max)());
  }

 static _Ty epsilon() throw ()
  {
  return (2.2204460492503131e-016);
  }

 static _Ty round_error() throw ()
  {
  return (0.5);
  }

 static _Ty denorm_min() throw ()
  {
  return (:: _LDenorm._Long_double);
  }

 static _Ty infinity() throw ()
  {
  return (:: _LInf._Long_double);
  }

 static _Ty quiet_NaN() throw ()
  {
  return (:: _LNan._Long_double);
  }

 static _Ty signaling_NaN() throw ()
  {
  return (:: _LSnan._Long_double);
  }

 static const int digits = (int)(53);
 static const int digits10 = (int)(15);

 static const int max_digits10 = (int)(2 + 53 * 301L / 1000);

 static const int max_exponent = (int)((int)1024);
 static const int max_exponent10 = (int)((int)308);
 static const int min_exponent = (int)((int)(-1021));
 static const int min_exponent10 = (int)((int)(-307));
 };
#line 1454 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\limits"
}

#pragma warning(pop)
#pragma pack(pop)
#line 7 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory0"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\new"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"








#pragma pack(push,8)
#pragma warning(push, 3)
#line 23 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"
namespace std {
#line 36 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"
}




#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\eh.h"
#line 15 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\eh.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 15 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\eh.h"
#line 24 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\eh.h"
#pragma pack(push,8)







typedef void (__cdecl *terminate_function)();
typedef void (__cdecl *terminate_handler)();
typedef void (__cdecl *unexpected_function)();
typedef void (__cdecl *unexpected_handler)();
#line 50 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\eh.h"
struct _EXCEPTION_POINTERS;

typedef void (__cdecl *_se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);


__declspec(dllimport) __declspec(noreturn) void __cdecl terminate(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl unexpected(void);

__declspec(dllimport) int __cdecl _is_exception_typeof( const type_info &_Type, struct _EXCEPTION_POINTERS * _ExceptionPtr);



__declspec(dllimport) terminate_function __cdecl set_terminate( terminate_function _NewPtFunc);
extern "C" __declspec(dllimport) terminate_function __cdecl _get_terminate(void);
__declspec(dllimport) unexpected_function __cdecl set_unexpected( unexpected_function _NewPtFunc);
extern "C" __declspec(dllimport) unexpected_function __cdecl _get_unexpected(void);




__declspec(dllimport) _se_translator_function __cdecl _set_se_translator( _se_translator_function _NewPtFunc);

__declspec(dllimport) bool __cdecl __uncaught_exception();
#line 82 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\eh.h"
#pragma pack(pop)
#line 40 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\malloc.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\malloc.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\malloc.h"






#pragma pack(push,8)


extern "C" {
#line 58 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\malloc.h"
typedef struct _heapinfo {
        int * _pentry;
        size_t _size;
        int _useflag;
        } _HEAPINFO;
#line 143 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\malloc.h"
__declspec(dllimport) int __cdecl _resetstkoflw (void);




__declspec(dllimport) unsigned long __cdecl _set_malloc_crt_max_wait( unsigned long _NewValue);
#line 158 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\malloc.h"
                                                                   __declspec(dllimport) void * __cdecl _expand( void * _Memory, size_t _NewSize);
               __declspec(dllimport) size_t __cdecl _msize( void * _Memory);






                                               void * __cdecl _alloca( size_t _Size);


__declspec(dllimport) int __cdecl _heapwalk( _HEAPINFO * _EntryInfo);
__declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);



               __declspec(dllimport) int __cdecl _heapadd( void * _Memory, size_t _Size);
               __declspec(dllimport) int __cdecl _heapchk(void);
               __declspec(dllimport) int __cdecl _heapmin(void);
__declspec(dllimport) int __cdecl _heapset( unsigned int _Fill);
__declspec(dllimport) size_t __cdecl _heapused(size_t * _Used, size_t * _Commit);
#line 195 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\malloc.h"
typedef char __static_assert_t[ (sizeof(unsigned int) <= 8) ];


#pragma warning(push)
#pragma warning(disable: 6540)
__inline void *_MarkAllocaS( void *_Ptr, unsigned int _Marker)
{
    if (_Ptr)
    {
        *((unsigned int*)_Ptr) = _Marker;
        _Ptr = (char*)_Ptr + 8;
    }
    return _Ptr;
}

__inline int _MallocaIsSizeInRange(size_t size)
{
    return size + 8 > size;
}
#pragma warning(pop)
#line 253 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\malloc.h"
#pragma warning(push)
#pragma warning(disable: 6014)
__declspec(noalias) __inline void __cdecl _freea( void * _Memory)
{
    unsigned int _Marker;
    if (_Memory)
    {
        _Memory = (char*)_Memory - 8;
        _Marker = *(unsigned int *)_Memory;
        if (_Marker == 0xDDDD)
        {
            free(_Memory);
        }

        else if (_Marker != 0xCCCC)
        {
#pragma warning(suppress: 4548)
 ((void)0);
        }

    }
}
#pragma warning(pop)
#line 289 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\malloc.h"
}


#pragma pack(pop)
#line 41 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"
#line 80 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"
 namespace std {
#line 89 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"
class __declspec(dllimport) exception
 {
public:
                                      exception();
                   explicit exception(const char * const &);
                                      exception(const char * const &, int);
                                      exception(const exception&);
                   exception& operator=(const exception&);
                   virtual ~exception() throw ();
                   virtual const char * what() const;

private:
                   void _Copy_str(const char *);
                   void _Tidy();

 const char * _Mywhat;
 bool _Mydofree;
 };
#line 188 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"
using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);

__declspec(dllimport) bool __cdecl uncaught_exception();


inline terminate_handler __cdecl get_terminate()
 {
 return (_get_terminate());
 }

inline unexpected_handler __cdecl get_unexpected()
 {
 return (_get_unexpected());
 }


}
#line 328 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"
namespace std {





class bad_exception : public exception
 {
public:
                    bad_exception(const char *_Message = "bad exception")
  throw ()
  : exception(_Message)
  {
  }

 virtual ~bad_exception() throw ()
  {
  }
#line 355 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"
 };


class bad_alloc : public exception
 {
public:
                    bad_alloc() throw ()
  : exception("bad allocation", 1)
  {
  }

 virtual ~bad_alloc() throw ()
  {
  }

private:
 friend class bad_array_new_length;

                    bad_alloc(const char *_Message) throw ()
  : exception(_Message, 1)
  {
  }
#line 386 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"
 };


class bad_array_new_length
 : public bad_alloc
 {
public:

 bad_array_new_length() throw ()
  : bad_alloc("bad array new length")
  {
  }
 };


}
#line 413 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\exception"
__declspec(dllimport) void __cdecl __ExceptionPtrCreate( void* );
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy( void* );
__declspec(dllimport) void __cdecl __ExceptionPtrCopy( void*, const void* );
__declspec(dllimport) void __cdecl __ExceptionPtrAssign( void*, const void* );
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare( const void*, const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrToBool( const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrSwap( void*, void*);

__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException( void*);
__declspec(dllimport) void __cdecl __ExceptionPtrRethrow( const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException( void*, const void*, const void*);

namespace std {

class exception_ptr
 {
public:
 exception_ptr()
  {
  __ExceptionPtrCreate(this);
  }
 exception_ptr(nullptr_t)
  {
  __ExceptionPtrCreate(this);
  }
 ~exception_ptr() throw ()
  {
  __ExceptionPtrDestroy(this);
  }
 exception_ptr(const exception_ptr& _Rhs)
  {
  __ExceptionPtrCopy(this, &_Rhs);
  }
 exception_ptr& operator=(const exception_ptr& _Rhs)
  {
  __ExceptionPtrAssign(this, &_Rhs);
  return *this;
  }
 exception_ptr& operator=(nullptr_t)
  {
  exception_ptr _Ptr;
  __ExceptionPtrAssign(this, &_Ptr);
  return *this;
  }

 typedef exception_ptr _Myt;

 explicit operator bool() const throw ()
  {
  return __ExceptionPtrToBool(this);
  }

 void _RethrowException() const
  {
  __ExceptionPtrRethrow(this);
  }

 static exception_ptr _Current_exception()
  {
  exception_ptr _Retval;
  __ExceptionPtrCurrentException(&_Retval);
  return _Retval;
  }
 static exception_ptr _Copy_exception( void* _Except, const void* _Ptr)
  {
  exception_ptr _Retval = 0;
  if (!_Ptr)
   {

   return _Retval;
   }
  __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
  return _Retval;
  }
private:
 void* _Data1;
 void* _Data2;
 };

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs)
 {
 __ExceptionPtrSwap(&_Lhs, &_Rhs);
 }

inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs)
 {
 return __ExceptionPtrCompare(&_Lhs, &_Rhs);
 }

inline bool operator==(nullptr_t, const exception_ptr& _Rhs)
 {
 return !_Rhs;
 }

inline bool operator==(const exception_ptr& _Lhs, nullptr_t)
 {
 return !_Lhs;
 }

inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs)
 {
 return !(_Lhs == _Rhs);
 }

inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs)
 {
 return !(_Lhs == _Rhs);
 }

inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs)
 {
 return !(_Lhs == _Rhs);
 }

inline exception_ptr current_exception()
 {
 return exception_ptr::_Current_exception();
 }

inline void rethrow_exception( exception_ptr _P)
 {
 _P._RethrowException();
 }

template <class _E> void *__GetExceptionInfo(_E);

template<class _E> exception_ptr make_exception_ptr(_E _Except)
 {
 return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
 }
}








#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\new"


#pragma pack(push,8)
#pragma warning(push, 3)
#line 23 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\new"
namespace std {







typedef void (__cdecl * new_handler) ();




struct nothrow_t
 {
 };

extern const nothrow_t nothrow;



__declspec(dllimport) new_handler __cdecl set_new_handler( new_handler)
 throw ();

__declspec(dllimport) new_handler __cdecl get_new_handler()
 throw ();
}


void __cdecl operator delete(void *) throw ();
#pragma warning(suppress: 4985)
 void *__cdecl operator new(size_t _Size) throw (...);



inline void *__cdecl operator new(size_t, void *_Where) throw ()
 {
 return (_Where);
 }

inline void __cdecl operator delete(void *, void *) throw ()
 {
 }




inline void *__cdecl operator new[](size_t, void *_Where) throw ()
 {
 return (_Where);
 }

inline void __cdecl operator delete[](void *, void *) throw ()
 {
 }


void __cdecl operator delete[](void *) throw ();

                                               void *__cdecl operator new[](size_t _Size)
 throw (...);



                                                 void *__cdecl operator new(size_t _Size, const ::std:: nothrow_t&)
 throw ();

                                                 void *__cdecl operator new[](size_t _Size, const ::std:: nothrow_t&)
 throw ();

void __cdecl operator delete(void *, const ::std:: nothrow_t&)
 throw ();

void __cdecl operator delete[](void *, const ::std:: nothrow_t&)
 throw ();




using ::std:: new_handler;



#pragma warning(pop)
#pragma pack(pop)
#line 8 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory0"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
#line 10 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {
#line 36 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct __declspec(dllimport) _Container_base0
 {
 void _Orphan_all()
  {
  }

 void _Swap_all(_Container_base0&)
  {
  }
 };

struct _Iterator_base0
 {
 void _Adopt(const void *)
  {
  }

 const _Container_base0 *_Getcont() const
  {
  return (0);
  }
 };


struct _Container_proxy
 {
 _Container_proxy()
  : _Mycont(0), _Myfirstiter(0)
  {
  }

 const _Container_base12 *_Mycont;
 _Iterator_base12 *_Myfirstiter;
 };

struct __declspec(dllimport) _Container_base12
 {
public:
 _Container_base12()
  : _Myproxy(0)
  {
  }

 _Container_base12(const _Container_base12&)
  : _Myproxy(0)
  {
  }

 _Container_base12& operator=(const _Container_base12&)
  {
  return (*this);
  }

 ~_Container_base12() throw ()
  {
  _Orphan_all();
  }

 _Iterator_base12 **_Getpfirst() const
  {
  return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
  }

 void _Orphan_all();
 void _Swap_all(_Container_base12&);

 _Container_proxy *_Myproxy;
 };

struct _Iterator_base12
 {
public:
 _Iterator_base12()
  : _Myproxy(0), _Mynextiter(0)
  {
  }

 _Iterator_base12(const _Iterator_base12& _Right)
  : _Myproxy(0), _Mynextiter(0)
  {
  *this = _Right;
  }

 _Iterator_base12& operator=(const _Iterator_base12& _Right)
  {
  if (_Myproxy == _Right._Myproxy)
   ;
  else if (_Right._Myproxy != 0)
   _Adopt(_Right._Myproxy->_Mycont);
  else
   {




   }
  return (*this);
  }

 ~_Iterator_base12() throw ()
  {




  }

 void _Adopt(const _Container_base12 *_Parent)
  {
  if (_Parent == 0)
   {




   }
  else
   {
   _Container_proxy *_Parent_proxy = _Parent->_Myproxy;
#line 171 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
   _Myproxy = _Parent_proxy;

   }
  }

 void _Clrcont()
  {
  _Myproxy = 0;
  }

 const _Container_base12 *_Getcont() const
  {
  return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
  }

 _Iterator_base12 **_Getpnext()
  {
  return (&_Mynextiter);
  }

 void _Orphan_me()
  {
#line 206 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
  }

 _Container_proxy *_Myproxy;
 _Iterator_base12 *_Mynextiter;
 };


inline void _Container_base12::_Orphan_all()
 {
#line 226 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
 }

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
 {




 _Container_proxy *_Temp = _Myproxy;
 _Myproxy = _Right._Myproxy;
 _Right._Myproxy = _Temp;

 if (_Myproxy != 0)
  _Myproxy->_Mycont = (_Container_base12 *)this;
 if (_Right._Myproxy != 0)
  _Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
 }


typedef _Container_base0 _Container_base;
typedef _Iterator_base0 _Iterator_base;
#line 260 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _Ty>
 struct _Get_unchecked_type
  { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::_Unchecked_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<_Ty>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Is_checked_helper
  { template<class _Uty> static auto _Fn(int, _Identity<typename _Uty::_Unchecked_type> * = 0, _Identity<typename _Uty::_Unchecked_type> * = 0, _Identity<typename _Uty::_Unchecked_type> * = 0) -> true_type; template<class _Uty> static auto _Fn(_Wrap_int) -> false_type; typedef decltype(_Fn<_Ty>(0)) type; };


template<class _Iter> inline
 typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
 {
 return (typename _Is_checked_helper<_Iter>::type());
 }


template<class _Iter> inline
 _Iter _Unchecked(_Iter _Src)
 {
 return (_Src);
 }


template<class _Iter,
 class _UIter> inline
 _Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
 {
 _Dest = _Src;
 return (_Dest);
 }



struct input_iterator_tag
 {
 };

struct _Mutable_iterator_tag
 {
 };

struct output_iterator_tag
 : _Mutable_iterator_tag
 {
 };

struct forward_iterator_tag
 : input_iterator_tag, _Mutable_iterator_tag
 {
 };

struct bidirectional_iterator_tag
 : forward_iterator_tag
 {
 };

struct random_access_iterator_tag
 : bidirectional_iterator_tag
 {
 };


struct _Nonscalar_ptr_iterator_tag
 {
 };
struct _Scalar_ptr_iterator_tag
 {
 };


template<class _Category,
 class _Ty,
 class _Diff = ptrdiff_t,
 class _Pointer = _Ty *,
 class _Reference = _Ty&>
 struct iterator
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;
 typedef _Diff distance_type;
 typedef _Pointer pointer;
 typedef _Reference reference;
 };

template<class _Category,
 class _Ty,
 class _Diff,
 class _Pointer,
 class _Reference,
 class _Base>
 struct _Iterator012
  : public _Base
 {
 typedef _Category iterator_category;
 typedef _Ty value_type;
 typedef _Diff difference_type;
 typedef _Diff distance_type;
 typedef _Pointer pointer;
 typedef _Reference reference;
 };


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;


template<class _Iter>
 struct iterator_traits
 {
 typedef typename _Iter::iterator_category iterator_category;
 typedef typename _Iter::value_type value_type;
 typedef typename _Iter::difference_type difference_type;
 typedef difference_type distance_type;
 typedef typename _Iter::pointer pointer;
 typedef typename _Iter::reference reference;
 };

template<class _Ty>
 struct iterator_traits<_Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;
 typedef ptrdiff_t distance_type;
 typedef _Ty *pointer;
 typedef _Ty& reference;
 };

template<class _Ty>
 struct iterator_traits<const _Ty *>
 {
 typedef random_access_iterator_tag iterator_category;
 typedef _Ty value_type;
 typedef ptrdiff_t difference_type;
 typedef ptrdiff_t distance_type;
 typedef const _Ty *pointer;
 typedef const _Ty& reference;
 };


template<class _Iter> inline
 typename iterator_traits<_Iter>::iterator_category
  _Iter_cat(const _Iter&)
 {
 typename iterator_traits<_Iter>::iterator_category _Cat;
 return (_Cat);
 }


template<class _Iter1,
 class _Iter2> inline
 _Nonscalar_ptr_iterator_tag _Ptr_cat(_Iter1&, _Iter2&)
 {
 _Nonscalar_ptr_iterator_tag _Cat;
 return (_Cat);
 }

template<class _Elem1,
 class _Elem2>
 struct _Ptr_cat_helper
 {
 typedef _Nonscalar_ptr_iterator_tag type;
 };

template<class _Elem>
 struct _Ptr_cat_helper<_Elem, _Elem>
 {
 typedef typename _If<is_scalar<_Elem>::value,
  _Scalar_ptr_iterator_tag,
  _Nonscalar_ptr_iterator_tag>::type type;
 };

template<class _Anything>
 struct _Ptr_cat_helper<_Anything *, const _Anything *>
 {
 typedef _Scalar_ptr_iterator_tag type;
 };

template<class _Elem1,
 class _Elem2> inline
 typename _Ptr_cat_helper<_Elem1, _Elem2>::type
  _Ptr_cat(_Elem1 *, _Elem2 *)
 {
 typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
 return (_Cat);
 }

template<class _Elem1,
 class _Elem2> inline
 typename _Ptr_cat_helper<_Elem1, _Elem2>::type
  _Ptr_cat(const _Elem1 *, _Elem2 *)
 {
 typename _Ptr_cat_helper<_Elem1, _Elem2>::type _Cat;
 return (_Cat);
 }
#line 643 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _Iter> inline
 typename iterator_traits<_Iter>::value_type *_Val_type(_Iter)
 {
 return (0);
 }


template<class _InIt,
 class _Diff> inline
 void _Advance(_InIt& _Where, _Diff _Off, input_iterator_tag)
 {





 for (; 0 < _Off; --_Off)
  ++_Where;
 }

template<class _FwdIt,
 class _Diff> inline
 void _Advance(_FwdIt& _Where, _Diff _Off, forward_iterator_tag)
 {





 for (; 0 < _Off; --_Off)
  ++_Where;
 }

template<class _BidIt,
 class _Diff> inline
 void _Advance(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
 {
 for (; 0 < _Off; --_Off)
  ++_Where;
 for (; _Off < 0; ++_Off)
  --_Where;
 }

template<class _RanIt,
 class _Diff> inline
 void _Advance(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
 {
 _Where += _Off;
 }

template<class _InIt,
 class _Diff> inline
 void advance(_InIt& _Where, _Diff _Off)
 {
 _Advance(_Where, _Off, _Iter_cat(_Where));
 }



template<class _Iter> inline
 typename iterator_traits<_Iter>::difference_type
  *_Dist_type(_Iter)
 {
 return (0);
 }


template<class _InIt,
 class _Diff> inline
  void _Distance2(_InIt _First, _InIt _Last, _Diff& _Off,
   input_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _FwdIt,
 class _Diff> inline
  void _Distance2(_FwdIt _First, _FwdIt _Last, _Diff& _Off,
   forward_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _BidIt,
 class _Diff> inline
  void _Distance2(_BidIt _First, _BidIt _Last, _Diff& _Off,
   bidirectional_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  ++_Off;
 }

template<class _RanIt,
 class _Diff> inline
  void _Distance2(_RanIt _First, _RanIt _Last, _Diff& _Off,
   random_access_iterator_tag)
 {
#line 750 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
 _Off += _Last - _First;
 }

template<class _InIt> inline
 typename iterator_traits<_InIt>::difference_type
  distance(_InIt _First, _InIt _Last)
 {
 typename iterator_traits<_InIt>::difference_type _Off = 0;
 _Distance2(_First, _Last, _Off, _Iter_cat(_First));
 return (_Off);
 }

template<class _InIt,
 class _Diff> inline
  void _Distance(_InIt _First, _InIt _Last, _Diff& _Off)
 {
 _Distance2(_First, _Last, _Off, _Iter_cat(_First));
 }


template<class _FwdIt> inline
 _FwdIt next(_FwdIt _First,
  typename iterator_traits<_FwdIt>::difference_type _Off = 1)
 {
 static_assert((is_base_of<forward_iterator_tag,
  typename iterator_traits<_FwdIt>::iterator_category>::value),
  "next requires forward iterator");

 ::std:: advance(_First, _Off);
 return (_First);
 }


template<class _BidIt> inline
 _BidIt prev(_BidIt _First,
  typename iterator_traits<_BidIt>::difference_type _Off = 1)
 {
 static_assert((is_base_of<bidirectional_iterator_tag,
  typename iterator_traits<_BidIt>::iterator_category>::value),
  "prev requires bidirectional iterator");

 ::std:: advance(_First, -_Off);
 return (_First);
 }



template<class _Ty>
 struct pointer_traits;

template<class _RanIt,
 class _Base>
 class _Revranit
  : public _Base
 {
public:
 typedef _Revranit<_RanIt, _Base> _Myt;
 typedef typename _Base::difference_type difference_type;
 typedef typename _Base::pointer pointer;
 typedef typename _Base::reference reference;
 typedef _RanIt iterator_type;

 _Revranit()
  {
  }

 explicit _Revranit(_RanIt _Right)
  : current(_Right)
  {
  }

 template<class _RanIt2,
  class _Base2>
  _Revranit(const _Revranit<_RanIt2, _Base2>& _Right)
  : current(_Right.base())
  {
  }

 _RanIt base() const
  {
  return (current);
  }

 reference operator*() const
  {
  _RanIt _Tmp = current;
  return (*--_Tmp);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {
  --current;
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

 _Myt& operator--()
  {
  ++current;
  return (*this);
  }

 _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }

 template<class _RanIt2,
  class _Base2>
  bool _Equal(const _Revranit<_RanIt2, _Base2>& _Right) const
  {
  return (current == _Right.base());
  }



 _Myt& operator+=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

 _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

 _Myt& operator-=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

 _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 template<class _RanIt2,
  class _Base2>
  bool _Less(const _Revranit<_RanIt2, _Base2>& _Right) const
  {
  return (_Right.base() < current);
  }

 difference_type operator-(const _Myt& _Right) const
  {
  return (_Right.base() - current);
  }

protected:
 _RanIt current;
 };


template<class _RanIt,
 class _Base,
 class _Diff> inline
 _Revranit<_RanIt, _Base>
  operator+(_Diff _Off,
  const _Revranit<_RanIt, _Base>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2>
 auto inline operator-(
  const _Revranit<_RanIt1, _Base1>& _Left,
  const _Revranit<_RanIt2, _Base2>& _Right)
   -> decltype(_Right.base() - _Left.base())
 {
 return (_Right.base() - _Left.base());
 }

template<class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2> inline
 bool operator==(
  const _Revranit<_RanIt1, _Base1>& _Left,
  const _Revranit<_RanIt2, _Base2>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2> inline
 bool operator!=(
  const _Revranit<_RanIt1, _Base1>& _Left,
  const _Revranit<_RanIt2, _Base2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2> inline
 bool operator<(
  const _Revranit<_RanIt1, _Base1>& _Left,
  const _Revranit<_RanIt2, _Base2>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2> inline
 bool operator>(
  const _Revranit<_RanIt1, _Base1>& _Left,
  const _Revranit<_RanIt2, _Base2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2> inline
 bool operator<=(
  const _Revranit<_RanIt1, _Base1>& _Left,
  const _Revranit<_RanIt2, _Base2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2> inline
 bool operator>=(
  const _Revranit<_RanIt1, _Base1>& _Left,
  const _Revranit<_RanIt2, _Base2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _RanIt>
 class reverse_iterator
  : public _Revranit<_RanIt, iterator<
   typename iterator_traits<_RanIt>::iterator_category,
   typename iterator_traits<_RanIt>::value_type,
   typename iterator_traits<_RanIt>::difference_type,
   typename iterator_traits<_RanIt>::pointer,
   typename iterator_traits<_RanIt>::reference> >
 {
 typedef reverse_iterator<_RanIt> _Myt;
 typedef _Revranit<_RanIt, iterator<
  typename iterator_traits<_RanIt>::iterator_category,
  typename iterator_traits<_RanIt>::value_type,
  typename iterator_traits<_RanIt>::difference_type,
  typename iterator_traits<_RanIt>::pointer,
  typename iterator_traits<_RanIt>::reference> > _Mybase;

public:
 typedef typename iterator_traits<_RanIt>::difference_type difference_type;
 typedef typename iterator_traits<_RanIt>::pointer pointer;
 typedef typename iterator_traits<_RanIt>::reference reference;
 typedef _RanIt iterator_type;

 reverse_iterator()
  {
  }

 explicit reverse_iterator(_RanIt _Right)
  : _Mybase(_Right)
  {
  }

 template<class _Other>
  reverse_iterator(const reverse_iterator<_Other>& _Right)
  : _Mybase(_Right.base())
  {
  }

 reverse_iterator(_Mybase _Right)
  : _Mybase(_Right)
  {
  }

 template<class _Other>
  _Myt& operator=(const reverse_iterator<_Other>& _Right)
  {
  this->current = _Right.base();
  return (*this);
  }

 _Myt& operator++()
  {
  ++*((_Mybase *)this);
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myt& operator--()
  {
  --*((_Mybase *)this);
  return (*this);
  }

 _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myt& operator+=(difference_type _Off)
  {
  *((_Mybase *)this) += _Off;
  return (*this);
  }

 _Myt operator+(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myt& operator-=(difference_type _Off)
  {
  *((_Mybase *)this) -= _Off;
  return (*this);
  }

 _Myt operator-(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }
 };

template<class _RanIt>
 struct _Is_checked_helper<reverse_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt,
 class _Diff> inline
 reverse_iterator<_RanIt> operator+(_Diff _Off,
  const reverse_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
 auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
   -> decltype(_Right.base() - _Left.base())
 {
 return (_Right.base() - _Left.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator==(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator!=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator<(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator>(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator<=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator>=(const reverse_iterator<_RanIt1>& _Left,
  const reverse_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }



template<class _Container>
 auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
 auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
 {
 return (_Cont.begin());
 }

template<class _Container>
 auto inline end(_Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Container>
 auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
 {
 return (_Cont.end());
 }

template<class _Ty,
 size_t _Size> inline
 _Ty *begin(_Ty (&_Array)[_Size])
 {
 return (_Array);
 }

template<class _Ty,
 size_t _Size> inline
 _Ty *end(_Ty (&_Array)[_Size])
 {
 return (_Array + _Size);
 }


template<class _Container>
 auto inline cbegin(const _Container& _Cont) -> decltype(::std:: begin(_Cont))
 {
 return (::std:: begin(_Cont));
 }

template<class _Container>
 auto inline cend(const _Container& _Cont) -> decltype(::std:: end(_Cont))
 {
 return (::std:: end(_Cont));
 }


template<class _Container>
 auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
 auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
 {
 return (_Cont.rbegin());
 }

template<class _Container>
 auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Container>
 auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
 {
 return (_Cont.rend());
 }

template<class _Ty,
 size_t _Size> inline
 reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array + _Size));
 }

template<class _Ty,
 size_t _Size> inline
 reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
 {
 return (reverse_iterator<_Ty *>(_Array));
 }

template<class _Elem> inline
 reverse_iterator<const _Elem *> rbegin(initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.end()));
 }

template<class _Elem> inline
 reverse_iterator<const _Elem *> rend(initializer_list<_Elem> _Ilist)
 {
 return (reverse_iterator<const _Elem *>(_Ilist.begin()));
 }


template<class _Container>
 auto inline crbegin(const _Container& _Cont) -> decltype(::std:: rbegin(_Cont))
 {
 return (::std:: rbegin(_Cont));
 }

template<class _Container>
 auto inline crend(const _Container& _Cont) -> decltype(::std:: rend(_Cont))
 {
 return (::std:: rend(_Cont));
 }



template<class _Ty,
 size_t _Size>
 class _Array_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   _Ty,
   ptrdiff_t,
   const _Ty *,
   const _Ty&,
   _Iterator_base>
 {
public:
 typedef _Array_const_iterator<_Ty, _Size> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef const _Ty *pointer;
 typedef const _Ty& reference;
 enum {_EEN_SIZE = _Size};
 enum {_EEN_IDL =
  0};


 _Array_const_iterator()
  {
  _Ptr = 0;
  }

 explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
  {
  _Ptr = _Parg + _Off;
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  _Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Ptr);
  }

 reference operator*() const
  {
  return (*_Ptr);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  return (_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  return (_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }

 pointer _Ptr;
#line 1654 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_const_iterator<_Ty, _Size>&
  _Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
   typename _Array_const_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
 _Array_const_iterator<_Ty, _Size> operator+(
  typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
  _Array_const_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _Ty,
 size_t _Size>
 class _Array_iterator
  : public _Array_const_iterator<_Ty, _Size>
 {
public:
 typedef _Array_iterator<_Ty, _Size> _Myiter;
 typedef _Array_const_iterator<_Ty, _Size> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty *pointer;
 typedef _Ty& reference;

 _Array_iterator()
  {
  }

 explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
  : _Mybase(_Parg, _Off)
  {
  }
 enum {_EEN_SIZE = _Size};
 enum {_EEN_IDL =
  0};

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  ((_Mybase *)this)->_Rechecked(_Right);
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return ((pointer)((_Mybase *)this)->_Unchecked());
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Ty,
 size_t _Size> inline
 typename _Array_iterator<_Ty, _Size>::_Unchecked_type
  _Unchecked(_Array_iterator<_Ty, _Size> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Ty,
 size_t _Size> inline
 _Array_iterator<_Ty, _Size>&
  _Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
   typename _Array_iterator<_Ty, _Size>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Ty,
 size_t _Size> inline
 _Array_iterator<_Ty, _Size> operator+(
  typename _Array_iterator<_Ty, _Size>::difference_type _Off,
  _Array_iterator<_Ty, _Size> _Next)
 {
 return (_Next += _Off);
 }


template<class _RanIt>
 class move_iterator
 {
public:
 typedef move_iterator<_RanIt> _Myt;
 typedef typename iterator_traits<_RanIt>::iterator_category
  iterator_category;
 typedef typename iterator_traits<_RanIt>::value_type
  value_type;
 typedef typename iterator_traits<_RanIt>::difference_type
  difference_type;
 typedef _RanIt pointer;
 typedef value_type&& reference;
 typedef _RanIt iterator_type;

 move_iterator()
  {
  }

 explicit move_iterator(iterator_type _Right)
  : current(_Right)
  {
  }

 template<class _RanIt2>
  move_iterator(const move_iterator<_RanIt2>& _Right)
  : current(_Right.base())
  {
  }

 template<class _RanIt2>
  _Myt& operator=(const move_iterator<_RanIt2>& _Right)
  {
  current = _Right.base();
  return (*this);
  }

 _RanIt base() const
  {
  return (current);
  }

 reference operator*() const
  {
  return (::std:: move(*current));
  }

 pointer operator->() const
  {
  return (current);
  }

 _Myt& operator++()
  {
  ++current;
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++current;
  return (_Tmp);
  }

 _Myt& operator--()
  {
  --current;
  return (*this);
  }

 _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --current;
  return (_Tmp);
  }

 template<class _RanIt2>
  bool _Equal(const move_iterator<_RanIt2>& _Right) const
  {
  return (current == _Right.base());
  }



 _Myt& operator+=(difference_type _Off)
  {
  current += _Off;
  return (*this);
  }

 _Myt operator+(difference_type _Off) const
  {
  return (_Myt(current + _Off));
  }

 _Myt& operator-=(difference_type _Off)
  {
  current -= _Off;
  return (*this);
  }

 _Myt operator-(difference_type _Off) const
  {
  return (_Myt(current - _Off));
  }

 reference operator[](difference_type _Off) const
  {
  return (::std:: move(current[_Off]));
  }

 template<class _RanIt2>
  bool _Less(const move_iterator<_RanIt2>& _Right) const
  {
  return (current < _Right.base());
  }

 difference_type operator-(const _Myt& _Right) const
  {
  return (current - _Right.base());
  }

protected:
 iterator_type current;
 };

template<class _RanIt>
 struct _Is_checked_helper<move_iterator<_RanIt> >
  : public _Is_checked_helper<_RanIt>
 {
 };


template<class _RanIt,
 class _Diff> inline
 move_iterator<_RanIt>
  operator+(_Diff _Off,
  const move_iterator<_RanIt>& _Right)
 {
 return (_Right + _Off);
 }

template<class _RanIt1,
 class _RanIt2>
 auto inline operator-(
  move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
   -> decltype(_Left.base() - _Right.base())
 {
 return (_Left.base() - _Right.base());
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator==(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator!=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator<(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator>(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (_Right < _Left);
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator<=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _RanIt1,
 class _RanIt2> inline
 bool operator>=(
  const move_iterator<_RanIt1>& _Left,
  const move_iterator<_RanIt2>& _Right)
 {
 return (!(_Left < _Right));
 }


template<class _RanIt> inline
 move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
 {
 return (move_iterator<_RanIt>(_Iter));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, ++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_impl(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Copy_impl(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt copy(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Copy_impl(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
#line 2151 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag)
 {
 *_Dest = *_First;
 while (0 < --_Count)
  *++_Dest = *++_First;
 return (++_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, forward_iterator_tag)
 {
 for (; 0 < _Count; --_Count, ++_Dest, ++_First)
  *_Dest = *_First;
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 return (_Copy_n(_First, _Count,
  _Dest, _Iter_cat(_First)));
 }
template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt _Copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {
 return (_Copy_n(_First, _Count,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _Diff,
 class _OutIt> inline
 _OutIt copy_n(_InIt _First, _Diff _Count,
  _OutIt _Dest)
 {
 if (_Count <= 0)
  return (_Dest);
 else
  return (_Rechecked(_Dest,
   _Copy_n(_Unchecked(_First), _Count,
    _Unchecked(_Dest))));
 }
#line 2340 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = *--_Last;
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Copy_backward(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest - _Count, &*_First,
  _Count * sizeof (*_First));
 return (_Dest - _Count);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Copy_backward(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Rechecked(_Dest,
  _Copy_backward(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
#line 2414 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_Dest, ++_First)
  *_Dest = ::std:: move(*_First);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Move(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _OutIt> inline
 _OutIt move(_InIt _First, _InIt _Last,
  _OutIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Move(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
#line 2521 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag)
 {
 while (_First != _Last)
  *--_Dest = ::std:: move(*--_Last);
 return (_Dest);
 }

template<class _InIt,
 class _OutIt> inline
 _OutIt _Move_backward(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest - _Count, &*_First,
  _Count * sizeof (*_First));
 return (_Dest - _Count);
 }

template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 _Move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Move_backward(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _BidIt1,
 class _BidIt2> inline
 _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest)
 {
 return (_Rechecked(_Dest,
  _Move_backward(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
#line 2595 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _FwdIt,
 class _Ty> inline
 void _Fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 for (; _First != _Last; ++_First)
  *_First = _Val;
 }

inline void _Fill(char *_First, char *_Last, char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

inline void _Fill(signed char *_First, signed char *_Last, signed char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val)
 {
 :: memset(_First, _Val, _Last - _First);
 }

template<class _FwdIt,
 class _Ty> inline
 void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
                            ;
 _Fill(_Unchecked(_First), _Unchecked(_Last), _Val);
 }


template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt _Fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {
 for (; 0 < _Count; --_Count, ++_Dest)
  *_Dest = _Val;
 return (_Dest);
 }

inline char *_Fill_n(char *_Dest, size_t _Count, char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }

inline signed char *_Fill_n(signed char *_Dest, size_t _Count,
 signed char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }

inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count,
 unsigned char _Val)
 {
 :: memset(_Dest, _Val, _Count);
 return (_Dest + _Count);
 }


template<class _OutIt,
 class _Diff,
 class _Ty> inline
 _OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
 {
 return (_Rechecked(_Dest, _Fill_n(_Unchecked(_Dest), _Count, _Val)));
 }
#line 2732 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _InIt1,
 class _InIt2> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2)
 {
 for (; _First1 != _Last1; ++_First1, ++_First2)
  if (!(*_First1 == *_First2))
   return (false);
 return (true);
 }

inline bool _Equal(const char *_First1, const char *_Last1,
 const char *_First2)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }

inline bool _Equal(const signed char *_First1, const signed char *_Last1,
 const signed char *_First2)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }

inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1,
 const unsigned char *_First2)
 {
 return (:: memcmp(_First1, _First2, _Last1 - _First1) == 0);
 }


template<class _InIt1,
 class _InIt2> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2)
 {
 return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2)));
 }
#line 2815 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred)
 {
 for (; _First1 != _Last1; ++_First1, ++_First2)
  if (!_Pred(*_First1, *_First2))
   return (false);
 return (true);
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool equal(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred)
 {
 return (_Equal(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Pred));
 }
#line 2887 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _InIt1,
 class _InIt2> inline
 bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
  if (((*_First1) < (*_First2)))
   return (true);
  else if (*_First2 < *_First1)
   return (false);
 return (_First1 == _Last1 && _First2 != _Last2);
 }

inline bool _Lexicographical_compare(
 const unsigned char *_First1, const unsigned char *_Last1,
 const unsigned char *_First2, const unsigned char *_Last2)
 {
 ptrdiff_t _Num1 = _Last1 - _First1;
 ptrdiff_t _Num2 = _Last2 - _First2;
 int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
 return (_Ans < 0 || (_Ans == 0 && _Num1 < _Num2));
 }
#line 2922 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xutility"
template<class _InIt1,
 class _InIt2> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
                              ;
                              ;
 return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2)));
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
  if (_Pred(*_First1, *_First2))
   return (true);
  else if (_Pred(*_First2, *_First1))
   return (false);
 return (_First1 == _Last1 && _First2 != _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                      ;
 return (_Lexicographical_compare(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred));
 }


template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, true_type, true_type, _Ignored)
 {
 return ((-128) <= _Val && _Val <= 127);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
 {
 return (_Val <= 127 || static_cast<_Ty>((-128)) <= _Val);
 }

template<class _Ty> inline
 bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
 {
 return (_Val <= 127);
 }

template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, false_type, true_type, _Ignored)
 {
 return (0 <= _Val && _Val <= 0xff);
 }

template<class _Ty,
 class _Ignored> inline
 bool _Within_limits(const _Ty& _Val, false_type, false_type, _Ignored)
 {
 return (_Val <= 0xff);
 }

template<class _InIt,
 class _Ty> inline
 bool _Within_limits(_InIt, const _Ty& _Val)
 {
 typedef typename remove_pointer<_InIt>::type _Elem;
 return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
  integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
 }

template<class _InIt> inline
 bool _Within_limits(_InIt, const bool&)
 {
 return (true);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
 {
 if (!_Within_limits(_First, _Val))
  return (_Last);
 _First = static_cast<_InIt>(:: memchr(
  _First, static_cast<unsigned char>(_Val), _Last - _First));
 return (_First ? _First : _Last);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
 {
 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   break;
 return (_First);
 }

template<class _InIt,
 class _Ty> inline
 _InIt _Find(_InIt _First, _InIt _Last, const _Ty& _Val)
 {

 typedef integral_constant<bool,
  ( is_same<_InIt, char *>::value
  || is_same<_InIt, signed char *>::value
  || is_same<_InIt, unsigned char *>::value
  || is_same<_InIt, const char *>::value
  || is_same<_InIt, const signed char *>::value
  || is_same<_InIt, const unsigned char *>::value)
  && is_integral<_Ty>::value
 > _Memchr_opt;
 return (_Find(_First, _Last, _Val, _Memchr_opt()));
 }

template<class _InIt,
 class _Ty> inline
 _InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Rechecked(_First,
  _Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 _InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   break;
 return (_First);
 }


template<class _InIt,
 class _Ty> inline
 typename iterator_traits<_InIt>::difference_type
  _Count_np(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
 typename iterator_traits<_InIt>::difference_type _Count = 0;

 for (; _First != _Last; ++_First)
  if (*_First == _Val)
   ++_Count;
 return (_Count);
 }

template<class _InIt,
 class _Ty> inline
 typename iterator_traits<_InIt>::difference_type
  count(_InIt _First, _InIt _Last, const _Ty& _Val)
 {
                            ;
 return (_Count_np(_Unchecked(_First), _Unchecked(_Last), _Val));
 }


template<class _InIt,
 class _Ty,
 class _Pr> inline
 typename iterator_traits<_InIt>::difference_type
  _Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
 {
 typename iterator_traits<_InIt>::difference_type _Count = 0;

 for (; _First != _Last; ++_First)
  if (_Pred(*_First, _Val))
   ++_Count;
 return (_Count);
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool _Is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred)
 {
 for (; _First1 != _Last1; ++_First1, ++_First2)
  if (!_Pred(*_First1, *_First2))
   break;
 if (_First1 != _Last1)
  {
  _FwdIt2 _Last2 = _First2;
  advance(_Last2, distance(_First1, _Last1));
  for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
   if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
    {
    typename iterator_traits<_FwdIt2>::difference_type _Count =
     _Count_pr(_First2, _Last2, *_Next1, _Pred);
    if (_Count == 0
     || _Count != _Count_pr(_Next1, _Last1, *_Next1, _Pred))
     return (false);
    }
  }
 return (true);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred)
 {
                              ;
                      ;
 return _Is_permutation(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Pred);
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2)
 {
 return (::std:: is_permutation(_First1, _Last1,
  _First2, equal_to<>()));
 }


template<class _BidIt> inline
 void _Reverse(_BidIt _First, _BidIt _Last, bidirectional_iterator_tag)
 {
 for (; _First != _Last && _First != --_Last; ++_First)
  ::std:: iter_swap(_First, _Last);
 }

template<class _BidIt> inline
 void reverse(_BidIt _First, _BidIt _Last)
 {
                            ;
 _Reverse(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
 }


template<class _FwdIt> inline
 void _Rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag)
 {
 for (_FwdIt _Next = _Mid; ; )
  {
  ::std:: iter_swap(_First, _Next);
  if (++_First == _Mid)
   if (++_Next == _Last)
    break;
   else
    _Mid = _Next;
  else if (++_Next == _Last)
   _Next = _Mid;
  }
 }

template<class _BidIt> inline
 void _Rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag)
 {
 ::std:: reverse(_First, _Mid);
 ::std:: reverse(_Mid, _Last);
 ::std:: reverse(_First, _Last);
 }

template<class _RanIt,
 class _Diff,
 class _Ty> inline
 void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty *)
 {
 _Diff _Shift = _Mid - _First;
 _Diff _Count = _Last - _First;

 for (_Diff _Factor = _Shift; _Factor != 0; )
  {
  _Diff _Tmp = _Count % _Factor;
  _Count = _Factor;
  _Factor = _Tmp;
  }

 if (_Count < _Last - _First)
  for (; 0 < _Count; --_Count)
   {
   _RanIt _Hole = _First + _Count;
   _RanIt _Next = _Hole;
   _RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
   for (; ; )
    {
    iter_swap(_Next, _Next1);
    _Next = _Next1;
    _Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
     : _First + (_Shift - (_Last - _Next1));
    if (_Next1 == _Hole)
     break;
    }
   }
 }

template<class _RanIt> inline
 void _Rotate(_RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag)
 {
 _Rotate(_First, _Mid, _Last, _Dist_type(_First), _Val_type(_First));
 }

template<class _FwdIt> inline
 _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
 {
                           ;
                          ;
 if (_First != _Mid && _Mid != _Last)
  _Rotate(_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last),
   _Iter_cat(_First));
 ::std:: advance(_First, ::std:: distance(_Mid, _Last));
 return (_First);
 }


template<class _Diff, class _Urng>
 class _Rng_from_urng
 {
public:
 typedef typename make_unsigned<_Diff>::type _Ty0;
 typedef typename _Urng::result_type _Ty1;

 typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
  _Ty0, _Ty1>::type _Udiff;


 explicit _Rng_from_urng(_Urng& _Func)
  : _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
  {
  for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
   --_Bits;
  }

 _Diff operator()(_Diff _Index)
  {
  for (; ; )
   {
   _Udiff _Ret = 0;
   _Udiff _Mask = 0;

   while (_Mask < _Udiff(_Index - 1))
    {
    _Ret <<= _Bits - 1;
    _Ret <<= 1;
    _Ret |= _Get_bits();
    _Mask <<= _Bits - 1;
    _Mask <<= 1;
    _Mask |= _Bmask;
    }


   if (_Ret / _Index < _Mask / _Index
    || _Mask % _Index == _Udiff(_Index - 1))
    return (_Ret % _Index);
   }
  }

 _Udiff _Get_all_bits()
  {
  _Udiff _Ret = 0;

  for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
   _Num += _Bits)
   {
   _Ret <<= _Bits - 1;
   _Ret <<= 1;
   _Ret |= _Get_bits();
   }

  return (_Ret);
  }

private:
 _Udiff _Get_bits()
  {
  for (; ; )
   {
   _Udiff _Val = _Ref() - (_Urng::min)();

   if (_Val <= _Bmask)
    return (_Val);
   }
  }

 _Urng& _Ref;
 size_t _Bits;
 _Udiff _Bmask;

public:
 _Rng_from_urng(const _Rng_from_urng&) = delete;
 _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;
 };


template<class _Elem>
 class __declspec(dllimport) _Yarn
 {
public:
 typedef _Yarn<_Elem> _Myt;

                    _Yarn()
  : _Myptr(0), _Nul(0)
  {
  }

                    _Yarn(const _Myt& _Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

                    _Yarn(const _Elem *_Right)
  : _Myptr(0), _Nul(0)
  {
  *this = _Right;
  }

 _Myt& operator=(const _Myt& _Right)
  {
  return (*this = _Right._Myptr);
  }

 _Myt& operator=(const _Elem *_Right)
  {
  if (_Myptr != _Right)
   {
   _Tidy();

   if (_Right != 0)
    {
    const _Elem *_Ptr = _Right;
    while (*_Ptr != (_Elem)0)
     ++_Ptr;
    size_t _Count = ((const char *)++_Ptr - (const char *)_Right);






    _Myptr = (_Elem *):: malloc(_Count);


    if (_Myptr != 0)
     :: memcpy(_Myptr, _Right, _Count);
    }
   }
  return (*this);
  }

                    ~_Yarn() throw ()
  {
  _Tidy();
  }

 bool empty() const
  {
  return (_Myptr == 0);
  }

 const _Elem * c_str() const
  {
  return (_Myptr != 0 ? _Myptr : &_Nul);
  }

 bool _Empty() const
  {
  return (_Myptr == 0);
  }

 const _Elem * _C_str() const
  {
  return (_Myptr != 0 ? _Myptr : &_Nul);
  }

private:
 void _Tidy()
  {
  if (_Myptr != 0)





   :: free(_Myptr);


  _Myptr = 0;
  }

 _Elem *_Myptr;
 _Elem _Nul;
 };


template<class _Ty,
 class _Alloc>
 struct _Has_allocator_type
 {
 template<class _Uty>
  static auto _Fn(int)
   -> is_convertible<_Alloc,
    typename _Uty::allocator_type>;
 template<class _Uty>
  static auto _Fn(_Wrap_int)
   -> false_type;

 typedef decltype(_Fn<_Ty>(0)) type;
 };


struct allocator_arg_t
 {
 };

const allocator_arg_t allocator_arg = allocator_arg_t();

__declspec(dllimport) __declspec(noreturn) void __cdecl _Xbad_alloc();
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xinvalid_argument( const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xlength_error( const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xout_of_range( const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xoverflow_error( const char *);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xruntime_error( const char *);
}

namespace std {

template<class _Ty,
 class _Alloc>
 struct uses_allocator
  : _Has_allocator_type<_Ty, _Alloc>::type
 {
 };
}

#pragma warning(pop)
#pragma pack(pop)
#line 9 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory0"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4100)

namespace std {

template<class _Ty> inline
 _Ty *_Allocate(size_t _Count, _Ty *)
 {
 void *_Ptr = 0;

 if (_Count == 0)
  ;
 else if (((size_t)(-1) / sizeof (_Ty) < _Count)
  || (_Ptr = ::operator new(_Count * sizeof (_Ty))) == 0)
  _Xbad_alloc();

 return ((_Ty *)_Ptr);
 }


template<class _Ty1,
 class _Ty2> inline
 void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
 {
 void *_Vptr = _Ptr;
 ::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
 }

template<class _Ty1> inline
 void _Construct(_Ty1 *_Ptr)
 {
 void *_Vptr = _Ptr;

 ::new (_Vptr) _Ty1();
 }


template<class _Ty> inline
 void _Destroy(_Ty *_Ptr)
 {
 _Ptr->~_Ty();
 }

template<> inline
 void _Destroy(char *)
 {
 }

template<> inline
 void _Destroy(wchar_t *)
 {
 }


template<> inline
 void _Destroy(unsigned short *)
 {
 }



template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al,
  _Nonscalar_ptr_iterator_tag)
 {
 for (; _First != _Last; ++_First)
  _Al.destroy(_First);
 }

template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al,
  _Scalar_ptr_iterator_tag)
 {
 }

template<class _Alloc> inline
 void _Destroy_range(typename _Alloc::pointer _First,
  typename _Alloc::pointer _Last, _Alloc& _Al)
 {
 _Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
 }


template<class _Alty>
 struct _Is_simple_alloc
  : _Cat_base<is_same<typename _Alty::size_type, size_t>::value
  && is_same<typename _Alty::difference_type, ptrdiff_t>::value
  && is_same<typename _Alty::pointer,
   typename _Alty::value_type *>::value
  && is_same<typename _Alty::const_pointer,
   const typename _Alty::value_type *>::value
  && is_same<typename _Alty::reference,
   typename _Alty::value_type&>::value
  && is_same<typename _Alty::const_reference,
   const typename _Alty::value_type&>::value>
 {
 };


template<class _Value_type>
 struct _Simple_types
 {
 typedef _Value_type value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef value_type& reference;
 typedef const value_type& const_reference;
 };


template<class _Alty,
 class _Pointer>
 struct _Get_voidptr
 {
 typedef typename _Alty::template rebind<void>::other _Alvoid;
 typedef typename _Alvoid::pointer type;
 };

template<class _Alty,
 class _Ty>
 struct _Get_voidptr<_Alty, _Ty *>
 {
 typedef void *type;
 };


template<class _Iter>
 struct _Is_iterator
 : public integral_constant<bool, !is_integral<_Iter>::value>
 {
 };


template<class _Ty>
 struct _Get_first_parameter;

template<template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Get_first_parameter<_Ty<_First, _Rest...> >
 {
 typedef _First type;
 };


template<class _Newfirst,
 class _Ty>
 struct _Replace_first_parameter;

template<class _Newfirst,
 template<class, class...> class _Ty,
 class _First,
 class... _Rest>
 struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
 {
 typedef _Ty<_Newfirst, _Rest...> type;
 };


template<class _Ty>
 struct _Get_element_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::element_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_first_parameter<_Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_ptr_difference_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<ptrdiff_t>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty,
 class _Other>
 struct _Get_rebind_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other>::other>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct pointer_traits
 {
 typedef typename _Get_element_type<_Ty>::type element_type;
 typedef _Ty pointer;
 typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;

 template<class _Other>
  using rebind = typename _Get_rebind_type<_Ty, _Other>::type;

 typedef typename _If<is_void<element_type>::value,
  char&,
  typename add_reference<element_type>::type>::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (_Ty::pointer_to(_Val));
  }
 };


template<class _Ty>
 struct pointer_traits<_Ty *>
 {
 typedef _Ty element_type;
 typedef _Ty *pointer;
 typedef ptrdiff_t difference_type;

 template<class _Other>
  using rebind = _Other *;

 typedef typename _If<is_void<_Ty>::value,
  char&,
  typename add_reference<_Ty>::type>::type _Reftype;

 static pointer pointer_to(_Reftype _Val)
  {
  return (::std:: addressof(_Val));
  }
 };


template<class _Ty>
 struct _Get_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Ty::value_type *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_const_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_void_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_const_void_pointer_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void> >; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_difference_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_size_type
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::size_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename make_unsigned< typename _Get_difference_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };




template<class _Ty>
 struct _Get_propagate_on_container_copy
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_copy_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_propagate_on_container_move
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_move_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



template<class _Ty>
 struct _Get_propagate_on_container_swap
 { template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_swap>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };



struct _Alloc_allocate
 {


 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer _Hint)
   -> decltype(_Al.allocate(_Count, _Hint))
  {
  return (_Al.allocate(_Count, _Hint));
  }

 template<class _Alloc,
  class _Size_type,
  class _Const_void_pointer>
  static auto _Fn(_Wrap_int, _Alloc& _Al,
   _Size_type _Count,
   _Const_void_pointer)
   -> decltype(_Al.allocate(_Count))
  {
  return (_Al.allocate(_Count));
  }
 };


struct _Alloc_construct
 {


 template<class _Ty,
  class _Objty,
  class... _Types>
  static auto _Fn(int, _Ty& _Al, _Objty *_Ptr,
   _Types&&... _Args)
   -> decltype(
    _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...))
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }

 template<class _Ty,
  class _Objty,
  class... _Types>
  static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr,
   _Types&&... _Args)
   -> void
  {
  ::new (static_cast<void *>(_Ptr))
   _Objty(::std:: forward<_Types>(_Args)...);
  }

 };


struct _Alloc_destroy
 {
 template<class _Ty,
  class _Objty>
  static auto _Fn(int, _Ty& _Al, _Objty *_Ptr)
   -> decltype(_Al.destroy(_Ptr))
  {
  _Al.destroy(_Ptr);
  }

 template<class _Ty,
  class _Objty>
  static auto _Fn(_Wrap_int, _Ty&, _Objty *_Ptr)
   -> void
  {
  _Ptr->~_Objty();
  }
 };


struct _Alloc_max_size
 {
 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al)
   -> decltype(_Al.max_size())
  {
  return (_Al.max_size());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty&)
   -> typename _Get_size_type<_Ty>::type
  {
  return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)());
  }
 };


struct _Alloc_select
 {


 template<class _Ty>
  static auto _Fn(int, const _Ty& _Al)
   -> decltype((_Ty)_Al.select_on_container_copy_construction())
  {
  return (_Al.select_on_container_copy_construction());
  }

 template<class _Ty>
  static auto _Fn(_Wrap_int, const _Ty& _Al)
   -> _Ty
  {
  return (_Al);
  }
 };


template<class _Alloc>
 struct allocator_traits
 {
 typedef allocator_traits<_Alloc> other;

 typedef _Alloc allocator_type;
 typedef typename _Alloc::value_type value_type;

 typedef typename _Get_pointer_type<_Alloc>::type
  pointer;
 typedef typename _Get_const_pointer_type<_Alloc>::type
  const_pointer;
 typedef typename _Get_void_pointer_type<_Alloc>::type
  void_pointer;
 typedef typename _Get_const_void_pointer_type<_Alloc>::type
  const_void_pointer;

 typedef typename _Get_size_type<_Alloc>::type size_type;
 typedef typename _Get_difference_type<_Alloc>::type difference_type;

 typedef typename _Get_propagate_on_container_copy<_Alloc>::type
  propagate_on_container_copy_assignment;
 typedef typename _Get_propagate_on_container_move<_Alloc>::type
  propagate_on_container_move_assignment;
 typedef typename _Get_propagate_on_container_swap<_Alloc>::type
  propagate_on_container_swap;

 template<class _Other>
  using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

 template<class _Other>
  using rebind_traits = allocator_traits<rebind_alloc<_Other> >;

 static pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Ty,
  class... _Types>
  static void construct(_Alloc& _Al, _Ty *_Ptr,
   _Types&&... _Args)
  {
  _Alloc_construct::_Fn(0, _Al, _Ptr,
   ::std:: forward<_Types>(_Args)...);
  }


 template<class _Ty>
  static void destroy(_Alloc& _Al, _Ty *_Ptr)
  {
  _Alloc_destroy::_Fn(0, _Al, _Ptr);
  }

 static size_type max_size(const _Alloc& _Al)
  {
  return (_Alloc_max_size::_Fn(0, _Al));
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Alloc_select::_Fn(0, _Al));
  }
 };


template<class _Ty>
 struct _Allocator_base
 {
 typedef _Ty value_type;
 };


template<class _Ty>
 struct _Allocator_base<const _Ty>
 {
 typedef _Ty value_type;
 };


template<class _Ty>
 class allocator
  : public _Allocator_base<_Ty>
 {
public:
 typedef allocator<_Ty> other;

 typedef _Allocator_base<_Ty> _Mybase;
 typedef typename _Mybase::value_type value_type;

 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef void *void_pointer;
 typedef const void *const_void_pointer;

 typedef value_type& reference;
 typedef const value_type& const_reference;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef false_type propagate_on_container_copy_assignment;
 typedef false_type propagate_on_container_move_assignment;
 typedef false_type propagate_on_container_swap;

 allocator<_Ty> select_on_container_copy_construction() const
  {
  return (*this);
  }

 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

 pointer address(reference _Val) const throw ()
  {
  return (::std:: addressof(_Val));
  }

 const_pointer address(const_reference _Val) const throw ()
  {
  return (::std:: addressof(_Val));
  }

 allocator() throw ()
  {
  }

 allocator(const allocator<_Ty>&) throw ()
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) throw ()
  {
  }

 template<class _Other>
  allocator<_Ty>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }

 void deallocate(pointer _Ptr, size_type)
  {
  ::operator delete(_Ptr);
  }

 pointer allocate(size_type _Count)
  {
  return (_Allocate(_Count, (pointer)0));
  }

 pointer allocate(size_type _Count, const void *)
  {
  return (allocate(_Count));
  }

 void construct(_Ty *_Ptr)
  {
  ::new ((void *)_Ptr) _Ty();
  }

 void construct(_Ty *_Ptr, const _Ty& _Val)
  {
  ::new ((void *)_Ptr) _Ty(_Val);
  }

 template<class _Objty,
  class... _Types>
  void construct(_Objty *_Ptr, _Types&&... _Args)
  {
  ::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
  }


 template<class _Uty>
  void destroy(_Uty *_Ptr)
  {
  _Ptr->~_Uty();
  }

 size_t max_size() const throw ()
  {
  return ((size_t)(-1) / sizeof (_Ty));
  }
 };


template<>
 class allocator<void>
 {
public:
 typedef allocator<void> other;

 typedef void value_type;

 typedef void *pointer;
 typedef const void *const_pointer;
 typedef void *void_pointer;
 typedef const void *const_void_pointer;

 template<class _Other>
  struct rebind
  {
  typedef allocator<_Other> other;
  };

 allocator() throw ()
  {
  }

 allocator(const allocator<void>&) throw ()
  {
  }

 template<class _Other>
  allocator(const allocator<_Other>&) throw ()
  {
  }

 template<class _Other>
  allocator<void>& operator=(const allocator<_Other>&)
  {
  return (*this);
  }
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const allocator<_Ty>&,
  const allocator<_Other>&) throw ()
 {
 return (true);
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const allocator<_Ty>& _Left,
  const allocator<_Other>& _Right) throw ()
 {
 return (!(_Left == _Right));
 }


template<class _Ty>
 struct allocator_traits<allocator<_Ty> >
 {
 typedef allocator<_Ty> _Alloc;

 typedef allocator_traits<_Alloc> other;

 typedef _Alloc allocator_type;
 typedef typename _Alloc::value_type value_type;

 typedef value_type *pointer;
 typedef const value_type *const_pointer;
 typedef void *void_pointer;
 typedef const void *const_void_pointer;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef false_type propagate_on_container_copy_assignment;
 typedef false_type propagate_on_container_move_assignment;
 typedef false_type propagate_on_container_swap;

 template<class _Other>
  using rebind_alloc = allocator<_Other>;

 template<class _Other>
  using rebind_traits = allocator_traits<allocator<_Other> >;

 static pointer allocate(_Alloc& _Al, size_type _Count)
  {
  return (_Al.allocate(_Count));
  }

 static pointer allocate(_Alloc& _Al, size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Al.allocate(_Count, _Hint));
  }

 static void deallocate(_Alloc& _Al,
  pointer _Ptr, size_type _Count)
  {
  _Al.deallocate(_Ptr, _Count);
  }

 template<class _Objty,
  class... _Types>
  static void construct(_Alloc& _Al, _Objty *_Ptr,
   _Types&&... _Args)
  {
  _Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
  }


 template<class _Uty>
  static void destroy(_Alloc& _Al, _Uty *_Ptr)
  {
  _Al.destroy(_Ptr);
  }

 static size_type max_size(const _Alloc& _Al)
  {
  return (_Al.max_size());
  }

 static _Alloc select_on_container_copy_construction(
  const _Alloc& _Al)
  {
  return (_Al.select_on_container_copy_construction());
  }
 };


template<class _Alloc>
 struct _Wrap_alloc
  : public _Alloc
 {
 typedef _Wrap_alloc<_Alloc> other;

 typedef _Alloc _Mybase;
 typedef allocator_traits<_Alloc> _Mytraits;

 typedef typename _Mytraits::value_type value_type;

 typedef typename _Mytraits::pointer pointer;
 typedef typename _Mytraits::const_pointer const_pointer;
 typedef typename _Mytraits::void_pointer void_pointer;
 typedef typename _Mytraits::const_void_pointer const_void_pointer;

 typedef typename _If<is_void<value_type>::value,
  int, value_type>::type& reference;
 typedef typename _If<is_void<const value_type>::value,
  const int, const value_type>::type& const_reference;

 typedef typename _Mytraits::size_type size_type;
 typedef typename _Mytraits::difference_type difference_type;

 typedef typename _Mytraits::propagate_on_container_copy_assignment
  propagate_on_container_copy_assignment;
 typedef typename _Mytraits::propagate_on_container_move_assignment
  propagate_on_container_move_assignment;
 typedef typename _Mytraits::propagate_on_container_swap
  propagate_on_container_swap;

 _Wrap_alloc select_on_container_copy_construction() const
  {
  return (_Mytraits::select_on_container_copy_construction(*this));
  }

 template<class _Other>
  struct rebind
  {
  typedef typename _Mytraits::template rebind_alloc<_Other> _Other_alloc;
  typedef _Wrap_alloc<_Other_alloc> other;
  };

 pointer address(reference _Val) const
  {
  return (::std:: addressof(_Val));
  }

 const_pointer address(const_reference _Val) const
  {
  return (::std:: addressof(_Val));
  }

 _Wrap_alloc() throw ()
  : _Mybase()
  {
  }

 _Wrap_alloc(const _Mybase& _Right) throw ()
  : _Mybase(_Right)
  {
  }

 _Wrap_alloc(const _Wrap_alloc& _Right) throw ()
  : _Mybase(_Right)
  {
  }

 template<class _Other>
  _Wrap_alloc(const _Other& _Right) throw ()
  : _Mybase(_Right)
  {
  }

 template<class _Other>
  _Wrap_alloc(_Other& _Right) throw ()
  : _Mybase(_Right)
  {
  }

 _Wrap_alloc& operator=(const _Mybase& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 _Wrap_alloc& operator=(const _Wrap_alloc& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 template<class _Other>
  _Wrap_alloc& operator=(const _Other& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 pointer allocate(size_type _Count)
  {
  return (_Mybase::allocate(_Count));
  }

 pointer allocate(size_type _Count,
  const_void_pointer _Hint)
  {
  return (_Mytraits::allocate(*this, _Count, _Hint));
  }

 void deallocate(pointer _Ptr, size_type _Count)
  {
  _Mybase::deallocate(_Ptr, _Count);
  }

 void construct(value_type *_Ptr)
  {
  _Mytraits::construct(*this, _Ptr);
  }

 template<class _Ty,
  class... _Types>
  void construct(_Ty *_Ptr,
   _Types&&... _Args)
  {
  _Mytraits::construct(*this, _Ptr,
   ::std:: forward<_Types>(_Args)...);
  }


 template<class _Ty>
  void destroy(_Ty *_Ptr)
  {
  _Mytraits::destroy(*this, _Ptr);
  }

 size_type max_size() const throw ()
  {
  return (_Mytraits::max_size(*this));
  }
 };

template<class _Ty,
 class _Other> inline
 bool operator==(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) throw ()
 {
 return (static_cast<_Ty>(_Left) == static_cast<_Other>(_Right));
 }

template<class _Ty,
 class _Other> inline
 bool operator!=(const _Wrap_alloc<_Ty>& _Left,
  const _Wrap_alloc<_Other>& _Right) throw ()
 {
 return (!(_Left == _Right));
 }
}





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xatomic0.h"







#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {





typedef enum memory_order {
 memory_order_relaxed,
 memory_order_consume,
 memory_order_acquire,
 memory_order_release,
 memory_order_acq_rel,
 memory_order_seq_cst
 } memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;
#line 70 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xatomic0.h"
typedef long _Atomic_flag_t;






inline _Uint4_t _Atomic_load_4(volatile _Uint4_t *, memory_order);
inline int _Atomic_compare_exchange_weak_4(
 volatile _Uint4_t *, _Uint4_t *, _Uint4_t, memory_order, memory_order);
inline _Uint4_t _Atomic_fetch_add_4(
 volatile _Uint4_t *, _Uint4_t, memory_order);
inline _Uint4_t _Atomic_fetch_sub_4(
 volatile _Uint4_t *, _Uint4_t, memory_order);

typedef _Atomic_integral_t _Atomic_counter_t;


inline _Atomic_integral_t
 _Get_atomic_count(const _Atomic_counter_t& _Counter)
 {
 return (_Counter);
 }

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
 _Atomic_integral_t _Value)
 {
 _Counter = _Value;
 }

inline _Atomic_integral_t _Inc_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_fetch_add_4(&_Counter, 1, _Order) + 1);
 }

inline _Atomic_integral_t _Inc_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Inc_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Dec_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_fetch_sub_4(&_Counter, 1, _Order) - 1);
 }

inline _Atomic_integral_t _Dec_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Dec_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Load_atomic_counter_explicit(
 _Atomic_counter_t& _Counter, memory_order _Order)
 {
 return (_Atomic_load_4(&_Counter, _Order));
 }

inline _Atomic_integral_t _Load_atomic_counter(_Atomic_counter_t& _Counter)
 {
 return (_Load_atomic_counter_explicit(_Counter, memory_order_seq_cst));
 }

inline _Atomic_integral_t _Compare_increment_atomic_counter_explicit(
 _Atomic_counter_t& _Counter,
 _Atomic_integral_t _Expected,
 memory_order _Order)
 {
 return (_Atomic_compare_exchange_weak_4(
  &_Counter, &_Expected, _Expected + 1,
  _Order, _Order));
 }

inline _Atomic_integral_t _Compare_increment_atomic_counter(
 _Atomic_counter_t& _Counter, _Atomic_integral_t _Expected)
 {
 return (_Compare_increment_atomic_counter_explicit(
  _Counter, _Expected, memory_order_seq_cst));
 }
#line 184 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xatomic0.h"
extern "C" {
__declspec(dllimport) void __cdecl _Lock_shared_ptr_spin_lock();
__declspec(dllimport) void __cdecl _Unlock_shared_ptr_spin_lock();
}
}

#pragma warning(pop)
#pragma pack(pop)
#line 908 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory0"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
#line 18 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 18 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\setjmp.h"
#line 21 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\setjmp.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 21 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\setjmp.h"
#line 37 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\setjmp.h"
#pragma pack(push,8)


extern "C" {
#line 63 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\setjmp.h"
typedef struct __JUMP_BUFFER {
    unsigned long Ebp;
    unsigned long Ebx;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Esp;
    unsigned long Eip;
    unsigned long Registration;
    unsigned long TryLevel;
    unsigned long Cookie;
    unsigned long UnwindFunc;
    unsigned long UnwindData[6];
} _JUMP_BUFFER;
#line 167 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\setjmp.h"
typedef int jmp_buf[16];







int __cdecl _setjmp( jmp_buf _Buf);


}



#pragma warning(push)
#pragma warning(disable: 4987)
extern "C"
{
__declspec(dllimport) __declspec(noreturn) void __cdecl longjmp( jmp_buf _Buf, int _Value) throw(...);
}
#pragma warning(pop)




#pragma pack(pop)
#line 19 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"







#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
#line 23 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wmmintrin.h"
#line 26 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wmmintrin.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\nmmintrin.h"
#line 27 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\nmmintrin.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\smmintrin.h"
#line 27 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\smmintrin.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\tmmintrin.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\tmmintrin.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\pmmintrin.h"
#line 31 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\pmmintrin.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\emmintrin.h"
#line 33 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\emmintrin.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
#line 41 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\mmintrin.h"
#line 19 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\mmintrin.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 19 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\mmintrin.h"







extern "C" {




typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64 m64_u64;
    float m64_f32[2];
    __int8 m64_i8[8];
    __int16 m64_i16[4];
    __int32 m64_i32[2];
    __int64 m64_i64;
    unsigned __int8 m64_u8[8];
    unsigned __int16 m64_u16[4];
    unsigned __int32 m64_u32[2];
} __m64;


void _m_empty(void);
__m64 _m_from_int(int _I);
int _m_to_int(__m64 _M);
__m64 _m_packsswb(__m64 _MM1, __m64 _MM2);
__m64 _m_packssdw(__m64 _MM1, __m64 _MM2);
__m64 _m_packuswb(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckldq(__m64 _MM1, __m64 _MM2);


__m64 _m_paddb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddd(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubd(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmaddwd(__m64 _MM1, __m64 _MM2);
__m64 _m_pmulhw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmullw(__m64 _MM1, __m64 _MM2);


__m64 _m_psllw(__m64 _M, __m64 _Count);
__m64 _m_psllwi(__m64 _M, int _Count);
__m64 _m_pslld(__m64 _M, __m64 _Count);
__m64 _m_pslldi(__m64 _M, int _Count);
__m64 _m_psllq(__m64 _M, __m64 _Count);
__m64 _m_psllqi(__m64 _M, int _Count);
__m64 _m_psraw(__m64 _M, __m64 _Count);
__m64 _m_psrawi(__m64 _M, int _Count);
__m64 _m_psrad(__m64 _M, __m64 _Count);
__m64 _m_psradi(__m64 _M, int _Count);
__m64 _m_psrlw(__m64 _M, __m64 _Count);
__m64 _m_psrlwi(__m64 _M, int _Count);
__m64 _m_psrld(__m64 _M, __m64 _Count);
__m64 _m_psrldi(__m64 _M, int _Count);
__m64 _m_psrlq(__m64 _M, __m64 _Count);
__m64 _m_psrlqi(__m64 _M, int _Count);


__m64 _m_pand(__m64 _MM1, __m64 _MM2);
__m64 _m_pandn(__m64 _MM1, __m64 _MM2);
__m64 _m_por(__m64 _MM1, __m64 _MM2);
__m64 _m_pxor(__m64 _MM1, __m64 _MM2);


__m64 _m_pcmpeqb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqd(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtd(__m64 _MM1, __m64 _MM2);


__m64 _mm_setzero_si64(void);
__m64 _mm_set_pi32(int _I1, int _I0);
__m64 _mm_set_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_set_pi8(char _B7, char _B6, char _B5, char _B4,
                  char _B3, char _B2, char _B1, char _B0);
__m64 _mm_set1_pi32(int _I);
__m64 _mm_set1_pi16(short _S);
__m64 _mm_set1_pi8(char _B);
__m64 _mm_setr_pi32(int _I1, int _I0);
__m64 _mm_setr_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_setr_pi8(char _B7, char _B6, char _B5, char _B4,
                   char _B3, char _B2, char _B1, char _B0);
#line 182 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\mmintrin.h"
};
#line 41 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
#line 60 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float m128_f32[4];
     unsigned __int64 m128_u64[2];
     __int8 m128_i8[16];
     __int16 m128_i16[8];
     __int32 m128_i32[4];
     __int64 m128_i64[2];
     unsigned __int8 m128_u8[16];
     unsigned __int16 m128_u16[8];
     unsigned __int32 m128_u32[4];
 } __m128;
#line 178 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
extern "C" {







extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern __m64 _mm_cvt_ps2pi(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m64 _mm_cvtt_ps2pi(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);
extern float _mm_cvtss_f32(__m128 _A);
#line 280 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);





extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);





extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);
extern void _mm_stream_pi(__m64 *, __m64);
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);
#line 378 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
__inline __m128 _mm_cvtpi16_ps(__m64 a)
{
  __m128 tmp;
  __m64 ext_val = _m_pcmpgtw(_mm_setzero_si64(), a);

  tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(a, ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(tmp, tmp),
                        _m_punpcklwd(a, ext_val)));
}
#line 397 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
__inline __m128 _mm_cvtpu16_ps(__m64 a)
{
  __m128 tmp;
  __m64 ext_val = _mm_setzero_si64();

  tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(a, ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(tmp, tmp),
                        _m_punpcklwd(a, ext_val)));
}
#line 416 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
__inline __m64 _mm_cvtps_pi16(__m128 a)
{
  return _m_packssdw(_mm_cvt_ps2pi(a),
                        _mm_cvt_ps2pi(_mm_movehl_ps(a, a)));
}
#line 431 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
__inline __m128 _mm_cvtpi8_ps(__m64 a)
{
  __m64 ext_val = _m_pcmpgtb(_mm_setzero_si64(), a);

  return _mm_cvtpi16_ps(_m_punpcklbw(a, ext_val));
}
#line 448 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
__inline __m128 _mm_cvtpu8_ps(__m64 a)
{
  return _mm_cvtpu16_ps(_m_punpcklbw(a, _mm_setzero_si64()));
}
#line 462 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
__inline __m64 _mm_cvtps_pi8(__m128 a)
{
  return _m_packsswb(_mm_cvtps_pi16(a), _mm_setzero_si64());
}
#line 477 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmmintrin.h"
__inline __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), a),
                       _mm_cvt_pi2ps(_mm_setzero_ps(), b));
}



};
#line 33 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\emmintrin.h"


typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8 m128i_i8[16];
    __int16 m128i_i16[8];
    __int32 m128i_i32[4];
    __int64 m128i_i64[2];
    unsigned __int8 m128i_u8[16];
    unsigned __int16 m128i_u16[8];
    unsigned __int32 m128i_u32[4];
    unsigned __int64 m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double m128d_f64[2];
} __m128d;
#line 60 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\emmintrin.h"
extern "C" {







extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);

extern __m64 _mm_cvtpd_pi32(__m128d _A);
extern __m64 _mm_cvttpd_pi32(__m128d _A);
extern __m128d _mm_cvtpi32_pd(__m64 _A);





extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);





extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_add_si64(__m64 _A, __m64 _B);
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);
extern __m64 _mm_mul_su32(__m64 _A, __m64 _B);
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);
extern __m64 _mm_sub_si64(__m64 _A, __m64 _B);
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);
extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);
extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);





extern __m128i _mm_set_epi64(__m64 _Q1, __m64 _Q0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_set1_epi64(__m64 _Q);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);
extern __m128i _mm_setr_epi64(__m64 _Q0, __m64 _Q1);
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);
extern __m128i _mm_movpi64_epi64(__m64 _Q);
extern __m64 _mm_movepi64_pi64(__m128i _Q);





extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128 _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128 _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);
#line 409 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\emmintrin.h"
};
#line 31 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\pmmintrin.h"
#line 55 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\pmmintrin.h"
extern "C" {







extern __m128 _mm_addsub_ps(__m128 a, __m128 b);
extern __m128 _mm_hadd_ps(__m128 a, __m128 b);
extern __m128 _mm_hsub_ps(__m128 a, __m128 b);
extern __m128 _mm_movehdup_ps(__m128 a);
extern __m128 _mm_moveldup_ps(__m128 a);





extern __m128d _mm_addsub_pd(__m128d a, __m128d b);
extern __m128d _mm_hadd_pd(__m128d a, __m128d b);
extern __m128d _mm_hsub_pd(__m128d a, __m128d b);
extern __m128d _mm_loaddup_pd(double const * dp);
extern __m128d _mm_movedup_pd(__m128d a);




extern __m128i _mm_lddqu_si128(__m128i const *p);







extern void _mm_monitor(void const *p, unsigned extensions, unsigned hints);




extern void _mm_mwait(unsigned extensions, unsigned hints);


};
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\tmmintrin.h"
#line 30 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\tmmintrin.h"
extern "C" {





    extern __m128i _mm_hadd_epi16 (__m128i a, __m128i b);
    extern __m128i _mm_hadd_epi32 (__m128i a, __m128i b);
    extern __m128i _mm_hadds_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_hadd_pi16 (__m64 a, __m64 b);
    extern __m64 _mm_hadd_pi32 (__m64 a, __m64 b);
    extern __m64 _mm_hadds_pi16 (__m64 a, __m64 b);




    extern __m128i _mm_hsub_epi16 (__m128i a, __m128i b);
    extern __m128i _mm_hsub_epi32 (__m128i a, __m128i b);
    extern __m128i _mm_hsubs_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_hsub_pi16 (__m64 a, __m64 b);
    extern __m64 _mm_hsub_pi32 (__m64 a, __m64 b);
    extern __m64 _mm_hsubs_pi16 (__m64 a, __m64 b);




    extern __m128i _mm_maddubs_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_maddubs_pi16 (__m64 a, __m64 b);




    extern __m128i _mm_mulhrs_epi16 (__m128i a, __m128i b);

    extern __m64 _mm_mulhrs_pi16 (__m64 a, __m64 b);




    extern __m128i _mm_shuffle_epi8 (__m128i a, __m128i b);

    extern __m64 _mm_shuffle_pi8 (__m64 a, __m64 b);




    extern __m128i _mm_sign_epi8 (__m128i a, __m128i b);
    extern __m128i _mm_sign_epi16 (__m128i a, __m128i b);
    extern __m128i _mm_sign_epi32 (__m128i a, __m128i b);

    extern __m64 _mm_sign_pi8 (__m64 a, __m64 b);
    extern __m64 _mm_sign_pi16 (__m64 a, __m64 b);
    extern __m64 _mm_sign_pi32 (__m64 a, __m64 b);




    extern __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int n);

    extern __m64 _mm_alignr_pi8 (__m64 a, __m64 b, int n);




    extern __m128i _mm_abs_epi8 (__m128i a);
    extern __m128i _mm_abs_epi16 (__m128i a);
    extern __m128i _mm_abs_epi32 (__m128i a);

    extern __m64 _mm_abs_pi8 (__m64 a);
    extern __m64 _mm_abs_pi16 (__m64 a);
    extern __m64 _mm_abs_pi32 (__m64 a);


};
#line 27 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\smmintrin.h"
#line 78 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\smmintrin.h"
extern "C" {





        extern __m128i _mm_blend_epi16 (__m128i v1, __m128i v2,
                                        const int mask);
        extern __m128i _mm_blendv_epi8 (__m128i v1, __m128i v2, __m128i mask);




        extern __m128 _mm_blend_ps (__m128 v1, __m128 v2, const int mask);
        extern __m128 _mm_blendv_ps(__m128 v1, __m128 v2, __m128 v3);




        extern __m128d _mm_blend_pd (__m128d v1, __m128d v2, const int mask);
        extern __m128d _mm_blendv_pd(__m128d v1, __m128d v2, __m128d v3);




        extern __m128 _mm_dp_ps(__m128 val1, __m128 val2, const int mask);
        extern __m128d _mm_dp_pd(__m128d val1, __m128d val2, const int mask);




        extern __m128i _mm_cmpeq_epi64(__m128i val1, __m128i val2);



        extern __m128i _mm_min_epi8 (__m128i val1, __m128i val2);
        extern __m128i _mm_max_epi8 (__m128i val1, __m128i val2);

        extern __m128i _mm_min_epu16(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epu16(__m128i val1, __m128i val2);

        extern __m128i _mm_min_epi32(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epi32(__m128i val1, __m128i val2);
        extern __m128i _mm_min_epu32(__m128i val1, __m128i val2);
        extern __m128i _mm_max_epu32(__m128i val1, __m128i val2);




        extern __m128i _mm_mullo_epi32(__m128i a, __m128i b);




        extern __m128i _mm_mul_epi32(__m128i a, __m128i b);




        extern int _mm_testz_si128(__m128i mask, __m128i val);




        extern int _mm_testc_si128(__m128i mask, __m128i val);





        extern int _mm_testnzc_si128(__m128i mask, __m128i s2);







        extern __m128 _mm_insert_ps(__m128 dst, __m128 src, const int ndx);
#line 166 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\smmintrin.h"
        extern int _mm_extract_ps(__m128 src, const int ndx);
#line 184 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\smmintrin.h"
        extern __m128i _mm_insert_epi8 (__m128i dst, int s, const int ndx);
        extern __m128i _mm_insert_epi32(__m128i dst, int s, const int ndx);







        extern int _mm_extract_epi8 (__m128i src, const int ndx);
        extern int _mm_extract_epi32(__m128i src, const int ndx);
#line 203 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\smmintrin.h"
        extern __m128i _mm_minpos_epu16(__m128i shortValues);



        extern __m128d _mm_round_pd(__m128d val, int iRoundMode);
        extern __m128d _mm_round_sd(__m128d dst, __m128d val, int iRoundMode);



        extern __m128 _mm_round_ps(__m128 val, int iRoundMode);
        extern __m128 _mm_round_ss(__m128 dst, __m128 val, int iRoundMode);



        extern __m128i _mm_cvtepi8_epi32 (__m128i byteValues);
        extern __m128i _mm_cvtepi16_epi32(__m128i shortValues);
        extern __m128i _mm_cvtepi8_epi64 (__m128i byteValues);
        extern __m128i _mm_cvtepi32_epi64(__m128i intValues);
        extern __m128i _mm_cvtepi16_epi64(__m128i shortValues);
        extern __m128i _mm_cvtepi8_epi16 (__m128i byteValues);



        extern __m128i _mm_cvtepu8_epi32 (__m128i byteValues);
        extern __m128i _mm_cvtepu16_epi32(__m128i shortValues);
        extern __m128i _mm_cvtepu8_epi64 (__m128i shortValues);
        extern __m128i _mm_cvtepu32_epi64(__m128i intValues);
        extern __m128i _mm_cvtepu16_epi64(__m128i shortValues);
        extern __m128i _mm_cvtepu8_epi16 (__m128i byteValues);





        extern __m128i _mm_packus_epi32(__m128i val1, __m128i val2);





        extern __m128i _mm_mpsadbw_epu8(__m128i s1, __m128i s2, const int msk);





        extern __m128i _mm_stream_load_si128(__m128i* v1);


};
#line 27 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\nmmintrin.h"




extern "C" {
#line 78 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\nmmintrin.h"
    extern __m128i _mm_cmpistrm (__m128i a, __m128i b, const int mode);
    extern int _mm_cmpistri (__m128i a, __m128i b, const int mode);

    extern __m128i _mm_cmpestrm (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int _mm_cmpestri (__m128i a, int la, __m128i b, int lb, const int mode);





    extern int _mm_cmpistrz (__m128i a, __m128i b, const int mode);
    extern int _mm_cmpistrc (__m128i a, __m128i b, const int mode);
    extern int _mm_cmpistrs (__m128i a, __m128i b, const int mode);
    extern int _mm_cmpistro (__m128i a, __m128i b, const int mode);
    extern int _mm_cmpistra (__m128i a, __m128i b, const int mode);

    extern int _mm_cmpestrz (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int _mm_cmpestrc (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int _mm_cmpestrs (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int _mm_cmpestro (__m128i a, int la, __m128i b, int lb, const int mode);
    extern int _mm_cmpestra (__m128i a, int la, __m128i b, int lb, const int mode);






    extern __m128i _mm_cmpgt_epi64(__m128i val1, __m128i val2);





    extern int _mm_popcnt_u32(unsigned int v);
#line 121 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\nmmintrin.h"
    extern unsigned int _mm_crc32_u8 (unsigned int crc, unsigned char v);
    extern unsigned int _mm_crc32_u16(unsigned int crc, unsigned short v);
    extern unsigned int _mm_crc32_u32(unsigned int crc, unsigned int v);






};
#line 26 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\wmmintrin.h"




extern "C" {






extern __m128i _mm_aesdec_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesdeclast_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesenc_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesenclast_si128(__m128i v, __m128i rkey);





extern __m128i _mm_aesimc_si128(__m128i v);






extern __m128i _mm_aeskeygenassist_si128(__m128i ckey, const int rcon);







extern __m128i _mm_clmulepi64_si128(__m128i v1, __m128i v2,
                                            const int imm8);





};
#line 23 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"



extern "C" {





typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8 m256i_i8[32];
    __int16 m256i_i16[16];
    __int32 m256i_i32[8];
    __int64 m256i_i64[4];
    unsigned __int8 m256i_u8[32];
    unsigned __int16 m256i_u16[16];
    unsigned __int32 m256i_u32[8];
    unsigned __int64 m256i_u64[4];
} __m256i;
#line 101 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);
#line 111 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_add_ps(__m256, __m256);
#line 124 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);
#line 137 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);
#line 146 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);
#line 155 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_and_ps(__m256, __m256);
#line 164 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);
#line 173 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);
#line 187 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);
#line 201 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);
#line 211 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);
#line 221 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);
#line 230 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);
#line 239 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_div_ps(__m256, __m256);
#line 254 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);
#line 263 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);
#line 272 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);
#line 281 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);
#line 290 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);
#line 299 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);
#line 308 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_max_ps(__m256, __m256);
#line 317 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);
#line 326 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_min_ps(__m256, __m256);
#line 336 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);
#line 346 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);
#line 355 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);
#line 364 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_or_ps(__m256, __m256);
#line 376 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);
#line 389 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);
#line 398 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);
#line 408 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);
#line 417 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);
#line 426 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);
#line 442 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);
#line 459 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);
#line 473 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);
#line 486 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);
#line 495 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);
#line 504 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_cvtepi32_ps(__m256i);
#line 514 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m128 __cdecl _mm256_cvtpd_ps(__m256d);
#line 523 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256i __cdecl _mm256_cvtps_epi32(__m256);
#line 533 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_cvtps_pd(__m128);
#line 546 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);
#line 555 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);
#line 568 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256i __cdecl _mm256_cvttps_epi32(__m256);







extern __m128 __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);
#line 603 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128 __cdecl _mm_permutevar_ps(__m128, __m128i);
#line 614 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_permute_ps(__m256, int);
extern __m128 __cdecl _mm_permute_ps(__m128, int);
#line 625 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);
#line 636 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);
#line 646 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);
#line 657 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_broadcast_ss(float const *);
extern __m128 __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256 __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);
#line 685 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);
#line 696 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_load_pd(double const *);
extern void __cdecl _mm256_store_pd(double *, __m256d);
#line 706 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_load_ps(float const *);
extern void __cdecl _mm256_store_ps(float *, __m256);
#line 716 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void __cdecl _mm256_storeu_pd(double *, __m256d);
#line 726 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_loadu_ps(float const *);
extern void __cdecl _mm256_storeu_ps(float *, __m256);
#line 736 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void __cdecl _mm256_store_si256(__m256i *, __m256i);
#line 746 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void __cdecl _mm256_storeu_si256(__m256i *, __m256i);
#line 819 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);
#line 842 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128 __cdecl _mm_maskload_ps(float const *, __m128i);
extern void __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256 __cdecl _mm256_movehdup_ps(__m256);







extern __m256 __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);
#line 879 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void __cdecl _mm256_stream_si256(__m256i *, __m256i);
#line 896 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern void __cdecl _mm256_stream_pd(double *, __m256d);
#line 905 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern void __cdecl _mm256_stream_ps(float *, __m256);
#line 915 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_rcp_ps(__m256);
#line 926 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_rsqrt_ps(__m256);
#line 935 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_sqrt_pd(__m256d);
#line 944 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_sqrt_ps(__m256);
#line 957 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_round_pd(__m256d, int);
#line 972 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256 __cdecl _mm256_round_ps(__m256, int);
#line 982 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256 __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256 __cdecl _mm256_unpacklo_ps(__m256, __m256);
#line 1016 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern int __cdecl _mm256_testz_si256(__m256i, __m256i);



extern int __cdecl _mm256_testc_si256(__m256i, __m256i);



extern int __cdecl _mm256_testnzc_si256(__m256i, __m256i);
#line 1039 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern int __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int __cdecl _mm_testz_pd(__m128d, __m128d);
extern int __cdecl _mm_testc_pd(__m128d, __m128d);
extern int __cdecl _mm_testnzc_pd(__m128d, __m128d);
#line 1057 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern int __cdecl _mm256_testz_ps(__m256, __m256);
extern int __cdecl _mm256_testc_ps(__m256, __m256);
extern int __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int __cdecl _mm_testz_ps(__m128, __m128);
extern int __cdecl _mm_testc_ps(__m128, __m128);
extern int __cdecl _mm_testnzc_ps(__m128, __m128);
#line 1071 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern int __cdecl _mm256_movemask_pd(__m256d);
#line 1080 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern int __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256 __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256 __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);
#line 1121 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256 __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256 __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256 __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256 __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128 __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256 __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128 __cdecl _mm_cvtph_ps(__m128i);
extern __m256 __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 m1, const int imm);
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);
#line 1202 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern unsigned __int64 __cdecl _xgetbv(unsigned int);


extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);
#line 1222 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern void __cdecl _xsaveopt(void *, unsigned __int64);
#line 1232 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern void __cdecl _xrstor(void const *, unsigned __int64);
#line 1241 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern void __cdecl _fxsave(void *);
#line 1250 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern void __cdecl _fxrstor(void const *);
#line 1261 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);
#line 1288 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern __m128 __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256 __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256 __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256 __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256 __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128 __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128 __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256 __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256 __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);





extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);
extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128 __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256 __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i );

extern void __cdecl _mm_maskstore_epi32(int * ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i ,
                                        __m128i );

extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i );

extern void __cdecl _mm256_maskstore_epi32(int * ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i ,
                                           __m256i );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256 __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d ,
                                                double const * ,
                                                __m128i ,
                                                __m256d ,
                                                const int );
extern __m256 __cdecl _mm256_mask_i32gather_ps(__m256 ,
                                                float const * ,
                                                __m256i ,
                                                __m256 ,
                                                const int );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d ,
                                                double const * ,
                                                __m256i ,
                                                __m256d ,
                                                const int );
extern __m128 __cdecl _mm256_mask_i64gather_ps(__m128 ,
                                                float const * ,
                                                __m256i ,
                                                __m128 ,
                                                const int );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d ,
                                             double const * ,
                                             __m128i ,
                                             __m128d ,
                                             const int );
extern __m128 __cdecl _mm_mask_i32gather_ps(__m128 ,
                                             float const * ,
                                             __m128i ,
                                             __m128 ,
                                             const int );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d ,
                                             double const * ,
                                             __m128i ,
                                             __m128d ,
                                             const int );
extern __m128 __cdecl _mm_mask_i64gather_ps(__m128 ,
                                             float const * ,
                                             __m128i ,
                                             __m128 ,
                                             const int );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i ,
                                                   int const * ,
                                                   __m256i ,
                                                   __m256i ,
                                                   const int );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i ,
                                                   __int64 const * ,
                                                   __m128i ,
                                                   __m256i ,
                                                   const int );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i ,
                                                   int const * ,
                                                   __m256i ,
                                                   __m128i ,
                                                   const int );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i ,
                                                   __int64 const * ,
                                                   __m256i ,
                                                   __m256i ,
                                                   const int );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i ,
                                                int const * ,
                                                __m128i ,
                                                __m128i ,
                                                const int );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i ,
                                                __int64 const * ,
                                                __m128i ,
                                                __m128i ,
                                                const int );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i ,
                                                int const * ,
                                                __m128i ,
                                                __m128i ,
                                                const int );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i ,
                                                __int64 const * ,
                                                __m128i ,
                                                __m128i ,
                                                const int );





extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i ,
                                           const int );
extern __m256 __cdecl _mm256_i32gather_ps(float const * ,
                                           __m256i ,
                                           const int );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i ,
                                           const int );
extern __m128 __cdecl _mm256_i64gather_ps(float const * ,
                                           __m256i ,
                                           const int );

extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i ,
                                        const int );
extern __m128 __cdecl _mm_i32gather_ps(float const * ,
                                        __m128i ,
                                        const int );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i ,
                                        const int );
extern __m128 __cdecl _mm_i64gather_ps(float const * ,
                                        __m128i ,
                                        const int );

extern __m256i __cdecl _mm256_i32gather_epi32(int const * ,
                                              __m256i ,
                                              const int );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i ,
                                              const int );
extern __m128i __cdecl _mm256_i64gather_epi32(int const * ,
                                              __m256i ,
                                              const int );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i ,
                                              const int );

extern __m128i __cdecl _mm_i32gather_epi32(int const * ,
                                           __m128i ,
                                           const int );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i ,
                                           const int );
extern __m128i __cdecl _mm_i64gather_epi32(int const * ,
                                           __m128i ,
                                           const int );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i ,
                                           const int );





extern unsigned int _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int _blsi_u32(unsigned int);
extern unsigned int _blsmsk_u32(unsigned int);
extern unsigned int _blsr_u32(unsigned int);
extern unsigned int _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int _sarx_i32(int ,
                                  unsigned int );
extern unsigned int _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int _shrx_u32(unsigned int ,
                                          unsigned int );
#line 1812 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern unsigned int _lzcnt_u32(unsigned int);
#line 1824 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern unsigned int _tzcnt_u32(unsigned int);
#line 1834 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern void __cdecl _invpcid(unsigned int , void * );


extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);

extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);

extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);

extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);

extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);

extern unsigned char _interlockedbittestandset_HLEAcquire(long *a,long b);
extern unsigned char _interlockedbittestandset_HLERelease(long *a,long b);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *a,long b);
extern unsigned char _interlockedbittestandreset_HLERelease(long *a,long b);
#line 1898 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern unsigned int __cdecl _xbegin(void);
extern void __cdecl _xend(void);
extern void __cdecl _xabort(const unsigned int);
extern unsigned char __cdecl _xtest(void);
#line 1910 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);
extern int __cdecl _rdseed64_step(unsigned __int64 *);
#line 1923 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
extern unsigned char __cdecl _addcarryx_u32(unsigned char ,
                                                   unsigned int ,
                                                   unsigned int ,
                                                   unsigned int * );
#line 1935 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\immintrin.h"
};
#line 26 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ammintrin.h"
#line 23 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ammintrin.h"
extern "C" {
#line 118 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ammintrin.h"
__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);


__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);


__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);


__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);


__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);



__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);



__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);
#line 217 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ammintrin.h"
__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);



__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);


void __llwpcb(void *);
void *__slwpcb();
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);






unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);
#line 269 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ammintrin.h"
unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);
#line 293 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ammintrin.h"
};
#line 27 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"




#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\mm3dnow.h"
#line 21 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\mm3dnow.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 21 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\mm3dnow.h"





extern "C" {




void _m_femms(void);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pf2id(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pmulhrw(__m64, __m64);
void _m_prefetch(void*);
void _m_prefetchw(volatile const void*_Source);

__m64 _m_from_float(float);
float _m_to_float(__m64);



__m64 _m_pf2iw(__m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pswapd(__m64);


};
#line 31 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
#line 43 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
extern "C" {
#line 107 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
void * _AddressOfReturnAddress(void);
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);

unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);
#line 131 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
long _InterlockedAddLargeStatistic(__int64 volatile * _Addend, long _Value);



long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);
#line 146 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
char _InterlockedAnd8(char volatile * _Value, char _Mask);
#line 155 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
long __cdecl _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);



short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);




__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);




char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);



void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);
#line 182 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
long __cdecl _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);
#line 195 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
long __cdecl _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);







char _InterlockedExchange8(char volatile * _Target, char _Value);



long __cdecl _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);







char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);
#line 228 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
__forceinline static void * _Intrin_h_InterlockedExchangePointer(void * volatile * _Target, void * _Value)
{
    return (void *)_InterlockedExchange((long volatile *) _Target, (long) _Value);
}
#line 242 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
long __cdecl _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);
#line 255 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);
#line 266 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
char _InterlockedOr8(char volatile * _Value, char _Mask);
#line 275 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);
#line 286 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
char _InterlockedXor8(char volatile * _Value, char _Mask);
#line 303 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
void _ReadBarrier(void);

void _ReadWriteBarrier(void);
void * _ReturnAddress(void);

void _WriteBarrier(void);

void __addfsbyte(unsigned long, unsigned char);
void __addfsdword(unsigned long, unsigned long);
void __addfsword(unsigned long, unsigned short);




void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);

unsigned int __getcallerseflags(void);
void __halt(void);

unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);
void __incfsbyte(unsigned long);
void __incfsdword(unsigned long);
void __incfsword(unsigned long);




unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);
#line 353 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\intrin.h"
void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);

void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);

void __movsw(unsigned short *, unsigned short const *, size_t);

void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);




unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);

unsigned long __readcr0(void);

unsigned long __readcr2(void);

unsigned long __readcr3(void);

unsigned long __readcr4(void);

unsigned long __readcr8(void);

unsigned int __readdr(unsigned int);

unsigned int __readeflags(void);
unsigned char __readfsbyte(unsigned long);
unsigned long __readfsdword(unsigned long);
unsigned __int64 __readfsqword(unsigned long);
unsigned short __readfsword(unsigned long);




unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);
unsigned long __segmentlimit(unsigned long);



void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);

void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);



void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);

void __vmx_off(void);




void __vmx_vmptrst(unsigned __int64 *);



void __wbinvd(void);



void __writecr0(unsigned int);

void __writecr3(unsigned int);

void __writecr4(unsigned int);

void __writecr8(unsigned int);

void __writedr(unsigned int, unsigned int);

void __writeeflags(unsigned int);
void __writefsbyte(unsigned long, unsigned char);
void __writefsdword(unsigned long, unsigned long);
void __writefsqword(unsigned long, unsigned __int64);
void __writefsword(unsigned long, unsigned short);




void __writemsr(unsigned long, unsigned __int64);

unsigned char _bittest(long const *, long);

unsigned char _bittestandcomplement(long *, long);

unsigned char _bittestandreset(long *, long);

unsigned char _bittestandset(long *, long);

unsigned __int64 __cdecl _byteswap_uint64( unsigned __int64);
unsigned long __cdecl _byteswap_ulong( unsigned long);
unsigned short __cdecl _byteswap_ushort( unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);




unsigned char _interlockedbittestandset(long volatile *, long);






unsigned long __cdecl _lrotl( unsigned long, int);
unsigned long __cdecl _lrotr( unsigned long, int);
void _m_empty(void);
void _m_femms(void);
__m64 _m_from_float(float);
__m64 _m_from_int(int);
void _m_maskmovq(__m64, __m64, char *);
__m64 _m_packssdw(__m64, __m64);
__m64 _m_packsswb(__m64, __m64);
__m64 _m_packuswb(__m64, __m64);
__m64 _m_paddb(__m64, __m64);
__m64 _m_paddd(__m64, __m64);
__m64 _m_paddsb(__m64, __m64);
__m64 _m_paddsw(__m64, __m64);
__m64 _m_paddusb(__m64, __m64);
__m64 _m_paddusw(__m64, __m64);
__m64 _m_paddw(__m64, __m64);
__m64 _m_pand(__m64, __m64);
__m64 _m_pandn(__m64, __m64);
__m64 _m_pavgb(__m64, __m64);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pavgw(__m64, __m64);
__m64 _m_pcmpeqb(__m64, __m64);
__m64 _m_pcmpeqd(__m64, __m64);
__m64 _m_pcmpeqw(__m64, __m64);
__m64 _m_pcmpgtb(__m64, __m64);
__m64 _m_pcmpgtd(__m64, __m64);
__m64 _m_pcmpgtw(__m64, __m64);
int _m_pextrw(__m64, int);
__m64 _m_pf2id(__m64);
__m64 _m_pf2iw(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pinsrw(__m64, int, int);
__m64 _m_pmaddwd(__m64, __m64);
__m64 _m_pmaxsw(__m64, __m64);
__m64 _m_pmaxub(__m64, __m64);
__m64 _m_pminsw(__m64, __m64);
__m64 _m_pminub(__m64, __m64);
int _m_pmovmskb(__m64);
__m64 _m_pmulhrw(__m64, __m64);
__m64 _m_pmulhuw(__m64, __m64);
__m64 _m_pmulhw(__m64, __m64);
__m64 _m_pmullw(__m64, __m64);
__m64 _m_por(__m64, __m64);
void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);
__m64 _m_psadbw(__m64, __m64);
__m64 _m_pshufw(__m64, int);
__m64 _m_pslld(__m64, __m64);
__m64 _m_pslldi(__m64, int);
__m64 _m_psllq(__m64, __m64);
__m64 _m_psllqi(__m64, int);
__m64 _m_psllw(__m64, __m64);
__m64 _m_psllwi(__m64, int);
__m64 _m_psrad(__m64, __m64);
__m64 _m_psradi(__m64, int);
__m64 _m_psraw(__m64, __m64);
__m64 _m_psrawi(__m64, int);
__m64 _m_psrld(__m64, __m64);
__m64 _m_psrldi(__m64, int);
__m64 _m_psrlq(__m64, __m64);
__m64 _m_psrlqi(__m64, int);
__m64 _m_psrlw(__m64, __m64);
__m64 _m_psrlwi(__m64, int);
__m64 _m_psubb(__m64, __m64);
__m64 _m_psubd(__m64, __m64);
__m64 _m_psubsb(__m64, __m64);
__m64 _m_psubsw(__m64, __m64);
__m64 _m_psubusb(__m64, __m64);
__m64 _m_psubusw(__m64, __m64);
__m64 _m_psubw(__m64, __m64);
__m64 _m_pswapd(__m64);
__m64 _m_punpckhbw(__m64, __m64);
__m64 _m_punpckhdq(__m64, __m64);
__m64 _m_punpckhwd(__m64, __m64);
__m64 _m_punpcklbw(__m64, __m64);
__m64 _m_punpckldq(__m64, __m64);
__m64 _m_punpcklwd(__m64, __m64);
__m64 _m_pxor(__m64, __m64);
float _m_to_float(__m64);
int _m_to_int(__m64);
__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);
__m64 _mm_abs_pi16(__m64);
__m64 _mm_abs_pi32(__m64);
__m64 _mm_abs_pi8(__m64);
__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);
__m64 _mm_add_si64(__m64, __m64);
__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);
__m64 _mm_alignr_pi8(__m64, __m64, int);
__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);

unsigned int _mm_crc32_u8(unsigned int, unsigned char);
__m128 _mm_cvt_pi2ps(__m128, __m64);
__m64 _mm_cvt_ps2pi(__m128);
__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);
__m64 _mm_cvtpd_pi32(__m128d);
__m128 _mm_cvtpd_ps(__m128d);
__m128d _mm_cvtpi32_pd(__m64);
__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);


__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);


__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);






__m128d _mm_cvtss_sd(__m128d, __m128);


__m64 _mm_cvtt_ps2pi(__m128);
int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);
__m64 _mm_cvttpd_pi32(__m128d);
__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);




__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);

int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);
__m64 _mm_hadd_pi16(__m64, __m64);
__m64 _mm_hadd_pi32(__m64, __m64);
__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);
__m64 _mm_hadds_pi16(__m64, __m64);
__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);
__m64 _mm_hsub_pi16(__m64, __m64);
__m64 _mm_hsub_pi32(__m64, __m64);
__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);
__m64 _mm_hsubs_pi16(__m64, __m64);
__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);

__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);
__m64 _mm_maddubs_pi16(__m64, __m64);
void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);
__m64 _mm_movepi64_pi64(__m128i);
__m128i _mm_movpi64_epi64(__m64);
__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);
__m64 _mm_mul_su32(__m64, __m64);
__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);
__m64 _mm_mulhrs_pi16(__m64, __m64);
__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
void _mm_pause(void);
int _mm_popcnt_u32(unsigned int);

void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);
__m128i _mm_set1_epi64(__m64);

__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);
__m64 _mm_set1_pi16(short);
__m64 _mm_set1_pi32(int);
__m64 _mm_set1_pi8(char);
__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);
__m128i _mm_set_epi64(__m64, __m64);

__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);
__m64 _mm_set_pi16(short, short, short, short);
__m64 _mm_set_pi32(int, int);
__m64 _mm_set_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);
__m128i _mm_setr_epi64(__m64, __m64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);
__m64 _mm_setr_pi16(short, short, short, short);
__m64 _mm_setr_pi32(int, int);
__m64 _mm_setr_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);
__m64 _mm_setzero_si64(void);
void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);
__m64 _mm_shuffle_pi8(__m64, __m64);
__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);
__m64 _mm_sign_pi16(__m64, __m64);
__m64 _mm_sign_pi32(__m64, __m64);
__m64 _mm_sign_pi8(__m64, __m64);
__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);
__m128i _mm_stream_load_si128(__m128i *);
void _mm_stream_pd(double *, __m128d);
void _mm_stream_pi(__m64 *, __m64);
void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);

void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);
__m64 _mm_sub_si64(__m64, __m64);
__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);

unsigned int __cdecl _rotl( unsigned int _Value, int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64( unsigned __int64 _Value, int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr( unsigned int _Value, int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64( unsigned __int64 _Value, int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
int __cdecl _setjmp(jmp_buf);


void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);




}
#line 909 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory0"
#line 926 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory0"
#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4700)

namespace std {

template<class _Ty> inline
 pair<_Ty *, ptrdiff_t>

  get_temporary_buffer(ptrdiff_t _Count) throw ()

 {
 _Ty *_Pbuf;

 if (_Count < 0)
  _Count = 0;
 else if (((size_t)(-1) / sizeof (_Ty) < _Count))
  _Xbad_alloc();
 for (_Pbuf = 0; 0 < _Count; _Count /= 2)
  if ((_Pbuf = (_Ty *)operator new(
   (size_t)_Count * sizeof (_Ty), nothrow)) != 0)
   break;

 return (pair<_Ty *, ptrdiff_t>(_Pbuf, _Count));
 }


template<class _Ty> inline
 void return_temporary_buffer(_Ty *_Pbuf)
 {
 operator delete(_Pbuf);
 }


template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, input_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 _Construct(&*_Dest, *_First);
 while (0 < --_Count)
  _Construct(&*++_Dest, *++_First);
 } catch (...) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(&*_Next);
 throw;
 }
 return (++_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, forward_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; 0 < _Count; --_Count, ++_Dest, ++_First)
  _Construct(&*_Dest, *_First);
 } catch (...) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(&*_Next);
 throw;
 }
 return (_Dest);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 return (_Uninitialized_copy_n(_First, _Count,
  _Dest, _Iter_cat(_First)));
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest, _Scalar_ptr_iterator_tag)
 {
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy_n(_First, _Count,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _Diff,
 class _FwdIt> inline
 _FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
  _FwdIt _Dest)
 {
 if (_Count <= 0)
  return (_Dest);
 else
  return (_Rechecked(_Dest,
   _Uninitialized_copy_n(_Unchecked(_First), _Count,
    _Unchecked(_Dest))));
 }
#line 251 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory"
template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Nonscalar_ptr_iterator_tag)
 {
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++_Dest, ++_First)
  _Construct(&*_Dest, *_First);
 } catch (...) {
 for (; _Next != _Dest; ++_Next)
  _Destroy(&*_Next);
 throw;
 }
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest, _Scalar_ptr_iterator_tag)
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First));
 return (_Dest + _Count);
 }

template<class _InIt,
 class _FwdIt> inline
 _FwdIt _Uninitialized_copy0(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 return (_Uninitialized_copy0(_First, _Last,
  _Dest, _Ptr_cat(_First, _Dest)));
 }


template<class _InIt,
 class _FwdIt> inline
 _FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
  _FwdIt _Dest)
 {
 return (_Rechecked(_Dest,
  _Uninitialized_copy0(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest))));
 }
#line 366 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xmemory"
template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Nonscalar_ptr_iterator_tag)
 {
                            ;
                      ;
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++_Dest, ++_First)
  _Al.construct(_Dest, *_First);
 } catch (...) {
 for (; _Next != _Dest; ++_Next)
  _Al.destroy(_Next);
 throw;
 }
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Scalar_ptr_iterator_tag)
 {
 return (_Uninit_copy(_First, _Last, _Dest,
  _Al, _Nonscalar_ptr_iterator_tag()));
 }

template<class _Ty1,
 class _Ty2> inline
 _Ty2 *_Uninit_copy(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<allocator<_Ty2> >&, _Scalar_ptr_iterator_tag)
 {
                            ;
                      ;
 size_t _Count = (size_t)(_Last - _First);
 return ((_Ty2 *):: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First)) + _Count);
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Uninit_copy(_First, _Last, _Dest, _Al,
  _Ptr_cat(_First, _Dest)));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Rechecked(_Dest,
  _Uninit_copy(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest), _Al)));
 }


template<class _InIt,
 class _FwdIt,
 class _Alloc,
 class _Valty> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
 {
                            ;
                      ;
 _FwdIt _Next = _Dest;

 try {
 for (; _First != _Last; ++_Dest, ++_First)
  _Al.construct(_Dest, (_Valty&&)*_First);
 } catch (...) {
 for (; _Next != _Dest; ++_Next)
  _Al.destroy(_Next);
 throw;
 }
 return (_Dest);
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc,
 class _Valty> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
 {
 return (_Uninit_move(_First, _Last, _Dest,
  _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag()));
 }

template<class _Ty1,
 class _Ty2,
 class _Valty> inline
 _Ty2 *_Uninit_move(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
  _Wrap_alloc<allocator<_Ty2> >&, _Valty *, _Scalar_ptr_iterator_tag)
 {
                            ;
                      ;
 size_t _Count = (size_t)(_Last - _First);
 return ((_Ty2 *):: memmove(&*_Dest, &*_First,
  _Count * sizeof (*_First)) + _Count);
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninit_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Uninit_move(_First, _Last, _Dest, _Al,
  _Val_type(_First), _Ptr_cat(_First, _Dest)));
 }

template<class _InIt,
 class _FwdIt,
 class _Alloc> inline
 _FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
  _Alloc& _Al)
 {
 return (_Rechecked(_Dest,
  _Uninit_move(_Unchecked(_First), _Unchecked(_Last),
   _Unchecked(_Dest), _Al)));
 }


template<class _FwdIt,
 class _Tval> inline
 void _Uninit_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val,
  _Nonscalar_ptr_iterator_tag)
 {
                            ;
 _FwdIt _Next = _First;

 try {
 for (; _First != _Last; ++_First)
  _Construct(&*_First, _Val);
 } catch (...) {
 for (; _Next != _First; ++_Next)
  _Destroy(&*_Next);
 throw;
 }
 }

template<class _Ty,
 class _Tval> inline
 void _Uninit_fill(_Ty *_First, _Ty *_Last, const _Tval& _Val,
  _Scalar_ptr_iterator_tag)
 {
 ::std:: fill(_First, _Last, _Val);
 }

template<class _FwdIt,
 class _Tval> inline
 void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
 {
 _Uninit_fill(_First, _Last, _Val, _Ptr_cat(_First, _First));
 }


template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt _Uninit_fill_n(_FwdIt _First, _Diff _Count, const _Tval& _Val,
  _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; --_Count, ++_First)
  _Construct(&*_First, _Val);
 } catch (...) {
 for (; _Next != _First; ++_Next)
  _Destroy(&*_Next);
 throw;
 }

 return (_First);
 }

template<class _Ty,
 class _Diff,
 class _Tval> inline
 _Ty *_Uninit_fill_n(_Ty *_First, _Diff _Count, const _Tval& _Val,
  _Scalar_ptr_iterator_tag)
 {
 return (_Fill_n(_First, _Count, _Val));
 }

template<class _FwdIt,
 class _Diff,
 class _Tval> inline
 _FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval& _Val)
 {
 return (_Uninit_fill_n(_First, _Count, _Val, _Ptr_cat(_First, _First)));
 }


template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty> inline
 void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
   _Valty *, _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; --_Count, ++_First)
  _Al.construct(_First, *_Pval);
 } catch (...) {
 for (; _Next != _First; ++_Next)
  _Al.destroy(_Next);
 throw;
 }
 }

template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc,
 class _Valty> inline
 void _Uninit_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<_Alloc>& _Al,
   _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Uninit_fill_n(_First, _Count,
  _Pval, _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
 }

template<class _Ty,
 class _Diff,
 class _Tval,
 class _Valty> inline
 void _Uninit_fill_n(_Ty *_First, _Diff _Count,
  const _Tval *_Pval, _Wrap_alloc<allocator<_Ty> >&,
   _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Fill_n(_First, _Count, *_Pval);
 }

template<class _FwdIt,
 class _Diff,
 class _Tval,
 class _Alloc> inline
 void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
  const _Tval *_Pval, _Alloc& _Al)
 {
 _Uninit_fill_n(_First, _Count, _Pval, _Al,
  _Val_type(_First), _Ptr_cat(_First, _First));
 }


template<class _FwdIt,
 class _Diff,
 class _Alloc,
 class _Valty> inline
 void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Nonscalar_ptr_iterator_tag)
 {





 _FwdIt _Next = _First;

 try {
 for (; 0 < _Count; --_Count, ++_First)

  _Al.construct(_First);

 } catch (...) {
 for (; _Next != _First; ++_Next)
  _Al.destroy(_Next);
 throw;
 }
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc,
 class _Valty> inline
 void _Uninit_def_fill_n(_FwdIt _First, _Diff _Count,
  _Wrap_alloc<_Alloc>& _Al, _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Uninit_def_fill_n(_First, _Count,
  _Al, (_Valty *)0, _Nonscalar_ptr_iterator_tag());
 }

template<class _Ty,
 class _Diff,
 class _Valty> inline
 void _Uninit_def_fill_n(_Ty *_First, _Diff _Count,
  _Wrap_alloc<allocator<_Ty> >&, _Valty *, _Scalar_ptr_iterator_tag)
 {
 _Fill_n(_First, _Count, (_Valty)0);
 }

template<class _FwdIt,
 class _Diff,
 class _Alloc> inline
 void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
  _Alloc& _Al)
 {
 _Uninit_def_fill_n(_First, _Count, _Al,
  _Val_type(_First), _Ptr_cat(_First, _First));
 }


template<class _OutIt,
 class _Ty>
 class raw_storage_iterator
  : public _Outit
 {
public:
 typedef _OutIt iterator_type;
 typedef _OutIt iter_type;
 typedef _Ty element_type;

 explicit raw_storage_iterator(_OutIt _First)
  : _Next(_First)
  {
  }

 raw_storage_iterator<_OutIt, _Ty>& operator*()
  {
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty>& operator=(const _Ty& _Val)
  {
  _Construct(&*_Next, _Val);
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty>& operator++()
  {
  ++_Next;
  return (*this);
  }

 raw_storage_iterator<_OutIt, _Ty> operator++(int)
  {
  raw_storage_iterator<_OutIt, _Ty> _Ans = *this;
  ++_Next;
  return (_Ans);
  }

private:
 _OutIt _Next;
 };


template<class _Ty>
 class _Temp_iterator
  : public _Outit
 {
public:
 typedef _Ty *_Pty;

 _Temp_iterator(ptrdiff_t _Count = 0)
  {
  _Buf._Begin = 0;
  _Buf._Current = 0;
  _Buf._Hiwater = 0;
  _Buf._Size = _Count;
  _Pbuf = &_Buf;
  }

 _Temp_iterator(const _Temp_iterator<_Ty>& _Right)
  {
  _Buf._Begin = 0;
  _Buf._Current = 0;
  _Buf._Hiwater = 0;
  _Buf._Size = 0;
  *this = _Right;
  }

 ~_Temp_iterator() throw ()
  {
  if (_Buf._Begin != 0)
   {
   for (_Pty _Next = _Buf._Begin;
    _Next != _Buf._Hiwater; ++_Next)
    _Destroy(&*_Next);
   ::std:: return_temporary_buffer(_Buf._Begin);
   }
  }

 _Temp_iterator<_Ty>& operator=(const _Temp_iterator<_Ty>& _Right)
  {
  _Pbuf = _Right._Pbuf;
  return (*this);
  }

 _Temp_iterator<_Ty>& operator=(const _Ty& _Val)
  {
  if (_Pbuf->_Current < _Pbuf->_Hiwater)
   *_Pbuf->_Current++ = _Val;
  else
   {
   _Pty _Ptr = &*_Pbuf->_Current;
   _Construct(_Ptr, _Val);
   _Pbuf->_Hiwater = ++_Pbuf->_Current;
   }
  return (*this);
  }

 _Temp_iterator<_Ty>& operator=(_Ty&& _Val)
  {
  if (_Pbuf->_Current < _Pbuf->_Hiwater)
   *_Pbuf->_Current++ =
    ::std:: forward<_Ty>(_Val);
  else
   {
   _Pty _Ptr = &*_Pbuf->_Current;
   _Construct(_Ptr, ::std:: forward<_Ty>(_Val));
   _Pbuf->_Hiwater = ++_Pbuf->_Current;
   }
  return (*this);
  }

 _Temp_iterator<_Ty>& operator*()
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& operator++()
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& operator++(int)
  {
  return (*this);
  }

 _Temp_iterator<_Ty>& _Init()
  {
  _Pbuf->_Current = _Pbuf->_Begin;
  return (*this);
  }

 _Pty _First() const
  {
  return (_Pbuf->_Begin);
  }

 _Pty _Last() const
  {
  return (_Pbuf->_Current);
  }

 ptrdiff_t _Maxlen()
  {
  if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
   {
   pair<_Pty, ptrdiff_t> _Pair =

    ::std:: get_temporary_buffer<_Ty>(_Pbuf->_Size);

   _Pbuf->_Begin = _Pair.first;
   _Pbuf->_Current = _Pair.first;
   _Pbuf->_Hiwater = _Pair.first;
   _Pbuf->_Size = _Pair.second;
   }
  return (_Pbuf->_Size);
  }

private:
 struct _Bufpar
  {
  _Pty _Begin;
  _Pty _Current;
  _Pty _Hiwater;
  ptrdiff_t _Size;
  };
 _Bufpar _Buf;
 _Bufpar *_Pbuf;
 };


template<class _Ty>
 class auto_ptr;

template<class _Ty>
 struct auto_ptr_ref
  {
 explicit auto_ptr_ref(_Ty *_Right)
  : _Ref(_Right)
  {
  }

 _Ty *_Ref;
 };

template<class _Ty>
 class auto_ptr
  {
public:
 typedef auto_ptr<_Ty> _Myt;
 typedef _Ty element_type;

 explicit auto_ptr(_Ty *_Ptr = 0) throw ()
  : _Myptr(_Ptr)
  {
  }

 auto_ptr(_Myt& _Right) throw ()
  : _Myptr(_Right.release())
  {
  }

 auto_ptr(auto_ptr_ref<_Ty> _Right) throw ()
  {
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;
  _Myptr = _Ptr;
  }

 template<class _Other>
  operator auto_ptr<_Other>() throw ()
  {
  return (auto_ptr<_Other>(*this));
  }

 template<class _Other>
  operator auto_ptr_ref<_Other>() throw ()
  {
  _Other *_Cvtptr = _Myptr;
  auto_ptr_ref<_Other> _Ans(_Cvtptr);
  _Myptr = 0;
  return (_Ans);
  }

 template<class _Other>
  _Myt& operator=(auto_ptr<_Other>& _Right) throw ()
  {
  reset(_Right.release());
  return (*this);
  }

 template<class _Other>
  auto_ptr(auto_ptr<_Other>& _Right) throw ()
  : _Myptr(_Right.release())
  {
  }

 _Myt& operator=(_Myt& _Right) throw ()
  {
  reset(_Right.release());
  return (*this);
  }

 _Myt& operator=(auto_ptr_ref<_Ty> _Right) throw ()
  {
  _Ty *_Ptr = _Right._Ref;
  _Right._Ref = 0;
  reset(_Ptr);
  return (*this);
  }

 ~auto_ptr() throw ()
  {
  delete _Myptr;
  }

 _Ty& operator*() const throw ()
  {





  return (*get());
  }

 _Ty *operator->() const throw ()
  {





  return (get());
  }

 _Ty *get() const throw ()
  {
  return (_Myptr);
  }

 _Ty *release() throw ()
  {
  _Ty *_Tmp = _Myptr;
  _Myptr = 0;
  return (_Tmp);
  }

 void reset(_Ty *_Ptr = 0)
  {
  if (_Ptr != _Myptr)
   delete _Myptr;
  _Myptr = _Ptr;
  }

private:
 _Ty *_Myptr;
 };
}


#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"


#pragma pack(push,8)
#pragma warning(push, 3)


#pragma warning(disable: 4244)

namespace std {

const int _ISORT_MAX = 32;


template<class _InIt,
 class _Fn1> inline
 void _For_each(_InIt _First, _InIt _Last, _Fn1& _Func)
 {
 for (; _First != _Last; ++_First)
  _Func(*_First);
 }

template<class _InIt,
 class _Fn1> inline
 _Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
 {
                            ;
                      ;
 _For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

 return (::std:: move(_Func));
 }


template<class _InIt,
 class _Pr> inline
 _InIt _Find_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   break;
 return (_First);
 }

template<class _InIt,
 class _Pr> inline
 _InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Rechecked(_First,
  _Find_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 if (_First != _Last)
  for (_FwdIt _Firstb; (_Firstb = _First), ++_First != _Last; )
   if (_Pred(*_Firstb, *_First))
    return (_Firstb);
 return (_Last);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Rechecked(_First,
  _Adjacent_find(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt> inline
 _FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: adjacent_find(_First, _Last, equal_to<>()));
 }


template<class _InIt,
 class _Pr> inline
 typename iterator_traits<_InIt>::difference_type
  _Count_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
 typename iterator_traits<_InIt>::difference_type _Count = 0;

 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   ++_Count;
 return (_Count);
 }

template<class _InIt,
 class _Pr> inline
 typename iterator_traits<_InIt>::difference_type
  count_if(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Count_if(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 pair<_InIt1, _InIt2>
  _Mismatch(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr _Pred)
 {
 for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
  ++_First1, ++_First2;
 return (pair<_InIt1, _InIt2>(_First1, _First2));
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 pair<_InIt1, _InIt2>
  mismatch(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2, _Pr _Pred)
 {
 pair<typename _Get_unchecked_type<_InIt1>::type, _InIt2> _Ans(
  _Mismatch(_Unchecked(_First1), _Unchecked(_Last1),
   _First2, _Pred));
 return (pair<_InIt1, _InIt2>(
  _Rechecked(_First1, _Ans.first),
  _Ans.second));
 }
#line 203 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt1,
 class _InIt2> inline
 pair<_InIt1, _InIt2>
  mismatch(_InIt1 _First1, _InIt1 _Last1,
   _InIt2 _First2)
 {
 return (::std:: mismatch(_First1, _Last1, _First2,
  equal_to<>()));
 }
#line 227 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt,
 class _Pr> inline
 bool _All_of(_InIt _First, _InIt _Last, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (!_Pred(*_First))
   return (false);
 return (true);
 }

template<class _InIt,
 class _Pr> inline
 bool all_of(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_All_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _InIt,
 class _Pr> inline
 bool _Any_of(_InIt _First, _InIt _Last, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   return (true);
 return (false);
 }

template<class _InIt,
 class _Pr> inline
 bool any_of(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Any_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _InIt,
 class _Pr> inline
 bool _None_of(_InIt _First, _InIt _Last, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   return (false);
 return (true);
 }

template<class _InIt,
 class _Pr> inline
 bool none_of(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_None_of(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _InIt,
 class _Pr> inline
 _InIt _Find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (!_Pred(*_First))
   break;
 return (_First);
 }

template<class _InIt,
 class _Pr> inline
 _InIt find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Rechecked(_First,
  _Find_if_not(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   *_Dest++ = *_First;
 return (_Dest);
 }


template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
  _Pr _Pred)
 {
 return (_Copy_if(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Pred));
 }
#line 382 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt,
 class _OutIt1,
 class _OutIt2,
 class _Pr> inline
 pair<_OutIt1, _OutIt2>
  _Partition_copy(_InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   *_Dest1++ = *_First;
  else
   *_Dest2++ = *_First;
 return (pair<_OutIt1, _OutIt2>( _Dest1, _Dest2));
 }


template<class _InIt,
 class _OutIt1,
 class _OutIt2,
 class _Pr> inline
 pair<_OutIt1, _OutIt2>
  partition_copy(_InIt _First, _InIt _Last,
   _OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
 {
 return (pair<_OutIt1, _OutIt2>(
  _Partition_copy(_Unchecked(_First), _Unchecked(_Last),
   _Dest1, _Dest2, _Pred)));
 }
#line 549 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt,
 class _Pr> inline
 bool _Is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (!_Pred(*_First))
   break;
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   return (false);
 return (true);
 }

template<class _InIt,
 class _Pr> inline
 bool is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Is_partitioned(_Unchecked(_First), _Unchecked(_Last),
  _Pred));
 }


template<class _FwdIt,
 class _Diff,
 class _Pr> inline
 _FwdIt _Partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);
 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return (_First);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Rechecked(_First,
  _Partition_point(_Unchecked(_First), _Unchecked(_Last), _Pred,
   _Dist_type(_First))));
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr> inline
 _FwdIt1 _Search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
 {
 _Diff1 _Count1 = 0;
 _Distance(_First1, _Last1, _Count1);
 _Diff2 _Count2 = 0;
 _Distance(_First2, _Last2, _Count2);

 for (; _Count2 <= _Count1; ++_First1, --_Count1)
  {
  _FwdIt1 _Mid1 = _First1;
  for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, ++_Mid2)
   if (_Mid2 == _Last2)
    return (_First1);
   else if (!_Pred(*_Mid1, *_Mid2))
    break;
  }
 return (_Last1);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                      ;
 return (_Rechecked(_First1,
  _Search(_Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Dist_type(_First1), _Dist_type(_First2))));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: search(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _FwdIt1,
 class _Diff2,
 class _Ty,
 class _Pr> inline
 _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty& _Val, _Pr _Pred, forward_iterator_tag)
 {
 if (_Count <= 0)
  return (_First1);

 for (; _First1 != _Last1; ++_First1)
  if (_Pred(*_First1, _Val))
   {
   _FwdIt1 _Mid1 = _First1;

   for (_Diff2 _Count1 = _Count; ; )
    if (--_Count1 == 0)
     return (_First1);
    else if (++_Mid1 == _Last1)
     return (_Last1);
    else if (!_Pred(*_Mid1, _Val))
     {
     break;
     }

   _First1 = _Mid1;
   }
 return (_Last1);
 }

template<class _FwdIt1,
 class _Diff2,
 class _Ty,
 class _Pr> inline
 _FwdIt1 _Search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty& _Val, _Pr _Pred, random_access_iterator_tag)
 {
 if (_Count <= 0)
  return (_First1);

 _FwdIt1 _Oldfirst1 = _First1;
 for (_Diff2 _Inc = 0; _Count <= _Last1 - _Oldfirst1; )
  {
  _First1 = _Oldfirst1 + _Inc;
  if (_Pred(*_First1, _Val))
   {
   _Diff2 _Count1 = _Count;
   _FwdIt1 _Mid1 = _First1;

   for (; _Oldfirst1 != _First1 && _Pred(_First1[-1], _Val);
    --_First1)
    --_Count1;

   if (_Count1 <= _Last1 - _Mid1)
    for (; ; )
     {
     if (--_Count1 == 0)
      return (_First1);
     else if (!_Pred(*++_Mid1, _Val))
      {
      break;
      }
     }
   _Oldfirst1 = ++_Mid1;
   _Inc = 0;
   }
  else
   {
   _Oldfirst1 = _First1 + 1;
   _Inc = _Count - 1;
   }
  }
 return (_Last1);
 }

template<class _FwdIt1,
 class _Diff2,
 class _Ty,
 class _Pr> inline
 _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty& _Val, _Pr _Pred)
 {
                              ;
                      ;
 return (_Rechecked(_First1,
  _Search_n(_Unchecked(_First1), _Unchecked(_Last1), _Count, _Val,
   _Pred, _Iter_cat(_First1))));
 }


template<class _FwdIt1,
 class _Diff2,
 class _Ty> inline
 _FwdIt1 search_n(_FwdIt1 _First1, _FwdIt1 _Last1,
  _Diff2 _Count, const _Ty& _Val)
 {
 return (::std:: search_n(_First1, _Last1, _Count, _Val,
  equal_to<>()));
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Diff1,
 class _Diff2,
 class _Pr> inline
 _FwdIt1 _Find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, _Diff1 *, _Diff2 *)
 {
 _Diff1 _Count1 = 0;
 _Distance(_First1, _Last1, _Count1);
 _Diff2 _Count2 = 0;
 _Distance(_First2, _Last2, _Count2);
 _FwdIt1 _Ans = _Last1;

 if (0 < _Count2)
  for (; _Count2 <= _Count1; ++_First1, --_Count1)
   {
   _FwdIt1 _Mid1 = _First1;
   for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
    if (!_Pred(*_Mid1, *_Mid2))
     break;
    else if (++_Mid2 == _Last2)
     {
     _Ans = _First1;
     break;
     }
   }
 return (_Ans);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                      ;
 return (_Rechecked(_First1,
  _Find_end(_Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred,
   _Dist_type(_First1), _Dist_type(_First2))));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: find_end(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 _Find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
 for (; _First1 != _Last1; ++_First1)
  for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
   if (_Pred(*_First1, *_Mid2))
    return (_First1);
 return (_First1);
 }

template<class _FwdIt1,
 class _FwdIt2,
 class _Pr> inline
 _FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
 {
                              ;
                              ;
                      ;
 return (_Rechecked(_First1,
  _Find_first_of(_Unchecked(_First1), _Unchecked(_Last1),
   _Unchecked(_First2), _Unchecked(_Last2), _Pred)));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _FwdIt2 _Last2)
 {
 return (::std:: find_first_of(_First1, _Last1, _First2, _Last2,
  equal_to<>()));
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 _Swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest)
 {
 for (; _First1 != _Last1; ++_First1, ++_Dest)
  ::std:: iter_swap(_First1, _Dest);
 return (_Dest);
 }


template<class _FwdIt1,
 class _FwdIt2> inline
 _FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _Dest)
 {
 return (_Swap_ranges(_Unchecked(_First1), _Unchecked(_Last1),
  _Dest));
 }
#line 943 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt,
 class _OutIt,
 class _Fn1> inline
 _OutIt _Transform(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1 _Func)
 {
 for (; _First != _Last; ++_First, ++_Dest)
  *_Dest = _Func(*_First);
 return (_Dest);
 }


template<class _InIt,
 class _OutIt,
 class _Fn1> inline
 _OutIt transform(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Fn1 _Func)
 {
 if (_First != _Last)
  return (_Transform(_Unchecked(_First), _Unchecked(_Last),
   _Dest, _Func));
 return (_Dest);
 }
#line 1046 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2> inline
 _OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
 {
 for (; _First1 != _Last1; ++_First1, ++_First2, ++_Dest)
  *_Dest = _Func(*_First1, *_First2);
 return (_Dest);
 }


template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Fn2> inline
 _OutIt transform(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
 {
 if (_First1 != _Last1)
  return (_Transform(_Unchecked(_First1), _Unchecked(_Last1),
   _First2, _Dest, _Func));
 return (_Dest);
 }
#line 1215 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _FwdIt,
 class _Ty> inline
 void _Replace(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Oldval, const _Ty& _Newval)
 {
 for (; _First != _Last; ++_First)
  if (*_First == _Oldval)
   *_First = _Newval;
 }

template<class _FwdIt,
 class _Ty> inline
 void replace(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Oldval, const _Ty& _Newval)
 {
                            ;
 _Replace(_Unchecked(_First), _Unchecked(_Last),
  _Oldval, _Newval);
 }


template<class _FwdIt,
 class _Pr,
 class _Ty> inline
 void _Replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
 {
 for (; _First != _Last; ++_First)
  if (_Pred(*_First))
   *_First = _Val;
 }

template<class _FwdIt,
 class _Pr,
 class _Ty> inline
 void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
 {
                            ;
                      ;
 _Replace_if(_Unchecked(_First), _Unchecked(_Last),
  _Pred, _Val);
 }


template<class _InIt,
 class _OutIt,
 class _Ty> inline
 _OutIt _Replace_copy(_InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
 {
 for (; _First != _Last; ++_First, ++_Dest)
  *_Dest = *_First == _Oldval ? _Newval : *_First;
 return (_Dest);
 }


template<class _InIt,
 class _OutIt,
 class _Ty> inline
 _OutIt replace_copy(_InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
 {
 return (_Replace_copy(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Oldval, _Newval));
 }
#line 1359 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty> inline
 _OutIt _Replace_copy_if(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred, const _Ty& _Val)
 {
 for (; _First != _Last; ++_First, ++_Dest)
  *_Dest = _Pred(*_First) ? _Val : *_First;
 return (_Dest);
 }


template<class _InIt,
 class _OutIt,
 class _Pr,
 class _Ty> inline
 _OutIt replace_copy_if(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred, const _Ty& _Val)
 {
 return (_Replace_copy_if(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Pred, _Val));
 }
#line 1469 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _FwdIt,
 class _Fn0> inline
 void _Generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
 {
 for (; _First != _Last; ++_First)
  *_First = _Func();
 }

template<class _FwdIt,
 class _Fn0> inline
 void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
 {
                            ;
                      ;
 _Generate(_Unchecked(_First), _Unchecked(_Last), _Func);
 }


template<class _OutIt,
 class _Diff,
 class _Fn0> inline
 _OutIt _Generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
 {
 for (; 0 < _Count; --_Count, ++_Dest)
  *_Dest = _Func();
 return (_Dest);
 }


template<class _OutIt,
 class _Diff,
 class _Fn0> inline
 _OutIt generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
 {
 return (_Generate_n(_Dest, _Count, _Func));
 }
#line 1575 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt,
 class _OutIt,
 class _Ty> inline
 _OutIt _Remove_copy(_InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty& _Val)
 {
 for (; _First != _Last; ++_First)
  if (!(*_First == _Val))
   *_Dest++ = *_First;
 return (_Dest);
 }


template<class _InIt,
 class _OutIt,
 class _Ty> inline
 _OutIt remove_copy(_InIt _First, _InIt _Last,
  _OutIt _Dest, const _Ty& _Val)
 {
 return (_Remove_copy(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Val));
 }
#line 1651 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Remove_copy_if(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred)
 {
 for (; _First != _Last; ++_First)
  if (!_Pred(*_First))
   *_Dest++ = *_First;
 return (_Dest);
 }


template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt remove_copy_if(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred)
 {
 return (_Remove_copy_if(_Unchecked(_First), _Unchecked(_Last),
  _Dest, _Pred));
 }
#line 1728 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _FwdIt,
 class _Ty> inline
 _FwdIt _Remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _FwdIt _Next = _First;
 for (++_First; _First != _Last; ++_First)
  if (!(*_First == _Val))
   *_Next++ = _Move(*_First);
 return (_Next);
 }

template<class _FwdIt,
 class _Ty> inline
 _FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 _First = ::std:: find(_First, _Last, _Val);
 if (_First == _Last)
  return (_First);
 else
  return (_Rechecked(_First,
   _Remove(_Unchecked(_First), _Unchecked(_Last), _Val)));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 _FwdIt _Next = _First;
 for (++_First; _First != _Last; ++_First)
 if (!_Pred(*_First))
  *_Next++ = _Move(*_First);
 return (_Next);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 _First = ::std:: find_if(_First, _Last, _Pred);
 if (_First == _Last)
  return (_First);
 else
  return (_Rechecked(_First,
   _Remove_if(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 if (_First != _Last)
  for (_FwdIt _Firstb; (_Firstb = _First), ++_First != _Last; )
   if (_Pred(*_Firstb, *_First))
    {
    for (; ++_First != _Last; )
     if (!_Pred(*_Firstb, *_First))
      *++_Firstb = _Move(*_First);
    return (++_Firstb);
    }
 return (_Last);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Rechecked(_First,
  _Unique(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt> inline
 _FwdIt unique(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: unique(_First, _Last, equal_to<>()));
 }


template<class _InIt,
 class _OutIt,
 class _Ty,
 class _Pr> inline
 _OutIt _Unique_copy(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred, _Ty *)
 {
 _Ty _Val = *_First;

 for (*_Dest++ = _Val; ++_First != _Last; )
  if (!_Pred(_Val, *_First))
   {
   _Val = *_First;
   *_Dest++ = _Val;
   }
 return (_Dest);
 }

template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Unique_copy(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred, input_iterator_tag)
 {
 return (_Unique_copy(_First, _Last, _Dest, _Pred,
  _Val_type(_First)));
 }

template<class _FwdIt,
 class _OutIt,
 class _Pr> inline
 _OutIt _Unique_copy(_FwdIt _First, _FwdIt _Last,
  _OutIt _Dest, _Pr _Pred, forward_iterator_tag)
 {
 _FwdIt _Firstb = _First;

 for (*_Dest++ = *_Firstb; ++_First != _Last; )
  if (!_Pred(*_Firstb, *_First))
   {
   _Firstb = _First;
   *_Dest++ = *_Firstb;
   }
 return (_Dest);
 }


template<class _InIt,
 class _OutIt,
 class _Pr> inline
 _OutIt unique_copy(_InIt _First, _InIt _Last,
  _OutIt _Dest, _Pr _Pred)
 {
 return (_First == _Last ? _Dest :
  _Unique_copy(_Unchecked(_First), _Unchecked(_Last),
   _Dest, _Pred, _Iter_cat(_First)));
 }
#line 1918 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt,
 class _OutIt> inline
 _OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
 {
 return (::std:: unique_copy(_First, _Last, _Dest,
  equal_to<>()));
 }
#line 1939 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _BidIt,
 class _OutIt> inline
 _OutIt _Reverse_copy(_BidIt _First, _BidIt _Last,
  _OutIt _Dest)
 {
 for (; _First != _Last; ++_Dest)
  *_Dest = *--_Last;
 return (_Dest);
 }


template<class _BidIt,
 class _OutIt> inline
 _OutIt reverse_copy(_BidIt _First, _BidIt _Last,
  _OutIt _Dest)
 {
 return (_Reverse_copy(_Unchecked(_First), _Unchecked(_Last),
  _Dest));
 }
#line 2029 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _FwdIt,
 class _OutIt> inline
 _OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  _OutIt _Dest)
 {
 _Dest = ::std:: copy(_Mid, _Last, _Dest);
 return (::std:: copy(_First, _Mid, _Dest));
 }


template<class _RanIt,
 class _Fn1,
 class _Diff> inline
 void _Random_shuffle(_RanIt _First, _RanIt _Last, _Fn1& _Func, _Diff *)
 {
 _RanIt _Next = _First;
 for (_Diff _Index = 2; ++_Next != _Last; ++_Index)
  {
  _Diff _Off = _Func(_Index);
#line 2060 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
  ::std:: iter_swap(_Next, _First + _Off);
  }
 }

template<class _RanIt,
 class _Fn1> inline
 void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&& _Func)
 {
                            ;
                      ;
 if (_First != _Last)
  _Random_shuffle(_Unchecked(_First), _Unchecked(_Last), _Func,
   _Dist_type(_First));
 }


template<class _RanIt,
 class _Urng> inline
 void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func)
 {
 typedef typename iterator_traits<_RanIt>::difference_type _Diff;
 typedef typename remove_reference<_Urng>::type _Urng0;
 _Rng_from_urng<_Diff, _Urng0> _Rng(_Func);
 ::std:: random_shuffle(_First, _Last, _Rng);
 }


struct _Rand_urng_from_func
 {
 typedef unsigned int result_type;

 static result_type (min)()
  {
  return (0);
  }

 static result_type (max)()
  {
  return (0x7fff);
  }

 result_type operator()()
  {
  return (:: rand());
  }
 };


template<class _RanIt> inline
 void random_shuffle(_RanIt _First, _RanIt _Last)
 {
 _Rand_urng_from_func _Func;
 ::std:: shuffle(_First, _Last, _Func);
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred,
  forward_iterator_tag)
 {
 while (_First != _Last && _Pred(*_First))
  ++_First;

 if (_First == _Last)
  return (_First);

 for (_FwdIt _Next = ::std:: next(_First); _Next != _Last; ++_Next)
  if (_Pred(*_Next))
   ::std:: iter_swap(_First++, _Next);

 return (_First);
 }

template<class _BidIt,
 class _Pr> inline
 _BidIt _Partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
  bidirectional_iterator_tag)
 {
 for (; ; ++_First)
  {
  for (; _First != _Last && _Pred(*_First); ++_First)
   ;
  if (_First == _Last)
   break;

  for (; _First != --_Last && !_Pred(*_Last); )
   ;
  if (_First == _Last)
   break;

  ::std:: iter_swap(_First, _Last);
  }
 return (_First);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Rechecked(_First,
  _Partition(_Unchecked(_First), _Unchecked(_Last), _Pred,
   _Iter_cat(_First))));
 }


template<class _BidIt,
 class _Diff,
 class _Ty> inline
 _BidIt _Buffered_rotate(_BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>& _Tempbuf)
 {
 if (_Count1 == 0 || _Count2 == 0)
  {
  ::std:: advance(_First, _Count2);
  return (_First);
  }
 else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
  {
  _Move(_First, _Mid, _Tempbuf._Init());
  _Move(_Mid, _Last, _First);
  return (_Move_backward(_Tempbuf._First(), _Tempbuf._Last(),
   _Last));
  }
 else if (_Count2 <= _Tempbuf._Maxlen())
  {
  _Move(_Mid, _Last, _Tempbuf._Init());
  _Move_backward(_First, _Mid, _Last);
  return (_Move(_Tempbuf._First(), _Tempbuf._Last(), _First));
  }
 else
  {
  return (::std:: rotate(_First, _Mid, _Last));
  }
 }

template<class _BidIt,
 class _Pr,
 class _Diff,
 class _Ty> inline
 _BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
  _Diff _Count, _Temp_iterator<_Ty>& _Tempbuf)
 {
 if (_Count == 0)
  return (_First);
 else if (_Count == 1)
  return (_Pred(*_First) ? _Last : _First);
 else if (_Count <= _Tempbuf._Maxlen())
  {
  _BidIt _Next = _First;
  for (_Tempbuf._Init(); _First != _Last; ++_First)
   if (_Pred(*_First))
    *_Next++ = _Move(*_First);
   else
    *_Tempbuf++ = _Move(*_First);

  _Move(_Tempbuf._First(), _Tempbuf._Last(), _Next);
  return (_Next);
  }
 else
  {
  _BidIt _Mid = _First;
  ::std:: advance(_Mid, _Count / 2);

  _BidIt _Left = _Stable_partition(_First, _Mid, _Pred,
   _Count / 2, _Tempbuf);
  _BidIt _Right = _Stable_partition(_Mid, _Last, _Pred,
   _Count - _Count / 2, _Tempbuf);

  _Diff _Count1 = 0;
  _Distance(_Left, _Mid, _Count1);
  _Diff _Count2 = 0;
  _Distance(_Mid, _Right, _Count2);

  return (_Buffered_rotate(_Left, _Mid, _Right,
   _Count1, _Count2, _Tempbuf));
  }
 }

template<class _BidIt,
 class _Pr,
 class _Diff,
 class _Ty> inline
 _BidIt _Stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred,
  _Diff *, _Ty *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);
 _Temp_iterator<_Ty> _Tempbuf(_Count);
 return (_Stable_partition(_First, _Last, _Pred, _Count, _Tempbuf));
 }

template<class _BidIt,
 class _Pr> inline
 _BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_First == _Last ? _First
  : _Rechecked(_First,
   _Stable_partition(_Unchecked(_First), _Unchecked(_Last),
    _Pred, _Dist_type(_First), _Val_type(_First))));
 }
#line 2307 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Push_heap(_RanIt _First, _Diff _Hole,
  _Diff _Top, _Ty&& _Val, _Pr _Pred)
 {
 for (_Diff _Idx = (_Hole - 1) / 2;
  _Top < _Hole && _Pred(*(_First + _Idx), _Val);
  _Idx = (_Hole - 1) / 2)
  {
  *(_First + _Hole) = _Move(*(_First + _Idx));
  _Hole = _Idx;
  }

 *(_First + _Hole) = _Move(_Val);
 }

template<class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Push_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
 {
 _Diff _Count = _Last - _First;
 if (0 < _Count)
  {
  _Ty _Val = _Move(*_Last);
  _Push_heap(_First, _Count, _Diff(0), _Move(_Val), _Pred);
  }
 }

template<class _RanIt,
 class _Pr> inline
 void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 if (_First != _Last)
  {
  --_Last;
                                        ;
  _Push_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
   _Dist_type(_First), _Val_type(_First));
  }
 }


template<class _RanIt> inline
 void push_heap(_RanIt _First, _RanIt _Last)
 {
 ::std:: push_heap(_First, _Last, less<>());
 }


template<class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Adjust_heap(_RanIt _First, _Diff _Hole, _Diff _Bottom,
  _Ty&& _Val, _Pr _Pred)
 {
 _Diff _Top = _Hole;
 _Diff _Idx = 2 * _Hole + 2;

 for (; _Idx < _Bottom; _Idx = 2 * _Idx + 2)
  {
  if (_Pred(*(_First + _Idx), *(_First + (_Idx - 1))))
   --_Idx;
  *(_First + _Hole) = _Move(*(_First + _Idx));
  _Hole = _Idx;
  }

 if (_Idx == _Bottom)
  {
  *(_First + _Hole) = _Move(*(_First + (_Bottom - 1)));
  _Hole = _Bottom - 1;
  }
 _Push_heap(_First, _Hole, _Top, _Move(_Val), _Pred);
 }

template<class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Pop_heap(_RanIt _First, _RanIt _Last, _RanIt _Dest,
  _Ty&& _Val, _Pr _Pred, _Diff *)
 {
 *_Dest = _Move(*_First);
 _Adjust_heap(_First, _Diff(0), _Diff(_Last - _First),
  _Move(_Val), _Pred);
 }

template<class _RanIt,
 class _Ty,
 class _Pr> inline
 void _Pop_heap_0(_RanIt _First, _RanIt _Last, _Pr _Pred, _Ty *)
 {
 _Ty _Val = _Move(*(_Last - 1));
 _Pop_heap(_First, _Last - 1, _Last - 1,
  _Move(_Val), _Pred, _Dist_type(_First));
 }

template<class _RanIt,
 class _Pr> inline
 void _Pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
 _Pop_heap_0(_Unchecked(_First), _Unchecked(_Last), _Pred,
  _Val_type(_First));
 }

template<class _RanIt,
 class _Pr> inline
 void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
                      ;
                                       ;
 if (1 < _Last - _First)
  _Pop_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
 }


template<class _RanIt> inline
 void pop_heap(_RanIt _First, _RanIt _Last)
 {
 ::std:: pop_heap(_First, _Last, less<>());
 }


template<class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *, _Ty *)
 {
 _Diff _Bottom = _Last - _First;
 for (_Diff _Hole = _Bottom / 2; 0 < _Hole; )
  {
  --_Hole;
  _Ty _Val = _Move(*(_First + _Hole));
  _Adjust_heap(_First, _Hole, _Bottom,
   _Move(_Val), _Pred);
  }
 }

template<class _RanIt,
 class _Pr> inline
 void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 if (1 < _Last - _First)
  _Make_heap(_Unchecked(_First), _Unchecked(_Last), _Pred,
   _Dist_type(_First), _Val_type(_First));
 }


template<class _RanIt> inline
 void make_heap(_RanIt _First, _RanIt _Last)
 {
 ::std:: make_heap(_First, _Last, less<>());
 }


template<class _RanIt,
 class _Pr> inline
 void _Sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
 for (; 1 < _Last - _First; --_Last)
  _Pop_heap(_First, _Last, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
                      ;
                                       ;
 _Sort_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
 }


template<class _RanIt> inline
 void sort_heap(_RanIt _First, _RanIt _Last)
 {
 ::std:: sort_heap(_First, _Last, less<>());
 }


template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 _FwdIt _Lower_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid, _Val))

   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return (_First);
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {

 return (_Rechecked(_First,
  _Lower_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
   _Dist_type(_First))));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: lower_bound(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 _FwdIt _Upper_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (!_Pred(_Val, *_Mid))

   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else
   _Count = _Count2;
  }
 return (_First);
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {

 return (_Rechecked(_First,
  _Upper_bound(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred,
   _Dist_type(_First))));
 }


template<class _FwdIt,
 class _Ty> inline
 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: upper_bound(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Diff,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  _Equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val, _Pr _Pred, _Diff *)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);

 while (0 < _Count)
  {
  _Diff _Count2 = _Count / 2;
  _FwdIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Pred(*_Mid, _Val))
   {
   _First = ++_Mid;
   _Count -= _Count2 + 1;
   }
  else if (_Pred(_Val, *_Mid))
   _Count = _Count2;
  else
   {
   _FwdIt _First2 = ::std:: lower_bound(_First, _Mid, _Val, _Pred);
   ::std:: advance(_First, _Count);
   _FwdIt _Last2 = ::std:: upper_bound(++_Mid, _First, _Val, _Pred);
   return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
   }
  }

 return (pair<_FwdIt, _FwdIt>(_First, _First));
 }

template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val, _Pr _Pred)
 {
                                        ;
 pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
  _Equal_range(_Unchecked(_First), _Unchecked(_Last),
   _Val, _Pred, _Dist_type(_First)));
 return (pair<_FwdIt, _FwdIt>(
  _Rechecked(_First, _Ans.first),
  _Rechecked(_Last, _Ans.second)));
 }


template<class _FwdIt,
 class _Ty> inline
 pair<_FwdIt, _FwdIt>
  equal_range(_FwdIt _First, _FwdIt _Last,
   const _Ty& _Val)
 {
 return (::std:: equal_range(_First, _Last, _Val, less<>()));
 }


template<class _FwdIt,
 class _Ty,
 class _Pr> inline
 bool binary_search(_FwdIt _First, _FwdIt _Last,
  const _Ty& _Val, _Pr _Pred)
 {
 _First = ::std:: lower_bound(_First, _Last, _Val, _Pred);
 return (_First != _Last && !_Pred(_Val, *_First));
 }


template<class _FwdIt,
 class _Ty> inline
 bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
 {
 return (::std:: binary_search(_First, _Last, _Val, less<>()));
 }


template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Merge0(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred)
 {
 if (_First1 != _Last1 && _First2 != _Last2)
  for (; ; )
   {
   if (_Pred(*_First2, *_First1))
    {
    *_Dest++ = *_First2++;
    if (_First2 == _Last2)
     break;
    }
   else
    {
    *_Dest++ = *_First1++;
    if (_First1 == _Last1)
     break;
    }
   }

 _Dest = _Copy_impl(_First1, _Last1, _Dest);
 return (_Copy_impl(_First2, _Last2, _Dest));
 }


template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt merge(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred)
 {
 return (_Merge0(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2),
  _Dest, _Pred));
 }
#line 2818 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt1,
 class _InIt2,
 class _OutIt> inline
 _OutIt merge(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest)
 {
 return (::std:: merge(_First1, _Last1, _First2, _Last2, _Dest,
  less<>()));
 }
#line 2844 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _BidIt1,
 class _BidIt2,
 class _BidIt3,
 class _Pr> inline
 _BidIt3 _Merge_backward(_BidIt1 _First1, _BidIt1 _Last1,
  _BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr _Pred)
 {
 if (_First1 != _Last1 && _First2 != _Last2)
  for (; ; )
   {
   if (_Pred(*--_Last2, *--_Last1))
    {
    *--_Dest = _Move(*_Last1);
    ++_Last2;
    if (_First1 == _Last1)
     break;
    }
   else
    {
    *--_Dest = _Move(*_Last2);
    ++_Last1;
    if (_First2 == _Last2)
     break;
    }
   }

 _Dest = _Move_backward(_First2, _Last2, _Dest);
 return (_Move_backward(_First1, _Last1, _Dest));
 }

template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Merge(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred)
 {
 if (_First1 != _Last1 && _First2 != _Last2)
  for (; ; )
   {
   if (_Pred(*_First2, *_First1))
    {
    *_Dest++ = _Move(*_First2++);
    if (_First2 == _Last2)
     break;
    }
   else
    {
    *_Dest++ = _Move(*_First1++);
    if (_First1 == _Last1)
     break;
    }
   }

 _Dest = _Move(_First1, _Last1, _Dest);
 return (_Move(_First2, _Last2, _Dest));
 }

template<class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Buffered_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last,
  _Diff _Count1, _Diff _Count2,
   _Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
 {
 if (_Count1 == 0 || _Count2 == 0)
  ;
 else if (_Count1 + _Count2 == 2)
  {
  if (_Pred(*_Mid, *_First))
   ::std:: iter_swap(_First, _Mid);
  }
 else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
  {
  _Move(_First, _Mid, _Tempbuf._Init());
  _Merge(_Tempbuf._First(), _Tempbuf._Last(),
   _Mid, _Last, _First, _Pred);
  }
 else if (_Count2 <= _Tempbuf._Maxlen())
  {
  _Move(_Mid, _Last, _Tempbuf._Init());
  _Merge_backward(_First, _Mid,
   _Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred);
  }
 else
  {
  _BidIt _Firstn, _Lastn;
  _Diff _Count1n, _Count2n;
  if (_Count2 < _Count1)
   {
   _Count1n = _Count1 / 2, _Count2n = 0;
   _Firstn = _First;
   ::std:: advance(_Firstn, _Count1n);
   _Lastn = ::std:: lower_bound(_Mid, _Last, *_Firstn, _Pred);
   _Distance(_Mid, _Lastn, _Count2n);
   }
  else
   {
   _Count1n = 0, _Count2n = _Count2 / 2;
   _Lastn = _Mid;
   ::std:: advance(_Lastn, _Count2n);
   _Firstn = ::std:: upper_bound(_First, _Mid, *_Lastn, _Pred);
   _Distance(_First, _Firstn, _Count1n);
   }
  _BidIt _Midn = _Buffered_rotate(_Firstn, _Mid, _Lastn,
   _Count1 - _Count1n, _Count2n, _Tempbuf);
  _Buffered_merge(_First, _Firstn, _Midn,
   _Count1n, _Count2n, _Tempbuf, _Pred);
  _Buffered_merge(_Midn, _Lastn, _Last,
   _Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
  }
 }

template<class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred,
  _Diff *, _Ty *)
 {
 _Diff _Count1 = 0;
 _Distance(_First, _Mid, _Count1);
 _Diff _Count2 = 0;
 _Distance(_Mid, _Last, _Count2);
 _Temp_iterator<_Ty> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
 _Buffered_merge(_First, _Mid, _Last,
  _Count1, _Count2, _Tempbuf, _Pred);
 }

template<class _BidIt,
 class _Pr> inline
 void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
 {
                                       ;
                                      ;
 if (_First != _Mid && _Mid != _Last)
  _Inplace_merge(
   _Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
   _Dist_type(_First), _Val_type(_First));
 }


template<class _BidIt> inline
 void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
 {
 ::std:: inplace_merge(_First, _Mid, _Last, less<>());
 }


template<class _BidIt,
 class _Pr,
 class _Ty> inline
 void _Insertion_sort1(_BidIt _First, _BidIt _Last, _Pr _Pred, _Ty *)
 {
 if (_First != _Last)
  for (_BidIt _Next = _First; ++_Next != _Last; )
   {
   _BidIt _Next1 = _Next;
   _Ty _Val = _Move(*_Next);

   if (_Pred(_Val, *_First))
    {
    _Move_backward(_First, _Next, ++_Next1);
    *_First = _Move(_Val);
    }
   else
    {
    for (_BidIt _First1 = _Next1;
     _Pred(_Val, *--_First1);
     _Next1 = _First1)
     *_Next1 = _Move(*_First1);
    *_Next1 = _Move(_Val);
    }
   }
 }

template<class _BidIt,
 class _Pr> inline
 void _Insertion_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
 _Insertion_sort1(_First, _Last, _Pred, _Val_type(_First));
 }

template<class _RanIt,
 class _Pr> inline
 void _Med3(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
 {
 if (_Pred(*_Mid, *_First))
  ::std:: iter_swap(_Mid, _First);
 if (_Pred(*_Last, *_Mid))
  {
  ::std:: iter_swap(_Last, _Mid);
  if (_Pred(*_Mid, *_First))
   ::std:: iter_swap(_Mid, _First);
  }
 }

template<class _RanIt,
 class _Pr> inline
 void _Median(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
 {
 if (40 < _Last - _First)
  {
  size_t _Step = (_Last - _First + 1) / 8;
  _Med3(_First, _First + _Step, _First + 2 * _Step, _Pred);
  _Med3(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
  _Med3(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);
  _Med3(_First + _Step, _Mid, _Last - _Step, _Pred);
  }
 else
  _Med3(_First, _Mid, _Last, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 pair<_RanIt, _RanIt>
  _Unguarded_partition(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
 _RanIt _Mid = _First + (_Last - _First) / 2;
 _Median(_First, _Mid, _Last - 1, _Pred);
 _RanIt _Pfirst = _Mid;
 _RanIt _Plast = _Pfirst + 1;

 while (_First < _Pfirst
  && !_Pred(*(_Pfirst - 1), *_Pfirst)
  && !_Pred(*_Pfirst, *(_Pfirst - 1)))
  --_Pfirst;
 while (_Plast < _Last
  && !_Pred(*_Plast, *_Pfirst)
  && !_Pred(*_Pfirst, *_Plast))
  ++_Plast;

 _RanIt _Gfirst = _Plast;
 _RanIt _Glast = _Pfirst;

 for (; ; )
  {
  for (; _Gfirst < _Last; ++_Gfirst)
   if (_Pred(*_Pfirst, *_Gfirst))
    ;
   else if (_Pred(*_Gfirst, *_Pfirst))
    break;
   else if (_Plast++ != _Gfirst)
    ::std:: iter_swap(_Plast - 1, _Gfirst);
  for (; _First < _Glast; --_Glast)
   if (_Pred(*(_Glast - 1), *_Pfirst))
    ;
   else if (_Pred(*_Pfirst, *(_Glast - 1)))
    break;
   else if (--_Pfirst != _Glast - 1)
    ::std:: iter_swap(_Pfirst, _Glast - 1);
  if (_Glast == _First && _Gfirst == _Last)
   return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

  if (_Glast == _First)
   {
   if (_Plast != _Gfirst)
    ::std:: iter_swap(_Pfirst, _Plast);
   ++_Plast;
   ::std:: iter_swap(_Pfirst++, _Gfirst++);
   }
  else if (_Gfirst == _Last)
   {
   if (--_Glast != --_Pfirst)
    ::std:: iter_swap(_Glast, _Pfirst);
   ::std:: iter_swap(_Pfirst, --_Plast);
   }
  else
   ::std:: iter_swap(_Gfirst++, --_Glast);
  }
 }

template<class _RanIt,
 class _Diff,
 class _Pr> inline
 void _Sort(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr _Pred)
 {
 _Diff _Count;
 for (; _ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal; )
  {
  pair<_RanIt, _RanIt> _Mid =
   _Unguarded_partition(_First, _Last, _Pred);
  _Ideal /= 2, _Ideal += _Ideal / 2;

  if (_Mid.first - _First < _Last - _Mid.second)
   {
   _Sort(_First, _Mid.first, _Ideal, _Pred);
   _First = _Mid.second;
   }
  else
   {
   _Sort(_Mid.second, _Last, _Ideal, _Pred);
   _Last = _Mid.first;
   }
  }

 if (_ISORT_MAX < _Count)
  {
  ::std:: make_heap(_First, _Last, _Pred);
  ::std:: sort_heap(_First, _Last, _Pred);
  }
 else if (1 < _Count)
  _Insertion_sort(_First, _Last, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 _Sort(_Unchecked(_First), _Unchecked(_Last), _Last - _First, _Pred);
 }


template<class _RanIt> inline
 void sort(_RanIt _First, _RanIt _Last)
 {
 ::std:: sort(_First, _Last, less<>());
 }


template<class _BidIt,
 class _OutIt,
 class _Diff,
 class _Pr> inline
 void _Chunked_merge(_BidIt _First, _BidIt _Last, _OutIt _Dest,
  _Diff _Chunk, _Diff _Count, _Pr _Pred)
 {
 for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
  {
  _BidIt _Mid1 = _First;
  ::std:: advance(_Mid1, _Chunk);
  _BidIt _Mid2 = _Mid1;
  ::std:: advance(_Mid2, _Chunk);

  _Dest = _Merge(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
  _First = _Mid2;
  }

 if (_Count <= _Chunk)
  _Move(_First, _Last, _Dest);
 else
  {
  _BidIt _Mid1 = _First;
  ::std:: advance(_Mid1, _Chunk);

  _Merge(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
  }
 }

template<class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Buffered_merge_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
 {
 _BidIt _Mid = _First;
 for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
  {
  _BidIt _Midn = _Mid;
  ::std:: advance(_Midn, (int)_ISORT_MAX);

  _Insertion_sort(_Mid, _Midn, _Pred);
  _Mid = _Midn;
  }
 _Insertion_sort(_Mid, _Last, _Pred);

 for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
  {
  _Chunked_merge(_First, _Last, _Tempbuf._Init(),
   _Chunk, _Count, _Pred);
  _Chunked_merge(_Tempbuf._First(), _Tempbuf._Last(), _First,
   _Chunk *= 2, _Count, _Pred);
  }
 }

template<class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff _Count,
  _Temp_iterator<_Ty>& _Tempbuf, _Pr _Pred)
 {
 if (_Count <= _ISORT_MAX)
  _Insertion_sort(_First, _Last, _Pred);
 else
  {
  _Diff _Count2 = (_Count + 1) / 2;
  _BidIt _Mid = _First;
  ::std:: advance(_Mid, _Count2);

  if (_Count2 <= _Tempbuf._Maxlen())
   {
   _Buffered_merge_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
   _Buffered_merge_sort(_Mid, _Last, _Count - _Count2,
    _Tempbuf, _Pred);
   }
  else
   {
   _Stable_sort(_First, _Mid, _Count2, _Tempbuf, _Pred);
   _Stable_sort(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);
   }

  _Buffered_merge(_First, _Mid, _Last,
   _Count2, _Count - _Count2, _Tempbuf, _Pred);
  }
 }

template<class _BidIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 void _Stable_sort(_BidIt _First, _BidIt _Last, _Diff *, _Ty *, _Pr _Pred)
 {
 _Diff _Count = 0;
 _Distance(_First, _Last, _Count);
 _Temp_iterator<_Ty> _Tempbuf((_Count + 1) / 2);
 _Stable_sort(_First, _Last, _Count, _Tempbuf, _Pred);
 }

template<class _BidIt,
 class _Pr> inline
 void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 if (_First != _Last)
  _Stable_sort(_Unchecked(_First), _Unchecked(_Last),
   _Dist_type(_First), _Val_type(_First), _Pred);
 }


template<class _BidIt> inline
 void stable_sort(_BidIt _First, _BidIt _Last)
 {
 ::std:: stable_sort(_First, _Last, less<>());
 }


template<class _RanIt,
 class _Ty,
 class _Pr> inline
 void _Partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last,
  _Pr _Pred, _Ty *)
 {
                           ;
                          ;
                      ;
 ::std:: make_heap(_First, _Mid, _Pred);

 for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
  if (_Pred(*_Next, *_First))
   {
   _Ty _Val = _Move(*_Next);
   _Pop_heap(_First, _Mid, _Next, _Move(_Val), _Pred,
    _Dist_type(_First));
   }
 ::std:: sort_heap(_First, _Mid, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
 {
 _Partial_sort(
  _Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred,
  _Val_type(_First));
 }


template<class _RanIt> inline
 void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
 {
 ::std:: partial_sort(_First, _Mid, _Last, less<>());
 }


template<class _InIt,
 class _RanIt,
 class _Diff,
 class _Ty,
 class _Pr> inline
 _RanIt _Partial_sort_copy(_InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Pr _Pred, _Diff *, _Ty *)
 {
 _RanIt _Mid2 = _First2;
 for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, ++_Mid2)
  *_Mid2 = *_First1;
 ::std:: make_heap(_First2, _Mid2, _Pred);

 for (; _First1 != _Last1; ++_First1)
  if (_Pred(*_First1, *_First2))
   _Adjust_heap(_First2, _Diff(0), _Diff(_Mid2 - _First2),
    _Ty(*_First1), _Pred);

 ::std:: sort_heap(_First2, _Mid2, _Pred);
 return (_Mid2);
 }

template<class _InIt,
 class _RanIt,
 class _Pr> inline
 _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2, _Pr _Pred)
 {
                              ;
                              ;
                      ;
 return (_First1 == _Last1 || _First2 == _Last2 ? _First2
  : _Rechecked(_First2,
   _Partial_sort_copy(
    _Unchecked(_First1), _Unchecked(_Last1),
    _Unchecked(_First2), _Unchecked(_Last2), _Pred,
    _Dist_type(_First2), _Val_type(_First1))));
 }


template<class _InIt,
 class _RanIt> inline
 _RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
  _RanIt _First2, _RanIt _Last2)
 {
 return (::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2,
  less<>()));
 }


template<class _RanIt,
 class _Pr> inline
 void _Nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
 {
 for (; _ISORT_MAX < _Last - _First; )
  {
  pair<_RanIt, _RanIt> _Mid =
   _Unguarded_partition(_First, _Last, _Pred);

  if (_Mid.second <= _Nth)
   _First = _Mid.second;
  else if (_Mid.first <= _Nth)
   return;
  else
   _Last = _Mid.first;
  }

 _Insertion_sort(_First, _Last, _Pred);
 }

template<class _RanIt,
 class _Pr> inline
 void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 _Nth_element(
  _Unchecked(_First), _Unchecked(_Nth), _Unchecked(_Last), _Pred);
 }


template<class _RanIt> inline
 void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
 {
 ::std:: nth_element(_First, _Nth, _Last, less<>());
 }


template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool _Includes(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if (_Pred(*_First2, *_First1))
   return (false);
  else if (_Pred(*_First1, *_First2))
   ++_First1;
  else
   {
   ++_First1;
   ++_First2;
   }
 return (_First2 == _Last2);
 }

template<class _InIt1,
 class _InIt2,
 class _Pr> inline
 bool includes(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
 {
                                          ;
                                          ;
 return (_Includes(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2), _Pred));
 }


template<class _InIt1,
 class _InIt2> inline
 bool includes(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2)
 {
 return (::std:: includes(_First1, _Last1, _First2, _Last2,
  less<>()));
 }


template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_union(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if (_Pred(*_First1, *_First2))
   {
   *_Dest++ = *_First1;
   ++_First1;
   }
  else if (_Pred(*_First2, *_First1))
   {
   *_Dest++ = *_First2;
   ++_First2;
   }
  else
   {
   *_Dest++ = *_First1;
   ++_First1;
   ++_First2;
   }
 _Dest = ::std:: copy(_First1, _Last1, _Dest);
 return (::std:: copy(_First2, _Last2, _Dest));
 }


template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
 {
 return (_Set_union(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2),
  _Dest, _Pred));
 }
#line 3557 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt1,
 class _InIt2,
 class _OutIt> inline
 _OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
 {
 return (::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest,
  less<>()));
 }
#line 3581 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_intersection(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if (_Pred(*_First1, *_First2))
   ++_First1;
  else if (_Pred(*_First2, *_First1))
   ++_First2;
  else
   {
   *_Dest++ = *_First1++;
   ++_First2;
   }
 return (_Dest);
 }


template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
 {
 return (_Set_intersection(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2),
  _Dest, _Pred));
 }
#line 3675 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt1,
 class _InIt2,
 class _OutIt> inline
 _OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
 {
 return (::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest,
  less<>()));
 }
#line 3699 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_difference(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if (_Pred(*_First1, *_First2))
   {
   *_Dest++ = *_First1;
   ++_First1;
   }
  else if (_Pred(*_First2, *_First1))
   ++_First2;
  else
   {
   ++_First1;
   ++_First2;
   }
 return (::std:: copy(_First1, _Last1, _Dest));
 }


template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred)
 {
 return (_Set_difference(_Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2),
  _Dest, _Pred));
 }
#line 3800 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt1,
 class _InIt2,
 class _OutIt> inline
 _OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest)
 {
 return (::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest,
  less<>()));
 }
#line 3826 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt _Set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; )
  if (_Pred(*_First1, *_First2))
   {
   *_Dest++ = *_First1;
   ++_First1;
   }
  else if (_Pred(*_First2, *_First1))
   {
   *_Dest++ = *_First2;
   ++_First2;
   }
  else
   {
   ++_First1;
   ++_First2;
   }
 _Dest = ::std:: copy(_First1, _Last1, _Dest);
 return (::std:: copy(_First2, _Last2, _Dest));
 }


template<class _InIt1,
 class _InIt2,
 class _OutIt,
 class _Pr> inline
 _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest, _Pr _Pred)
 {
 return (_Set_symmetric_difference(
  _Unchecked(_First1), _Unchecked(_Last1),
  _Unchecked(_First2), _Unchecked(_Last2),
  _Dest, _Pred));
 }
#line 3933 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _InIt1,
 class _InIt2,
 class _OutIt> inline
 _OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2,
  _OutIt _Dest)
 {
 return (::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2,
  _Dest, less<>()));
 }
#line 3959 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\algorithm"
template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 _FwdIt _Found = _First;
 if (_First != _Last)
  for (; ++_First != _Last; )
   if (_Pred(*_Found, *_First))
    _Found = _First;
 return (_Found);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Rechecked(_First,
  _Max_element(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt> inline
 _FwdIt max_element(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: max_element(_First, _Last, less<>()));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 _FwdIt _Found = _First;
 if (_First != _Last)
  for (; ++_First != _Last; )
   if (_Pred(*_First, *_Found))
    _Found = _First;
 return (_Found);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Rechecked(_First,
  _Min_element(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }


template<class _FwdIt> inline
 _FwdIt min_element(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: min_element(_First, _Last, less<>()));
 }


template<class _FwdIt,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  _Minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 pair<_FwdIt, _FwdIt> _Found(_First, _First);

 if (_First != _Last)
  for (; ++_First != _Last; )
   {
   _FwdIt _Next = _First;
   if (++_Next == _Last)
    {
    if (_Pred(*_First, *_Found.first))
     _Found.first = _First;
    else if (!_Pred(*_First, *_Found.second))
     _Found.second = _First;
    }
   else
    {
    if (_Pred(*_Next, *_First))
     {
     if (_Pred(*_Next, *_Found.first))
      _Found.first = _Next;
     if (!_Pred(*_First, *_Found.second))
      _Found.second = _First;
     }
    else
     {
     if (_Pred(*_First, *_Found.first))
      _Found.first = _First;
     if (!_Pred(*_Next, *_Found.second))
      _Found.second = _Next;
     }
    _First = _Next;
    }
   }
 return (_Found);
 }

template<class _FwdIt,
 class _Pr> inline
 pair<_FwdIt, _FwdIt>
  minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 pair<typename _Get_unchecked_type<_FwdIt>::type, typename _Get_unchecked_type<_FwdIt>::type> _Ans(
  _Minmax_element(_Unchecked(_First), _Unchecked(_Last), _Pred));
 return (pair<_FwdIt, _FwdIt>(
  _Rechecked(_First, _Ans.first),
  _Rechecked(_Last, _Ans.second)));
 }


template<class _FwdIt> inline
 pair<_FwdIt, _FwdIt>
  minmax_element(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: minmax_element(_First, _Last, less<>()));
 }


template<class _Ty> inline



 const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
 {
 return (((_Left) < (_Right)) ? _Right : _Left);
 }

template<class _Ty> inline
 _Ty (max)(::std:: initializer_list<_Ty> _Ilist)
 {
 const _Ty *_Res = ::std:: max_element(_Ilist.begin(), _Ilist.end());
 return (*_Res);
 }


template<class _Ty,
 class _Pr> inline
 const _Ty& (max)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
 {
 return (_Pred(_Left, _Right) ? _Right : _Left);
 }

template<class _Ty,
 class _Pr> inline
 _Ty (max)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 const _Ty *_Res = ::std:: max_element(_Ilist.begin(), _Ilist.end(), _Pred);
 return (*_Res);
 }


template<class _Ty> inline



 const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
 {
 return (((_Right) < (_Left)) ? _Right : _Left);
 }

template<class _Ty> inline
 _Ty (min)(::std:: initializer_list<_Ty> _Ilist)
 {
 const _Ty *_Res = ::std:: min_element(_Ilist.begin(), _Ilist.end());
 return (*_Res);
 }


template<class _Ty,
 class _Pr> inline
 const _Ty& (min)(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
 {
 return (_Pred(_Right, _Left) ? _Right : _Left);
 }

template<class _Ty,
 class _Pr> inline
 _Ty (min)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 const _Ty *_Res = ::std:: min_element(_Ilist.begin(), _Ilist.end(), _Pred);
 return (*_Res);
 }


template<class _Ty> inline
 pair<const _Ty&, const _Ty&>
  minmax(const _Ty& _Left, const _Ty& _Right)
 {
 return (_Right < _Left
  ? pair<const _Ty&, const _Ty&>(_Right, _Left)
  : pair<const _Ty&, const _Ty&>(_Left, _Right));
 }

template<class _Ty> inline
 pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist)
 {
 pair<const _Ty *, const _Ty *> _Res = ::std:: minmax_element(
  _Ilist.begin(), _Ilist.end());
 return (pair<_Ty, _Ty>(*_Res.first, *_Res.second));
 }


template<class _Ty,
 class _Pr> inline
 pair<const _Ty&, const _Ty&>
  minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
 {
 return (_Pred(_Right, _Left)
  ? pair<const _Ty&, const _Ty&>(_Right, _Left)
  : pair<const _Ty&, const _Ty&>(_Left, _Right));
 }

template<class _Ty,
 class _Pr> inline
 pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
 {
 pair<const _Ty *, const _Ty *> _Res = ::std:: minmax_element(
  _Ilist.begin(), _Ilist.end(), _Pred);
 return (pair<_Ty, _Ty>(*_Res.first, *_Res.second));
 }


template<class _BidIt,
 class _Pr> inline
 bool _Next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
 _BidIt _Next = _Last;
 if (_First == _Last || _First == --_Next)
  return (false);

 for (; ; )
  {
  _BidIt _Next1 = _Next;
  if (_Pred(*--_Next, *_Next1))
   {
   _BidIt _Mid = _Last;
   for (; !_Pred(*_Next, *--_Mid); )
    ;
   ::std:: iter_swap(_Next, _Mid);
   ::std:: reverse(_Next1, _Last);
   return (true);
   }

  if (_Next == _First)
   {
   ::std:: reverse(_First, _Last);
   return (false);
   }
  }
 }

template<class _BidIt,
 class _Pr> inline
 bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Next_permutation(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _BidIt> inline
 bool next_permutation(_BidIt _First, _BidIt _Last)
 {
 return (::std:: next_permutation(_First, _Last, less<>()));
 }


template<class _BidIt,
 class _Pr> inline
 bool _Prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
 _BidIt _Next = _Last;
 if (_First == _Last || _First == --_Next)
  return (false);

 for (; ; )
  {
  _BidIt _Next1 = _Next;
  if (_Pred(*_Next1, *--_Next))
   {
   _BidIt _Mid = _Last;
   for (; !_Pred(*--_Mid, *_Next); )
    ;
   ::std:: iter_swap(_Next, _Mid);
   ::std:: reverse(_Next1, _Last);
   return (true);
   }

  if (_Next == _First)
   {
   ::std:: reverse(_First, _Last);
   return (false);
   }
  }
 }

template<class _BidIt,
 class _Pr> inline
 bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Prev_permutation(_Unchecked(_First), _Unchecked(_Last), _Pred));
 }


template<class _BidIt> inline
 bool prev_permutation(_BidIt _First, _BidIt _Last)
 {
 return (::std:: prev_permutation(_First, _Last, less<>()));
 }


template<class _RanIt,
 class _Diff,
 class _Pr> inline
 _RanIt _Is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred, _Diff *)
 {
 _Diff _Size = _Last - _First;

 if (2 <= _Size)
  for (_Diff _Off = 0; ++_Off < _Size; )
   if (_Pred(*(_First + (_Off - 1) / 2), *(_First + _Off)))

    return (_First + _Off);
 return (_Last);
 }

template<class _RanIt,
 class _Pr>
 _RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Rechecked(_First,
  _Is_heap_until(_Unchecked(_First), _Unchecked(_Last), _Pred,
   _Dist_type(_First))));
 }

template<class _RanIt,
 class _Pr>
 bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
 {
 return (_Is_heap_until(_First, _Last, _Pred, _Dist_type(_First))
  == _Last);
 }


template<class _RanIt>
 _RanIt is_heap_until(_RanIt _First, _RanIt _Last)
 {
 return (::std:: is_heap_until(_First, _Last, less<>()));
 }

template<class _RanIt>
 bool is_heap(_RanIt _First, _RanIt _Last)
 {
 return (::std:: is_heap(_First, _Last, less<>()));
 }


template<class _FwdIt,
 class _Pr> inline
 _FwdIt _Is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 if (_First != _Last)
  for (_FwdIt _Next = _First; ++_Next != _Last; ++_First)
   if (_Pred(*_Next, *_First))
    return (_Next);
 return (_Last);
 }

template<class _FwdIt,
 class _Pr> inline
 _FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
                            ;
                      ;
 return (_Rechecked(_First,
  _Is_sorted_until(_Unchecked(_First), _Unchecked(_Last), _Pred)));
 }

template<class _FwdIt,
 class _Pr> inline
 bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
 {
 return (::std:: is_sorted_until(_First, _Last, _Pred) == _Last);
 }


template<class _FwdIt> inline
 _FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: is_sorted_until(_First, _Last, less<>()));
 }

template<class _FwdIt> inline
 bool is_sorted(_FwdIt _First, _FwdIt _Last)
 {
 return (::std:: is_sorted(_First, _Last, less<>()));
 }
}

#pragma warning(pop)
#pragma pack(pop)
#line 89 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 179 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
typedef signed char qint8;
typedef unsigned char quint8;
typedef short qint16;
typedef unsigned short quint16;
typedef int qint32;
typedef unsigned int quint32;



typedef __int64 qint64;
typedef unsigned __int64 quint64;







typedef qint64 qlonglong;
typedef quint64 qulonglong;
#line 217 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;





typedef double qreal;
#line 357 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
extern "C"

__declspec(dllimport) const char *qVersion() throw();
#line 385 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
namespace QtPrivate {
    template <class T>
    struct AlignOfHelper
    {
        char c;
        T type;

        AlignOfHelper();
        ~AlignOfHelper();
    };

    template <class T>
    struct AlignOf_Default
    {
        enum { Value = sizeof(AlignOfHelper<T>) - sizeof(T) };
    };

    template <class T> struct AlignOf : AlignOf_Default<T> { };
    template <class T> struct AlignOf<T &> : AlignOf<T> {};
    template <size_t N, class T> struct AlignOf<T[N]> : AlignOf<T> {};


    template <class T> struct AlignOf<T &&> : AlignOf<T> {};
#line 425 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
}
#line 441 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
template <int> struct QIntegerForSize;
template <> struct QIntegerForSize<1> { typedef quint8 Unsigned; typedef qint8 Signed; };
template <> struct QIntegerForSize<2> { typedef quint16 Unsigned; typedef qint16 Signed; };
template <> struct QIntegerForSize<4> { typedef quint32 Unsigned; typedef qint32 Signed; };
template <> struct QIntegerForSize<8> { typedef quint64 Unsigned; typedef qint64 Signed; };
template <class T> struct QIntegerForSizeof: QIntegerForSize<sizeof(T)> { };
typedef QIntegerForSize<4>::Signed qregisterint;
typedef QIntegerForSize<4>::Unsigned qregisteruint;
typedef QIntegerForSizeof<void*>::Unsigned quintptr;
typedef QIntegerForSizeof<void*>::Signed qptrdiff;
typedef qptrdiff qintptr;
#line 503 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
typedef int QNoImplicitBoolCast;





template <typename T>
                 inline T qAbs(const T &t) { return t >= 0 ? t : -t; }

                 inline int qRound(double d)
{ return d >= 0.0 ? int(d + 0.5) : int(d - double(int(d-1)) + 0.5) + int(d-1); }
                 inline int qRound(float d)
{ return d >= 0.0f ? int(d + 0.5f) : int(d - float(int(d-1)) + 0.5f) + int(d-1); }







                 inline qint64 qRound64(double d)
{ return d >= 0.0 ? qint64(d + 0.5) : qint64(d - double(qint64(d-1)) + 0.5) + qint64(d-1); }
                 inline qint64 qRound64(float d)
{ return d >= 0.0f ? qint64(d + 0.5f) : qint64(d - float(qint64(d-1)) + 0.5f) + qint64(d-1); }







template <typename T>
                 inline const T &qMin(const T &a, const T &b) { return (a < b) ? a : b; }
template <typename T>
                 inline const T &qMax(const T &a, const T &b) { return (a < b) ? b : a; }
template <typename T>
                 inline const T &qBound(const T &min, const T &val, const T &max)
{ return qMax(min, qMin(max, val)); }
#line 566 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
class QDataStream;
#line 584 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
inline void qt_noop(void) {}
#line 611 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
__declspec(noreturn) __declspec(dllimport) void qTerminate() throw();







__declspec(dllimport) bool qSharedBuild() throw();
#line 652 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
class QString;
__declspec(dllimport) QString qt_error_string(int errorCode = -1);




__declspec(dllimport) void qt_assert(const char *assertion, const char *file, int line) throw();
#line 675 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
__declspec(dllimport) void qt_assert_x(const char *where, const char *what, const char *file, int line) throw();
#line 706 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
__declspec(dllimport) void qt_check_pointer(const char *, int);
__declspec(dllimport) void qBadAlloc();
#line 719 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
template <typename T>
inline T *q_check_ptr(T *p) { do { if (!(p)) qBadAlloc(); } while (0); return p; }

typedef void (*QFunctionPointer)();





                 static inline bool qFuzzyCompare(double p1, double p2) ;
                 static inline bool qFuzzyCompare(double p1, double p2)
{
    return (qAbs(p1 - p2) * 1000000000000. <= qMin(qAbs(p1), qAbs(p2)));
}

                 static inline bool qFuzzyCompare(float p1, float p2) ;
                 static inline bool qFuzzyCompare(float p1, float p2)
{
    return (qAbs(p1 - p2) * 100000.f <= qMin(qAbs(p1), qAbs(p2)));
}




                 static inline bool qFuzzyIsNull(double d) ;
                 static inline bool qFuzzyIsNull(double d)
{
    return qAbs(d) <= 0.000000000001;
}




                 static inline bool qFuzzyIsNull(float f) ;
                 static inline bool qFuzzyIsNull(float f)
{
    return qAbs(f) <= 0.00001f;
}






static inline bool qIsNull(double d) ;
static inline bool qIsNull(double d)
{
    union U {
        double d;
        quint64 u;
    };
    U val;
    val.d = d;
    return (val.u & 0x7fffffffffffffffui64) == 0;
}






static inline bool qIsNull(float f) ;
static inline bool qIsNull(float f)
{
    union U {
        float f;
        quint32 u;
    };
    U val;
    val.f = f;
    return (val.u & 0x7fffffff) == 0;
}
#line 812 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
template <typename T>
inline void qSwap(T &value1, T &value2)
{
    using std::swap;
    swap(value1, value2);
}
#line 826 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
__declspec(dllimport) void *qMallocAligned(size_t size, size_t alignment) ;
__declspec(dllimport) void *qReallocAligned(void *ptr, size_t size, size_t oldsize, size_t alignment) ;
__declspec(dllimport) void qFreeAligned(void *ptr);
#line 841 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#pragma warning(disable: 4251)
#pragma warning(disable: 4244)
#pragma warning(disable: 4275)
#pragma warning(disable: 4514)
#pragma warning(disable: 4800)
#pragma warning(disable: 4097)
#pragma warning(disable: 4706)



#pragma warning(disable: 4355)



#pragma warning(disable: 4710)
#pragma warning(disable: 4530)
#line 887 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
struct QForeachContainerBase {};

template <typename T>
class QForeachContainer : public QForeachContainerBase {
    QForeachContainer &operator=(const QForeachContainer &) = delete;
public:
    inline QForeachContainer(const T& t): c(t), brk(0), i(c.begin()), e(c.end()){}
    QForeachContainer(const QForeachContainer &other)
        : c(other.c), brk(other.brk), i(other.i), e(other.e) {}
    const T c;
    mutable int brk;
    mutable typename T::const_iterator i, e;
    inline bool condition() const { return (!brk++ && i != e); }
};

template <typename T> inline T *qForeachPointer(const T &) { return 0; }

template <typename T> inline QForeachContainer<T> qForeachContainerNew(const T& t)
{ return QForeachContainer<T>(t); }

template <typename T>
inline const QForeachContainer<T> *qForeachContainer(const QForeachContainerBase *base, const T *)
{ return static_cast<const QForeachContainer<T> *>(base); }
#line 944 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
template <typename T> static inline T *qGetPtrHelper(T *ptr) { return ptr; }
template <typename Wrapper> static inline typename Wrapper::pointer qGetPtrHelper(const Wrapper &p) { return p.data(); }
#line 977 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
__declspec(dllimport) QString qtTrId(const char *id, int n = -1);
#line 1007 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
class QByteArray;
__declspec(dllimport) QByteArray qgetenv(const char *varName);
__declspec(dllimport) bool qputenv(const char *varName, const QByteArray& value);
__declspec(dllimport) bool qunsetenv(const char *varName);

__declspec(dllimport) bool qEnvironmentVariableIsEmpty(const char *varName) ;
__declspec(dllimport) bool qEnvironmentVariableIsSet(const char *varName) ;

inline int qIntCast(double f) { return int(f); }
inline int qIntCast(float f) { return int(f); }




__declspec(dllimport) void qsrand(uint seed);
__declspec(dllimport) int qrand();
#line 1038 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
namespace QtPrivate {

template <bool B, typename T = void> struct QEnableIf;
template <typename T> struct QEnableIf<true, T> { typedef T Type; };

template <bool B, typename T, typename F> struct QConditional { typedef T Type; };
template <typename T, typename F> struct QConditional<false, T, F> { typedef F Type; };
}
#line 1065 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 105 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 105 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 114 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
namespace QtPrivate {



typedef char small_;

struct big_ {
  char dummy[2];
};


template <class T>
struct identity_ {
  typedef T type;
};






template<class T, T v>
struct integral_constant {
  static const T value = v;
  typedef T value_type;
  typedef integral_constant<T, v> type;
};

template <class T, T v> const T integral_constant<T, v>::value;





typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;
typedef true_type true_;
typedef false_type false_;




template<bool cond, typename A, typename B>
struct if_{
  typedef A type;
};

template<typename A, typename B>
struct if_<false, A, B> {
  typedef B type;
};







template<typename A, typename B>
struct type_equals_ : public false_ {
};

template<typename A>
struct type_equals_<A, A> : public true_ {
};



template<typename A, typename B>
struct and_ : public integral_constant<bool, (A::value && B::value)> {
};



template<typename A, typename B>
struct or_ : public integral_constant<bool, (A::value || B::value)> {
};

template <class T> struct is_integral;
template <class T> struct is_floating_point;
template <class T> struct is_pointer;





template <class T> struct is_reference;
template <class T> struct is_pod;
template <class T> struct has_trivial_constructor;
template <class T> struct has_trivial_copy;
template <class T> struct has_trivial_assign;
template <class T> struct has_trivial_destructor;
template <class T> struct remove_const;
template <class T> struct remove_volatile;
template <class T> struct remove_cv;
template <class T> struct remove_reference;
template <class T> struct add_reference;
template <class T> struct remove_pointer;
template <class T, class U> struct is_same;






template <class T> struct is_integral : false_type { };
template<> struct is_integral<bool> : true_type { };
template<> struct is_integral<char> : true_type { };
template<> struct is_integral<unsigned char> : true_type { };
template<> struct is_integral<signed char> : true_type { };




template<> struct is_integral<__wchar_t> : true_type { };



template<> struct is_integral<short> : true_type { };
template<> struct is_integral<unsigned short> : true_type { };
template<> struct is_integral<int> : true_type { };
template<> struct is_integral<unsigned int> : true_type { };
template<> struct is_integral<long> : true_type { };
template<> struct is_integral<unsigned long> : true_type { };

template<> struct is_integral<__int64> : true_type { };
template<> struct is_integral<unsigned __int64> : true_type { };




template <class T> struct is_integral<const T> : is_integral<T> { };
template <class T> struct is_integral<volatile T> : is_integral<T> { };
template <class T> struct is_integral<const volatile T> : is_integral<T> { };







template <class T> struct is_floating_point : false_type { };
template<> struct is_floating_point<float> : true_type { };
template<> struct is_floating_point<double> : true_type { };
template<> struct is_floating_point<long double> : true_type { };
template <class T> struct is_floating_point<const T>
    : is_floating_point<T> { };
template <class T> struct is_floating_point<volatile T>
    : is_floating_point<T> { };
template <class T> struct is_floating_point<const volatile T>
    : is_floating_point<T> { };




template <class T> struct is_pointer : false_type { };
template <class T> struct is_pointer<T*> : true_type { };
template <class T> struct is_pointer<const T> : is_pointer<T> { };
template <class T> struct is_pointer<volatile T> : is_pointer<T> { };
template <class T> struct is_pointer<const volatile T> : is_pointer<T> { };
#line 325 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
template<typename T> struct is_reference : false_type {};
template<typename T> struct is_reference<T&> : true_type {};






template <class T> struct is_pod
 : integral_constant<bool, (is_integral<T>::value ||
                            is_floating_point<T>::value ||




                            is_pointer<T>::value)> { };
template <class T> struct is_pod<const T> : is_pod<T> { };
template <class T> struct is_pod<volatile T> : is_pod<T> { };
template <class T> struct is_pod<const volatile T> : is_pod<T> { };







template <class T> struct has_trivial_constructor : is_pod<T> { };
template <class T, class U> struct has_trivial_constructor<std::pair<T, U> >
  : integral_constant<bool,
                      (has_trivial_constructor<T>::value &&
                       has_trivial_constructor<U>::value)> { };
template <class A, int N> struct has_trivial_constructor<A[N]>
  : has_trivial_constructor<A> { };
template <class T> struct has_trivial_constructor<const T>
  : has_trivial_constructor<T> { };






template <class T> struct has_trivial_copy : is_pod<T> { };
template <class T, class U> struct has_trivial_copy<std::pair<T, U> >
  : integral_constant<bool,
                      (has_trivial_copy<T>::value &&
                       has_trivial_copy<U>::value)> { };
template <class A, int N> struct has_trivial_copy<A[N]>
  : has_trivial_copy<A> { };
template <class T> struct has_trivial_copy<const T> : has_trivial_copy<T> { };





template <class T> struct has_trivial_assign : is_pod<T> { };
template <class T, class U> struct has_trivial_assign<std::pair<T, U> >
  : integral_constant<bool,
                      (has_trivial_assign<T>::value &&
                       has_trivial_assign<U>::value)> { };
template <class A, int N> struct has_trivial_assign<A[N]>
  : has_trivial_assign<A> { };






template <class T> struct has_trivial_destructor : is_pod<T> { };
template <class T, class U> struct has_trivial_destructor<std::pair<T, U> >
  : integral_constant<bool,
                      (has_trivial_destructor<T>::value &&
                       has_trivial_destructor<U>::value)> { };
template <class A, int N> struct has_trivial_destructor<A[N]>
  : has_trivial_destructor<A> { };
template <class T> struct has_trivial_destructor<const T>
  : has_trivial_destructor<T> { };


template<typename T> struct remove_const { typedef T type; };
template<typename T> struct remove_const<T const> { typedef T type; };
template<typename T> struct remove_volatile { typedef T type; };
template<typename T> struct remove_volatile<T volatile> { typedef T type; };
template<typename T> struct remove_cv {
  typedef typename remove_const<typename remove_volatile<T>::type>::type type;
};



template<typename T> struct remove_reference { typedef T type; };
template<typename T> struct remove_reference<T&> { typedef T type; };

template <typename T> struct add_reference { typedef T& type; };
template <typename T> struct add_reference<T&> { typedef T& type; };


template<typename T> struct remove_pointer { typedef T type; };
template<typename T> struct remove_pointer<T*> { typedef T type; };
template<typename T> struct remove_pointer<T* const> { typedef T type; };
template<typename T> struct remove_pointer<T* volatile> { typedef T type; };
template<typename T> struct remove_pointer<T* const volatile> {
  typedef T type; };


template<typename T, typename U> struct is_same : public false_type { };
template<typename T> struct is_same<T, T> : public true_type { };
#line 465 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
template <typename T>
struct not_
    : integral_constant<bool, !T::value> {};


template <bool B>
struct not_c
    : integral_constant<bool, !B> {};


template <typename T>
struct is_unsigned
    : integral_constant<bool, (T(0) < T(-1))> {};


template <typename T>
struct is_signed
    : not_< is_unsigned<T> > {};

static_assert(bool(( is_unsigned<quint8>::value)), "( is_unsigned<quint8>::value)");
static_assert(bool((!is_unsigned<qint8>::value)), "(!is_unsigned<qint8>::value)");

static_assert(bool((!is_signed<quint8>::value)), "(!is_signed<quint8>::value)");
static_assert(bool(( is_signed<qint8>::value)), "( is_signed<qint8>::value)");

static_assert(bool(( is_unsigned<quint16>::value)), "( is_unsigned<quint16>::value)");
static_assert(bool((!is_unsigned<qint16>::value)), "(!is_unsigned<qint16>::value)");

static_assert(bool((!is_signed<quint16>::value)), "(!is_signed<quint16>::value)");
static_assert(bool(( is_signed<qint16>::value)), "( is_signed<qint16>::value)");

static_assert(bool(( is_unsigned<quint32>::value)), "( is_unsigned<quint32>::value)");
static_assert(bool((!is_unsigned<qint32>::value)), "(!is_unsigned<qint32>::value)");

static_assert(bool((!is_signed<quint32>::value)), "(!is_signed<quint32>::value)");
static_assert(bool(( is_signed<qint32>::value)), "( is_signed<qint32>::value)");

static_assert(bool(( is_unsigned<quint64>::value)), "( is_unsigned<quint64>::value)");
static_assert(bool((!is_unsigned<qint64>::value)), "(!is_unsigned<qint64>::value)");

static_assert(bool((!is_signed<quint64>::value)), "(!is_signed<quint64>::value)");
static_assert(bool(( is_signed<qint64>::value)), "( is_signed<qint64>::value)");

}
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 57 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
template <typename T>
class QTypeInfo
{
public:
    enum {
        isPointer = false,
        isIntegral = QtPrivate::is_integral<T>::value,
        isComplex = true,
        isStatic = true,
        isLarge = (sizeof(T)>sizeof(void*)),
        isDummy = false,
        sizeOf = sizeof(T)
    };
};

template<>
class QTypeInfo<void>
{
public:
    enum {
        isPointer = false,
        isIntegral = false,
        isComplex = false,
        isStatic = false,
        isLarge = false,
        isDummy = false,
        sizeOf = 0
    };
};

template <typename T>
class QTypeInfo<T*>
{
public:
    enum {
        isPointer = true,
        isIntegral = false,
        isComplex = false,
        isStatic = false,
        isLarge = false,
        isDummy = false,
        sizeOf = sizeof(T*)
    };
};
#line 122 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
template <class T, class T1, class T2 = T1, class T3 = T1, class T4 = T1>
class QTypeInfoMerger
{
public:
    enum {
        isComplex = QTypeInfo<T1>::isComplex || QTypeInfo<T2>::isComplex || QTypeInfo<T3>::isComplex || QTypeInfo<T4>::isComplex,
        isStatic = QTypeInfo<T1>::isStatic || QTypeInfo<T2>::isStatic || QTypeInfo<T3>::isStatic || QTypeInfo<T4>::isStatic,
        isLarge = sizeof(T) > sizeof(void*),
        isPointer = false,
        isIntegral = false,
        isDummy = false,
        sizeOf = sizeof(T)
    };
};
#line 154 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
template <typename T> class QList; template <typename T> class QTypeInfo< QList<T> > { public: enum { isPointer = false, isIntegral = false, isComplex = true, isStatic = false, isLarge = (sizeof(QList<T>) > sizeof(void*)), isDummy = false, sizeOf = sizeof(QList<T>) }; };
template <typename T> class QVector; template <typename T> class QTypeInfo< QVector<T> > { public: enum { isPointer = false, isIntegral = false, isComplex = true, isStatic = false, isLarge = (sizeof(QVector<T>) > sizeof(void*)), isDummy = false, sizeOf = sizeof(QVector<T>) }; };
template <typename T> class QQueue; template <typename T> class QTypeInfo< QQueue<T> > { public: enum { isPointer = false, isIntegral = false, isComplex = true, isStatic = false, isLarge = (sizeof(QQueue<T>) > sizeof(void*)), isDummy = false, sizeOf = sizeof(QQueue<T>) }; };
template <typename T> class QStack; template <typename T> class QTypeInfo< QStack<T> > { public: enum { isPointer = false, isIntegral = false, isComplex = true, isStatic = false, isLarge = (sizeof(QStack<T>) > sizeof(void*)), isDummy = false, sizeOf = sizeof(QStack<T>) }; };
template <typename T> class QLinkedList; template <typename T> class QTypeInfo< QLinkedList<T> > { public: enum { isPointer = false, isIntegral = false, isComplex = true, isStatic = false, isLarge = (sizeof(QLinkedList<T>) > sizeof(void*)), isDummy = false, sizeOf = sizeof(QLinkedList<T>) }; };
template <typename T> class QSet; template <typename T> class QTypeInfo< QSet<T> > { public: enum { isPointer = false, isIntegral = false, isComplex = true, isStatic = false, isLarge = (sizeof(QSet<T>) > sizeof(void*)), isDummy = false, sizeOf = sizeof(QSet<T>) }; };
#line 171 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
enum {
    Q_COMPLEX_TYPE = 0,
    Q_PRIMITIVE_TYPE = 0x1,
    Q_STATIC_TYPE = 0,
    Q_MOVABLE_TYPE = 0x2,
    Q_DUMMY_TYPE = 0x4
};
#line 200 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
template<typename T> class QFlags;
template<typename T>
class QTypeInfo<QFlags<T> > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QFlags<T>)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QFlags<T> >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QFlags<T>) }; static inline const char *name() { return "QFlags<T>"; } };
#line 230 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
template<> class QTypeInfo<bool > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(bool)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< bool >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(bool) }; static inline const char *name() { return "bool"; } };
template<> class QTypeInfo<char > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(char)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< char >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(char) }; static inline const char *name() { return "char"; } };
template<> class QTypeInfo<signed char > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(signed char)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< signed char >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(signed char) }; static inline const char *name() { return "signed char"; } };
template<> class QTypeInfo<uchar > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(uchar)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< uchar >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(uchar) }; static inline const char *name() { return "uchar"; } };
template<> class QTypeInfo<short > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(short)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< short >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(short) }; static inline const char *name() { return "short"; } };
template<> class QTypeInfo<ushort > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(ushort)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< ushort >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(ushort) }; static inline const char *name() { return "ushort"; } };
template<> class QTypeInfo<int > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(int)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< int >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(int) }; static inline const char *name() { return "int"; } };
template<> class QTypeInfo<uint > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(uint)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< uint >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(uint) }; static inline const char *name() { return "uint"; } };
template<> class QTypeInfo<long > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(long)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< long >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(long) }; static inline const char *name() { return "long"; } };
template<> class QTypeInfo<ulong > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(ulong)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< ulong >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(ulong) }; static inline const char *name() { return "ulong"; } };
template<> class QTypeInfo<qint64 > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(qint64)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< qint64 >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(qint64) }; static inline const char *name() { return "qint64"; } };
template<> class QTypeInfo<quint64 > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(quint64)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< quint64 >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(quint64) }; static inline const char *name() { return "quint64"; } };
template<> class QTypeInfo<float > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(float)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< float >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(float) }; static inline const char *name() { return "float"; } };
template<> class QTypeInfo<double > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(double)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< double >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(double) }; static inline const char *name() { return "double"; } };

template<> class QTypeInfo<long double > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(long double)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< long double >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(long double) }; static inline const char *name() { return "long double"; } };
#line 1065 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsysinfo.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsysinfo.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsysinfo.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsysinfo.h"
class QString;
class __declspec(dllimport) QSysInfo {
public:
    enum Sizes {
        WordSize = (sizeof(void *)<<3)
    };
#line 68 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsysinfo.h"
    enum Endian {
        BigEndian,
        LittleEndian






        , ByteOrder = LittleEndian



    };


    enum WinVersion {
        WV_32s = 0x0001,
        WV_95 = 0x0002,
        WV_98 = 0x0003,
        WV_Me = 0x0004,
        WV_DOS_based= 0x000f,


        WV_NT = 0x0010,
        WV_2000 = 0x0020,
        WV_XP = 0x0030,
        WV_2003 = 0x0040,
        WV_VISTA = 0x0080,
        WV_WINDOWS7 = 0x0090,
        WV_WINDOWS8 = 0x00a0,
        WV_WINDOWS8_1 = 0x00b0,
        WV_NT_based = 0x00f0,


        WV_4_0 = WV_NT,
        WV_5_0 = WV_2000,
        WV_5_1 = WV_XP,
        WV_5_2 = WV_2003,
        WV_6_0 = WV_VISTA,
        WV_6_1 = WV_WINDOWS7,
        WV_6_2 = WV_WINDOWS8,
        WV_6_3 = WV_WINDOWS8_1,

        WV_CE = 0x0100,
        WV_CENET = 0x0200,
        WV_CE_5 = 0x0300,
        WV_CE_6 = 0x0400,
        WV_CE_based = 0x0f00
    };
    static const WinVersion WindowsVersion;
    static WinVersion windowsVersion();
#line 165 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsysinfo.h"
};
#line 1066 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlogging.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlogging.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlogging.h"
#line 59 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlogging.h"
class QDebug;
class QNoDebug;

enum QtMsgType { QtDebugMsg, QtWarningMsg, QtCriticalMsg, QtFatalMsg, QtSystemMsg = QtCriticalMsg };

class QMessageLogContext
{
    QMessageLogContext(const QMessageLogContext &) = delete; QMessageLogContext &operator=(const QMessageLogContext &) = delete;
public:
                     QMessageLogContext() : version(1), line(0), file(0), function(0), category(0) {}
                     QMessageLogContext(const char *fileName, int lineNumber, const char *functionName, const char *categoryName)
        : version(1), line(lineNumber), file(fileName), function(functionName), category(categoryName) {}

    void copy(const QMessageLogContext &logContext);

    int version;
    int line;
    const char *file;
    const char *function;
    const char *category;

private:
    friend class QMessageLogger;
    friend class QDebug;
};

class QLoggingCategory;

class __declspec(dllimport) QMessageLogger
{
    QMessageLogger(const QMessageLogger &) = delete; QMessageLogger &operator=(const QMessageLogger &) = delete;
public:
                     QMessageLogger() : context() {}
                     QMessageLogger(const char *file, int line, const char *function)
        : context(file, line, function, "default") {}
                     QMessageLogger(const char *file, int line, const char *function, const char *category)
        : context(file, line, function, category) {}

    void debug(const char *msg, ...) const ;
    void noDebug(const char *, ...) const
    {}
    void warning(const char *msg, ...) const ;
    void critical(const char *msg, ...) const ;

    typedef const QLoggingCategory &(*CategoryFunction)();

    void debug(const QLoggingCategory &cat, const char *msg, ...) const ;
    void debug(CategoryFunction catFunc, const char *msg, ...) const ;
    void warning(const QLoggingCategory &cat, const char *msg, ...) const ;
    void warning(CategoryFunction catFunc, const char *msg, ...) const ;
    void critical(const QLoggingCategory &cat, const char *msg, ...) const ;
    void critical(CategoryFunction catFunc, const char *msg, ...) const ;




    void fatal(const char *msg, ...) const throw() ;


    QDebug debug() const;
    QDebug debug(const QLoggingCategory &cat) const;
    QDebug debug(CategoryFunction catFunc) const;
    QDebug warning() const;
    QDebug warning(const QLoggingCategory &cat) const;
    QDebug warning(CategoryFunction catFunc) const;
    QDebug critical() const;
    QDebug critical(const QLoggingCategory &cat) const;
    QDebug critical(CategoryFunction catFunc) const;

    QNoDebug noDebug() const throw();


private:
    QMessageLogContext context;
};
#line 155 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlogging.h"
__declspec(dllimport) void qt_message_output(QtMsgType, const QMessageLogContext &context,
                                     const QString &message);

__declspec(dllimport) void qErrnoWarning(int code, const char *msg, ...);
__declspec(dllimport) void qErrnoWarning(const char *msg, ...);






typedef void (*QtMessageHandler)(QtMsgType, const QMessageLogContext &, const QString &);
__declspec(dllimport) QtMessageHandler qInstallMessageHandler(QtMessageHandler);

__declspec(dllimport) void qSetMessagePattern(const QString &messagePattern);
#line 1067 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qflags.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qflags.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qflags.h"





#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 105 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 105 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qflags.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 105 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 105 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qflags.h"




class QFlag
{
    int i;
public:
                     inline QFlag(int ai) : i(ai) {}
                     inline operator int() const { return i; }
#line 72 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qflags.h"
};
template<> class QTypeInfo<QFlag > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QFlag)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QFlag >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QFlag) }; static inline const char *name() { return "QFlag"; } };

class QIncompatibleFlag
{
    int i;
public:
                     inline explicit QIncompatibleFlag(int i);
                     inline operator int() const { return i; }
};
template<> class QTypeInfo<QIncompatibleFlag > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QIncompatibleFlag)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QIncompatibleFlag >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QIncompatibleFlag) }; static inline const char *name() { return "QIncompatibleFlag"; } };

                 inline QIncompatibleFlag::QIncompatibleFlag(int ai) : i(ai) {}




template<typename Enum>
class QFlags
{
    static_assert(bool((sizeof(Enum) <= sizeof(int))), "QFlags uses an int as storage, so an enum with underlying " "long long will overflow.");


    struct Private;
    typedef int (Private::*Zero);
public:



    typedef int Int;







    typedef Enum enum_type;





                     inline QFlags(Enum f) : i(Int(f)) {}
                     inline QFlags(Zero = 0) : i(0) {}
                     inline QFlags(QFlag f) : i(f) {}

    inline QFlags &operator&=(int mask) { i &= mask; return *this; }
    inline QFlags &operator&=(uint mask) { i &= mask; return *this; }
    inline QFlags &operator&=(Enum mask) { i &= Int(mask); return *this; }
    inline QFlags &operator|=(QFlags f) { i |= f.i; return *this; }
    inline QFlags &operator|=(Enum f) { i |= Int(f); return *this; }
    inline QFlags &operator^=(QFlags f) { i ^= f.i; return *this; }
    inline QFlags &operator^=(Enum f) { i ^= Int(f); return *this; }

                      inline operator Int() const { return i; }

                     inline QFlags operator|(QFlags f) const { return QFlags(QFlag(i | f.i)); }
                     inline QFlags operator|(Enum f) const { return QFlags(QFlag(i | Int(f))); }
                     inline QFlags operator^(QFlags f) const { return QFlags(QFlag(i ^ f.i)); }
                     inline QFlags operator^(Enum f) const { return QFlags(QFlag(i ^ Int(f))); }
                     inline QFlags operator&(int mask) const { return QFlags(QFlag(i & mask)); }
                     inline QFlags operator&(uint mask) const { return QFlags(QFlag(i & mask)); }
                     inline QFlags operator&(Enum f) const { return QFlags(QFlag(i & Int(f))); }
                     inline QFlags operator~() const { return QFlags(QFlag(~i)); }

                     inline bool operator!() const { return !i; }

                     inline bool testFlag(Enum f) const { return (i & Int(f)) == Int(f) && (Int(f) != 0 || i == Int(f) ); }
private:
    Int i;
};
#line 1069 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"





#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbasicatomic.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbasicatomic.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbasicatomic.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbasicatomic.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic_msvc.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic_msvc.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qgenericatomic.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qgenericatomic.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qgenericatomic.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 105 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 105 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qgenericatomic.h"
#line 64 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qgenericatomic.h"
template<int> struct QAtomicOpsSupport { enum { IsSupported = 0 }; };
template<> struct QAtomicOpsSupport<4> { enum { IsSupported = 1 }; };

template <typename T> struct QAtomicAdditiveType
{
    typedef T AdditiveT;
    static const int AddScale = 1;
};
template <typename T> struct QAtomicAdditiveType<T *>
{
    typedef qptrdiff AdditiveT;
    static const int AddScale = sizeof(T);
};


template <typename BaseClass> struct QGenericAtomicOps
{
    template <typename T> struct AtomicType { typedef T Type; typedef T *PointerType; };

    template <typename T> static void acquireMemoryFence(const T &_q_value) throw()
    {
        BaseClass::orderedMemoryFence(_q_value);
    }
    template <typename T> static void releaseMemoryFence(const T &_q_value) throw()
    {
        BaseClass::orderedMemoryFence(_q_value);
    }
    template <typename T> static void orderedMemoryFence(const T &) throw()
    {
    }

    template <typename T> static inline
    T load(const T &_q_value) throw()
    {
        return _q_value;
    }

    template <typename T, typename X> static inline
    void store(T &_q_value, X newValue) throw()
    {
        _q_value = newValue;
    }

    template <typename T> static inline
    T loadAcquire(const T &_q_value) throw()
    {
        T tmp = *static_cast<const volatile T *>(&_q_value);
        BaseClass::acquireMemoryFence(_q_value);
        return tmp;
    }

    template <typename T, typename X> static inline
    void storeRelease(T &_q_value, X newValue) throw()
    {
        BaseClass::releaseMemoryFence(_q_value);
        *static_cast<volatile T *>(&_q_value) = newValue;
    }

    static inline bool isReferenceCountingNative() throw()
    { return BaseClass::isFetchAndAddNative(); }
    static inline bool isReferenceCountingWaitFree() throw()
    { return BaseClass::isFetchAndAddWaitFree(); }
    template <typename T> static inline
    bool ref(T &_q_value) throw()
    {
        return BaseClass::fetchAndAddRelaxed(_q_value, 1) != T(-1);
    }

    template <typename T> static inline
    bool deref(T &_q_value) throw()
    {
         return BaseClass::fetchAndAddRelaxed(_q_value, -1) != 1;
    }
#line 149 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qgenericatomic.h"
    template <typename T, typename X> static inline
    bool testAndSetAcquire(T &_q_value, X expectedValue, X newValue) throw()
    {
        bool tmp = BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue);
        BaseClass::acquireMemoryFence(_q_value);
        return tmp;
    }

    template <typename T, typename X> static inline
    bool testAndSetRelease(T &_q_value, X expectedValue, X newValue) throw()
    {
        BaseClass::releaseMemoryFence(_q_value);
        return BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue);
    }

    template <typename T, typename X> static inline
    bool testAndSetOrdered(T &_q_value, X expectedValue, X newValue) throw()
    {
        BaseClass::orderedMemoryFence(_q_value);
        return BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue);
    }

    template <typename T, typename X> static inline
    bool testAndSetAcquire(T &_q_value, X expectedValue, X newValue, X *currentValue) throw()
    {
        bool tmp = BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue, currentValue);
        BaseClass::acquireMemoryFence(_q_value);
        return tmp;
    }

    template <typename T, typename X> static inline
    bool testAndSetRelease(T &_q_value, X expectedValue, X newValue, X *currentValue) throw()
    {
        BaseClass::releaseMemoryFence(_q_value);
        return BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue, currentValue);
    }

    template <typename T, typename X> static inline
    bool testAndSetOrdered(T &_q_value, X expectedValue, X newValue, X *currentValue) throw()
    {
        BaseClass::orderedMemoryFence(_q_value);
        return BaseClass::testAndSetRelaxed(_q_value, expectedValue, newValue, currentValue);
    }

    static inline bool isFetchAndStoreNative() throw() { return false; }
    static inline bool isFetchAndStoreWaitFree() throw() { return false; }

    template <typename T, typename X> static inline
    T fetchAndStoreRelaxed(T &_q_value, X newValue) throw()
    {

        for(;;) {
            T tmp = load(_q_value);
            if (BaseClass::testAndSetRelaxed(_q_value, tmp, newValue))
                return tmp;
        }
    }

    template <typename T, typename X> static inline
    T fetchAndStoreAcquire(T &_q_value, X newValue) throw()
    {
        T tmp = BaseClass::fetchAndStoreRelaxed(_q_value, newValue);
        BaseClass::acquireMemoryFence(_q_value);
        return tmp;
    }

    template <typename T, typename X> static inline
    T fetchAndStoreRelease(T &_q_value, X newValue) throw()
    {
        BaseClass::releaseMemoryFence(_q_value);
        return BaseClass::fetchAndStoreRelaxed(_q_value, newValue);
    }

    template <typename T, typename X> static inline
    T fetchAndStoreOrdered(T &_q_value, X newValue) throw()
    {
        BaseClass::orderedMemoryFence(_q_value);
        return BaseClass::fetchAndStoreRelaxed(_q_value, newValue);
    }

    static inline bool isFetchAndAddNative() throw() { return false; }
    static inline bool isFetchAndAddWaitFree() throw() { return false; }
    template <typename T> static inline
    T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) throw()
    {

        for(;;) {
            T tmp = BaseClass::load(_q_value);
            if (BaseClass::testAndSetRelaxed(_q_value, tmp, T(tmp + valueToAdd)))
                return tmp;
        }
    }

    template <typename T> static inline
    T fetchAndAddAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) throw()
    {
        T tmp = BaseClass::fetchAndAddRelaxed(_q_value, valueToAdd);
        BaseClass::acquireMemoryFence(_q_value);
        return tmp;
    }

    template <typename T> static inline
    T fetchAndAddRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) throw()
    {
        BaseClass::releaseMemoryFence(_q_value);
        return BaseClass::fetchAndAddRelaxed(_q_value, valueToAdd);
    }

    template <typename T> static inline
    T fetchAndAddOrdered(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) throw()
    {
        BaseClass::orderedMemoryFence(_q_value);
        return BaseClass::fetchAndAddRelaxed(_q_value, valueToAdd);
    }

    template <typename T> static inline
    T fetchAndSubRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT operand) throw()
    {

        return fetchAndAddRelaxed(_q_value, -operand);
    }

    template <typename T> static inline
    T fetchAndSubAcquire(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT operand) throw()
    {
        T tmp = BaseClass::fetchAndSubRelaxed(_q_value, operand);
        BaseClass::acquireMemoryFence(_q_value);
        return tmp;
    }

    template <typename T> static inline
    T fetchAndSubRelease(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT operand) throw()
    {
        BaseClass::releaseMemoryFence(_q_value);
        return BaseClass::fetchAndSubRelaxed(_q_value, operand);
    }

    template <typename T> static inline
    T fetchAndSubOrdered(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT operand) throw()
    {
        BaseClass::orderedMemoryFence(_q_value);
        return BaseClass::fetchAndSubRelaxed(_q_value, operand);
    }

    template <typename T> static inline
    T fetchAndAndRelaxed(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {

        for(;;) {
            T tmp = BaseClass::load(_q_value);
            if (BaseClass::testAndSetRelaxed(_q_value, tmp, T(tmp & operand)))
                return tmp;
        }
    }

    template <typename T> static inline
    T fetchAndAndAcquire(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {
        T tmp = BaseClass::fetchAndAndRelaxed(_q_value, operand);
        BaseClass::acquireMemoryFence(_q_value);
        return tmp;
    }

    template <typename T> static inline
    T fetchAndAndRelease(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {
        BaseClass::releaseMemoryFence(_q_value);
        return BaseClass::fetchAndAndRelaxed(_q_value, operand);
    }

    template <typename T> static inline
    T fetchAndAndOrdered(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {
        BaseClass::orderedMemoryFence(_q_value);
        return BaseClass::fetchAndAndRelaxed(_q_value, operand);
    }

    template <typename T> static inline
    T fetchAndOrRelaxed(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {

        for(;;) {
            T tmp = BaseClass::load(_q_value);
            if (BaseClass::testAndSetRelaxed(_q_value, tmp, T(tmp | operand)))
                return tmp;
        }
    }

    template <typename T> static inline
    T fetchAndOrAcquire(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {
        T tmp = BaseClass::fetchAndOrRelaxed(_q_value, operand);
        BaseClass::acquireMemoryFence(_q_value);
        return tmp;
    }

    template <typename T> static inline
    T fetchAndOrRelease(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {
        BaseClass::releaseMemoryFence(_q_value);
        return BaseClass::fetchAndOrRelaxed(_q_value, operand);
    }

    template <typename T> static inline
    T fetchAndOrOrdered(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {
        BaseClass::orderedMemoryFence(_q_value);
        return BaseClass::fetchAndOrRelaxed(_q_value, operand);
    }

    template <typename T> static inline
    T fetchAndXorRelaxed(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {

        for(;;) {
            T tmp = BaseClass::load(_q_value);
            if (BaseClass::testAndSetRelaxed(_q_value, tmp, T(tmp ^ operand)))
                return tmp;
        }
    }

    template <typename T> static inline
    T fetchAndXorAcquire(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {
        T tmp = BaseClass::fetchAndXorRelaxed(_q_value, operand);
        BaseClass::acquireMemoryFence(_q_value);
        return tmp;
    }

    template <typename T> static inline
    T fetchAndXorRelease(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {
        BaseClass::releaseMemoryFence(_q_value);
        return BaseClass::fetchAndXorRelaxed(_q_value, operand);
    }

    template <typename T> static inline
    T fetchAndXorOrdered(T &_q_value, typename QtPrivate::QEnableIf<QTypeInfo<T>::isIntegral, T>::Type operand) throw()
    {
        BaseClass::orderedMemoryFence(_q_value);
        return BaseClass::fetchAndXorRelaxed(_q_value, operand);
    }
};
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic_msvc.h"
#line 124 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic_msvc.h"
extern "C" {

    long __cdecl _InterlockedIncrement(long volatile *);
    long __cdecl _InterlockedDecrement(long volatile *);
    long __cdecl _InterlockedCompareExchange(long volatile *, long, long);
    long __cdecl _InterlockedExchange(long volatile *, long);
    long __cdecl _InterlockedExchangeAdd(long volatile *, long);
#line 139 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic_msvc.h"
    short __cdecl _InterlockedIncrement16(short volatile *);
    short __cdecl _InterlockedDecrement16(short volatile *);
    short __cdecl _InterlockedCompareExchange16(short volatile *, short, short);
    short __cdecl _InterlockedExchange16(short volatile *, short);
    short __cdecl _InterlockedExchangeAdd16(short volatile *, short);
#line 152 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic_msvc.h"
}
#line 163 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic_msvc.h"
#pragma intrinsic (_InterlockedIncrement)
#pragma intrinsic (_InterlockedDecrement)
#pragma intrinsic (_InterlockedExchange)
#pragma intrinsic (_InterlockedCompareExchange)
#pragma intrinsic (_InterlockedExchangeAdd)
#line 278 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic_msvc.h"
template<> struct QAtomicOpsSupport<2> { enum { IsSupported = 1 }; };
#line 299 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic_msvc.h"
template <int N> struct QAtomicWindowsType { typedef typename QIntegerForSize<N>::Signed Type; };
template <> struct QAtomicWindowsType<4> { typedef long Type; };


template <int N> struct QAtomicOpsBySize : QGenericAtomicOps<QAtomicOpsBySize<N> >
{
    static inline bool isReferenceCountingNative() throw() { return true; }
    static inline bool isReferenceCountingWaitFree() throw() { return true; }
    template <typename T> static bool ref(T &_q_value) throw();
    template <typename T> static bool deref(T &_q_value) throw();

    static inline bool isTestAndSetNative() throw() { return true; }
    static inline bool isTestAndSetWaitFree() throw() { return true; }
    template <typename T> static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) throw();
    template <typename T>
    static bool testAndSetRelaxed(T &_q_value, T expectedValue, T newValue, T *currentValue) throw();

    static inline bool isFetchAndStoreNative() throw() { return true; }
    static inline bool isFetchAndStoreWaitFree() throw() { return true; }
    template <typename T> static T fetchAndStoreRelaxed(T &_q_value, T newValue) throw();

    static inline bool isFetchAndAddNative() throw() { return true; }
    static inline bool isFetchAndAddWaitFree() throw() { return true; }
    template <typename T> static T fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) throw();

private:
    typedef typename QAtomicWindowsType<N>::Type Type;
    template <typename T> static inline Type *atomic(T *t)
    { static_assert(bool(sizeof(T) == sizeof(Type)), "sizeof(T) == sizeof(Type)"); return reinterpret_cast<Type *>(t); }
    template <typename T> static inline Type value(T t)
    { static_assert(bool(sizeof(T) == sizeof(Type)), "sizeof(T) == sizeof(Type)"); return Type(t); }
};

template <typename T>
struct QAtomicOps : QAtomicOpsBySize<sizeof(T)>
{
    typedef T Type;
};

template<> template<typename T>
inline bool QAtomicOpsBySize<4>::ref(T &_q_value) throw()
{
    return _InterlockedIncrement(atomic(&_q_value)) != 0;
}

template<> template<typename T>
inline bool QAtomicOpsBySize<4>::deref(T &_q_value) throw()
{
    return _InterlockedDecrement(atomic(&_q_value)) != 0;
}

template<> template<typename T>
inline bool QAtomicOpsBySize<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) throw()
{
    return _InterlockedCompareExchange(atomic(&_q_value), value(newValue), value(expectedValue)) == value(expectedValue);
}

template<> template <typename T>
inline bool QAtomicOpsBySize<4>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue, T *currentValue) throw()
{
    *currentValue = T(_InterlockedCompareExchange(atomic(&_q_value), newValue, expectedValue));
    return *currentValue == expectedValue;
}

template<> template<typename T>
inline T QAtomicOpsBySize<4>::fetchAndStoreRelaxed(T &_q_value, T newValue) throw()
{
    return _InterlockedExchange(atomic(&_q_value), value(newValue));
}

template<> template<typename T>
inline T QAtomicOpsBySize<4>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) throw()
{
    return _InterlockedExchangeAdd(atomic(&_q_value), value<T>(valueToAdd * QAtomicAdditiveType<T>::AddScale));
}


template<> template<typename T>
inline bool QAtomicOpsBySize<2>::ref(T &_q_value) throw()
{
    return _InterlockedIncrement16(atomic(&_q_value)) != 0;
}

template<> template<typename T>
inline bool QAtomicOpsBySize<2>::deref(T &_q_value) throw()
{
    return _InterlockedDecrement16(atomic(&_q_value)) != 0;
}

template<> template<typename T>
inline bool QAtomicOpsBySize<2>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue) throw()
{
    return _InterlockedCompareExchange16(atomic(&_q_value), value(newValue), value(expectedValue)) == value(expectedValue);
}

template<> template <typename T>
inline bool QAtomicOpsBySize<2>::testAndSetRelaxed(T &_q_value, T expectedValue, T newValue, T *currentValue) throw()
{
    *currentValue = T(_InterlockedCompareExchange16(atomic(&_q_value), newValue, expectedValue));
    return *currentValue == expectedValue;
}

template<> template<typename T>
inline T QAtomicOpsBySize<2>::fetchAndStoreRelaxed(T &_q_value, T newValue) throw()
{
    return _InterlockedExchange16(atomic(&_q_value), value(newValue));
}

template<> template<typename T>
inline T QAtomicOpsBySize<2>::fetchAndAddRelaxed(T &_q_value, typename QAtomicAdditiveType<T>::AdditiveT valueToAdd) throw()
{
    return _InterlockedExchangeAdd16(atomic(&_q_value), value<T>(valueToAdd * QAtomicAdditiveType<T>::AddScale));
}
#line 454 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic_msvc.h"
template <typename T>
struct QAtomicOps<T *> : QGenericAtomicOps<QAtomicOps<T *> >
{
    typedef T *Type;

    static inline bool isTestAndSetNative() throw() { return true; }
    static inline bool isTestAndSetWaitFree() throw() { return true; }
    static bool testAndSetRelaxed(T *&_q_value, T *expectedValue, T *newValue) throw();
    static bool testAndSetRelaxed(T *&_q_value, T *expectedValue, T *newValue, T **currentValue) throw();

    static inline bool isFetchAndStoreNative() throw() { return true; }
    static inline bool isFetchAndStoreWaitFree() throw() { return true; }
    static T *fetchAndStoreRelaxed(T *&_q_value, T *newValue) throw();

    static inline bool isFetchAndAddNative() throw() { return true; }
    static inline bool isFetchAndAddWaitFree() throw() { return true; }
    static T *fetchAndAddRelaxed(T *&_q_value, qptrdiff valueToAdd) throw();
};

template <typename T>
inline bool QAtomicOps<T *>::testAndSetRelaxed(T *&_q_value, T *expectedValue, T *newValue) throw()
{
    return reinterpret_cast<void *>( _InterlockedCompareExchange( reinterpret_cast<long volatile *>(&_q_value), long(newValue), long(expectedValue))) == expectedValue;
}

template <typename T>
inline bool QAtomicOps<T *>::testAndSetRelaxed(T *&_q_value, T *expectedValue, T *newValue, T **currentValue) throw()
{
    *currentValue = reinterpret_cast<T *>(reinterpret_cast<void *>( _InterlockedCompareExchange( reinterpret_cast<long volatile *>(&_q_value), long(newValue), long(expectedValue))));
    return *currentValue == expectedValue;
}

template <typename T>
inline T *QAtomicOps<T *>::fetchAndStoreRelaxed(T *&_q_value, T *newValue) throw()
{
    return reinterpret_cast<T *>(_InterlockedExchange( reinterpret_cast<long volatile *>(&_q_value), long(newValue)));
}

template <typename T>
inline T *QAtomicOps<T *>::fetchAndAddRelaxed(T *&_q_value, qptrdiff valueToAdd) throw()
{
    return reinterpret_cast<T *>(_InterlockedExchangeAdd( reinterpret_cast<long volatile *>(&_q_value), (valueToAdd * sizeof(T))));
}
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbasicatomic.h"
#line 111 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbasicatomic.h"
template <typename T>
class QBasicAtomicInteger
{
public:
    typedef QAtomicOps<T> Ops;

    static_assert(bool(QTypeInfo<T>::isIntegral), "template parameter is not an integral type");
    static_assert(bool(QAtomicOpsSupport<sizeof(T)>::IsSupported), "template parameter is an integral of a size not supported on this platform");

    typename Ops::Type _q_value;



    T load() const throw() { return Ops::load(_q_value); }
    void store(T newValue) throw() { Ops::store(_q_value, newValue); }

    T loadAcquire() const throw() { return Ops::loadAcquire(_q_value); }
    void storeRelease(T newValue) throw() { Ops::storeRelease(_q_value, newValue); }
    operator T() const throw() { return loadAcquire(); }
    T operator=(T newValue) throw() { storeRelease(newValue); return newValue; }

    static bool isReferenceCountingNative() throw() { return Ops::isReferenceCountingNative(); }
    static bool isReferenceCountingWaitFree() throw() { return Ops::isReferenceCountingWaitFree(); }

    bool ref() throw() { return Ops::ref(_q_value); }
    bool deref() throw() { return Ops::deref(_q_value); }

    static bool isTestAndSetNative() throw() { return Ops::isTestAndSetNative(); }
    static bool isTestAndSetWaitFree() throw() { return Ops::isTestAndSetWaitFree(); }

    bool testAndSetRelaxed(T expectedValue, T newValue) throw()
    { return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue); }
    bool testAndSetAcquire(T expectedValue, T newValue) throw()
    { return Ops::testAndSetAcquire(_q_value, expectedValue, newValue); }
    bool testAndSetRelease(T expectedValue, T newValue) throw()
    { return Ops::testAndSetRelease(_q_value, expectedValue, newValue); }
    bool testAndSetOrdered(T expectedValue, T newValue) throw()
    { return Ops::testAndSetOrdered(_q_value, expectedValue, newValue); }

    bool testAndSetRelaxed(T expectedValue, T newValue, T &currentValue) throw()
    { return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue, &currentValue); }
    bool testAndSetAcquire(T expectedValue, T newValue, T &currentValue) throw()
    { return Ops::testAndSetAcquire(_q_value, expectedValue, newValue, &currentValue); }
    bool testAndSetRelease(T expectedValue, T newValue, T &currentValue) throw()
    { return Ops::testAndSetRelease(_q_value, expectedValue, newValue, &currentValue); }
    bool testAndSetOrdered(T expectedValue, T newValue, T &currentValue) throw()
    { return Ops::testAndSetOrdered(_q_value, expectedValue, newValue, &currentValue); }

    static bool isFetchAndStoreNative() throw() { return Ops::isFetchAndStoreNative(); }
    static bool isFetchAndStoreWaitFree() throw() { return Ops::isFetchAndStoreWaitFree(); }

    T fetchAndStoreRelaxed(T newValue) throw()
    { return Ops::fetchAndStoreRelaxed(_q_value, newValue); }
    T fetchAndStoreAcquire(T newValue) throw()
    { return Ops::fetchAndStoreAcquire(_q_value, newValue); }
    T fetchAndStoreRelease(T newValue) throw()
    { return Ops::fetchAndStoreRelease(_q_value, newValue); }
    T fetchAndStoreOrdered(T newValue) throw()
    { return Ops::fetchAndStoreOrdered(_q_value, newValue); }

    static bool isFetchAndAddNative() throw() { return Ops::isFetchAndAddNative(); }
    static bool isFetchAndAddWaitFree() throw() { return Ops::isFetchAndAddWaitFree(); }

    T fetchAndAddRelaxed(T valueToAdd) throw()
    { return Ops::fetchAndAddRelaxed(_q_value, valueToAdd); }
    T fetchAndAddAcquire(T valueToAdd) throw()
    { return Ops::fetchAndAddAcquire(_q_value, valueToAdd); }
    T fetchAndAddRelease(T valueToAdd) throw()
    { return Ops::fetchAndAddRelease(_q_value, valueToAdd); }
    T fetchAndAddOrdered(T valueToAdd) throw()
    { return Ops::fetchAndAddOrdered(_q_value, valueToAdd); }

    T fetchAndSubRelaxed(T valueToAdd) throw()
    { return Ops::fetchAndSubRelaxed(_q_value, valueToAdd); }
    T fetchAndSubAcquire(T valueToAdd) throw()
    { return Ops::fetchAndSubAcquire(_q_value, valueToAdd); }
    T fetchAndSubRelease(T valueToAdd) throw()
    { return Ops::fetchAndSubRelease(_q_value, valueToAdd); }
    T fetchAndSubOrdered(T valueToAdd) throw()
    { return Ops::fetchAndSubOrdered(_q_value, valueToAdd); }

    T fetchAndAndRelaxed(T valueToAdd) throw()
    { return Ops::fetchAndAndRelaxed(_q_value, valueToAdd); }
    T fetchAndAndAcquire(T valueToAdd) throw()
    { return Ops::fetchAndAndAcquire(_q_value, valueToAdd); }
    T fetchAndAndRelease(T valueToAdd) throw()
    { return Ops::fetchAndAndRelease(_q_value, valueToAdd); }
    T fetchAndAndOrdered(T valueToAdd) throw()
    { return Ops::fetchAndAndOrdered(_q_value, valueToAdd); }

    T fetchAndOrRelaxed(T valueToAdd) throw()
    { return Ops::fetchAndOrRelaxed(_q_value, valueToAdd); }
    T fetchAndOrAcquire(T valueToAdd) throw()
    { return Ops::fetchAndOrAcquire(_q_value, valueToAdd); }
    T fetchAndOrRelease(T valueToAdd) throw()
    { return Ops::fetchAndOrRelease(_q_value, valueToAdd); }
    T fetchAndOrOrdered(T valueToAdd) throw()
    { return Ops::fetchAndOrOrdered(_q_value, valueToAdd); }

    T fetchAndXorRelaxed(T valueToAdd) throw()
    { return Ops::fetchAndXorRelaxed(_q_value, valueToAdd); }
    T fetchAndXorAcquire(T valueToAdd) throw()
    { return Ops::fetchAndXorAcquire(_q_value, valueToAdd); }
    T fetchAndXorRelease(T valueToAdd) throw()
    { return Ops::fetchAndXorRelease(_q_value, valueToAdd); }
    T fetchAndXorOrdered(T valueToAdd) throw()
    { return Ops::fetchAndXorOrdered(_q_value, valueToAdd); }

    T operator++() throw()
    { return fetchAndAddOrdered(1) + 1; }
    T operator++(int) throw()
    { return fetchAndAddOrdered(1); }
    T operator--() throw()
    { return fetchAndSubOrdered(1) - 1; }
    T operator--(int) throw()
    { return fetchAndSubOrdered(1); }

    T operator+=(T v) throw()
    { return fetchAndAddOrdered(v) + v; }
    T operator-=(T v) throw()
    { return fetchAndSubOrdered(v) - v; }
    T operator&=(T v) throw()
    { return fetchAndAndOrdered(v) & v; }
    T operator|=(T v) throw()
    { return fetchAndOrOrdered(v) | v; }
    T operator^=(T v) throw()
    { return fetchAndXorOrdered(v) ^ v; }
#line 247 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbasicatomic.h"
};
typedef QBasicAtomicInteger<int> QBasicAtomicInt;

template <typename X>
class QBasicAtomicPointer
{
public:
    typedef X *Type;
    typedef QAtomicOps<Type> Ops;
    typedef typename Ops::Type AtomicType;

    AtomicType _q_value;

    Type load() const throw() { return _q_value; }
    void store(Type newValue) throw() { _q_value = newValue; }
    operator Type() const throw() { return loadAcquire(); }
    Type operator=(Type newValue) throw() { storeRelease(newValue); return newValue; }


    Type loadAcquire() const throw() { return Ops::loadAcquire(_q_value); }
    void storeRelease(Type newValue) throw() { Ops::storeRelease(_q_value, newValue); }

    static bool isTestAndSetNative() throw() { return Ops::isTestAndSetNative(); }
    static bool isTestAndSetWaitFree() throw() { return Ops::isTestAndSetWaitFree(); }

    bool testAndSetRelaxed(Type expectedValue, Type newValue) throw()
    { return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue); }
    bool testAndSetAcquire(Type expectedValue, Type newValue) throw()
    { return Ops::testAndSetAcquire(_q_value, expectedValue, newValue); }
    bool testAndSetRelease(Type expectedValue, Type newValue) throw()
    { return Ops::testAndSetRelease(_q_value, expectedValue, newValue); }
    bool testAndSetOrdered(Type expectedValue, Type newValue) throw()
    { return Ops::testAndSetOrdered(_q_value, expectedValue, newValue); }

    bool testAndSetRelaxed(Type expectedValue, Type newValue, Type &currentValue) throw()
    { return Ops::testAndSetRelaxed(_q_value, expectedValue, newValue, &currentValue); }
    bool testAndSetAcquire(Type expectedValue, Type newValue, Type &currentValue) throw()
    { return Ops::testAndSetAcquire(_q_value, expectedValue, newValue, &currentValue); }
    bool testAndSetRelease(Type expectedValue, Type newValue, Type &currentValue) throw()
    { return Ops::testAndSetRelease(_q_value, expectedValue, newValue, &currentValue); }
    bool testAndSetOrdered(Type expectedValue, Type newValue, Type &currentValue) throw()
    { return Ops::testAndSetOrdered(_q_value, expectedValue, newValue, &currentValue); }

    static bool isFetchAndStoreNative() throw() { return Ops::isFetchAndStoreNative(); }
    static bool isFetchAndStoreWaitFree() throw() { return Ops::isFetchAndStoreWaitFree(); }

    Type fetchAndStoreRelaxed(Type newValue) throw()
    { return Ops::fetchAndStoreRelaxed(_q_value, newValue); }
    Type fetchAndStoreAcquire(Type newValue) throw()
    { return Ops::fetchAndStoreAcquire(_q_value, newValue); }
    Type fetchAndStoreRelease(Type newValue) throw()
    { return Ops::fetchAndStoreRelease(_q_value, newValue); }
    Type fetchAndStoreOrdered(Type newValue) throw()
    { return Ops::fetchAndStoreOrdered(_q_value, newValue); }

    static bool isFetchAndAddNative() throw() { return Ops::isFetchAndAddNative(); }
    static bool isFetchAndAddWaitFree() throw() { return Ops::isFetchAndAddWaitFree(); }

    Type fetchAndAddRelaxed(qptrdiff valueToAdd) throw()
    { return Ops::fetchAndAddRelaxed(_q_value, valueToAdd); }
    Type fetchAndAddAcquire(qptrdiff valueToAdd) throw()
    { return Ops::fetchAndAddAcquire(_q_value, valueToAdd); }
    Type fetchAndAddRelease(qptrdiff valueToAdd) throw()
    { return Ops::fetchAndAddRelease(_q_value, valueToAdd); }
    Type fetchAndAddOrdered(qptrdiff valueToAdd) throw()
    { return Ops::fetchAndAddOrdered(_q_value, valueToAdd); }

    Type fetchAndSubRelaxed(qptrdiff valueToAdd) throw()
    { return Ops::fetchAndSubRelaxed(_q_value, valueToAdd); }
    Type fetchAndSubAcquire(qptrdiff valueToAdd) throw()
    { return Ops::fetchAndSubAcquire(_q_value, valueToAdd); }
    Type fetchAndSubRelease(qptrdiff valueToAdd) throw()
    { return Ops::fetchAndSubRelease(_q_value, valueToAdd); }
    Type fetchAndSubOrdered(qptrdiff valueToAdd) throw()
    { return Ops::fetchAndSubOrdered(_q_value, valueToAdd); }

    Type operator++() throw()
    { return fetchAndAddOrdered(1) + 1; }
    Type operator++(int) throw()
    { return fetchAndAddOrdered(1); }
    Type operator--() throw()
    { return fetchAndSubOrdered(1) - 1; }
    Type operator--(int) throw()
    { return fetchAndSubOrdered(1); }
    Type operator+=(qptrdiff valueToAdd) throw()
    { return fetchAndAddOrdered(valueToAdd) + valueToAdd; }
    Type operator-=(qptrdiff valueToSub) throw()
    { return fetchAndSubOrdered(valueToSub) - valueToSub; }
#line 343 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbasicatomic.h"
};
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
template <typename T>
class QAtomicInteger : public QBasicAtomicInteger<T>
{
public:




    inline QAtomicInteger(T value = 0) throw()
    {
        this->_q_value = value;
    }


    inline QAtomicInteger(const QAtomicInteger &other) throw()



    {
        this->storeRelease(other.loadAcquire());
    }

    inline QAtomicInteger &operator=(const QAtomicInteger &other) throw()
    {
        this->storeRelease(other.loadAcquire());
        return *this;
    }
#line 155 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
};

class QAtomicInt : public QAtomicInteger<int>
{
public:






    QAtomicInt(int value = 0) throw() : QAtomicInteger<int>(value) {}
};


template <typename T>
class QAtomicPointer : public QBasicAtomicPointer<T>
{
public:



    inline QAtomicPointer(T *value = 0) throw()
    {
        this->store(value);
    }

    inline QAtomicPointer(const QAtomicPointer<T> &other) throw()
    {
        this->storeRelease(other.loadAcquire());
    }

    inline QAtomicPointer<T> &operator=(const QAtomicPointer<T> &other) throw()
    {
        this->storeRelease(other.loadAcquire());
        return *this;
    }
#line 223 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
};
#line 239 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
template <typename T>
inline void qAtomicAssign(T *&d, T *x)
{
    if (d == x)
        return;
    x->ref.ref();
    if (!d->ref.deref())
        delete d;
    d = x;
}
#line 258 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
template <typename T>
inline void qAtomicDetach(T *&d)
{
    if (d->ref.load() == 1)
        return;
    T *x = d;
    d = new T(*d);
    if (!x->ref.deref())
        delete x;
}
#line 1071 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobalstatic.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobalstatic.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobalstatic.h"





#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobalstatic.h"




namespace QtGlobalStatic {
enum GuardValues {
    Destroyed = -2,
    Initialized = -1,
    Uninitialized = 0,
    Initializing = 1
};
}
#line 102 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobalstatic.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmutex.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmutex.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmutex.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmutex.h"
#line 60 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmutex.h"
class QMutexData;

class __declspec(dllimport) QBasicMutex
{
public:
    inline void lock() {
        if (!fastTryLock())
            lockInternal();
    }

    inline void unlock() throw() {
        ((!(d_ptr.load())) ? qt_assert("d_ptr.load()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmutex.h",71) : qt_noop());
        if (!fastTryUnlock())
            unlockInternal();
    }

    bool tryLock() throw() {
        return fastTryLock();
    }

    bool isRecursive();

private:
    inline bool fastTryLock() throw() {
        return d_ptr.testAndSetAcquire(0, dummyLocked());
    }
    inline bool fastTryUnlock() throw() {
        return d_ptr.testAndSetRelease(dummyLocked(), 0);
    }
    inline bool fastTryLock(QMutexData *&current) throw() {
        return d_ptr.testAndSetAcquire(0, dummyLocked(), current);
    }
    inline bool fastTryUnlock(QMutexData *&current) throw() {
        return d_ptr.testAndSetRelease(dummyLocked(), 0, current);
    }

    void lockInternal() ;
    bool lockInternal(int timeout) ;
    void unlockInternal() throw();

    QBasicAtomicPointer<QMutexData> d_ptr;
    static inline QMutexData *dummyLocked() {
        return reinterpret_cast<QMutexData *>(quintptr(1));
    }

    friend class QMutex;
    friend class QMutexData;
};

class __declspec(dllimport) QMutex : public QBasicMutex {
public:
    enum RecursionMode { NonRecursive, Recursive };
    explicit QMutex(RecursionMode mode = NonRecursive);
    ~QMutex();

    void lock() ;
    bool tryLock(int timeout = 0) ;
    void unlock() throw();

    using QBasicMutex::isRecursive;

private:
    QMutex(const QMutex &) = delete; QMutex &operator=(const QMutex &) = delete;
    friend class QMutexLocker;
};

class __declspec(dllimport) QMutexLocker
{
public:
    inline explicit QMutexLocker(QBasicMutex *m)
    {
        ((!((reinterpret_cast<quintptr>(m) & quintptr(1u)) == quintptr(0))) ? qt_assert_x("QMutexLocker", "QMutex pointer is misaligned","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmutex.h",132) : qt_noop());

        val = quintptr(m);
        if ((m)) {

            static_cast<QMutex *>(m)->lock();
            val |= 1;
        }
    }
    inline ~QMutexLocker() { unlock(); }

    inline void unlock() throw()
    {
        if ((val & quintptr(1u)) == quintptr(1u)) {
            val &= ~quintptr(1u);
            mutex()->unlock();
        }
    }

    inline void relock()
    {
        if (val) {
            if ((val & quintptr(1u)) == quintptr(0u)) {
                mutex()->lock();
                val |= quintptr(1u);
            }
        }
    }


#pragma warning(push)
#pragma warning(disable: 4312)


 inline QMutex *mutex() const
    {
        return reinterpret_cast<QMutex *>(val & ~quintptr(1u));
    }


#pragma warning(pop)


private:
    QMutexLocker(const QMutexLocker &) = delete; QMutexLocker &operator=(const QMutexLocker &) = delete;

    quintptr val;
};
#line 102 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobalstatic.h"
#line 129 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobalstatic.h"
template <typename T, T *(&innerFunction)(), QBasicAtomicInt &guard>
struct QGlobalStatic
{
    typedef T Type;

    bool isDestroyed() const { return guard.load() <= QtGlobalStatic::Destroyed; }
    bool exists() const { return guard.load() == QtGlobalStatic::Initialized; }
    operator Type *() { if (isDestroyed()) return 0; return innerFunction(); }
    Type *operator()() { if (isDestroyed()) return 0; return innerFunction(); }
    Type *operator->()
    {
      ((!(!isDestroyed())) ? qt_assert_x("Q_GLOBAL_STATIC", "The global static was used after being destroyed","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobalstatic.h",140) : qt_noop());
      return innerFunction();
    }
    Type &operator*()
    {
      ((!(!isDestroyed())) ? qt_assert_x("Q_GLOBAL_STATIC", "The global static was used after being destroyed","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobalstatic.h",145) : qt_noop());
      return *innerFunction();
    }
};
#line 1072 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qnumeric.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qnumeric.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qnumeric.h"





__declspec(dllimport) bool qIsInf(double d);
__declspec(dllimport) bool qIsNaN(double d);
__declspec(dllimport) bool qIsFinite(double d);
__declspec(dllimport) bool qIsInf(float f);
__declspec(dllimport) bool qIsNaN(float f);
__declspec(dllimport) bool qIsFinite(float f);
__declspec(dllimport) double qSNaN();
__declspec(dllimport) double qQNaN();
__declspec(dllimport) double qInf();

__declspec(dllimport) quint32 qFloatDistance(float a, float b);
__declspec(dllimport) quint64 qFloatDistance(double a, double b);
#line 1073 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobal.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcoreapplication.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qchar.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qchar.h"
class QString;

struct QLatin1Char
{
public:
                     inline explicit QLatin1Char(char c) : ch(c) {}
                     inline char toLatin1() const { return ch; }
                     inline ushort unicode() const { return ushort(uchar(ch)); }

private:
    char ch;
};


class __declspec(dllimport) QChar {
public:
    enum SpecialCharacter {
        Null = 0x0000,
        Tabulation = 0x0009,
        LineFeed = 0x000a,
        CarriageReturn = 0x000d,
        Space = 0x0020,
        Nbsp = 0x00a0,
        SoftHyphen = 0x00ad,
        ReplacementCharacter = 0xfffd,
        ObjectReplacementCharacter = 0xfffc,
        ByteOrderMark = 0xfeff,
        ByteOrderSwapped = 0xfffe,
        ParagraphSeparator = 0x2029,
        LineSeparator = 0x2028,
        LastValidCodePoint = 0x10ffff
    };

                     QChar() : ucs(0) {}
                     QChar(ushort rc) : ucs(rc){}
                     QChar(uchar c, uchar r) : ucs(ushort((r << 8) | c)){}
                     QChar(short rc) : ucs(ushort(rc)){}
                     QChar(uint rc) : ucs(ushort(rc & 0xffff)){}
                     QChar(int rc) : ucs(ushort(rc & 0xffff)){}
                     QChar(SpecialCharacter s) : ucs(ushort(s)) {}
                     QChar(QLatin1Char ch) : ucs(ch.unicode()) {}


                                        explicit QChar(char c) : ucs(uchar(c)) { }
                                        explicit QChar(uchar c) : ucs(c) { }



    enum Category
    {
        Mark_NonSpacing,
        Mark_SpacingCombining,
        Mark_Enclosing,

        Number_DecimalDigit,
        Number_Letter,
        Number_Other,

        Separator_Space,
        Separator_Line,
        Separator_Paragraph,

        Other_Control,
        Other_Format,
        Other_Surrogate,
        Other_PrivateUse,
        Other_NotAssigned,

        Letter_Uppercase,
        Letter_Lowercase,
        Letter_Titlecase,
        Letter_Modifier,
        Letter_Other,

        Punctuation_Connector,
        Punctuation_Dash,
        Punctuation_Open,
        Punctuation_Close,
        Punctuation_InitialQuote,
        Punctuation_FinalQuote,
        Punctuation_Other,

        Symbol_Math,
        Symbol_Currency,
        Symbol_Modifier,
        Symbol_Other
    };

    enum Script
    {
        Script_Unknown,
        Script_Inherited,
        Script_Common,

        Script_Latin,
        Script_Greek,
        Script_Cyrillic,
        Script_Armenian,
        Script_Hebrew,
        Script_Arabic,
        Script_Syriac,
        Script_Thaana,
        Script_Devanagari,
        Script_Bengali,
        Script_Gurmukhi,
        Script_Gujarati,
        Script_Oriya,
        Script_Tamil,
        Script_Telugu,
        Script_Kannada,
        Script_Malayalam,
        Script_Sinhala,
        Script_Thai,
        Script_Lao,
        Script_Tibetan,
        Script_Myanmar,
        Script_Georgian,
        Script_Hangul,
        Script_Ethiopic,
        Script_Cherokee,
        Script_CanadianAboriginal,
        Script_Ogham,
        Script_Runic,
        Script_Khmer,
        Script_Mongolian,
        Script_Hiragana,
        Script_Katakana,
        Script_Bopomofo,
        Script_Han,
        Script_Yi,
        Script_OldItalic,
        Script_Gothic,
        Script_Deseret,
        Script_Tagalog,
        Script_Hanunoo,
        Script_Buhid,
        Script_Tagbanwa,
        Script_Coptic,


        Script_Limbu,
        Script_TaiLe,
        Script_LinearB,
        Script_Ugaritic,
        Script_Shavian,
        Script_Osmanya,
        Script_Cypriot,
        Script_Braille,


        Script_Buginese,
        Script_NewTaiLue,
        Script_Glagolitic,
        Script_Tifinagh,
        Script_SylotiNagri,
        Script_OldPersian,
        Script_Kharoshthi,


        Script_Balinese,
        Script_Cuneiform,
        Script_Phoenician,
        Script_PhagsPa,
        Script_Nko,


        Script_Sundanese,
        Script_Lepcha,
        Script_OlChiki,
        Script_Vai,
        Script_Saurashtra,
        Script_KayahLi,
        Script_Rejang,
        Script_Lycian,
        Script_Carian,
        Script_Lydian,
        Script_Cham,


        Script_TaiTham,
        Script_TaiViet,
        Script_Avestan,
        Script_EgyptianHieroglyphs,
        Script_Samaritan,
        Script_Lisu,
        Script_Bamum,
        Script_Javanese,
        Script_MeeteiMayek,
        Script_ImperialAramaic,
        Script_OldSouthArabian,
        Script_InscriptionalParthian,
        Script_InscriptionalPahlavi,
        Script_OldTurkic,
        Script_Kaithi,


        Script_Batak,
        Script_Brahmi,
        Script_Mandaic,


        Script_Chakma,
        Script_MeroiticCursive,
        Script_MeroiticHieroglyphs,
        Script_Miao,
        Script_Sharada,
        Script_SoraSompeng,
        Script_Takri,

        ScriptCount
    };

    enum Direction
    {
        DirL, DirR, DirEN, DirES, DirET, DirAN, DirCS, DirB, DirS, DirWS, DirON,
        DirLRE, DirLRO, DirAL, DirRLE, DirRLO, DirPDF, DirNSM, DirBN,
        DirLRI, DirRLI, DirFSI, DirPDI
    };

    enum Decomposition
    {
        NoDecomposition,
        Canonical,
        Font,
        NoBreak,
        Initial,
        Medial,
        Final,
        Isolated,
        Circle,
        Super,
        Sub,
        Vertical,
        Wide,
        Narrow,
        Small,
        Square,
        Compat,
        Fraction
    };

    enum JoiningType {
        Joining_None,
        Joining_Causing,
        Joining_Dual,
        Joining_Right,
        Joining_Left,
        Joining_Transparent
    };


    enum Joining
    {
        OtherJoining, Dual, Right, Center
    };


    enum CombiningClass
    {
        Combining_BelowLeftAttached = 200,
        Combining_BelowAttached = 202,
        Combining_BelowRightAttached = 204,
        Combining_LeftAttached = 208,
        Combining_RightAttached = 210,
        Combining_AboveLeftAttached = 212,
        Combining_AboveAttached = 214,
        Combining_AboveRightAttached = 216,

        Combining_BelowLeft = 218,
        Combining_Below = 220,
        Combining_BelowRight = 222,
        Combining_Left = 224,
        Combining_Right = 226,
        Combining_AboveLeft = 228,
        Combining_Above = 230,
        Combining_AboveRight = 232,

        Combining_DoubleBelow = 233,
        Combining_DoubleAbove = 234,
        Combining_IotaSubscript = 240
    };

    enum UnicodeVersion {
        Unicode_Unassigned,
        Unicode_1_1,
        Unicode_2_0,
        Unicode_2_1_2,
        Unicode_3_0,
        Unicode_3_1,
        Unicode_3_2,
        Unicode_4_0,
        Unicode_4_1,
        Unicode_5_0,
        Unicode_5_1,
        Unicode_5_2,
        Unicode_6_0,
        Unicode_6_1,
        Unicode_6_2,
        Unicode_6_3
    };


    inline Category category() const { return QChar::category(ucs); }
    inline Direction direction() const { return QChar::direction(ucs); }
    inline JoiningType joiningType() const { return QChar::joiningType(ucs); }

                  inline Joining joining() const
    {
        switch (QChar::joiningType(ucs)) {
        case QChar::Joining_Causing: return QChar::Center;
        case QChar::Joining_Dual: return QChar::Dual;
        case QChar::Joining_Right: return QChar::Right;
        case QChar::Joining_None:
        case QChar::Joining_Left:
        case QChar::Joining_Transparent:
        default: return QChar::OtherJoining;
        }
    }

    inline unsigned char combiningClass() const { return QChar::combiningClass(ucs); }

    inline QChar mirroredChar() const { return QChar::mirroredChar(ucs); }
    inline bool hasMirrored() const { return QChar::hasMirrored(ucs); }

    QString decomposition() const;
    inline Decomposition decompositionTag() const { return QChar::decompositionTag(ucs); }

    inline int digitValue() const { return QChar::digitValue(ucs); }
    inline QChar toLower() const { return QChar::toLower(ucs); }
    inline QChar toUpper() const { return QChar::toUpper(ucs); }
    inline QChar toTitleCase() const { return QChar::toTitleCase(ucs); }
    inline QChar toCaseFolded() const { return QChar::toCaseFolded(ucs); }

    inline Script script() const { return QChar::script(ucs); }

    inline UnicodeVersion unicodeVersion() const { return QChar::unicodeVersion(ucs); }




    inline char toLatin1() const;
    inline ushort unicode() const { return ucs; }
    inline ushort &unicode() { return ucs; }





    static inline QChar fromLatin1(char c);

    inline bool isNull() const { return ucs == 0; }

    inline bool isPrint() const { return QChar::isPrint(ucs); }
    inline bool isSpace() const { return QChar::isSpace(ucs); }
    inline bool isMark() const { return QChar::isMark(ucs); }
    inline bool isPunct() const { return QChar::isPunct(ucs); }
    inline bool isSymbol() const { return QChar::isSymbol(ucs); }
    inline bool isLetter() const { return QChar::isLetter(ucs); }
    inline bool isNumber() const { return QChar::isNumber(ucs); }
    inline bool isLetterOrNumber() const { return QChar::isLetterOrNumber(ucs); }
    inline bool isDigit() const { return QChar::isDigit(ucs); }
    inline bool isLower() const { return QChar::isLower(ucs); }
    inline bool isUpper() const { return QChar::isUpper(ucs); }
    inline bool isTitleCase() const { return QChar::isTitleCase(ucs); }

    inline bool isNonCharacter() const { return QChar::isNonCharacter(ucs); }
    inline bool isHighSurrogate() const { return QChar::isHighSurrogate(ucs); }
    inline bool isLowSurrogate() const { return QChar::isLowSurrogate(ucs); }
    inline bool isSurrogate() const { return QChar::isSurrogate(ucs); }

    inline uchar cell() const { return uchar(ucs & 0xff); }
    inline uchar row() const { return uchar((ucs>>8)&0xff); }
    inline void setCell(uchar cell);
    inline void setRow(uchar row);

    static inline bool isNonCharacter(uint ucs4) {
        return ucs4 >= 0xfdd0 && (ucs4 <= 0xfdef || (ucs4 & 0xfffe) == 0xfffe);
    }
    static inline bool isHighSurrogate(uint ucs4) {
        return ((ucs4 & 0xfffffc00) == 0xd800);
    }
    static inline bool isLowSurrogate(uint ucs4) {
        return ((ucs4 & 0xfffffc00) == 0xdc00);
    }
    static inline bool isSurrogate(uint ucs4) {
        return (ucs4 - 0xd800u < 2048u);
    }
    static inline bool requiresSurrogates(uint ucs4) {
        return (ucs4 >= 0x10000);
    }
    static inline uint surrogateToUcs4(ushort high, ushort low) {
        return (uint(high)<<10) + low - 0x35fdc00;
    }
    static inline uint surrogateToUcs4(QChar high, QChar low) {
        return surrogateToUcs4(high.unicode(), low.unicode());
    }
    static inline ushort highSurrogate(uint ucs4) {
        return ushort((ucs4>>10) + 0xd7c0);
    }
    static inline ushort lowSurrogate(uint ucs4) {
        return ushort(ucs4%0x400 + 0xdc00);
    }

    static Category __fastcall category(uint ucs4);
    static Direction __fastcall direction(uint ucs4);
    static JoiningType __fastcall joiningType(uint ucs4);

                  static Joining __fastcall joining(uint ucs4);

    static unsigned char __fastcall combiningClass(uint ucs4);

    static uint __fastcall mirroredChar(uint ucs4);
    static bool __fastcall hasMirrored(uint ucs4);

    static QString __fastcall decomposition(uint ucs4);
    static Decomposition __fastcall decompositionTag(uint ucs4);

    static int __fastcall digitValue(uint ucs4);
    static uint __fastcall toLower(uint ucs4);
    static uint __fastcall toUpper(uint ucs4);
    static uint __fastcall toTitleCase(uint ucs4);
    static uint __fastcall toCaseFolded(uint ucs4);

    static Script __fastcall script(uint ucs4);

    static UnicodeVersion __fastcall unicodeVersion(uint ucs4);

    static UnicodeVersion __fastcall currentUnicodeVersion();

    static bool __fastcall isPrint(uint ucs4);
    static inline bool isSpace(uint ucs4);
    static bool __fastcall isMark(uint ucs4);
    static bool __fastcall isPunct(uint ucs4);
    static bool __fastcall isSymbol(uint ucs4);
    static inline bool isLetter(uint ucs4);
    static inline bool isNumber(uint ucs4);
    static inline bool isLetterOrNumber(uint ucs4);
    static inline bool isDigit(uint ucs4);
    static inline bool isLower(uint ucs4);
    static inline bool isUpper(uint ucs4);
    static inline bool isTitleCase(uint ucs4);

private:
    static bool __fastcall isSpace_helper(uint ucs4);
    static bool __fastcall isLetter_helper(uint ucs4);
    static bool __fastcall isNumber_helper(uint ucs4);
    static bool __fastcall isLetterOrNumber_helper(uint ucs4);





    ushort ucs;
};

template<> class QTypeInfo<QChar > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QChar)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QChar >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QChar) }; static inline const char *name() { return "QChar"; } };

inline char QChar::toLatin1() const { return ucs > 0xff ? '\0' : char(ucs); }
inline QChar QChar::fromLatin1(char c) { return QChar(ushort(uchar(c))); }

inline void QChar::setCell(uchar acell)
{ ucs = ushort((ucs & 0xff00) + acell); }
inline void QChar::setRow(uchar arow)
{ ucs = ushort((ushort(arow)<<8) + (ucs&0xff)); }

inline bool QChar::isSpace(uint ucs4)
{

    return ucs4 == 0x20 || (ucs4 <= 0x0d && ucs4 >= 0x09)
            || (ucs4 > 127 && (ucs4 == 0x85 || ucs4 == 0xa0 || QChar::isSpace_helper(ucs4)));
}
inline bool QChar::isLetter(uint ucs4)
{
    return (ucs4 >= 'A' && ucs4 <= 'z' && (ucs4 >= 'a' || ucs4 <= 'Z'))
            || (ucs4 > 127 && QChar::isLetter_helper(ucs4));
}
inline bool QChar::isNumber(uint ucs4)
{ return (ucs4 <= '9' && ucs4 >= '0') || (ucs4 > 127 && QChar::isNumber_helper(ucs4)); }
inline bool QChar::isLetterOrNumber(uint ucs4)
{
    return (ucs4 >= 'A' && ucs4 <= 'z' && (ucs4 >= 'a' || ucs4 <= 'Z'))
            || (ucs4 >= '0' && ucs4 <= '9')
            || (ucs4 > 127 && QChar::isLetterOrNumber_helper(ucs4));
}
inline bool QChar::isDigit(uint ucs4)
{ return (ucs4 <= '9' && ucs4 >= '0') || (ucs4 > 127 && QChar::category(ucs4) == Number_DecimalDigit); }
inline bool QChar::isLower(uint ucs4)
{ return (ucs4 <= 'z' && ucs4 >= 'a') || (ucs4 > 127 && QChar::category(ucs4) == Letter_Lowercase); }
inline bool QChar::isUpper(uint ucs4)
{ return (ucs4 <= 'Z' && ucs4 >= 'A') || (ucs4 > 127 && QChar::category(ucs4) == Letter_Uppercase); }
inline bool QChar::isTitleCase(uint ucs4)
{ return ucs4 > 127 && QChar::category(ucs4) == Letter_Titlecase; }

inline bool operator==(QChar c1, QChar c2) { return c1.unicode() == c2.unicode(); }
inline bool operator!=(QChar c1, QChar c2) { return c1.unicode() != c2.unicode(); }
inline bool operator<=(QChar c1, QChar c2) { return c1.unicode() <= c2.unicode(); }
inline bool operator>=(QChar c1, QChar c2) { return c1.unicode() >= c2.unicode(); }
inline bool operator<(QChar c1, QChar c2) { return c1.unicode() < c2.unicode(); }
inline bool operator>(QChar c1, QChar c2) { return c1.unicode() > c2.unicode(); }


__declspec(dllimport) QDataStream &operator<<(QDataStream &, QChar);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QChar &);
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qrefcount.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qrefcount.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qrefcount.h"





namespace QtPrivate
{

class RefCount
{
public:
    inline bool ref() throw() {
        int count = atomic.load();

        if (count == 0)
            return false;

        if (count != -1)
            atomic.ref();
        return true;
    }

    inline bool deref() throw() {
        int count = atomic.load();

        if (count == 0)
            return false;

        if (count == -1)
            return true;
        return atomic.deref();
    }


    bool setSharable(bool sharable) throw()
    {
        ((!(!isShared())) ? qt_assert("!isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qrefcount.h",81) : qt_noop());
        if (sharable)
            return atomic.testAndSetRelaxed(0, 1);
        else
            return atomic.testAndSetRelaxed(1, 0);
    }

    bool isSharable() const throw()
    {

        return atomic.load() != 0;
    }


    bool isStatic() const throw()
    {

        return atomic.load() == -1;
    }

    bool isShared() const throw()
    {
        int count = atomic.load();
        return (count != 1) && (count != 0);
    }

    void initializeOwned() throw() { atomic.store(1); }
    void initializeUnsharable() throw() { atomic.store(0); }

    QBasicAtomicInt atomic;
};

}
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qnamespace.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qnamespace.h"
namespace



Qt {
#line 110 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qnamespace.h"
    enum GlobalColor {
        color0,
        color1,
        black,
        white,
        darkGray,
        gray,
        lightGray,
        red,
        green,
        blue,
        cyan,
        magenta,
        yellow,
        darkRed,
        darkGreen,
        darkBlue,
        darkCyan,
        darkMagenta,
        darkYellow,
        transparent
    };

    enum KeyboardModifier {
        NoModifier = 0x00000000,
        ShiftModifier = 0x02000000,
        ControlModifier = 0x04000000,
        AltModifier = 0x08000000,
        MetaModifier = 0x10000000,
        KeypadModifier = 0x20000000,
        GroupSwitchModifier = 0x40000000,

        KeyboardModifierMask = 0xfe000000
    };
    typedef QFlags<KeyboardModifier> KeyboardModifiers;






    enum Modifier {
        META = Qt::MetaModifier,
        SHIFT = Qt::ShiftModifier,
        CTRL = Qt::ControlModifier,
        ALT = Qt::AltModifier,
        MODIFIER_MASK = KeyboardModifierMask,
        UNICODE_ACCEL = 0x00000000
    };

    enum MouseButton {
        NoButton = 0x00000000,
        LeftButton = 0x00000001,
        RightButton = 0x00000002,
        MidButton = 0x00000004,
        MiddleButton = MidButton,
        BackButton = 0x00000008,
        XButton1 = BackButton,
        ExtraButton1 = XButton1,
        ForwardButton = 0x00000010,
        XButton2 = ForwardButton,
        ExtraButton2 = ForwardButton,
        TaskButton = 0x00000020,
        ExtraButton3 = TaskButton,
        ExtraButton4 = 0x00000040,
        ExtraButton5 = 0x00000080,
        ExtraButton6 = 0x00000100,
        ExtraButton7 = 0x00000200,
        ExtraButton8 = 0x00000400,
        ExtraButton9 = 0x00000800,
        ExtraButton10 = 0x00001000,
        ExtraButton11 = 0x00002000,
        ExtraButton12 = 0x00004000,
        ExtraButton13 = 0x00008000,
        ExtraButton14 = 0x00010000,
        ExtraButton15 = 0x00020000,
        ExtraButton16 = 0x00040000,
        ExtraButton17 = 0x00080000,
        ExtraButton18 = 0x00100000,
        ExtraButton19 = 0x00200000,
        ExtraButton20 = 0x00400000,
        ExtraButton21 = 0x00800000,
        ExtraButton22 = 0x01000000,
        ExtraButton23 = 0x02000000,
        ExtraButton24 = 0x04000000,
        AllButtons = 0x07ffffff,
        MaxMouseButton = ExtraButton24,

        MouseButtonMask = 0xffffffff
    };
    typedef QFlags<MouseButton> MouseButtons;

    enum Orientation {
        Horizontal = 0x1,
        Vertical = 0x2
    };

    typedef QFlags<Orientation> Orientations;

    enum FocusPolicy {
        NoFocus = 0,
        TabFocus = 0x1,
        ClickFocus = 0x2,
        StrongFocus = TabFocus | ClickFocus | 0x8,
        WheelFocus = StrongFocus | 0x4
    };

    enum SortOrder {
        AscendingOrder,
        DescendingOrder
    };

    enum TileRule {
        StretchTile,
        RepeatTile,
        RoundTile
    };





    enum AlignmentFlag {
        AlignLeft = 0x0001,
        AlignLeading = AlignLeft,
        AlignRight = 0x0002,
        AlignTrailing = AlignRight,
        AlignHCenter = 0x0004,
        AlignJustify = 0x0008,
        AlignAbsolute = 0x0010,
        AlignHorizontal_Mask = AlignLeft | AlignRight | AlignHCenter | AlignJustify | AlignAbsolute,

        AlignTop = 0x0020,
        AlignBottom = 0x0040,
        AlignVCenter = 0x0080,
        AlignBaseline = 0x0100,




        AlignVertical_Mask = AlignTop | AlignBottom | AlignVCenter | AlignBaseline,

        AlignCenter = AlignVCenter | AlignHCenter
    };

    typedef QFlags<AlignmentFlag> Alignment;

    enum TextFlag {
        TextSingleLine = 0x0100,
        TextDontClip = 0x0200,
        TextExpandTabs = 0x0400,
        TextShowMnemonic = 0x0800,
        TextWordWrap = 0x1000,
        TextWrapAnywhere = 0x2000,
        TextDontPrint = 0x4000,
        TextIncludeTrailingSpaces = 0x08000000,
        TextHideMnemonic = 0x8000,
        TextJustificationForced = 0x10000,
        TextForceLeftToRight = 0x20000,
        TextForceRightToLeft = 0x40000,


        TextLongestVariant = 0x80000,
        TextBypassShaping = 0x100000
    };

    enum TextElideMode {
        ElideLeft,
        ElideRight,
        ElideMiddle,
        ElideNone
    };

    enum WhiteSpaceMode {
        WhiteSpaceNormal,
        WhiteSpacePre,
        WhiteSpaceNoWrap,
        WhiteSpaceModeUndefined = -1
    };

    enum HitTestAccuracy { ExactHit, FuzzyHit };

    enum WindowType {
        Widget = 0x00000000,
        Window = 0x00000001,
        Dialog = 0x00000002 | Window,
        Sheet = 0x00000004 | Window,
        Drawer = Sheet | Dialog,
        Popup = 0x00000008 | Window,
        Tool = Popup | Dialog,
        ToolTip = Popup | Sheet,
        SplashScreen = ToolTip | Dialog,
        Desktop = 0x00000010 | Window,
        SubWindow = 0x00000012,
        ForeignWindow = 0x00000020 | Window,
        CoverWindow = 0x00000040 | Window,

        WindowType_Mask = 0x000000ff,
        MSWindowsFixedSizeDialogHint = 0x00000100,
        MSWindowsOwnDC = 0x00000200,
        BypassWindowManagerHint = 0x00000400,
        X11BypassWindowManagerHint = BypassWindowManagerHint,
        FramelessWindowHint = 0x00000800,
        WindowTitleHint = 0x00001000,
        WindowSystemMenuHint = 0x00002000,
        WindowMinimizeButtonHint = 0x00004000,
        WindowMaximizeButtonHint = 0x00008000,
        WindowMinMaxButtonsHint = WindowMinimizeButtonHint | WindowMaximizeButtonHint,
        WindowContextHelpButtonHint = 0x00010000,
        WindowShadeButtonHint = 0x00020000,
        WindowStaysOnTopHint = 0x00040000,
        WindowTransparentForInput = 0x00080000,
        WindowOverridesSystemGestures = 0x00100000,
        WindowDoesNotAcceptFocus = 0x00200000,

        CustomizeWindowHint = 0x02000000,
        WindowStaysOnBottomHint = 0x04000000,
        WindowCloseButtonHint = 0x08000000,
        MacWindowToolBarButtonHint = 0x10000000,
        BypassGraphicsProxyWidget = 0x20000000,
        WindowOkButtonHint = 0x00080000,
        WindowCancelButtonHint = 0x00100000,
        NoDropShadowWindowHint = 0x40000000,
        WindowFullscreenButtonHint = 0x80000000
    };

    typedef QFlags<WindowType> WindowFlags;

    enum WindowState {
        WindowNoState = 0x00000000,
        WindowMinimized = 0x00000001,
        WindowMaximized = 0x00000002,
        WindowFullScreen = 0x00000004,
        WindowActive = 0x00000008
    };

    typedef QFlags<WindowState> WindowStates;

    enum ApplicationState {
        ApplicationSuspended = 0x00000000,
        ApplicationHidden = 0x00000001,
        ApplicationInactive = 0x00000002,
        ApplicationActive = 0x00000004
    };

    typedef QFlags<ApplicationState> ApplicationStates;

    enum ScreenOrientation {
        PrimaryOrientation = 0x00000000,
        PortraitOrientation = 0x00000001,
        LandscapeOrientation = 0x00000002,
        InvertedPortraitOrientation = 0x00000004,
        InvertedLandscapeOrientation = 0x00000008
    };

    typedef QFlags<ScreenOrientation> ScreenOrientations;

    enum WidgetAttribute {
        WA_Disabled = 0,
        WA_UnderMouse = 1,
        WA_MouseTracking = 2,
        WA_ContentsPropagated = 3,
        WA_OpaquePaintEvent = 4,
        WA_NoBackground = WA_OpaquePaintEvent,
        WA_StaticContents = 5,
        WA_LaidOut = 7,
        WA_PaintOnScreen = 8,
        WA_NoSystemBackground = 9,
        WA_UpdatesDisabled = 10,
        WA_Mapped = 11,
        WA_MacNoClickThrough = 12,
        WA_InputMethodEnabled = 14,
        WA_WState_Visible = 15,
        WA_WState_Hidden = 16,

        WA_ForceDisabled = 32,
        WA_KeyCompression = 33,
        WA_PendingMoveEvent = 34,
        WA_PendingResizeEvent = 35,
        WA_SetPalette = 36,
        WA_SetFont = 37,
        WA_SetCursor = 38,
        WA_NoChildEventsFromChildren = 39,
        WA_WindowModified = 41,
        WA_Resized = 42,
        WA_Moved = 43,
        WA_PendingUpdate = 44,
        WA_InvalidSize = 45,
        WA_MacBrushedMetal = 46,
        WA_MacMetalStyle = WA_MacBrushedMetal,
        WA_CustomWhatsThis = 47,
        WA_LayoutOnEntireRect = 48,
        WA_OutsideWSRange = 49,
        WA_GrabbedShortcut = 50,
        WA_TransparentForMouseEvents = 51,
        WA_PaintUnclipped = 52,
        WA_SetWindowIcon = 53,
        WA_NoMouseReplay = 54,
        WA_DeleteOnClose = 55,
        WA_RightToLeft = 56,
        WA_SetLayoutDirection = 57,
        WA_NoChildEventsForParent = 58,
        WA_ForceUpdatesDisabled = 59,

        WA_WState_Created = 60,
        WA_WState_CompressKeys = 61,
        WA_WState_InPaintEvent = 62,
        WA_WState_Reparented = 63,
        WA_WState_ConfigPending = 64,
        WA_WState_Polished = 66,
        WA_WState_DND = 67,
        WA_WState_OwnSizePolicy = 68,
        WA_WState_ExplicitShowHide = 69,

        WA_ShowModal = 70,
        WA_MouseNoMask = 71,
        WA_GroupLeader = 72,
        WA_NoMousePropagation = 73,
        WA_Hover = 74,
        WA_InputMethodTransparent = 75,
        WA_QuitOnClose = 76,

        WA_KeyboardFocusChange = 77,

        WA_AcceptDrops = 78,
        WA_DropSiteRegistered = 79,
        WA_ForceAcceptDrops = WA_DropSiteRegistered,

        WA_WindowPropagation = 80,

        WA_NoX11EventCompression = 81,
        WA_TintedBackground = 82,
        WA_X11OpenGLOverlay = 83,
        WA_AlwaysShowToolTips = 84,
        WA_MacOpaqueSizeGrip = 85,
        WA_SetStyle = 86,

        WA_SetLocale = 87,
        WA_MacShowFocusRect = 88,

        WA_MacNormalSize = 89,
        WA_MacSmallSize = 90,
        WA_MacMiniSize = 91,

        WA_LayoutUsesWidgetRect = 92,
        WA_StyledBackground = 93,
        WA_MSWindowsUseDirect3D = 94,
        WA_CanHostQMdiSubWindowTitleBar = 95,

        WA_MacAlwaysShowToolWindow = 96,

        WA_StyleSheet = 97,

        WA_ShowWithoutActivating = 98,

        WA_X11BypassTransientForHint = 99,

        WA_NativeWindow = 100,
        WA_DontCreateNativeAncestors = 101,

        WA_MacVariableSize = 102,

        WA_DontShowOnScreen = 103,


        WA_X11NetWmWindowTypeDesktop = 104,
        WA_X11NetWmWindowTypeDock = 105,
        WA_X11NetWmWindowTypeToolBar = 106,
        WA_X11NetWmWindowTypeMenu = 107,
        WA_X11NetWmWindowTypeUtility = 108,
        WA_X11NetWmWindowTypeSplash = 109,
        WA_X11NetWmWindowTypeDialog = 110,
        WA_X11NetWmWindowTypeDropDownMenu = 111,
        WA_X11NetWmWindowTypePopupMenu = 112,
        WA_X11NetWmWindowTypeToolTip = 113,
        WA_X11NetWmWindowTypeNotification = 114,
        WA_X11NetWmWindowTypeCombo = 115,
        WA_X11NetWmWindowTypeDND = 116,

        WA_MacFrameworkScaled = 117,

        WA_SetWindowModality = 118,
        WA_WState_WindowOpacitySet = 119,
        WA_TranslucentBackground = 120,

        WA_AcceptTouchEvents = 121,
        WA_WState_AcceptedTouchBeginEvent = 122,
        WA_TouchPadAcceptSingleTouchEvents = 123,

        WA_X11DoNotAcceptFocus = 126,
        WA_MacNoShadow = 127,


        WA_AttributeCount
    };

    enum ApplicationAttribute
    {
        AA_ImmediateWidgetCreation = 0,
        AA_MSWindowsUseDirect3DByDefault = 1,
        AA_DontShowIconsInMenus = 2,
        AA_NativeWindows = 3,
        AA_DontCreateNativeWidgetSiblings = 4,
        AA_MacPluginApplication = 5,
        AA_DontUseNativeMenuBar = 6,
        AA_MacDontSwapCtrlAndMeta = 7,
        AA_Use96Dpi = 8,
        AA_X11InitThreads = 10,
        AA_SynthesizeTouchForUnhandledMouseEvents = 11,
        AA_SynthesizeMouseForUnhandledTouchEvents = 12,
        AA_UseHighDpiPixmaps = 13,
        AA_ForceRasterWidgets = 14,
        AA_UseDesktopOpenGL = 15,
        AA_UseOpenGLES = 16,


        AA_AttributeCount
    };





    enum ImageConversionFlag {
        ColorMode_Mask = 0x00000003,
        AutoColor = 0x00000000,
        ColorOnly = 0x00000003,
        MonoOnly = 0x00000002,


        AlphaDither_Mask = 0x0000000c,
        ThresholdAlphaDither = 0x00000000,
        OrderedAlphaDither = 0x00000004,
        DiffuseAlphaDither = 0x00000008,
        NoAlpha = 0x0000000c,

        Dither_Mask = 0x00000030,
        DiffuseDither = 0x00000000,
        OrderedDither = 0x00000010,
        ThresholdDither = 0x00000020,


        DitherMode_Mask = 0x000000c0,
        AutoDither = 0x00000000,
        PreferDither = 0x00000040,
        AvoidDither = 0x00000080,

        NoOpaqueDetection = 0x00000100,
        NoFormatConversion = 0x00000200
    };
    typedef QFlags<ImageConversionFlag> ImageConversionFlags;

    enum BGMode {
        TransparentMode,
        OpaqueMode
    };

    enum Key {
        Key_Escape = 0x01000000,
        Key_Tab = 0x01000001,
        Key_Backtab = 0x01000002,
        Key_Backspace = 0x01000003,
        Key_Return = 0x01000004,
        Key_Enter = 0x01000005,
        Key_Insert = 0x01000006,
        Key_Delete = 0x01000007,
        Key_Pause = 0x01000008,
        Key_Print = 0x01000009,
        Key_SysReq = 0x0100000a,
        Key_Clear = 0x0100000b,
        Key_Home = 0x01000010,
        Key_End = 0x01000011,
        Key_Left = 0x01000012,
        Key_Up = 0x01000013,
        Key_Right = 0x01000014,
        Key_Down = 0x01000015,
        Key_PageUp = 0x01000016,
        Key_PageDown = 0x01000017,
        Key_Shift = 0x01000020,
        Key_Control = 0x01000021,
        Key_Meta = 0x01000022,
        Key_Alt = 0x01000023,
        Key_CapsLock = 0x01000024,
        Key_NumLock = 0x01000025,
        Key_ScrollLock = 0x01000026,
        Key_F1 = 0x01000030,
        Key_F2 = 0x01000031,
        Key_F3 = 0x01000032,
        Key_F4 = 0x01000033,
        Key_F5 = 0x01000034,
        Key_F6 = 0x01000035,
        Key_F7 = 0x01000036,
        Key_F8 = 0x01000037,
        Key_F9 = 0x01000038,
        Key_F10 = 0x01000039,
        Key_F11 = 0x0100003a,
        Key_F12 = 0x0100003b,
        Key_F13 = 0x0100003c,
        Key_F14 = 0x0100003d,
        Key_F15 = 0x0100003e,
        Key_F16 = 0x0100003f,
        Key_F17 = 0x01000040,
        Key_F18 = 0x01000041,
        Key_F19 = 0x01000042,
        Key_F20 = 0x01000043,
        Key_F21 = 0x01000044,
        Key_F22 = 0x01000045,
        Key_F23 = 0x01000046,
        Key_F24 = 0x01000047,
        Key_F25 = 0x01000048,
        Key_F26 = 0x01000049,
        Key_F27 = 0x0100004a,
        Key_F28 = 0x0100004b,
        Key_F29 = 0x0100004c,
        Key_F30 = 0x0100004d,
        Key_F31 = 0x0100004e,
        Key_F32 = 0x0100004f,
        Key_F33 = 0x01000050,
        Key_F34 = 0x01000051,
        Key_F35 = 0x01000052,
        Key_Super_L = 0x01000053,
        Key_Super_R = 0x01000054,
        Key_Menu = 0x01000055,
        Key_Hyper_L = 0x01000056,
        Key_Hyper_R = 0x01000057,
        Key_Help = 0x01000058,
        Key_Direction_L = 0x01000059,
        Key_Direction_R = 0x01000060,
        Key_Space = 0x20,
        Key_Any = Key_Space,
        Key_Exclam = 0x21,
        Key_QuoteDbl = 0x22,
        Key_NumberSign = 0x23,
        Key_Dollar = 0x24,
        Key_Percent = 0x25,
        Key_Ampersand = 0x26,
        Key_Apostrophe = 0x27,
        Key_ParenLeft = 0x28,
        Key_ParenRight = 0x29,
        Key_Asterisk = 0x2a,
        Key_Plus = 0x2b,
        Key_Comma = 0x2c,
        Key_Minus = 0x2d,
        Key_Period = 0x2e,
        Key_Slash = 0x2f,
        Key_0 = 0x30,
        Key_1 = 0x31,
        Key_2 = 0x32,
        Key_3 = 0x33,
        Key_4 = 0x34,
        Key_5 = 0x35,
        Key_6 = 0x36,
        Key_7 = 0x37,
        Key_8 = 0x38,
        Key_9 = 0x39,
        Key_Colon = 0x3a,
        Key_Semicolon = 0x3b,
        Key_Less = 0x3c,
        Key_Equal = 0x3d,
        Key_Greater = 0x3e,
        Key_Question = 0x3f,
        Key_At = 0x40,
        Key_A = 0x41,
        Key_B = 0x42,
        Key_C = 0x43,
        Key_D = 0x44,
        Key_E = 0x45,
        Key_F = 0x46,
        Key_G = 0x47,
        Key_H = 0x48,
        Key_I = 0x49,
        Key_J = 0x4a,
        Key_K = 0x4b,
        Key_L = 0x4c,
        Key_M = 0x4d,
        Key_N = 0x4e,
        Key_O = 0x4f,
        Key_P = 0x50,
        Key_Q = 0x51,
        Key_R = 0x52,
        Key_S = 0x53,
        Key_T = 0x54,
        Key_U = 0x55,
        Key_V = 0x56,
        Key_W = 0x57,
        Key_X = 0x58,
        Key_Y = 0x59,
        Key_Z = 0x5a,
        Key_BracketLeft = 0x5b,
        Key_Backslash = 0x5c,
        Key_BracketRight = 0x5d,
        Key_AsciiCircum = 0x5e,
        Key_Underscore = 0x5f,
        Key_QuoteLeft = 0x60,
        Key_BraceLeft = 0x7b,
        Key_Bar = 0x7c,
        Key_BraceRight = 0x7d,
        Key_AsciiTilde = 0x7e,

        Key_nobreakspace = 0x0a0,
        Key_exclamdown = 0x0a1,
        Key_cent = 0x0a2,
        Key_sterling = 0x0a3,
        Key_currency = 0x0a4,
        Key_yen = 0x0a5,
        Key_brokenbar = 0x0a6,
        Key_section = 0x0a7,
        Key_diaeresis = 0x0a8,
        Key_copyright = 0x0a9,
        Key_ordfeminine = 0x0aa,
        Key_guillemotleft = 0x0ab,
        Key_notsign = 0x0ac,
        Key_hyphen = 0x0ad,
        Key_registered = 0x0ae,
        Key_macron = 0x0af,
        Key_degree = 0x0b0,
        Key_plusminus = 0x0b1,
        Key_twosuperior = 0x0b2,
        Key_threesuperior = 0x0b3,
        Key_acute = 0x0b4,
        Key_mu = 0x0b5,
        Key_paragraph = 0x0b6,
        Key_periodcentered = 0x0b7,
        Key_cedilla = 0x0b8,
        Key_onesuperior = 0x0b9,
        Key_masculine = 0x0ba,
        Key_guillemotright = 0x0bb,
        Key_onequarter = 0x0bc,
        Key_onehalf = 0x0bd,
        Key_threequarters = 0x0be,
        Key_questiondown = 0x0bf,
        Key_Agrave = 0x0c0,
        Key_Aacute = 0x0c1,
        Key_Acircumflex = 0x0c2,
        Key_Atilde = 0x0c3,
        Key_Adiaeresis = 0x0c4,
        Key_Aring = 0x0c5,
        Key_AE = 0x0c6,
        Key_Ccedilla = 0x0c7,
        Key_Egrave = 0x0c8,
        Key_Eacute = 0x0c9,
        Key_Ecircumflex = 0x0ca,
        Key_Ediaeresis = 0x0cb,
        Key_Igrave = 0x0cc,
        Key_Iacute = 0x0cd,
        Key_Icircumflex = 0x0ce,
        Key_Idiaeresis = 0x0cf,
        Key_ETH = 0x0d0,
        Key_Ntilde = 0x0d1,
        Key_Ograve = 0x0d2,
        Key_Oacute = 0x0d3,
        Key_Ocircumflex = 0x0d4,
        Key_Otilde = 0x0d5,
        Key_Odiaeresis = 0x0d6,
        Key_multiply = 0x0d7,
        Key_Ooblique = 0x0d8,
        Key_Ugrave = 0x0d9,
        Key_Uacute = 0x0da,
        Key_Ucircumflex = 0x0db,
        Key_Udiaeresis = 0x0dc,
        Key_Yacute = 0x0dd,
        Key_THORN = 0x0de,
        Key_ssharp = 0x0df,
        Key_division = 0x0f7,
        Key_ydiaeresis = 0x0ff,






        Key_AltGr = 0x01001103,
        Key_Multi_key = 0x01001120,
        Key_Codeinput = 0x01001137,
        Key_SingleCandidate = 0x0100113c,
        Key_MultipleCandidate = 0x0100113d,
        Key_PreviousCandidate = 0x0100113e,


        Key_Mode_switch = 0x0100117e,



        Key_Kanji = 0x01001121,
        Key_Muhenkan = 0x01001122,

        Key_Henkan = 0x01001123,
        Key_Romaji = 0x01001124,
        Key_Hiragana = 0x01001125,
        Key_Katakana = 0x01001126,
        Key_Hiragana_Katakana = 0x01001127,
        Key_Zenkaku = 0x01001128,
        Key_Hankaku = 0x01001129,
        Key_Zenkaku_Hankaku = 0x0100112a,
        Key_Touroku = 0x0100112b,
        Key_Massyo = 0x0100112c,
        Key_Kana_Lock = 0x0100112d,
        Key_Kana_Shift = 0x0100112e,
        Key_Eisu_Shift = 0x0100112f,
        Key_Eisu_toggle = 0x01001130,
#line 819 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qnamespace.h"
        Key_Hangul = 0x01001131,
        Key_Hangul_Start = 0x01001132,
        Key_Hangul_End = 0x01001133,
        Key_Hangul_Hanja = 0x01001134,
        Key_Hangul_Jamo = 0x01001135,
        Key_Hangul_Romaja = 0x01001136,

        Key_Hangul_Jeonja = 0x01001138,
        Key_Hangul_Banja = 0x01001139,
        Key_Hangul_PreHanja = 0x0100113a,
        Key_Hangul_PostHanja = 0x0100113b,



        Key_Hangul_Special = 0x0100113f,



        Key_Dead_Grave = 0x01001250,
        Key_Dead_Acute = 0x01001251,
        Key_Dead_Circumflex = 0x01001252,
        Key_Dead_Tilde = 0x01001253,
        Key_Dead_Macron = 0x01001254,
        Key_Dead_Breve = 0x01001255,
        Key_Dead_Abovedot = 0x01001256,
        Key_Dead_Diaeresis = 0x01001257,
        Key_Dead_Abovering = 0x01001258,
        Key_Dead_Doubleacute = 0x01001259,
        Key_Dead_Caron = 0x0100125a,
        Key_Dead_Cedilla = 0x0100125b,
        Key_Dead_Ogonek = 0x0100125c,
        Key_Dead_Iota = 0x0100125d,
        Key_Dead_Voiced_Sound = 0x0100125e,
        Key_Dead_Semivoiced_Sound = 0x0100125f,
        Key_Dead_Belowdot = 0x01001260,
        Key_Dead_Hook = 0x01001261,
        Key_Dead_Horn = 0x01001262,


        Key_Back = 0x01000061,
        Key_Forward = 0x01000062,
        Key_Stop = 0x01000063,
        Key_Refresh = 0x01000064,
        Key_VolumeDown = 0x01000070,
        Key_VolumeMute = 0x01000071,
        Key_VolumeUp = 0x01000072,
        Key_BassBoost = 0x01000073,
        Key_BassUp = 0x01000074,
        Key_BassDown = 0x01000075,
        Key_TrebleUp = 0x01000076,
        Key_TrebleDown = 0x01000077,
        Key_MediaPlay = 0x01000080,
        Key_MediaStop = 0x01000081,
        Key_MediaPrevious = 0x01000082,
        Key_MediaNext = 0x01000083,
        Key_MediaRecord = 0x01000084,
        Key_MediaPause = 0x1000085,
        Key_MediaTogglePlayPause = 0x1000086,
        Key_HomePage = 0x01000090,
        Key_Favorites = 0x01000091,
        Key_Search = 0x01000092,
        Key_Standby = 0x01000093,
        Key_OpenUrl = 0x01000094,
        Key_LaunchMail = 0x010000a0,
        Key_LaunchMedia = 0x010000a1,
        Key_Launch0 = 0x010000a2,
        Key_Launch1 = 0x010000a3,
        Key_Launch2 = 0x010000a4,
        Key_Launch3 = 0x010000a5,
        Key_Launch4 = 0x010000a6,
        Key_Launch5 = 0x010000a7,
        Key_Launch6 = 0x010000a8,
        Key_Launch7 = 0x010000a9,
        Key_Launch8 = 0x010000aa,
        Key_Launch9 = 0x010000ab,
        Key_LaunchA = 0x010000ac,
        Key_LaunchB = 0x010000ad,
        Key_LaunchC = 0x010000ae,
        Key_LaunchD = 0x010000af,
        Key_LaunchE = 0x010000b0,
        Key_LaunchF = 0x010000b1,
        Key_MonBrightnessUp = 0x010000b2,
        Key_MonBrightnessDown = 0x010000b3,
        Key_KeyboardLightOnOff = 0x010000b4,
        Key_KeyboardBrightnessUp = 0x010000b5,
        Key_KeyboardBrightnessDown = 0x010000b6,
        Key_PowerOff = 0x010000b7,
        Key_WakeUp = 0x010000b8,
        Key_Eject = 0x010000b9,
        Key_ScreenSaver = 0x010000ba,
        Key_WWW = 0x010000bb,
        Key_Memo = 0x010000bc,
        Key_LightBulb = 0x010000bd,
        Key_Shop = 0x010000be,
        Key_History = 0x010000bf,
        Key_AddFavorite = 0x010000c0,
        Key_HotLinks = 0x010000c1,
        Key_BrightnessAdjust = 0x010000c2,
        Key_Finance = 0x010000c3,
        Key_Community = 0x010000c4,
        Key_AudioRewind = 0x010000c5,
        Key_BackForward = 0x010000c6,
        Key_ApplicationLeft = 0x010000c7,
        Key_ApplicationRight = 0x010000c8,
        Key_Book = 0x010000c9,
        Key_CD = 0x010000ca,
        Key_Calculator = 0x010000cb,
        Key_ToDoList = 0x010000cc,
        Key_ClearGrab = 0x010000cd,
        Key_Close = 0x010000ce,
        Key_Copy = 0x010000cf,
        Key_Cut = 0x010000d0,
        Key_Display = 0x010000d1,
        Key_DOS = 0x010000d2,
        Key_Documents = 0x010000d3,
        Key_Excel = 0x010000d4,
        Key_Explorer = 0x010000d5,
        Key_Game = 0x010000d6,
        Key_Go = 0x010000d7,
        Key_iTouch = 0x010000d8,
        Key_LogOff = 0x010000d9,
        Key_Market = 0x010000da,
        Key_Meeting = 0x010000db,
        Key_MenuKB = 0x010000dc,
        Key_MenuPB = 0x010000dd,
        Key_MySites = 0x010000de,
        Key_News = 0x010000df,
        Key_OfficeHome = 0x010000e0,
        Key_Option = 0x010000e1,
        Key_Paste = 0x010000e2,
        Key_Phone = 0x010000e3,
        Key_Calendar = 0x010000e4,
        Key_Reply = 0x010000e5,
        Key_Reload = 0x010000e6,
        Key_RotateWindows = 0x010000e7,
        Key_RotationPB = 0x010000e8,
        Key_RotationKB = 0x010000e9,
        Key_Save = 0x010000ea,
        Key_Send = 0x010000eb,
        Key_Spell = 0x010000ec,
        Key_SplitScreen = 0x010000ed,
        Key_Support = 0x010000ee,
        Key_TaskPane = 0x010000ef,
        Key_Terminal = 0x010000f0,
        Key_Tools = 0x010000f1,
        Key_Travel = 0x010000f2,
        Key_Video = 0x010000f3,
        Key_Word = 0x010000f4,
        Key_Xfer = 0x010000f5,
        Key_ZoomIn = 0x010000f6,
        Key_ZoomOut = 0x010000f7,
        Key_Away = 0x010000f8,
        Key_Messenger = 0x010000f9,
        Key_WebCam = 0x010000fa,
        Key_MailForward = 0x010000fb,
        Key_Pictures = 0x010000fc,
        Key_Music = 0x010000fd,
        Key_Battery = 0x010000fe,
        Key_Bluetooth = 0x010000ff,
        Key_WLAN = 0x01000100,
        Key_UWB = 0x01000101,
        Key_AudioForward = 0x01000102,
        Key_AudioRepeat = 0x01000103,
        Key_AudioRandomPlay = 0x01000104,
        Key_Subtitle = 0x01000105,
        Key_AudioCycleTrack = 0x01000106,
        Key_Time = 0x01000107,
        Key_Hibernate = 0x01000108,
        Key_View = 0x01000109,
        Key_TopMenu = 0x0100010a,
        Key_PowerDown = 0x0100010b,
        Key_Suspend = 0x0100010c,
        Key_ContrastAdjust = 0x0100010d,

        Key_LaunchG = 0x0100010e,
        Key_LaunchH = 0x0100010f,

        Key_TouchpadToggle = 0x01000110,
        Key_TouchpadOn = 0x01000111,
        Key_TouchpadOff = 0x01000112,

        Key_MicMute = 0x01000113,

        Key_Red = 0x01000114,
        Key_Green = 0x01000115,
        Key_Yellow = 0x01000116,
        Key_Blue = 0x01000117,

        Key_ChannelUp = 0x01000118,
        Key_ChannelDown = 0x01000119,

        Key_Guide = 0x0100011a,
        Key_Info = 0x0100011b,
        Key_Settings = 0x0100011c,

        Key_MediaLast = 0x0100ffff,


        Key_Select = 0x01010000,
        Key_Yes = 0x01010001,
        Key_No = 0x01010002,


        Key_Cancel = 0x01020001,
        Key_Printer = 0x01020002,
        Key_Execute = 0x01020003,
        Key_Sleep = 0x01020004,
        Key_Play = 0x01020005,
        Key_Zoom = 0x01020006,



        Key_Exit = 0x0102000a,


        Key_Context1 = 0x01100000,
        Key_Context2 = 0x01100001,
        Key_Context3 = 0x01100002,
        Key_Context4 = 0x01100003,
        Key_Call = 0x01100004,
        Key_Hangup = 0x01100005,
        Key_Flip = 0x01100006,
        Key_ToggleCallHangup = 0x01100007,
        Key_VoiceDial = 0x01100008,
        Key_LastNumberRedial = 0x01100009,

        Key_Camera = 0x01100020,
        Key_CameraFocus = 0x01100021,

        Key_unknown = 0x01ffffff
    };

    enum ArrowType {
        NoArrow,
        UpArrow,
        DownArrow,
        LeftArrow,
        RightArrow
    };

    enum PenStyle {
        NoPen,
        SolidLine,
        DashLine,
        DotLine,
        DashDotLine,
        DashDotDotLine,
        CustomDashLine

        , MPenStyle = 0x0f

    };

    enum PenCapStyle {
        FlatCap = 0x00,
        SquareCap = 0x10,
        RoundCap = 0x20,
        MPenCapStyle = 0x30
    };

    enum PenJoinStyle {
        MiterJoin = 0x00,
        BevelJoin = 0x40,
        RoundJoin = 0x80,
        SvgMiterJoin = 0x100,
        MPenJoinStyle = 0x1c0
    };

    enum BrushStyle {
        NoBrush,
        SolidPattern,
        Dense1Pattern,
        Dense2Pattern,
        Dense3Pattern,
        Dense4Pattern,
        Dense5Pattern,
        Dense6Pattern,
        Dense7Pattern,
        HorPattern,
        VerPattern,
        CrossPattern,
        BDiagPattern,
        FDiagPattern,
        DiagCrossPattern,
        LinearGradientPattern,
        RadialGradientPattern,
        ConicalGradientPattern,
        TexturePattern = 24
    };

    enum SizeMode {
        AbsoluteSize,
        RelativeSize
    };

    enum UIEffect {
        UI_General,
        UI_AnimateMenu,
        UI_FadeMenu,
        UI_AnimateCombo,
        UI_AnimateTooltip,
        UI_FadeTooltip,
        UI_AnimateToolBox
    };

    enum CursorShape {
        ArrowCursor,
        UpArrowCursor,
        CrossCursor,
        WaitCursor,
        IBeamCursor,
        SizeVerCursor,
        SizeHorCursor,
        SizeBDiagCursor,
        SizeFDiagCursor,
        SizeAllCursor,
        BlankCursor,
        SplitVCursor,
        SplitHCursor,
        PointingHandCursor,
        ForbiddenCursor,
        WhatsThisCursor,
        BusyCursor,
        OpenHandCursor,
        ClosedHandCursor,
        DragCopyCursor,
        DragMoveCursor,
        DragLinkCursor,
        LastCursor = DragLinkCursor,
        BitmapCursor = 24,
        CustomCursor = 25
    };

    enum TextFormat {
        PlainText,
        RichText,
        AutoText
    };

    enum AspectRatioMode {
        IgnoreAspectRatio,
        KeepAspectRatio,
        KeepAspectRatioByExpanding
    };

    enum DockWidgetArea {
        LeftDockWidgetArea = 0x1,
        RightDockWidgetArea = 0x2,
        TopDockWidgetArea = 0x4,
        BottomDockWidgetArea = 0x8,

        DockWidgetArea_Mask = 0xf,
        AllDockWidgetAreas = DockWidgetArea_Mask,
        NoDockWidgetArea = 0
    };
    enum DockWidgetAreaSizes {
        NDockWidgetAreas = 4
    };

    typedef QFlags<DockWidgetArea> DockWidgetAreas;

    enum ToolBarArea {
        LeftToolBarArea = 0x1,
        RightToolBarArea = 0x2,
        TopToolBarArea = 0x4,
        BottomToolBarArea = 0x8,

        ToolBarArea_Mask = 0xf,
        AllToolBarAreas = ToolBarArea_Mask,
        NoToolBarArea = 0
    };

    enum ToolBarAreaSizes {
        NToolBarAreas = 4
    };

    typedef QFlags<ToolBarArea> ToolBarAreas;

    enum DateFormat {
        TextDate,
        ISODate,
        SystemLocaleDate,
        LocalDate = SystemLocaleDate,
        LocaleDate,
        SystemLocaleShortDate,
        SystemLocaleLongDate,
        DefaultLocaleShortDate,
        DefaultLocaleLongDate,
        RFC2822Date
    };

    enum TimeSpec {
        LocalTime,
        UTC,
        OffsetFromUTC,
        TimeZone
    };

    enum DayOfWeek {
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6,
        Sunday = 7
    };

    enum ScrollBarPolicy {
        ScrollBarAsNeeded,
        ScrollBarAlwaysOff,
        ScrollBarAlwaysOn
    };

    enum CaseSensitivity {
        CaseInsensitive,
        CaseSensitive
    };

    enum Corner {
        TopLeftCorner = 0x00000,
        TopRightCorner = 0x00001,
        BottomLeftCorner = 0x00002,
        BottomRightCorner = 0x00003
    };

    enum Edge {
        TopEdge = 0x00001,
        LeftEdge = 0x00002,
        RightEdge = 0x00004,
        BottomEdge = 0x00008
    };

    typedef QFlags<Edge> Edges;

    enum ConnectionType {
        AutoConnection,
        DirectConnection,
        QueuedConnection,
        BlockingQueuedConnection,
        UniqueConnection = 0x80
    };

    enum ShortcutContext {
        WidgetShortcut,
        WindowShortcut,
        ApplicationShortcut,
        WidgetWithChildrenShortcut
    };

    enum FillRule {
        OddEvenFill,
        WindingFill
    };

    enum MaskMode {
        MaskInColor,
        MaskOutColor
    };

    enum ClipOperation {
        NoClip,
        ReplaceClip,
        IntersectClip
    };


    enum ItemSelectionMode {
        ContainsItemShape = 0x0,
        IntersectsItemShape = 0x1,
        ContainsItemBoundingRect = 0x2,
        IntersectsItemBoundingRect = 0x3
    };

    enum TransformationMode {
        FastTransformation,
        SmoothTransformation
    };

    enum Axis {
        XAxis,
        YAxis,
        ZAxis
    };

    enum FocusReason {
        MouseFocusReason,
        TabFocusReason,
        BacktabFocusReason,
        ActiveWindowFocusReason,
        PopupFocusReason,
        ShortcutFocusReason,
        MenuBarFocusReason,
        OtherFocusReason,
        NoFocusReason
    };

    enum ContextMenuPolicy {
        NoContextMenu,
        DefaultContextMenu,
        ActionsContextMenu,
        CustomContextMenu,
        PreventContextMenu
    };

    enum InputMethodQuery {
        ImEnabled = 0x1,
        ImCursorRectangle = 0x2,
        ImMicroFocus = 0x2,
        ImFont = 0x4,
        ImCursorPosition = 0x8,
        ImSurroundingText = 0x10,
        ImCurrentSelection = 0x20,
        ImMaximumTextLength = 0x40,
        ImAnchorPosition = 0x80,
        ImHints = 0x100,
        ImPreferredLanguage = 0x200,

        ImAbsolutePosition = 0x400,
        ImTextBeforeCursor = 0x800,
        ImTextAfterCursor = 0x1000,

        ImPlatformData = 0x80000000,
        ImQueryInput = ImCursorRectangle | ImCursorPosition | ImSurroundingText |
                       ImCurrentSelection | ImAnchorPosition,
        ImQueryAll = 0xffffffff
    };
    typedef QFlags<InputMethodQuery> InputMethodQueries;

    enum InputMethodHint {
        ImhNone = 0x0,

        ImhHiddenText = 0x1,
        ImhSensitiveData = 0x2,
        ImhNoAutoUppercase = 0x4,
        ImhPreferNumbers = 0x8,
        ImhPreferUppercase = 0x10,
        ImhPreferLowercase = 0x20,
        ImhNoPredictiveText = 0x40,

        ImhDate = 0x80,
        ImhTime = 0x100,

        ImhPreferLatin = 0x200,

        ImhMultiLine = 0x400,

        ImhDigitsOnly = 0x10000,
        ImhFormattedNumbersOnly = 0x20000,
        ImhUppercaseOnly = 0x40000,
        ImhLowercaseOnly = 0x80000,
        ImhDialableCharactersOnly = 0x100000,
        ImhEmailCharactersOnly = 0x200000,
        ImhUrlCharactersOnly = 0x400000,
        ImhLatinOnly = 0x800000,

        ImhExclusiveInputMask = 0xffff0000
    };
    typedef QFlags<InputMethodHint> InputMethodHints;

    enum ToolButtonStyle {
        ToolButtonIconOnly,
        ToolButtonTextOnly,
        ToolButtonTextBesideIcon,
        ToolButtonTextUnderIcon,
        ToolButtonFollowStyle
    };

    enum LayoutDirection {
        LeftToRight,
        RightToLeft,
        LayoutDirectionAuto
    };

    enum AnchorPoint {
        AnchorLeft = 0,
        AnchorHorizontalCenter,
        AnchorRight,
        AnchorTop,
        AnchorVerticalCenter,
        AnchorBottom
    };

    enum FindChildOption {
        FindDirectChildrenOnly = 0x0,
        FindChildrenRecursively = 0x1
    };
    typedef QFlags<FindChildOption> FindChildOptions;

    enum DropAction {
        CopyAction = 0x1,
        MoveAction = 0x2,
        LinkAction = 0x4,
        ActionMask = 0xff,
        TargetMoveAction = 0x8002,
        IgnoreAction = 0x0
    };
    typedef QFlags<DropAction> DropActions;

    enum CheckState {
        Unchecked,
        PartiallyChecked,
        Checked
    };

    enum ItemDataRole {
        DisplayRole = 0,
        DecorationRole = 1,
        EditRole = 2,
        ToolTipRole = 3,
        StatusTipRole = 4,
        WhatsThisRole = 5,

        FontRole = 6,
        TextAlignmentRole = 7,
        BackgroundColorRole = 8,
        BackgroundRole = 8,
        TextColorRole = 9,
        ForegroundRole = 9,
        CheckStateRole = 10,

        AccessibleTextRole = 11,
        AccessibleDescriptionRole = 12,

        SizeHintRole = 13,
        InitialSortOrderRole = 14,

        DisplayPropertyRole = 27,
        DecorationPropertyRole = 28,
        ToolTipPropertyRole = 29,
        StatusTipPropertyRole = 30,
        WhatsThisPropertyRole = 31,

        UserRole = 0x0100
    };

    enum ItemFlag {
        NoItemFlags = 0,
        ItemIsSelectable = 1,
        ItemIsEditable = 2,
        ItemIsDragEnabled = 4,
        ItemIsDropEnabled = 8,
        ItemIsUserCheckable = 16,
        ItemIsEnabled = 32,
        ItemIsTristate = 64,
        ItemNeverHasChildren = 128
    };
    typedef QFlags<ItemFlag> ItemFlags;

    enum MatchFlag {
        MatchExactly = 0,
        MatchContains = 1,
        MatchStartsWith = 2,
        MatchEndsWith = 3,
        MatchRegExp = 4,
        MatchWildcard = 5,
        MatchFixedString = 8,
        MatchCaseSensitive = 16,
        MatchWrap = 32,
        MatchRecursive = 64
    };
    typedef QFlags<MatchFlag> MatchFlags;

    typedef void * HANDLE;




    enum WindowModality {
        NonModal,
        WindowModal,
        ApplicationModal
    };

    enum TextInteractionFlag {
        NoTextInteraction = 0,
        TextSelectableByMouse = 1,
        TextSelectableByKeyboard = 2,
        LinksAccessibleByMouse = 4,
        LinksAccessibleByKeyboard = 8,
        TextEditable = 16,

        TextEditorInteraction = TextSelectableByMouse | TextSelectableByKeyboard | TextEditable,
        TextBrowserInteraction = TextSelectableByMouse | LinksAccessibleByMouse | LinksAccessibleByKeyboard
    };
    typedef QFlags<TextInteractionFlag> TextInteractionFlags;

    enum EventPriority {
        HighEventPriority = 1,
        NormalEventPriority = 0,
        LowEventPriority = -1
    };

    enum SizeHint {
        MinimumSize,
        PreferredSize,
        MaximumSize,
        MinimumDescent,
        NSizeHints
    };

    enum WindowFrameSection {
        NoSection,
        LeftSection,
        TopLeftSection,
        TopSection,
        TopRightSection,
        RightSection,
        BottomRightSection,
        BottomSection,
        BottomLeftSection,
        TitleBarArea
    };

    enum Initialization {
        Uninitialized
    };

    enum CoordinateSystem {
        DeviceCoordinates,
        LogicalCoordinates
    };

    enum TouchPointState {
        TouchPointPressed = 0x01,
        TouchPointMoved = 0x02,
        TouchPointStationary = 0x04,
        TouchPointReleased = 0x08
    };
    typedef QFlags<TouchPointState> TouchPointStates;


    enum GestureState
    {
        NoGesture,
        GestureStarted = 1,
        GestureUpdated = 2,
        GestureFinished = 3,
        GestureCanceled = 4
    };

    enum GestureType
    {
        TapGesture = 1,
        TapAndHoldGesture = 2,
        PanGesture = 3,
        PinchGesture = 4,
        SwipeGesture = 5,

        CustomGesture = 0x0100,

        LastGestureType = ~0u
    };

    enum GestureFlag
    {
        DontStartGestureOnChildren = 0x01,
        ReceivePartialGestures = 0x02,
        IgnoredGesturesPropagateToParent = 0x04
    };
    typedef QFlags<GestureFlag> GestureFlags;

    enum NativeGestureType
    {
        BeginNativeGesture,
        EndNativeGesture,
        PanNativeGesture,
        ZoomNativeGesture,
        SmartZoomNativeGesture,
        RotateNativeGesture,
        SwipeNativeGesture
    };



    enum NavigationMode
    {
        NavigationModeNone,
        NavigationModeKeypadTabOrder,
        NavigationModeKeypadDirectional,
        NavigationModeCursorAuto,
        NavigationModeCursorForceVisible
    };

    enum CursorMoveStyle {
        LogicalMoveStyle,
        VisualMoveStyle
    };

    enum TimerType {
        PreciseTimer,
        CoarseTimer,
        VeryCoarseTimer
    };

    enum ScrollPhase {
        ScrollBegin = 1,
        ScrollUpdate,
        ScrollEnd
    };

    enum MouseEventSource {
        MouseEventNotSynthesized,
        MouseEventSynthesizedBySystem,
        MouseEventSynthesizedByQt
    };

    enum MouseEventFlag {
        MouseEventCreatedDoubleClick = 0x01,
        MouseEventFlagMask = 0xFF
    };
    typedef QFlags<MouseEventFlag> MouseEventFlags;

}




 inline QFlags<Qt::MouseButtons::enum_type> operator|(Qt::MouseButtons::enum_type f1, Qt::MouseButtons::enum_type f2) { return QFlags<Qt::MouseButtons::enum_type>(f1) | f2; } inline QFlags<Qt::MouseButtons::enum_type> operator|(Qt::MouseButtons::enum_type f1, QFlags<Qt::MouseButtons::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::MouseButtons::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::Orientations::enum_type> operator|(Qt::Orientations::enum_type f1, Qt::Orientations::enum_type f2) { return QFlags<Qt::Orientations::enum_type>(f1) | f2; } inline QFlags<Qt::Orientations::enum_type> operator|(Qt::Orientations::enum_type f1, QFlags<Qt::Orientations::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::Orientations::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::KeyboardModifiers::enum_type> operator|(Qt::KeyboardModifiers::enum_type f1, Qt::KeyboardModifiers::enum_type f2) { return QFlags<Qt::KeyboardModifiers::enum_type>(f1) | f2; } inline QFlags<Qt::KeyboardModifiers::enum_type> operator|(Qt::KeyboardModifiers::enum_type f1, QFlags<Qt::KeyboardModifiers::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::KeyboardModifiers::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::WindowFlags::enum_type> operator|(Qt::WindowFlags::enum_type f1, Qt::WindowFlags::enum_type f2) { return QFlags<Qt::WindowFlags::enum_type>(f1) | f2; } inline QFlags<Qt::WindowFlags::enum_type> operator|(Qt::WindowFlags::enum_type f1, QFlags<Qt::WindowFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::WindowFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::Alignment::enum_type> operator|(Qt::Alignment::enum_type f1, Qt::Alignment::enum_type f2) { return QFlags<Qt::Alignment::enum_type>(f1) | f2; } inline QFlags<Qt::Alignment::enum_type> operator|(Qt::Alignment::enum_type f1, QFlags<Qt::Alignment::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::Alignment::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::Edges::enum_type> operator|(Qt::Edges::enum_type f1, Qt::Edges::enum_type f2) { return QFlags<Qt::Edges::enum_type>(f1) | f2; } inline QFlags<Qt::Edges::enum_type> operator|(Qt::Edges::enum_type f1, QFlags<Qt::Edges::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::Edges::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::ImageConversionFlags::enum_type> operator|(Qt::ImageConversionFlags::enum_type f1, Qt::ImageConversionFlags::enum_type f2) { return QFlags<Qt::ImageConversionFlags::enum_type>(f1) | f2; } inline QFlags<Qt::ImageConversionFlags::enum_type> operator|(Qt::ImageConversionFlags::enum_type f1, QFlags<Qt::ImageConversionFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::ImageConversionFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::DockWidgetAreas::enum_type> operator|(Qt::DockWidgetAreas::enum_type f1, Qt::DockWidgetAreas::enum_type f2) { return QFlags<Qt::DockWidgetAreas::enum_type>(f1) | f2; } inline QFlags<Qt::DockWidgetAreas::enum_type> operator|(Qt::DockWidgetAreas::enum_type f1, QFlags<Qt::DockWidgetAreas::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::DockWidgetAreas::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::ToolBarAreas::enum_type> operator|(Qt::ToolBarAreas::enum_type f1, Qt::ToolBarAreas::enum_type f2) { return QFlags<Qt::ToolBarAreas::enum_type>(f1) | f2; } inline QFlags<Qt::ToolBarAreas::enum_type> operator|(Qt::ToolBarAreas::enum_type f1, QFlags<Qt::ToolBarAreas::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::ToolBarAreas::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::WindowStates::enum_type> operator|(Qt::WindowStates::enum_type f1, Qt::WindowStates::enum_type f2) { return QFlags<Qt::WindowStates::enum_type>(f1) | f2; } inline QFlags<Qt::WindowStates::enum_type> operator|(Qt::WindowStates::enum_type f1, QFlags<Qt::WindowStates::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::WindowStates::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::ScreenOrientations::enum_type> operator|(Qt::ScreenOrientations::enum_type f1, Qt::ScreenOrientations::enum_type f2) { return QFlags<Qt::ScreenOrientations::enum_type>(f1) | f2; } inline QFlags<Qt::ScreenOrientations::enum_type> operator|(Qt::ScreenOrientations::enum_type f1, QFlags<Qt::ScreenOrientations::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::ScreenOrientations::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::DropActions::enum_type> operator|(Qt::DropActions::enum_type f1, Qt::DropActions::enum_type f2) { return QFlags<Qt::DropActions::enum_type>(f1) | f2; } inline QFlags<Qt::DropActions::enum_type> operator|(Qt::DropActions::enum_type f1, QFlags<Qt::DropActions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::DropActions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::ItemFlags::enum_type> operator|(Qt::ItemFlags::enum_type f1, Qt::ItemFlags::enum_type f2) { return QFlags<Qt::ItemFlags::enum_type>(f1) | f2; } inline QFlags<Qt::ItemFlags::enum_type> operator|(Qt::ItemFlags::enum_type f1, QFlags<Qt::ItemFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::ItemFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::MatchFlags::enum_type> operator|(Qt::MatchFlags::enum_type f1, Qt::MatchFlags::enum_type f2) { return QFlags<Qt::MatchFlags::enum_type>(f1) | f2; } inline QFlags<Qt::MatchFlags::enum_type> operator|(Qt::MatchFlags::enum_type f1, QFlags<Qt::MatchFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::MatchFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::TextInteractionFlags::enum_type> operator|(Qt::TextInteractionFlags::enum_type f1, Qt::TextInteractionFlags::enum_type f2) { return QFlags<Qt::TextInteractionFlags::enum_type>(f1) | f2; } inline QFlags<Qt::TextInteractionFlags::enum_type> operator|(Qt::TextInteractionFlags::enum_type f1, QFlags<Qt::TextInteractionFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::TextInteractionFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::InputMethodQueries::enum_type> operator|(Qt::InputMethodQueries::enum_type f1, Qt::InputMethodQueries::enum_type f2) { return QFlags<Qt::InputMethodQueries::enum_type>(f1) | f2; } inline QFlags<Qt::InputMethodQueries::enum_type> operator|(Qt::InputMethodQueries::enum_type f1, QFlags<Qt::InputMethodQueries::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::InputMethodQueries::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::InputMethodHints::enum_type> operator|(Qt::InputMethodHints::enum_type f1, Qt::InputMethodHints::enum_type f2) { return QFlags<Qt::InputMethodHints::enum_type>(f1) | f2; } inline QFlags<Qt::InputMethodHints::enum_type> operator|(Qt::InputMethodHints::enum_type f1, QFlags<Qt::InputMethodHints::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::InputMethodHints::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::TouchPointStates::enum_type> operator|(Qt::TouchPointStates::enum_type f1, Qt::TouchPointStates::enum_type f2) { return QFlags<Qt::TouchPointStates::enum_type>(f1) | f2; } inline QFlags<Qt::TouchPointStates::enum_type> operator|(Qt::TouchPointStates::enum_type f1, QFlags<Qt::TouchPointStates::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::TouchPointStates::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<Qt::MouseEventFlags::enum_type> operator|(Qt::MouseEventFlags::enum_type f1, Qt::MouseEventFlags::enum_type f2) { return QFlags<Qt::MouseEventFlags::enum_type>(f1) | f2; } inline QFlags<Qt::MouseEventFlags::enum_type> operator|(Qt::MouseEventFlags::enum_type f1, QFlags<Qt::MouseEventFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::MouseEventFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

 inline QFlags<Qt::GestureFlags::enum_type> operator|(Qt::GestureFlags::enum_type f1, Qt::GestureFlags::enum_type f2) { return QFlags<Qt::GestureFlags::enum_type>(f1) | f2; } inline QFlags<Qt::GestureFlags::enum_type> operator|(Qt::GestureFlags::enum_type f1, QFlags<Qt::GestureFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(Qt::GestureFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


typedef bool (*qInternalCallback)(void **);

class __declspec(dllimport) QInternal {
public:
    enum PaintDeviceFlags {
        UnknownDevice = 0x00,
        Widget = 0x01,
        Pixmap = 0x02,
        Image = 0x03,
        Printer = 0x04,
        Picture = 0x05,
        Pbuffer = 0x06,
        FramebufferObject = 0x07,
        CustomRaster = 0x08,
        MacQuartz = 0x09,
        PaintBuffer = 0x0a,
        OpenGL = 0x0b
    };
    enum RelayoutType {
        RelayoutNormal,
        RelayoutDragging,
        RelayoutDropped
    };

    enum DockPosition {
        LeftDock,
        RightDock,
        TopDock,
        BottomDock,
        DockCount
    };

    enum Callback {
        EventNotifyCallback,
        LastCallback
    };
    static bool registerCallback(Callback, qInternalCallback);
    static bool unregisterCallback(Callback, qInternalCallback);
    static bool activateCallbacks(Callback, void **);
};
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qarraydata.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qarraydata.h"
struct __declspec(dllimport) QArrayData
{
    QtPrivate::RefCount ref;
    int size;
    uint alloc : 31;
    uint capacityReserved : 1;

    qptrdiff offset;

    void *data()
    {
        ((!(size == 0 || offset < 0 || size_t(offset) >= sizeof(QArrayData))) ? qt_assert("size == 0 || offset < 0 || size_t(offset) >= sizeof(QArrayData)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qarraydata.h",62) : qt_noop());

        return reinterpret_cast<char *>(this) + offset;
    }

    const void *data() const
    {
        ((!(size == 0 || offset < 0 || size_t(offset) >= sizeof(QArrayData))) ? qt_assert("size == 0 || offset < 0 || size_t(offset) >= sizeof(QArrayData)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qarraydata.h",69) : qt_noop());

        return reinterpret_cast<const char *>(this) + offset;
    }




    bool isMutable() const
    {
        return alloc != 0;
    }

    enum AllocationOption {
        CapacityReserved = 0x1,

        Unsharable = 0x2,

        RawData = 0x4,
        Grow = 0x8,

        Default = 0
    };

    typedef QFlags<AllocationOption> AllocationOptions;

    size_t detachCapacity(size_t newSize) const
    {
        if (capacityReserved && newSize < alloc)
            return alloc;
        return newSize;
    }

    AllocationOptions detachFlags() const
    {
        AllocationOptions result;

        if (!ref.isSharable())
            result |= Unsharable;

        if (capacityReserved)
            result |= CapacityReserved;
        return result;
    }

    AllocationOptions cloneFlags() const
    {
        AllocationOptions result;
        if (capacityReserved)
            result |= CapacityReserved;
        return result;
    }

    static QArrayData *allocate(size_t objectSize, size_t alignment,
            size_t capacity, AllocationOptions options = Default)
                         ;
    static void deallocate(QArrayData *data, size_t objectSize,
            size_t alignment);

    static const QArrayData shared_null[2];
    static QArrayData *sharedNull() { return const_cast<QArrayData*>(shared_null); }
};

 inline QFlags<QArrayData::AllocationOptions::enum_type> operator|(QArrayData::AllocationOptions::enum_type f1, QArrayData::AllocationOptions::enum_type f2) { return QFlags<QArrayData::AllocationOptions::enum_type>(f1) | f2; } inline QFlags<QArrayData::AllocationOptions::enum_type> operator|(QArrayData::AllocationOptions::enum_type f1, QFlags<QArrayData::AllocationOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QArrayData::AllocationOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

template <class T>
struct QTypedArrayData
    : QArrayData
{
#line 207 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qarraydata.h"
    typedef T* iterator;
    typedef const T* const_iterator;


    T *data() { return static_cast<T *>(QArrayData::data()); }
    const T *data() const { return static_cast<const T *>(QArrayData::data()); }

    iterator begin(iterator = iterator()) { return data(); }
    iterator end(iterator = iterator()) { return data() + size; }
    const_iterator begin(const_iterator = const_iterator()) const { return data(); }
    const_iterator end(const_iterator = const_iterator()) const { return data() + size; }
    const_iterator constBegin(const_iterator = const_iterator()) const { return data(); }
    const_iterator constEnd(const_iterator = const_iterator()) const { return data() + size; }

    class AlignmentDummy { QArrayData header; T data; };

    static QTypedArrayData *allocate(size_t capacity,
            AllocationOptions options = Default)
    {
        static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)), "sizeof(QTypedArrayData) == sizeof(QArrayData)");
        return static_cast<QTypedArrayData *>(QArrayData::allocate(sizeof(T),
                    __alignof(AlignmentDummy), capacity, options));
    }

    static void deallocate(QArrayData *data)
    {
        static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)), "sizeof(QTypedArrayData) == sizeof(QArrayData)");
        QArrayData::deallocate(data, sizeof(T), __alignof(AlignmentDummy));
    }

    static QTypedArrayData *fromRawData(const T *data, size_t n,
            AllocationOptions options = Default)
    {
        static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)), "sizeof(QTypedArrayData) == sizeof(QArrayData)");
        QTypedArrayData *result = allocate(0, options | RawData);
        if (result) {
            ((!(!result->ref.isShared())) ? qt_assert("!result->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qarraydata.h",243) : qt_noop());

            result->offset = reinterpret_cast<const char *>(data)
                - reinterpret_cast<const char *>(result);
            result->size = int(n);
        }
        return result;
    }

    static QTypedArrayData *sharedNull()
    {
        static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)), "sizeof(QTypedArrayData) == sizeof(QArrayData)");
        return static_cast<QTypedArrayData *>(QArrayData::sharedNull());
    }

    static QTypedArrayData *sharedEmpty()
    {
        static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)), "sizeof(QTypedArrayData) == sizeof(QArrayData)");
        return allocate( 0);
    }

    static QTypedArrayData *unsharableEmpty()
    {
        static_assert(bool(sizeof(QTypedArrayData) == sizeof(QArrayData)), "sizeof(QTypedArrayData) == sizeof(QArrayData)");
        return allocate( 0, Unsharable);
    }
};

template <class T, size_t N>
struct QStaticArrayData
{
    QArrayData header;
    T data[N];
};


template <class T>
struct QArrayDataPointerRef
{
    QTypedArrayData<T> *ptr;
};
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h"




#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdarg.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdarg.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdarg.h"
#line 29 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdarg.h"
extern "C" {






void __declspec(dllimport) __cdecl _vacopy( va_list *, va_list);



}
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h"
#line 82 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h"
__declspec(dllimport) char *qstrdup(const char *);

inline uint qstrlen(const char *str)
{ return str ? uint(strlen(str)) : 0; }

inline uint qstrnlen(const char *str, uint maxlen)
{
    uint length = 0;
    if (str) {
        while (length < maxlen && *str++)
            length++;
    }
    return length;
}

__declspec(dllimport) char *qstrcpy(char *dst, const char *src);
__declspec(dllimport) char *qstrncpy(char *dst, const char *src, uint len);

__declspec(dllimport) int qstrcmp(const char *str1, const char *str2);
__declspec(dllimport) int qstrcmp(const QByteArray &str1, const QByteArray &str2);
__declspec(dllimport) int qstrcmp(const QByteArray &str1, const char *str2);
static inline int qstrcmp(const char *str1, const QByteArray &str2)
{ return -qstrcmp(str2, str1); }

inline int qstrncmp(const char *str1, const char *str2, uint len)
{
    return (str1 && str2) ? strncmp(str1, str2, len)
        : (str1 ? 1 : (str2 ? -1 : 0));
}
__declspec(dllimport) int qstricmp(const char *, const char *);
__declspec(dllimport) int qstrnicmp(const char *, const char *, uint len);


__declspec(dllimport) int qvsnprintf(char *str, size_t n, const char *fmt, va_list ap);
__declspec(dllimport) int qsnprintf(char *str, size_t n, const char *fmt, ...);



__declspec(dllimport) quint16 qChecksum(const char *s, uint len);

class QByteRef;
class QString;
class QDataStream;
template <typename T> class QList;

typedef QArrayData QByteArrayData;

template<int N> struct QStaticByteArrayData
{
    QByteArrayData ba;
    char data[N + 1];

    QByteArrayData *data_ptr() const
    {
        ((!(ba.ref.isStatic())) ? qt_assert("ba.ref.isStatic()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h",136) : qt_noop());
        return const_cast<QByteArrayData *>(&ba);
    }
};

struct QByteArrayDataPtr
{
    QByteArrayData *ptr;
};
#line 176 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h"
class __declspec(dllimport) QByteArray
{
private:
    typedef QTypedArrayData<char> Data;

public:
    enum Base64Option {
        Base64Encoding = 0,
        Base64UrlEncoding = 1,

        KeepTrailingEquals = 0,
        OmitTrailingEquals = 2
    };
    typedef QFlags<Base64Option> Base64Options;

    inline QByteArray();
    QByteArray(const char *, int size = -1);
    QByteArray(int size, char c);
    QByteArray(int size, Qt::Initialization);
    inline QByteArray(const QByteArray &);
    inline ~QByteArray();

    QByteArray &operator=(const QByteArray &);
    QByteArray &operator=(const char *str);

    inline QByteArray(QByteArray && other) : d(other.d) { other.d = Data::sharedNull(); }
    inline QByteArray &operator=(QByteArray &&other)
    { qSwap(d, other.d); return *this; }


    inline void swap(QByteArray &other) { qSwap(d, other.d); }

    inline int size() const;
    bool isEmpty() const;
    void resize(int size);

    QByteArray &fill(char c, int size = -1);

    int capacity() const;
    void reserve(int size);
    void squeeze();


    operator const char *() const;
    operator const void *() const;

    char *data();
    const char *data() const;
    inline const char *constData() const;
    inline void detach();
    bool isDetached() const;
    inline bool isSharedWith(const QByteArray &other) const { return d == other.d; }
    void clear();

    char at(int i) const;
    char operator[](int i) const;
    char operator[](uint i) const;
    QByteRef operator[](int i);
    QByteRef operator[](uint i);

    int indexOf(char c, int from = 0) const;
    int indexOf(const char *c, int from = 0) const;
    int indexOf(const QByteArray &a, int from = 0) const;
    int lastIndexOf(char c, int from = -1) const;
    int lastIndexOf(const char *c, int from = -1) const;
    int lastIndexOf(const QByteArray &a, int from = -1) const;

    bool contains(char c) const;
    bool contains(const char *a) const;
    bool contains(const QByteArray &a) const;
    int count(char c) const;
    int count(const char *a) const;
    int count(const QByteArray &a) const;

    QByteArray left(int len) const;
    QByteArray right(int len) const;
    QByteArray mid(int index, int len = -1) const;

    bool startsWith(const QByteArray &a) const;
    bool startsWith(char c) const;
    bool startsWith(const char *c) const;

    bool endsWith(const QByteArray &a) const;
    bool endsWith(char c) const;
    bool endsWith(const char *c) const;

    void truncate(int pos);
    void chop(int n);

    QByteArray toLower() const;
    QByteArray toUpper() const;

    QByteArray trimmed() const;
    QByteArray simplified() const;
    QByteArray leftJustified(int width, char fill = ' ', bool truncate = false) const;
    QByteArray rightJustified(int width, char fill = ' ', bool truncate = false) const;

    QByteArray &prepend(char c);
    QByteArray &prepend(const char *s);
    QByteArray &prepend(const char *s, int len);
    QByteArray &prepend(const QByteArray &a);
    QByteArray &append(char c);
    QByteArray &append(const char *s);
    QByteArray &append(const char *s, int len);
    QByteArray &append(const QByteArray &a);
    QByteArray &insert(int i, char c);
    QByteArray &insert(int i, const char *s);
    QByteArray &insert(int i, const char *s, int len);
    QByteArray &insert(int i, const QByteArray &a);
    QByteArray &remove(int index, int len);
    QByteArray &replace(int index, int len, const char *s);
    QByteArray &replace(int index, int len, const char *s, int alen);
    QByteArray &replace(int index, int len, const QByteArray &s);
    QByteArray &replace(char before, const char *after);
    QByteArray &replace(char before, const QByteArray &after);
    QByteArray &replace(const char *before, const char *after);
    QByteArray &replace(const char *before, int bsize, const char *after, int asize);
    QByteArray &replace(const QByteArray &before, const QByteArray &after);
    QByteArray &replace(const QByteArray &before, const char *after);
    QByteArray &replace(const char *before, const QByteArray &after);
    QByteArray &replace(char before, char after);
    QByteArray &operator+=(char c);
    QByteArray &operator+=(const char *s);
    QByteArray &operator+=(const QByteArray &a);

    QList<QByteArray> split(char sep) const;

    QByteArray repeated(int times) const;


                       QByteArray &append(const QString &s);
                       QByteArray &insert(int i, const QString &s);
                       QByteArray &replace(const QString &before, const char *after);
                       QByteArray &replace(char c, const QString &after);
                       QByteArray &replace(const QString &before, const QByteArray &after);

                       QByteArray &operator+=(const QString &s);
                       int indexOf(const QString &s, int from = 0) const;
                       int lastIndexOf(const QString &s, int from = -1) const;


    inline bool operator==(const QString &s2) const;
    inline bool operator!=(const QString &s2) const;
    inline bool operator<(const QString &s2) const;
    inline bool operator>(const QString &s2) const;
    inline bool operator<=(const QString &s2) const;
    inline bool operator>=(const QString &s2) const;


    short toShort(bool *ok = 0, int base = 10) const;
    ushort toUShort(bool *ok = 0, int base = 10) const;
    int toInt(bool *ok = 0, int base = 10) const;
    uint toUInt(bool *ok = 0, int base = 10) const;
    long toLong(bool *ok = 0, int base = 10) const;
    ulong toULong(bool *ok = 0, int base = 10) const;
    qlonglong toLongLong(bool *ok = 0, int base = 10) const;
    qulonglong toULongLong(bool *ok = 0, int base = 10) const;
    float toFloat(bool *ok = 0) const;
    double toDouble(bool *ok = 0) const;
    QByteArray toBase64(Base64Options options) const;
    QByteArray toBase64() const;
    QByteArray toHex() const;
    QByteArray toPercentEncoding(const QByteArray &exclude = QByteArray(),
                                 const QByteArray &include = QByteArray(),
                                 char percent = '%') const;

    QByteArray &setNum(short, int base = 10);
    QByteArray &setNum(ushort, int base = 10);
    QByteArray &setNum(int, int base = 10);
    QByteArray &setNum(uint, int base = 10);
    QByteArray &setNum(qlonglong, int base = 10);
    QByteArray &setNum(qulonglong, int base = 10);
    QByteArray &setNum(float, char f = 'g', int prec = 6);
    QByteArray &setNum(double, char f = 'g', int prec = 6);
    QByteArray &setRawData(const char *a, uint n);

    static QByteArray number(int, int base = 10);
    static QByteArray number(uint, int base = 10);
    static QByteArray number(qlonglong, int base = 10);
    static QByteArray number(qulonglong, int base = 10);
    static QByteArray number(double, char f = 'g', int prec = 6);
    static QByteArray fromRawData(const char *, int size);
    static QByteArray fromBase64(const QByteArray &base64, Base64Options options);
    static QByteArray fromBase64(const QByteArray &base64);
    static QByteArray fromHex(const QByteArray &hexEncoded);
    static QByteArray fromPercentEncoding(const QByteArray &pctEncoded, char percent = '%');
#line 376 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h"
    typedef char *iterator;
    typedef const char *const_iterator;
    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    iterator begin();
    const_iterator begin() const;
    const_iterator cbegin() const;
    const_iterator constBegin() const;
    iterator end();
    const_iterator end() const;
    const_iterator cend() const;
    const_iterator constEnd() const;


    typedef const char & const_reference;
    typedef char & reference;
    typedef char value_type;
    void push_back(char c);
    void push_back(const char *c);
    void push_back(const QByteArray &a);
    void push_front(char c);
    void push_front(const char *c);
    void push_front(const QByteArray &a);

    inline int count() const { return d->size; }
    int length() const { return d->size; }
    bool isNull() const;

    inline QByteArray(QByteArrayDataPtr dd)
        : d(static_cast<Data *>(dd.ptr))
    {
    }

private:
    operator QNoImplicitBoolCast() const;
    Data *d;
    void reallocData(uint alloc, Data::AllocationOptions options);
    void expand(int i);
    QByteArray nulTerminated() const;

    friend class QByteRef;
    friend class QString;
    friend __declspec(dllimport) QByteArray qUncompress(const uchar *data, int nbytes);
public:
    typedef Data * DataPtr;
    inline DataPtr &data_ptr() { return d; }
};

 inline QFlags<QByteArray::Base64Options::enum_type> operator|(QByteArray::Base64Options::enum_type f1, QByteArray::Base64Options::enum_type f2) { return QFlags<QByteArray::Base64Options::enum_type>(f1) | f2; } inline QFlags<QByteArray::Base64Options::enum_type> operator|(QByteArray::Base64Options::enum_type f1, QFlags<QByteArray::Base64Options::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QByteArray::Base64Options::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

inline QByteArray::QByteArray(): d(Data::sharedNull()) { }
inline QByteArray::~QByteArray() { if (!d->ref.deref()) Data::deallocate(d); }
inline int QByteArray::size() const
{ return d->size; }

inline char QByteArray::at(int i) const
{ ((!(uint(i) < uint(size()))) ? qt_assert("uint(i) < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h",432) : qt_noop()); return d->data()[i]; }
inline char QByteArray::operator[](int i) const
{ ((!(uint(i) < uint(size()))) ? qt_assert("uint(i) < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h",434) : qt_noop()); return d->data()[i]; }
inline char QByteArray::operator[](uint i) const
{ ((!(i < uint(size()))) ? qt_assert("i < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h",436) : qt_noop()); return d->data()[i]; }

inline bool QByteArray::isEmpty() const
{ return d->size == 0; }

inline QByteArray::operator const char *() const
{ return d->data(); }
inline QByteArray::operator const void *() const
{ return d->data(); }

inline char *QByteArray::data()
{ detach(); return d->data(); }
inline const char *QByteArray::data() const
{ return d->data(); }
inline const char *QByteArray::constData() const
{ return d->data(); }
inline void QByteArray::detach()
{ if (d->ref.isShared() || (d->offset != sizeof(QByteArrayData))) reallocData(uint(d->size) + 1u, d->detachFlags()); }
inline bool QByteArray::isDetached() const
{ return !d->ref.isShared(); }
inline QByteArray::QByteArray(const QByteArray &a) : d(a.d)
{ d->ref.ref(); }

inline int QByteArray::capacity() const
{ return d->alloc ? d->alloc - 1 : 0; }

inline void QByteArray::reserve(int asize)
{
    if (d->ref.isShared() || uint(asize) + 1u > d->alloc) {
        reallocData(qMax(uint(size()), uint(asize)) + 1u, d->detachFlags() | Data::CapacityReserved);
    } else {


        d->capacityReserved = true;
    }
}

inline void QByteArray::squeeze()
{
    if (d->ref.isShared() || uint(d->size) + 1u < d->alloc) {
        reallocData(uint(d->size) + 1u, d->detachFlags() & ~Data::CapacityReserved);
    } else {


        d->capacityReserved = false;
    }
}

class __declspec(dllimport) QByteRef {
    QByteArray &a;
    int i;
    inline QByteRef(QByteArray &array, int idx)
        : a(array),i(idx) {}
    friend class QByteArray;
public:
    inline operator char() const
        { return i < a.d->size ? a.d->data()[i] : char(0); }
    inline QByteRef &operator=(char c)
        { if (i >= a.d->size) a.expand(i); else a.detach();
          a.d->data()[i] = c; return *this; }
    inline QByteRef &operator=(const QByteRef &c)
        { if (i >= a.d->size) a.expand(i); else a.detach();
          a.d->data()[i] = c.a.d->data()[c.i]; return *this; }
    inline bool operator==(char c) const
    { return a.d->data()[i] == c; }
    inline bool operator!=(char c) const
    { return a.d->data()[i] != c; }
    inline bool operator>(char c) const
    { return a.d->data()[i] > c; }
    inline bool operator>=(char c) const
    { return a.d->data()[i] >= c; }
    inline bool operator<(char c) const
    { return a.d->data()[i] < c; }
    inline bool operator<=(char c) const
    { return a.d->data()[i] <= c; }
};

inline QByteRef QByteArray::operator[](int i)
{ ((!(i >= 0)) ? qt_assert("i >= 0","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbytearray.h",514) : qt_noop()); return QByteRef(*this, i); }
inline QByteRef QByteArray::operator[](uint i)
{ return QByteRef(*this, i); }
inline QByteArray::iterator QByteArray::begin()
{ detach(); return d->data(); }
inline QByteArray::const_iterator QByteArray::begin() const
{ return d->data(); }
inline QByteArray::const_iterator QByteArray::cbegin() const
{ return d->data(); }
inline QByteArray::const_iterator QByteArray::constBegin() const
{ return d->data(); }
inline QByteArray::iterator QByteArray::end()
{ detach(); return d->data() + d->size; }
inline QByteArray::const_iterator QByteArray::end() const
{ return d->data() + d->size; }
inline QByteArray::const_iterator QByteArray::cend() const
{ return d->data() + d->size; }
inline QByteArray::const_iterator QByteArray::constEnd() const
{ return d->data() + d->size; }
inline QByteArray &QByteArray::operator+=(char c)
{ return append(c); }
inline QByteArray &QByteArray::operator+=(const char *s)
{ return append(s); }
inline QByteArray &QByteArray::operator+=(const QByteArray &a)
{ return append(a); }
inline void QByteArray::push_back(char c)
{ append(c); }
inline void QByteArray::push_back(const char *c)
{ append(c); }
inline void QByteArray::push_back(const QByteArray &a)
{ append(a); }
inline void QByteArray::push_front(char c)
{ prepend(c); }
inline void QByteArray::push_front(const char *c)
{ prepend(c); }
inline void QByteArray::push_front(const QByteArray &a)
{ prepend(a); }
inline bool QByteArray::contains(const QByteArray &a) const
{ return indexOf(a) != -1; }
inline bool QByteArray::contains(char c) const
{ return indexOf(c) != -1; }
inline bool operator==(const QByteArray &a1, const QByteArray &a2)
{ return (a1.size() == a2.size()) && (memcmp(a1.constData(), a2.constData(), a1.size())==0); }
inline bool operator==(const QByteArray &a1, const char *a2)
{ return a2 ? qstrcmp(a1,a2) == 0 : a1.isEmpty(); }
inline bool operator==(const char *a1, const QByteArray &a2)
{ return a1 ? qstrcmp(a1,a2) == 0 : a2.isEmpty(); }
inline bool operator!=(const QByteArray &a1, const QByteArray &a2)
{ return !(a1==a2); }
inline bool operator!=(const QByteArray &a1, const char *a2)
{ return a2 ? qstrcmp(a1,a2) != 0 : !a1.isEmpty(); }
inline bool operator!=(const char *a1, const QByteArray &a2)
{ return a1 ? qstrcmp(a1,a2) != 0 : !a2.isEmpty(); }
inline bool operator<(const QByteArray &a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) < 0; }
 inline bool operator<(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) < 0; }
inline bool operator<(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) < 0; }
inline bool operator<=(const QByteArray &a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) <= 0; }
inline bool operator<=(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) <= 0; }
inline bool operator<=(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) <= 0; }
inline bool operator>(const QByteArray &a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) > 0; }
inline bool operator>(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) > 0; }
inline bool operator>(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) > 0; }
inline bool operator>=(const QByteArray &a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) >= 0; }
inline bool operator>=(const QByteArray &a1, const char *a2)
{ return qstrcmp(a1, a2) >= 0; }
inline bool operator>=(const char *a1, const QByteArray &a2)
{ return qstrcmp(a1, a2) >= 0; }

inline const QByteArray operator+(const QByteArray &a1, const QByteArray &a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(const QByteArray &a1, const char *a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(const QByteArray &a1, char a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(const char *a1, const QByteArray &a2)
{ return QByteArray(a1) += a2; }
inline const QByteArray operator+(char a1, const QByteArray &a2)
{ return QByteArray(&a1, 1) += a2; }

inline bool QByteArray::contains(const char *c) const
{ return indexOf(c) != -1; }
inline QByteArray &QByteArray::replace(char before, const char *c)
{ return replace(&before, 1, c, qstrlen(c)); }
inline QByteArray &QByteArray::replace(const QByteArray &before, const char *c)
{ return replace(before.constData(), before.size(), c, qstrlen(c)); }
inline QByteArray &QByteArray::replace(const char *before, const char *after)
{ return replace(before, qstrlen(before), after, qstrlen(after)); }

inline QByteArray &QByteArray::setNum(short n, int base)
{ return base == 10 ? setNum(qlonglong(n), base) : setNum(qulonglong(ushort(n)), base); }
inline QByteArray &QByteArray::setNum(ushort n, int base)
{ return setNum(qulonglong(n), base); }
inline QByteArray &QByteArray::setNum(int n, int base)
{ return base == 10 ? setNum(qlonglong(n), base) : setNum(qulonglong(uint(n)), base); }
inline QByteArray &QByteArray::setNum(uint n, int base)
{ return setNum(qulonglong(n), base); }
inline QByteArray &QByteArray::setNum(float n, char f, int prec)
{ return setNum(double(n),f,prec); }



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QByteArray &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QByteArray &);



__declspec(dllimport) QByteArray qCompress(const uchar* data, int nbytes, int compressionLevel = -1);
__declspec(dllimport) QByteArray qUncompress(const uchar* data, int nbytes);
inline QByteArray qCompress(const QByteArray& data, int compressionLevel = -1)
{ return qCompress(reinterpret_cast<const uchar *>(data.constData()), data.size(), compressionLevel); }
inline QByteArray qUncompress(const QByteArray& data)
{ return qUncompress(reinterpret_cast<const uchar*>(data.constData()), data.size()); }


template<> class QTypeInfo<QByteArray > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QByteArray)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QByteArray >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QByteArray) }; static inline const char *name() { return "QByteArray"; } }; template <> inline void qSwap<QByteArray>(QByteArray &value1, QByteArray &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QByteArray >(::QByteArray &value1, ::QByteArray &value2) { value1.swap(value2); } }
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"




#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\iterator"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\istream"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ostream"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ios"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocnum"
#line 10 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocnum"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\streambuf"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xiosbase"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocale"







#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"






#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstring"







#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {
#pragma warning(disable: 4127)

#pragma warning(disable: 4251)

template<class _Elem,
 class _Traits = char_traits<_Elem>,
 class _Ax = allocator<_Elem> >
 class basic_string;






template<class _Mystr>
 class _String_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   typename _Mystr::value_type,
   typename _Mystr::difference_type,
   typename _Mystr::const_pointer,
   typename _Mystr::const_reference,
   _Iterator_base>
 {
public:
 typedef _String_const_iterator<_Mystr> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::const_pointer pointer;
 typedef typename _Mystr::const_reference reference;

 _String_const_iterator()
  {
  this->_Ptr = 0;
  }

 _String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
  {
  this->_Adopt(_Pstring);
  this->_Ptr = _Parg;
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
#line 91 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstring"
                                    ;

  return (*this->_Ptr);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
#line 120 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstring"
  ++this->_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
#line 148 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstring"
  --this->_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
#line 180 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstring"
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }
#line 263 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstring"
 void _Compat(const _Myiter&) const
  {
  }


 pointer _Ptr;
 };

template<class _Mystr> inline
 typename _String_const_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_const_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr>
  _Rechecked(_String_const_iterator<_Mystr>& _Iter,
   typename _String_const_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_const_iterator<_Mystr> operator+(
  typename _String_const_iterator<_Mystr>
   ::difference_type _Off,
  _String_const_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }


template<class _Mystr>
 class _String_iterator
  : public _String_const_iterator<_Mystr>
 {
public:
 typedef _String_iterator<_Mystr> _Myiter;
 typedef _String_const_iterator<_Mystr> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr::value_type value_type;
 typedef typename _Mystr::difference_type difference_type;
 typedef typename _Mystr::pointer pointer;
 typedef typename _Mystr::reference reference;

 _String_iterator()
  {
  }

 _String_iterator(pointer _Parg, const _Container_base *_Pstring)
  : _Mybase(_Parg, _Pstring)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return ((_Mybase)*this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Mystr> inline
 typename _String_iterator<_Mystr>::_Unchecked_type
  _Unchecked(_String_iterator<_Mystr> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mystr> inline
 _String_iterator<_Mystr>
  _Rechecked(_String_iterator<_Mystr>& _Iter,
   typename _String_iterator<_Mystr>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Mystr> inline
 _String_iterator<_Mystr> operator+(
  typename _String_iterator<_Mystr>
   ::difference_type _Off,
  _String_iterator<_Mystr> _Next)
 {
 return (_Next += _Off);
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference>
 struct _String_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 };

template<class _Ty,
 class _Alloc0>
 struct _String_base_types
 {
 typedef _Alloc0 _Alloc;
 typedef _String_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;


 typedef typename _Alty::pointer _Tptr;
 typedef typename _Alty::template rebind<_Tptr>::other _Alpty;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Simple_types<typename _Alty::value_type>,
  _String_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference> >::type
  _Val_types;
 };


template<class _Val_types>
 class _String_val
  : public _Container_base
 {
public:
 typedef _String_val<_Val_types> _Myt;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _String_iterator<_Myt> iterator;
 typedef _String_const_iterator<_Myt> const_iterator;

 _String_val()
  {
  _Mysize = 0;
  _Myres = 0;
  }

 enum
  {
  _BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
   : 16 / sizeof (value_type)};
 enum
  {
  _ALLOC_MASK = sizeof (value_type) <= 1 ? 15
   : sizeof (value_type) <= 2 ? 7
   : sizeof (value_type) <= 4 ? 3
   : sizeof (value_type) <= 8 ? 1 : 0};

 value_type *_Myptr()
  {
  return (this->_BUF_SIZE <= this->_Myres
   ? ::std:: addressof(*this->_Bx._Ptr)
   : this->_Bx._Buf);
  }

 const value_type *_Myptr() const
  {
  return (this->_BUF_SIZE <= this->_Myres
   ? ::std:: addressof(*this->_Bx._Ptr)
   : this->_Bx._Buf);
  }

 union _Bxty
  {
  value_type _Buf[_BUF_SIZE];
  pointer _Ptr;
  char _Alias[_BUF_SIZE];
  } _Bx;

 size_type _Mysize;
 size_type _Myres;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _String_alloc
  : public _String_val<typename _Alloc_types::_Val_types>
 {
public:
 typename _Alloc_types::_Alty _Alval;

 typedef _String_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc;
 typedef typename _Alloc_types::_Alty _Alty;


 _String_alloc(const _Alloc& _Al = _Alloc())
  : _Alval(_Al)
  {
  }

 void _Change_alloc(const _Alty& _Al)
  {
  this->_Alval = _Al;
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Swap_adl(this->_Alval, _Right._Alval);
  }
#line 608 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstring"
 _Alty& _Getal()
  {
  return (this->_Alval);
  }

 const _Alty& _Getal() const
  {
  return (this->_Alval);
  }
 };

template<class _Alloc_types>
 class _String_alloc<false, _Alloc_types>
  : public _String_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _String_alloc<false, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc;

 typedef typename _Alloc_types::_Alty _Alty;


 _String_alloc(const _Alloc& = _Alloc())
  {
  }

 void _Change_alloc(const _Alty&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
#line 682 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstring"
 _Alty _Getal() const
  {
  return (_Alty());
  }
 };


template<class _Elem,
 class _Traits,
 class _Alloc>
 class basic_string
  : public _String_alloc<!is_empty<_Alloc>::value,
   _String_base_types<_Elem, _Alloc> >
 {
public:
 typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
 typedef _String_alloc<!is_empty<_Alloc>::value,
  _String_base_types<_Elem, _Alloc> > _Mybase;
 typedef _Traits traits_type;
 typedef _Alloc allocator_type;

 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;

 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 basic_string(const _Myt& _Right)

  : _Mybase(_Right._Getal().select_on_container_copy_construction())


  {
  _Tidy();
  assign(_Right, 0, npos);
  }

 basic_string(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Right, 0, npos);
  }

 basic_string()
  : _Mybase()
  {
  _Tidy();
  }

 explicit basic_string(const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  }

 basic_string(const _Myt& _Right, size_type _Roff,
  size_type _Count = npos)
  : _Mybase(_Right._Getal())
  {
  _Tidy();
  assign(_Right, _Roff, _Count);
  }

 basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
  const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Right, _Roff, _Count);
  }

 basic_string(const _Elem *_Ptr, size_type _Count)
  : _Mybase()
  {
  _Tidy();
  assign(_Ptr, _Count);
  }

 basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ptr, _Count);
  }

 basic_string(const _Elem *_Ptr)
  : _Mybase()
  {
  _Tidy();
  assign(_Ptr);
  }

 basic_string(const _Elem *_Ptr, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ptr);
  }

 basic_string(size_type _Count, _Elem _Ch)
  : _Mybase()
  {
  _Tidy();
  assign(_Count, _Ch);
  }

 basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Count, _Ch);
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>::type>
  basic_string(_Iter _First, _Iter _Last)
  : _Mybase()
  {
  _Tidy();
  _Construct(_First, _Last, _Iter_cat(_First));
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>::type>
  basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Tidy();
  _Construct(_First, _Last, _Iter_cat(_First));
  }

 template<class _Iter>
  void _Construct(_Iter _First,
   _Iter _Last, input_iterator_tag)
  {
  try {
  for (; _First != _Last; ++_First)
   append((size_type)1, (_Elem)*_First);
  } catch (...) {
  _Tidy(true);
  throw;
  }
  }

 template<class _Iter>
  void _Construct(_Iter _First,
   _Iter _Last, forward_iterator_tag)
  {
                             ;
  size_type _Count = 0;
  _Distance(_First, _Last, _Count);
  reserve(_Count);

  try {
  for (; _First != _Last; ++_First)
   append((size_type)1, (_Elem)*_First);
  } catch (...) {
  _Tidy(true);
  throw;
  }
  }

 basic_string(const_pointer _First, const_pointer _Last)
  : _Mybase()
  {
                             ;
  _Tidy();
  if (_First != _Last)
   assign(&*_First, _Last - _First);
  }

 basic_string(const_pointer _First, const_pointer _Last,
  const _Alloc& _Al)
  : _Mybase(_Al)
  {
                             ;
  _Tidy();
  if (_First != _Last)
   assign(&*_First, _Last - _First);
  }

 basic_string(const_iterator _First, const_iterator _Last)
  : _Mybase()
  {
                             ;
  _Tidy();
  if (_First != _Last)
   assign(&*_First, _Last - _First);
  }

 basic_string(_Myt&& _Right) throw ()
  : _Mybase(_Right._Getal())
  {
  _Tidy();
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 basic_string(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  if (this->_Getal() != _Right._Getal())
   assign(_Right.begin(), _Right.end());
  else
   _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right) throw ()
  {
  if (this != &_Right)
   {
   _Tidy(true);

   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Change_alloc(_Right._Getal());

   if (this->_Getal() != _Right._Getal())
    assign(_Right.begin(), _Right.end());
   else
    _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 _Myt& assign(_Myt&& _Right) throw ()
  {
  if (this == &_Right)
   ;
  else if (get_allocator() != _Right.get_allocator()
   && this->_BUF_SIZE <= _Right._Myres)
   *this = _Right;
  else
   {
   _Tidy(true);
   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right)
  {
  if (_Right._Myres < this->_BUF_SIZE)
   _Traits::move(this->_Bx._Buf, _Right._Bx._Buf,
    _Right._Mysize + 1);
  else
   {
   this->_Getal().construct(&this->_Bx._Ptr, _Right._Bx._Ptr);
   _Right._Bx._Ptr = pointer();
   }
  this->_Mysize = _Right._Mysize;
  this->_Myres = _Right._Myres;
  _Right._Tidy();
  }

 basic_string(::std:: initializer_list<_Elem> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  _Tidy();
  assign(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& operator+=(::std:: initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& assign(::std:: initializer_list<_Elem> _Ilist)
  {
  return (assign(_Ilist.begin(), _Ilist.end()));
  }

 _Myt& append(::std:: initializer_list<_Elem> _Ilist)
  {
  return (append(_Ilist.begin(), _Ilist.end()));
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<_Elem> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  ::std:: initializer_list<_Elem> _Ilist)
  {
  return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
  }

 ~basic_string() throw ()
  {
  _Tidy(true);
  }

          static const size_type npos;

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    _Tidy(true);
    this->_Change_alloc(_Right._Getal());
    }

   assign(_Right);
   }
  return (*this);
  }

 _Myt& operator=(const _Elem *_Ptr)
  {
  return (assign(_Ptr));
  }

 _Myt& operator=(_Elem _Ch)
  {
  return (assign(1, _Ch));
  }

 _Myt& operator+=(const _Myt& _Right)
  {
  return (append(_Right));
  }

 _Myt& operator+=(const _Elem *_Ptr)
  {
  return (append(_Ptr));
  }

 _Myt& operator+=(_Elem _Ch)
  {
  return (append((size_type)1, _Ch));
  }

 _Myt& append(const _Myt& _Right)
  {
  return (append(_Right, 0, npos));
  }

 _Myt& append(const _Myt& _Right,
  size_type _Roff, size_type _Count)
  {
  if (_Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::copy(this->_Myptr() + this->_Mysize,
    _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& append(const _Elem *_Ptr, size_type _Count)
  {





  if (_Inside(_Ptr))
   return (append(*this,
    _Ptr - this->_Myptr(), _Count));
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::copy(this->_Myptr() + this->_Mysize, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& append(const _Elem *_Ptr)
  {
                      ;
  return (append(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& append(size_type _Count, _Elem _Ch)
  {
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Chassign(this->_Mysize, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   _Myt&>::type
  append(_Iter _First, _Iter _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }

 _Myt& append(const_pointer _First, const_pointer _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }

 _Myt& append(const_iterator _First, const_iterator _Last)
  {
  return (replace(end(), end(), _First, _Last));
  }

 _Myt& assign(const _Myt& _Right)
  {
  return (assign(_Right, 0, npos));
  }

 _Myt& assign(const _Myt& _Right,
  size_type _Roff, size_type _Count)
  {
  if (_Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Count < _Num)
   _Num = _Count;

  if (this == &_Right)
   erase((size_type)(_Roff + _Num)), erase(0, _Roff);
  else if (_Grow(_Num))
   {
   _Traits::copy(this->_Myptr(),
    _Right._Myptr() + _Roff, _Num);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& assign(const _Elem *_Ptr, size_type _Count)
  {





  if (_Inside(_Ptr))
   return (assign(*this,
    _Ptr - this->_Myptr(), _Count));

  if (_Grow(_Count))
   {
   _Traits::copy(this->_Myptr(), _Ptr, _Count);
   _Eos(_Count);
   }
  return (*this);
  }

 _Myt& assign(const _Elem *_Ptr)
  {
                      ;
  return (assign(_Ptr, _Traits::length(_Ptr)));
  }

 _Myt& assign(size_type _Count, _Elem _Ch)
  {
  if (_Count == npos)
   _Xlen();

  if (_Grow(_Count))
   {
   _Chassign(0, _Count, _Ch);
   _Eos(_Count);
   }
  return (*this);
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   _Myt&>::type
  assign(_Iter _First, _Iter _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }

 _Myt& assign(const_pointer _First, const_pointer _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }

 _Myt& assign(const_iterator _First, const_iterator _Last)
  {
  return (replace(begin(), end(), _First, _Last));
  }

 _Myt& insert(size_type _Off, const _Myt& _Right)
  {
  return (insert(_Off, _Right, 0, npos));
  }

 _Myt& insert(size_type _Off,
  const _Myt& _Right, size_type _Roff, size_type _Count)
  {
  if (this->_Mysize < _Off || _Right.size() < _Roff)
   _Xran();
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;
  if (npos - this->_Mysize <= _Count)
   _Xlen();

  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   if (this == &_Right)
    _Traits::move(this->_Myptr() + _Off,
     this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
      _Count);
   else
    _Traits::copy(this->_Myptr() + _Off,
     _Right._Myptr() + _Roff, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& insert(size_type _Off,
  const _Elem *_Ptr, size_type _Count)
  {





  if (_Inside(_Ptr))
   return (insert(_Off, *this,
    _Ptr - this->_Myptr(), _Count));
  if (this->_Mysize < _Off)
   _Xran();
  if (npos - this->_Mysize <= _Count)
   _Xlen();
  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& insert(size_type _Off, const _Elem *_Ptr)
  {
                      ;
  return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& insert(size_type _Off,
  size_type _Count, _Elem _Ch)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (npos - this->_Mysize <= _Count)
   _Xlen();
  size_type _Num;
  if (0 < _Count && _Grow(_Num = this->_Mysize + _Count))
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off,
    this->_Mysize - _Off);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 iterator insert(const_iterator _Where)
  {
  return (insert(_Where, _Elem()));
  }

 iterator insert(const_iterator _Where, _Elem _Ch)
  {
  size_type _Off = _Pdif(_Where, begin());
  insert(_Off, 1, _Ch);
  return (begin() + _Off);
  }

 iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
  {
  size_type _Off = _Pdif(_Where, begin());
  insert(_Off, _Count, _Ch);
  return (begin() + _Off);
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   iterator>::type
  insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = _Pdif(_Where, begin());
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }

 iterator insert(const_iterator _Where,
  const_pointer _First, const_pointer _Last)
  {
  size_type _Off = _Pdif(_Where, begin());
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }

 iterator insert(const_iterator _Where,
  const_iterator _First, const_iterator _Last)
  {
  size_type _Off = _Pdif(_Where, begin());
  replace(_Where, _Where, _First, _Last);
  return (begin() + _Off);
  }

 _Myt& erase(size_type _Off = 0)
  {
  if (this->_Mysize < _Off)
   _Xran();
  _Eos(_Off);
  return (*this);
  }

 _Myt& erase(size_type _Off, size_type _Count)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off <= _Count)
   _Eos(_Off);
  else if (0 < _Count)
   {
   value_type *_Ptr = this->_Myptr() + _Off;
   size_type _Newsize = this->_Mysize - _Count;
   _Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
   _Eos(_Newsize);
   }
  return (*this);
  }

 iterator erase(const_iterator _Where)
  {
  size_type _Count = _Pdif(_Where, begin());
  erase(_Count, 1);
  return (iterator(this->_Myptr() + _Count, this));
  }

 iterator erase(const_iterator _First, const_iterator _Last)
  {
                             ;
  size_type _Count = _Pdif(_First, begin());
  erase(_Count, _Pdif(_Last, _First));
  return (iterator(this->_Myptr() + _Count, this));
  }

 void clear() throw ()
  {
  _Eos(0);
  }

 _Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
  {
  return (replace(_Off, _N0, _Right, 0, npos));
  }

 _Myt& replace(size_type _Off,
  size_type _N0, const _Myt& _Right, size_type _Roff, size_type _Count)
  {
  if (this->_Mysize < _Off || _Right.size() < _Roff)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  size_type _Num = _Right.size() - _Roff;
  if (_Num < _Count)
   _Count = _Num;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();

  size_type _Nm = this->_Mysize - _N0 - _Off;
  size_type _Newsize = this->_Mysize + _Count - _N0;
  if (this->_Mysize < _Newsize)
   _Grow(_Newsize);

  if (this != &_Right)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off,
    _Right._Myptr() + _Roff, _Count);
   }
  else if (_Count <= _N0)
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   }
  else if (_Roff <= _Off)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _Count);
   }
  else if (_Off + _N0 <= _Roff)
   {
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + (_Roff + _Count - _N0),
    _Count);
   }
  else
   {
   _Traits::move(this->_Myptr() + _Off,
    this->_Myptr() + _Roff, _N0);
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0, _Nm);
   _Traits::move(this->_Myptr() + _Off + _N0,
    this->_Myptr() + _Roff + _Count,
    _Count - _N0);
   }

  _Eos(_Newsize);
  return (*this);
  }

 _Myt& replace(size_type _Off,
  size_type _N0, const _Elem *_Ptr, size_type _Count)
  {





  if (_Inside(_Ptr))
   return (replace(_Off, _N0, *this,
    _Ptr - this->_Myptr(),
    _Count));
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();
  size_type _Nm = this->_Mysize - _N0 - _Off;

  if (_Count < _N0)
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0,
    _Nm);
  size_type _Num;
  if ((0 < _Count || 0 < _N0)
   && _Grow(_Num = this->_Mysize + _Count - _N0))
   {
   if (_N0 < _Count)
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
   _Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
  {
                      ;
  return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
  }

 _Myt& replace(size_type _Off,
  size_type _N0, size_type _Count, _Elem _Ch)
  {
  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;
  if (npos - _Count <= this->_Mysize - _N0)
   _Xlen();
  size_type _Nm = this->_Mysize - _N0 - _Off;

  if (_Count < _N0)
   _Traits::move(this->_Myptr() + _Off + _Count,
    this->_Myptr() + _Off + _N0,
    _Nm);
  size_type _Num;
  if ((0 < _Count || 0 < _N0)
   && _Grow(_Num = this->_Mysize + _Count - _N0))
   {
   if (_N0 < _Count)
    _Traits::move(this->_Myptr() + _Off + _Count,
     this->_Myptr() + _Off + _N0, _Nm);
   _Chassign(_Off, _Count, _Ch);
   _Eos(_Num);
   }
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Myt& _Right)
  {
  return (replace(
   _Pdif(_First, begin()), _Pdif(_Last, _First), _Right));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Elem *_Ptr, size_type _Count)
  {
  return (replace(
   _Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr, _Count));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const _Elem *_Ptr)
  {
  return (replace(
   _Pdif(_First, begin()), _Pdif(_Last, _First), _Ptr));
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  size_type _Count, _Elem _Ch)
  {
  return (replace(
   _Pdif(_First, begin()), _Pdif(_Last, _First), _Count, _Ch));
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   _Myt&>::type
  replace(const_iterator _First, const_iterator _Last,
   _Iter _First2, _Iter _Last2)
  {
  _Myt _Right(_First2, _Last2);
  replace(_First, _Last, _Right);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const_pointer _First2, const_pointer _Last2)
  {
  if (_First2 == _Last2)
   erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
  else
   replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  pointer _First2, pointer _Last2)
  {
  if (_First2 == _Last2)
   erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
  else
   replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  const_iterator _First2, const_iterator _Last2)
  {
  if (_First2 == _Last2)
   erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
  else
   replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 _Myt& replace(const_iterator _First, const_iterator _Last,
  iterator _First2, iterator _Last2)
  {
  if (_First2 == _Last2)
   erase(_Pdif(_First, begin()), _Pdif(_Last, _First));
  else
   replace(_Pdif(_First, begin()), _Pdif(_Last, _First),
    &*_First2, _Last2 - _First2);
  return (*this);
  }

 iterator begin() throw ()
  {
  return (iterator(this->_Myptr(), this));
  }

 const_iterator begin() const throw ()
  {
  return (const_iterator(this->_Myptr(), this));
  }

 iterator end() throw ()
  {
  return (iterator(this->_Myptr() + this->_Mysize, this));
  }

 const_iterator end() const throw ()
  {
  return (const_iterator(this->_Myptr() + this->_Mysize, this));
  }

 reverse_iterator rbegin() throw ()
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const throw ()
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() throw ()
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const throw ()
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const throw ()
  {
  return (((const _Myt *)this)->begin());
  }

 const_iterator cend() const throw ()
  {
  return (((const _Myt *)this)->end());
  }

 const_reverse_iterator crbegin() const throw ()
  {
  return (((const _Myt *)this)->rbegin());
  }

 const_reverse_iterator crend() const throw ()
  {
  return (((const _Myt *)this)->rend());
  }

 void shrink_to_fit()
  {
  if ((size() | this->_ALLOC_MASK) < capacity())
   {
   _Myt _Tmp(*this);
   swap(_Tmp);
   }
  }

 reference at(size_type _Off)
  {
  if (this->_Mysize <= _Off)
   _Xran();
  return (this->_Myptr()[_Off]);
  }

 const_reference at(size_type _Off) const
  {
  if (this->_Mysize <= _Off)
   _Xran();
  return (this->_Myptr()[_Off]);
  }

 reference operator[](size_type _Off)
  {
#line 1691 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstring"
  return (this->_Myptr()[_Off]);
  }

 const_reference operator[](size_type _Off) const
  {
#line 1704 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xstring"
  return (this->_Myptr()[_Off]);
  }

 void push_back(_Elem _Ch)
  {
  insert(end(), _Ch);
  }

 void pop_back()
  {
  erase(this->_Mysize - 1);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

 const _Elem *c_str() const throw ()
  {
  return (this->_Myptr());
  }

 const _Elem *data() const throw ()
  {
  return (c_str());
  }

 size_type length() const throw ()
  {
  return (this->_Mysize);
  }

 size_type size() const throw ()
  {
  return (this->_Mysize);
  }

 size_type max_size() const throw ()
  {
  size_type _Num = this->_Getal().max_size();
  return (_Num <= 1 ? 1 : _Num - 1);
  }

 void resize(size_type _Newsize)
  {
  resize(_Newsize, _Elem());
  }

 void resize(size_type _Newsize, _Elem _Ch)
  {
  if (_Newsize <= this->_Mysize)
   _Eos(_Newsize);
  else
   append(_Newsize - this->_Mysize, _Ch);
  }

 size_type capacity() const throw ()
  {
  return (this->_Myres);
  }

 void reserve(size_type _Newcap = 0)
  {
  if (this->_Mysize <= _Newcap && this->_Myres != _Newcap)
   {
   size_type _Size = this->_Mysize;
   if (_Grow(_Newcap, true))
    _Eos(_Size);
   }
  }

 bool empty() const throw ()
  {
  return (this->_Mysize == 0);
  }



 size_type copy(_Elem *_Ptr,
  size_type _Count, size_type _Off = 0) const
  {





  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _Count)
   _Count = this->_Mysize - _Off;
  _Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
  return (_Count);
  }

 size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
  size_type _Count, size_type _Off = 0) const
  {





  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _Count)
   _Count = this->_Mysize - _Off;
  _Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
  return (_Count);
  }

 void _Swap_bx(_Myt& _Right)
  {
  if (this->_BUF_SIZE <= this->_Myres)
   if (this->_BUF_SIZE <= _Right._Myres)
    _Swap_adl(this->_Bx._Ptr, _Right._Bx._Ptr);
   else
    {
    pointer _Ptr = this->_Bx._Ptr;
    this->_Getal().destroy(&this->_Bx._Ptr);
    _Traits::copy(this->_Bx._Buf,
     _Right._Bx._Buf, _Right._Mysize + 1);
    this->_Getal().construct(&_Right._Bx._Ptr, _Ptr);
    }
  else
   if (_Right._Myres < this->_BUF_SIZE)
    ::std:: swap(this->_Bx._Buf, _Right._Bx._Buf);
   else
    {
    pointer _Ptr = _Right._Bx._Ptr;
    this->_Getal().destroy(&_Right._Bx._Ptr);
    _Traits::copy(_Right._Bx._Buf,
     this->_Bx._Buf, this->_Mysize + 1);
    this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
    }
  }

 void swap(_Myt& _Right)
  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   _Swap_bx(_Right);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   ::std:: swap(this->_Myres, _Right._Myres);
   }

  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   _Swap_bx(_Right);
   ::std:: swap(this->_Bx, _Right._Bx);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   ::std:: swap(this->_Myres, _Right._Myres);
   }

  else
   {
   _Myt _Tmp = *this;

   *this = _Right;
   _Right = _Tmp;
   }
  }

 size_type find(const _Myt& _Right, size_type _Off = 0) const throw ()
  {
  return (find(_Right._Myptr(), _Off, _Right.size()));
  }

 size_type find(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {





  if (_Count == 0 && _Off <= this->_Mysize)
   return (_Off);

  size_type _Nm;
  if (_Off < this->_Mysize && _Count <= (_Nm = this->_Mysize - _Off))
   {
   const _Elem *_Uptr, *_Vptr;
   for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
    (_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
    _Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
    if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
     return (_Uptr - this->_Myptr());
   }

  return (npos);
  }

 size_type find(const _Elem *_Ptr, size_type _Off = 0) const
  {
                      ;
  return (find(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find(_Elem _Ch, size_type _Off = 0) const
  {
  return (find((const _Elem *)&_Ch, _Off, 1));
  }

 size_type rfind(const _Myt& _Right, size_type _Off = npos) const throw ()
  {
  return (rfind(_Right._Myptr(), _Off, _Right.size()));
  }

 size_type rfind(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {





  if (_Count == 0)
   return (_Off < this->_Mysize ? _Off
    : this->_Mysize);
  if (_Count <= this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr() +
    (_Off < this->_Mysize - _Count ? _Off
     : this->_Mysize - _Count);
   for (; ; --_Uptr)
    if (_Traits::eq(*_Uptr, *_Ptr)
     && _Traits::compare(_Uptr, _Ptr, _Count) == 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }

  return (npos);
  }

 size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
  {
                      ;
  return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type rfind(_Elem _Ch, size_type _Off = npos) const
  {
  return (rfind((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_first_of(const _Myt& _Right,
  size_type _Off = 0) const throw ()
  {
  return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
  }

 size_type find_first_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {





  if (0 < _Count && _Off < this->_Mysize)
   {
   const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
   for (const _Elem *_Uptr = this->_Myptr() + _Off;
    _Uptr < _Vptr; ++_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
     return (_Uptr - this->_Myptr());
   }

  return (npos);
  }

 size_type find_first_of(const _Elem *_Ptr,
  size_type _Off = 0) const
  {
                      ;
  return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_first_of(_Elem _Ch,
  size_type _Off = 0) const
  {
  return (find((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_last_of(const _Myt& _Right,
  size_type _Off = npos) const throw ()
  {
  return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
  }

 size_type find_last_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {





  if (0 < _Count && 0 < this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr()
    + (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
   for (; ; --_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }

  return (npos);
  }

 size_type find_last_of(const _Elem *_Ptr,
  size_type _Off = npos) const
  {
                      ;
  return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_last_of(_Elem _Ch,
  size_type _Off = npos) const
  {
  return (rfind((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_first_not_of(const _Myt& _Right,
  size_type _Off = 0) const throw ()
  {
  return (find_first_not_of(_Right._Myptr(), _Off,
   _Right.size()));
  }

 size_type find_first_not_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {





  if (_Off < this->_Mysize)
   {
   const _Elem *const _Vptr = this->_Myptr() + this->_Mysize;
   for (const _Elem *_Uptr = this->_Myptr() + _Off;
    _Uptr < _Vptr; ++_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
     return (_Uptr - this->_Myptr());
   }
  return (npos);
  }

 size_type find_first_not_of(const _Elem *_Ptr,
  size_type _Off = 0) const
  {
                      ;
  return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_first_not_of(_Elem _Ch,
  size_type _Off = 0) const
  {
  return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
  }

 size_type find_last_not_of(const _Myt& _Right,
  size_type _Off = npos) const throw ()
  {
  return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
  }

 size_type find_last_not_of(const _Elem *_Ptr,
  size_type _Off, size_type _Count) const
  {





  if (0 < this->_Mysize)
   {
   const _Elem *_Uptr = this->_Myptr()
    + (_Off < this->_Mysize ? _Off : this->_Mysize - 1);
   for (; ; --_Uptr)
    if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
     return (_Uptr - this->_Myptr());
    else if (_Uptr == this->_Myptr())
     break;
   }
  return (npos);
  }

 size_type find_last_not_of(const _Elem *_Ptr,
  size_type _Off = npos) const
  {
                      ;
  return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
  }

 size_type find_last_not_of(_Elem _Ch,
  size_type _Off = npos) const
  {
  return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
  }

 _Myt substr(size_type _Off = 0, size_type _Count = npos) const
  {
  return (_Myt(*this, _Off, _Count, get_allocator()));
  }

 int compare(const _Myt& _Right) const throw ()
  {
  return (compare(0, this->_Mysize, _Right._Myptr(), _Right.size()));
  }

 int compare(size_type _Off, size_type _N0,
  const _Myt& _Right) const
  {
  return (compare(_Off, _N0, _Right, 0, npos));
  }

 int compare(size_type _Off,
  size_type _N0, const _Myt& _Right,
  size_type _Roff, size_type _Count) const
  {
  if (_Right.size() < _Roff)
   _Xran();
  if (_Right._Mysize - _Roff < _Count)
   _Count = _Right._Mysize - _Roff;
  return (compare(_Off, _N0, _Right._Myptr() + _Roff, _Count));
  }

 int compare(const _Elem *_Ptr) const
  {
                      ;
  return (compare(0, this->_Mysize, _Ptr, _Traits::length(_Ptr)));
  }

 int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
  {
                      ;
  return (compare(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
  }

 int compare(size_type _Off,
  size_type _N0, const _Elem *_Ptr, size_type _Count) const
  {





  if (this->_Mysize < _Off)
   _Xran();
  if (this->_Mysize - _Off < _N0)
   _N0 = this->_Mysize - _Off;

  size_type _Ans = _Traits::compare(this->_Myptr() + _Off, _Ptr,
   _N0 < _Count ? _N0 : _Count);
  return (_Ans != 0 ? (int)_Ans : _N0 < _Count ? -1
   : _N0 == _Count ? 0 : +1);
  }

 allocator_type get_allocator() const throw ()
  {
  return (this->_Getal());
  }

 void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
  {
  if (_Count == 1)
   _Traits::assign(*(this->_Myptr() + _Off), _Ch);
  else
   _Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
  }

 void _Copy(size_type _Newsize, size_type _Oldlen)
  {
  size_type _Newres = _Newsize | this->_ALLOC_MASK;
  if (max_size() < _Newres)
   _Newres = _Newsize;
  else if (this->_Myres / 2 <= _Newres / 3)
   ;
  else if (this->_Myres <= max_size() - this->_Myres / 2)
   _Newres = this->_Myres
    + this->_Myres / 2;
  else
   _Newres = max_size();

  _Elem *_Ptr;
  try {
   _Ptr = this->_Getal().allocate(_Newres + 1);
  } catch (...) {
   _Newres = _Newsize;
   try {
    _Ptr = this->_Getal().allocate(_Newres + 1);
   } catch (...) {
   _Tidy(true);
   throw;
   }
  }

  if (0 < _Oldlen)
   _Traits::copy(_Ptr, this->_Myptr(),
    _Oldlen);
  _Tidy(true);
  this->_Getal().construct(&this->_Bx._Ptr, _Ptr);
  this->_Myres = _Newres;
  _Eos(_Oldlen);
  }

 void _Eos(size_type _Newsize)
  {
  _Traits::assign(this->_Myptr()[this->_Mysize = _Newsize], _Elem());
  }

 bool _Grow(size_type _Newsize,
  bool _Trim = false)
  {
  if (max_size() < _Newsize)
   _Xlen();
  if (this->_Myres < _Newsize)
   _Copy(_Newsize, this->_Mysize);
  else if (_Trim && _Newsize < this->_BUF_SIZE)
   _Tidy(true,
    _Newsize < this->_Mysize ? _Newsize : this->_Mysize);
  else if (_Newsize == 0)
   _Eos(0);
  return (0 < _Newsize);
  }

 bool _Inside(const _Elem *_Ptr)
  {
  if (_Ptr == 0 || _Ptr < this->_Myptr()
   || this->_Myptr() + this->_Mysize <= _Ptr)
   return (false);
  else
   return (true);
  }

 static size_type _Pdif(const_iterator _P2,
  const_iterator _P1)
  {
  return ((_P2)._Ptr == 0 ? 0 : _P2 - _P1);
  }

 void _Tidy(bool _Built = false,
  size_type _Newsize = 0)
  {
  if (!_Built)
   ;
  else if (this->_BUF_SIZE <= this->_Myres)
   {
   pointer _Ptr = this->_Bx._Ptr;
   this->_Getal().destroy(&this->_Bx._Ptr);
   if (0 < _Newsize)
    _Traits::copy(this->_Bx._Buf,
     ::std:: addressof(*_Ptr), _Newsize);
   this->_Getal().deallocate(_Ptr, this->_Myres + 1);
   }
  this->_Myres = this->_BUF_SIZE - 1;
  _Eos(_Newsize);
  }

 __declspec(noreturn) void _Xlen() const
  {
  _Xlength_error("string too long");
  }

 __declspec(noreturn) void _Xran() const
  {
  _Xout_of_range("invalid string position");
  }
 };


template<class _Elem,
 class _Traits,
 class _Alloc>
          const typename basic_string<_Elem, _Traits, _Alloc>::size_type
  basic_string<_Elem, _Traits, _Alloc>::npos =
   (typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);



template<class _Elem,
 class _Traits,
 class _Alloc> inline
 void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 _Left.swap(_Right);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem *_Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Traits::length(_Left) + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(1 + _Right.size());
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + _Traits::length(_Right));
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem _Right)
 {
 basic_string<_Elem, _Traits, _Alloc> _Ans;
 _Ans.reserve(_Left.size() + 1);
 _Ans += _Left;
 _Ans += _Right;
 return (_Ans);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 if (_Right.size() <= _Left.capacity() - _Left.size()
  || _Right.capacity() - _Right.size() < _Left.size())
  return (::std:: move(_Left.append(_Right)));
 else
  return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem *_Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  const _Elem _Left,
  basic_string<_Elem, _Traits, _Alloc>&& _Right)
 {
 return (::std:: move(_Right.insert(0, 1, _Left)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem *_Right)
 {
 return (::std:: move(_Left.append(_Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_string<_Elem, _Traits, _Alloc> operator+(
  basic_string<_Elem, _Traits, _Alloc>&& _Left,
  const _Elem _Right)
 {
 return (::std:: move(_Left.append(1, _Right)));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Left.compare(_Right) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator==(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Left.compare(_Right) == 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const _Elem *_Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator!=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Left == _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right.compare(_Left) > 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Left.compare(_Right) < 0);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (_Right < _Left);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator<=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Right < _Left));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const _Elem * _Left,
  const basic_string<_Elem, _Traits, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 bool operator>=(
  const basic_string<_Elem, _Traits, _Alloc>& _Left,
  const _Elem *_Right)
 {
 return (!(_Left < _Right));
 }

typedef basic_string<char, char_traits<char>, allocator<char> >
 string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
 wstring;


template<class _Elem,
 class _Traits,
 class _Alloc>
 struct hash<basic_string<_Elem, _Traits, _Alloc> >
  : public unary_function<basic_string<_Elem, _Traits, _Alloc>, size_t>
 {
 typedef basic_string<_Elem, _Traits, _Alloc> _Kty;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
   _Keyval.size() * sizeof (_Elem)));
  }
 };

typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
 u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
 u32string;
}


#pragma warning(pop)
#pragma pack(pop)
#line 7 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"


#pragma pack(push,8)
#pragma warning(push, 3)


namespace std {
#line 25 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"
class logic_error
 : public ::std:: exception
 {
public:
 typedef ::std:: exception _Mybase;

 explicit logic_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit logic_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
#line 50 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"
 };


class domain_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit domain_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit domain_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
#line 78 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"
 };


class invalid_argument
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit invalid_argument(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit invalid_argument(const char *_Message)
  : _Mybase(_Message)
  {
  }
#line 106 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"
 };


class length_error
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit length_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit length_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
#line 134 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"
 };


class out_of_range
 : public logic_error
 {
public:
 typedef logic_error _Mybase;

 explicit out_of_range(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit out_of_range(const char *_Message)
  : _Mybase(_Message)
  {
  }
#line 162 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"
 };


class runtime_error
 : public ::std:: exception
 {
public:
 typedef ::std:: exception _Mybase;

 explicit runtime_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit runtime_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
#line 190 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"
 };


class overflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit overflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit overflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
#line 218 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"
 };


class underflow_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit underflow_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit underflow_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
#line 246 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"
 };


class range_error
 : public runtime_error
 {
public:
 typedef runtime_error _Mybase;

 explicit range_error(const string& _Message)
  : _Mybase(_Message.c_str())
  {
  }

 explicit range_error(const char *_Message)
  : _Mybase(_Message)
  {
  }
#line 274 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\stdexcept"
 };
}

#pragma warning(pop)
#pragma pack(pop)
#line 8 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocale"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\typeinfo"
#line 23 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\typeinfo"
#pragma pack(push,8)
#pragma warning(push, 3)


#pragma warning(disable: 4275)
#line 37 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\typeinfo"
struct __type_info_node {
    void *_MemPtr;
    __type_info_node* _Next;
};

extern __type_info_node __type_info_root_node;

class type_info {
public:
 size_t hash_code() const throw ()
  {
  return (::std:: _Hash_seq((const unsigned char *) name(),
   :: strlen(name())));
  }







    virtual ~type_info() throw ();




    __declspec(dllimport) bool operator==(const type_info& _Rhs) const;
    __declspec(dllimport) bool operator!=(const type_info& _Rhs) const;

    __declspec(dllimport) bool before(const type_info& _Rhs) const;
    __declspec(dllimport) const char* name(__type_info_node* __ptype_info_node = &__type_info_root_node) const;
    __declspec(dllimport) const char* raw_name() const;
private:
    void *_M_data;
    char _M_d_name[1];




public:
                       type_info(const type_info&) = delete;
    type_info& operator=(const type_info&) = delete;
private:

    __declspec(dllimport) static const char *__cdecl _Name_base(const type_info *,__type_info_node* __ptype_info_node);
    __declspec(dllimport) static void __cdecl _Type_info_dtor(type_info *);
#line 95 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\typeinfo"
};



 namespace std {

using ::type_info;

 }






 namespace std {

class __declspec(dllimport) bad_cast : public exception {
public:
#line 132 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\typeinfo"
                       bad_cast(const char * _Message = "bad cast");
                       bad_cast(const bad_cast &);
    virtual ~bad_cast() throw ();







};

class __declspec(dllimport) bad_typeid : public exception {
public:
#line 156 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\typeinfo"
                       bad_typeid(const char * _Message = "bad typeid");
                       bad_typeid(const bad_typeid &);
    virtual ~bad_typeid() throw ();


};

class __declspec(dllimport) __non_rtti_object : public bad_typeid {
public:
#line 175 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\typeinfo"
                       __non_rtti_object(const char * _Message);
                       __non_rtti_object(const __non_rtti_object &);
    virtual ~__non_rtti_object() throw ();

};

 }
#line 245 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\typeinfo"
#pragma pack(pop)
#pragma warning(pop)
#line 9 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocale"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocinfo"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocinfo.h"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ctype.h"
#line 19 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ctype.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 19 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ctype.h"



extern "C" {
#line 119 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ctype.h"
               __declspec(dllimport) int __cdecl _isctype( int _C, int _Type);
               __declspec(dllimport) int __cdecl _isctype_l( int _C, int _Type, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isalpha( int _C);
               __declspec(dllimport) int __cdecl _isalpha_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isupper( int _C);
               __declspec(dllimport) int __cdecl _isupper_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl islower( int _C);
               __declspec(dllimport) int __cdecl _islower_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isdigit( int _C);
               __declspec(dllimport) int __cdecl _isdigit_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isxdigit( int _C);
               __declspec(dllimport) int __cdecl _isxdigit_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isspace( int _C);
               __declspec(dllimport) int __cdecl _isspace_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl ispunct( int _C);
               __declspec(dllimport) int __cdecl _ispunct_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isblank( int _C);
               __declspec(dllimport) int __cdecl _isblank_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl isalnum( int _C);
               __declspec(dllimport) int __cdecl _isalnum_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isprint( int _C);
               __declspec(dllimport) int __cdecl _isprint_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl isgraph( int _C);
               __declspec(dllimport) int __cdecl _isgraph_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl iscntrl( int _C);
               __declspec(dllimport) int __cdecl _iscntrl_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl toupper( int _C);
                                  __declspec(dllimport) int __cdecl tolower( int _C);
                                  __declspec(dllimport) int __cdecl _tolower( int _C);
               __declspec(dllimport) int __cdecl _tolower_l( int _C, _locale_t _Locale);
                                  __declspec(dllimport) int __cdecl _toupper( int _C);
               __declspec(dllimport) int __cdecl _toupper_l( int _C, _locale_t _Locale);
               __declspec(dllimport) int __cdecl __isascii( int _C);
               __declspec(dllimport) int __cdecl __toascii( int _C);
               __declspec(dllimport) int __cdecl __iscsymf( int _C);
               __declspec(dllimport) int __cdecl __iscsym( int _C);
#line 387 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ctype.h"
}
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocinfo.h"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\locale.h"
#line 19 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\locale.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 19 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\locale.h"






#pragma pack(push,8)


extern "C" {
#line 55 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\locale.h"
struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        wchar_t *_W_decimal_point;
        wchar_t *_W_thousands_sep;
        wchar_t *_W_int_curr_symbol;
        wchar_t *_W_currency_symbol;
        wchar_t *_W_mon_decimal_point;
        wchar_t *_W_mon_thousands_sep;
        wchar_t *_W_positive_sign;
        wchar_t *_W_negative_sign;
        };
#line 107 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\locale.h"
                   __declspec(dllimport) int __cdecl _configthreadlocale( int _Flag);
                   __declspec(dllimport) char * __cdecl setlocale( int _Category, const char * _Locale);
                   __declspec(dllimport) struct lconv * __cdecl localeconv(void);
                   __declspec(dllimport) _locale_t __cdecl _get_current_locale(void);
                   __declspec(dllimport) _locale_t __cdecl _create_locale( int _Category, const char * _Locale);
__declspec(dllimport) void __cdecl _free_locale( _locale_t _Locale);



               __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_get_current_locale" " instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __get_current_locale(void);
               __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_create_locale" " instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __create_locale( int _Category, const char * _Locale);
__declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "_free_locale" " instead. See online help for details.")) __declspec(dllimport) void __cdecl __free_locale( _locale_t _Locale);
#line 132 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\locale.h"
}


#pragma pack(pop)
#line 7 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocinfo.h"




#pragma pack(push,8)
#pragma warning(push, 3)






extern "C" {
#line 56 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocinfo.h"
typedef struct _Collvec
 {
 unsigned int _Page;
 wchar_t *_LocaleName;
 } _Collvec;

typedef struct _Ctypevec
 {
 unsigned int _Page;
 const short *_Table;
 int _Delfl;
 wchar_t *_LocaleName;
 } _Ctypevec;

typedef struct _Cvtvec
 {
 unsigned int _Page;
 unsigned int _Mbcurmax;
 int _Isclocale;
 unsigned char _Isleadbyte[32];
 } _Cvtvec;


__declspec(dllimport) _Collvec __cdecl _Getcoll();
__declspec(dllimport) _Ctypevec __cdecl _Getctype();
__declspec(dllimport) _Cvtvec __cdecl _Getcvt();
__declspec(dllimport) int __cdecl _Getdateorder();
#line 93 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocinfo.h"
__declspec(dllimport) int __cdecl _Mbrtowc( wchar_t *, const char *, size_t,
 mbstate_t *, const _Cvtvec *);


__declspec(dllimport) float __cdecl _Stof(const char *,
                                  char **, long);
__declspec(dllimport) double __cdecl _Stod(const char *,
                                  char **, long);
__declspec(dllimport) long double __cdecl _Stold(const char *,
                                  char **, long);

__declspec(dllimport) int __cdecl _Strcoll(const char *, const char *,
 const char *, const char *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Strxfrm(
                                                             char *_String1,
        char *_End1, const char *, const char *, const _Collvec *);
__declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Wcrtomb( char *, wchar_t, mbstate_t *,
 const _Cvtvec *);
__declspec(dllimport) int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
 const wchar_t *, const wchar_t *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Wcsxfrm(
                                                             wchar_t *_String1,
        wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

__declspec(dllimport) short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
__declspec(dllimport) const wchar_t *__cdecl _Getwctypes(const wchar_t *,
 const wchar_t *, short *, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);



}




extern "C" {
__declspec(dllimport) char *__cdecl _Getdays();
__declspec(dllimport) char *__cdecl _Getmonths();
__declspec(dllimport) void *__cdecl _Gettnames();
__declspec(dllimport) size_t __cdecl _Strftime( char *,
      size_t _Maxsize, const char *,
      const struct tm *, void *);

__declspec(dllimport) wchar_t *__cdecl _W_Getdays();
__declspec(dllimport) wchar_t *__cdecl _W_Getmonths();
__declspec(dllimport) void *__cdecl _W_Gettnames();
__declspec(dllimport) size_t __cdecl _Wcsftime( wchar_t *,
      size_t _Maxsize, const wchar_t *,
      const struct tm *, void *);
}
#line 156 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocinfo.h"
__declspec(dllimport) _locale_t __cdecl _GetLocaleForCP(unsigned int);



#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocinfo"




#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4412)

namespace std {

class __declspec(dllimport) _Timevec
 {
public:
                    _Timevec(void *_Ptr = 0)
  : _Timeptr(_Ptr)
  {
  }

                    _Timevec(const _Timevec& _Right)
  {
  *this = _Right;
  }

                    ~_Timevec() throw ()
  {
  free(_Timeptr);
  }

 _Timevec& operator=(const _Timevec& _Right)
  {
  _Timeptr = _Right._Timeptr;
  ((_Timevec *)&_Right)->_Timeptr = 0;
  return (*this);
  }

 void * _Getptr() const
  {
  return (_Timeptr);
  }

private:
 void *_Timeptr;
 };


class __declspec(dllimport) _Locinfo
 {
public:
 typedef ::_Collvec _Collvec;
 typedef ::_Ctypevec _Ctypevec;
 typedef ::_Cvtvec _Cvtvec;
 typedef ::std:: _Timevec _Timevec;

 static void __cdecl _Locinfo_ctor(
  _Locinfo *, const char *);
 static void __cdecl _Locinfo_ctor(
  _Locinfo *, int, const char *);
 static void __cdecl _Locinfo_dtor(
  _Locinfo *);
 static _Locinfo& __cdecl _Locinfo_Addcats(
  _Locinfo *, int, const char *);

                    _Locinfo(const char *_Pch = "C")

  : _Lock(0)


  {
  if (_Pch == 0)
   throw runtime_error("bad locale name");
  _Locinfo_ctor(this, _Pch);
  }

                    _Locinfo(int _Cat, const char *_Pch)

  : _Lock(0)


  {
  if (_Pch == 0)
   throw runtime_error("bad locale name");
  _Locinfo_ctor(this, _Cat, _Pch);
  }

                    ~_Locinfo() throw ()
  {
  _Locinfo_dtor(this);
  }

 _Locinfo& _Addcats(int _Cat, const char *_Pch)
  {
  if (_Pch == 0)
   throw runtime_error("bad locale name");
  return (_Locinfo_Addcats(this, _Cat, _Pch));
  }

 const char * _Getname() const
  {
  return (_Newlocname._C_str());
  }

 _Collvec _Getcoll() const
  {
  return (::_Getcoll());
  }

 _Ctypevec _Getctype() const
  {
  return (::_Getctype());
  }

 _Cvtvec _Getcvt() const
  {
  return (::_Getcvt());
  }

 const lconv * _Getlconv() const
  {
  return (localeconv());
  }

 _Timevec _Gettnames() const
  {
  return (_Timevec(::_Gettnames()));
  }

 const char * _Getdays() const
  {
  const char *_Ptr = ::_Getdays();

  if (_Ptr != 0)
   {
   ((_Locinfo *)this)->_Days = _Ptr;
   free((void *)_Ptr);
   }
  return (!_Days._Empty() ? _Days._C_str()
   : ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
    ":Thu:Thursday:Fri:Friday:Sat:Saturday");
  }

 const char * _Getmonths() const
  {
  const char *_Ptr = ::_Getmonths();

  if (_Ptr != 0)
   {
   ((_Locinfo *)this)->_Months = _Ptr;
   free((void *)_Ptr);
   }
  return (!_Months._Empty() ? _Months._C_str()
   : ":Jan:January:Feb:February:Mar:March"
    ":Apr:April:May:May:Jun:June"
    ":Jul:July:Aug:August:Sep:September"
    ":Oct:October:Nov:November:Dec:December");
  }

 const char * _Getfalse() const
  {
  return ("false");
  }

 const char * _Gettrue() const
  {
  return ("true");
  }

 int _Getdateorder() const
  {
  return (::_Getdateorder());
  }

 _Timevec _W_Gettnames() const
  {
  return (_Timevec(::_W_Gettnames()));
  }

 const unsigned short * _W_Getdays() const
  {
  const wchar_t *_Ptr = ::_W_Getdays();

  if (_Ptr != 0)
   {
   ((_Locinfo *)this)->_W_Days = _Ptr;
   free((void *)_Ptr);
   }
  return ((const unsigned short *)(!_W_Days._Empty()
   ? _W_Days._C_str()
   : L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
    L":Thu:Thursday:Fri:Friday:Sat:Saturday"));
  }

 const unsigned short * _W_Getmonths() const
  {
  const wchar_t *_Ptr = ::_W_Getmonths();

  if (_Ptr != 0)
   {
   ((_Locinfo *)this)->_W_Months = _Ptr;
   free((void *)_Ptr);
   }
  return ((const unsigned short *)(!_W_Months._Empty()
   ? _W_Months._C_str()
   : L":Jan:January:Feb:February:Mar:March"
    L":Apr:April:May:May:Jun:June"
    L":Jul:July:Aug:August:Sep:September"
    L":Oct:October:Nov:November:Dec:December"));
  }

 _Locinfo(const _Locinfo&) = delete;
 _Locinfo& operator=(const _Locinfo&) = delete;

private:




 _Lockit _Lock;


 _Yarn<char> _Days;
 _Yarn<char> _Months;
 _Yarn<wchar_t> _W_Days;
 _Yarn<wchar_t> _W_Months;
 _Yarn<char> _Oldlocname;
 _Yarn<char> _Newlocname;
 };


template<class _Elem> inline
 int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
  const _Elem *_First2, const _Elem *_Last2,
   const _Locinfo::_Collvec *)
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
  if (*_First1 < *_First2)
   return (-1);
  else if (*_First2 < *_First1)
   return (+1);
 return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
 }

template<> inline
 int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
  const char *_First2, const char *_Last2,
   const _Locinfo::_Collvec *_Vector)
 {
 return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
 }

template<> inline
 int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
  const wchar_t *_First2, const wchar_t *_Last2,
   const _Locinfo::_Collvec *_Vector)
 {
 return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
 }


template<class _Elem> inline
 size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
  const _Elem *_First2, const _Elem *_Last2,
   const _Locinfo::_Collvec *)
 {
 size_t _Count = _Last2 - _First2;
 if (_Count <= (size_t)(_Last1 - _First1))
  ::memcpy_s((_First1), ((_Last1 - _First1) * sizeof (_Elem)), (_First2), (_Count * sizeof (_Elem)));

 return (_Count);
 }

template<> inline
 size_t __cdecl _LStrxfrm(
                               char *_First1, char *_Last1,
  const char *_First2, const char *_Last2,
   const _Locinfo::_Collvec *_Vector)
 {
 return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
 }

template<> inline
 size_t __cdecl _LStrxfrm(
                               wchar_t *_First1, wchar_t *_Last1,
  const wchar_t *_First2, const wchar_t *_Last2,
   const _Locinfo::_Collvec *_Vector)
 {
 return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
 }
}

#pragma warning(pop)
#pragma pack(pop)
#line 10 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocale"

#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xdebug"







#pragma pack(push,8)
#pragma warning(push, 3)






namespace std {
struct _DebugHeapTag_t
 {
 int _Type;
 };
}
#line 77 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xdebug"
#pragma warning(pop)
#pragma pack(pop)
#line 11 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocale"


#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xfacet"







#pragma pack(push,8)
#pragma warning(push, 3)








namespace std {

class __declspec(dllimport) _Facet_base
 {
public:
 virtual ~_Facet_base() throw ()
  {
  }


 virtual void _Incref() = 0;


 virtual _Facet_base * _Decref() = 0;
 };





void __cdecl _Facet_Register(_Facet_base *);

}

#pragma warning(pop)
#pragma pack(pop)
#line 13 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocale"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4412 28197)

namespace std {

template<class _Dummy>
 class _Locbase
 {
public:
          static const int collate = ((1 << (1)) >> 1);
          static const int ctype = ((1 << (2)) >> 1);
          static const int monetary = ((1 << (3)) >> 1);
          static const int numeric = ((1 << (4)) >> 1);
          static const int time = ((1 << (5)) >> 1);
          static const int messages = ((1 << (6)) >> 1);
          static const int all = (((1 << ((6 + 1))) >> 1) - 1);
          static const int none = 0;
 };

template<class _Dummy>
 const int _Locbase<_Dummy>::collate;
template<class _Dummy>
 const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
 const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
 const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
 const int _Locbase<_Dummy>::time;
template<class _Dummy>
 const int _Locbase<_Dummy>::messages;
template<class _Dummy>
 const int _Locbase<_Dummy>::all;
template<class _Dummy>
 const int _Locbase<_Dummy>::none;


class locale;
template<class _Facet>
 const _Facet& __cdecl use_facet(const locale&);
template<class _Elem>
 class collate;

class locale
 : public _Locbase<int>
 {
public:
 typedef int category;


 class __declspec(dllimport) id
  {
 public:
                     id(size_t _Val = 0)
   : _Id(_Val)
   {
   }

                     operator size_t()
   {
   if (_Id == 0)
    {
    { ::std:: _Lockit _Lock(0);
     if (_Id == 0)
      _Id = ++_Id_cnt;
    }
    }
   return (_Id);
   }

 private:
  size_t _Id;

                          static int _Id_cnt;

 public:
                     id(const id&) = delete;
  id& operator=(const id&) = delete;
  };

 class _Locimp;


 class __declspec(dllimport) facet
  : public _Facet_base
  {
  friend class locale;
  friend class _Locimp;

  template<class _Ty>
   friend void __cdecl _DebugHeapDelete(_Ty *_Ptr);

 public:
  static size_t __cdecl _Getcat(const facet ** = 0,
   const locale * = 0)
   {
   return ((size_t)(-1));
   }
#line 143 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocale"
  virtual void _Incref()
   {
   _InterlockedIncrement(reinterpret_cast<volatile long *>(&_Refs));
   }

  virtual _Facet_base * _Decref()
   {
   if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Refs)) == 0)
    return (this);
   else
    return (0);
   }

 private:
  _Atomic_counter_t _Refs;

 protected:
  explicit facet(size_t _Initrefs = 0)
   {
   _Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs);
   }

  virtual ~facet() throw ()
   {
   }

 public:
                     facet(const facet&) = delete;
  facet& operator=(const facet&) = delete;
  };


#pragma warning(push)
#pragma warning(disable: 4275)

 class __declspec(dllimport) _Locimp
  : public facet
  {
 protected:
                     ~_Locimp() throw ()
  {
  _Locimp_dtor(this);
  }

 private:
  static _Locimp *__cdecl
   _New_Locimp(bool _Transparent = false);
  static _Locimp *__cdecl
   _New_Locimp(const _Locimp& _Right);

  static void __cdecl
   _Locimp_dtor(_Locimp *);
  static void __cdecl
   _Locimp_Addfac(_Locimp *, facet *, size_t);
  static void __cdecl
   _Locimp_ctor(_Locimp *, const _Locimp&);

  friend class locale;

                     _Locimp(bool _Transparent)
   : locale::facet(1), _Facetvec(0), _Facetcount(0),
    _Catmask(none), _Xparent(_Transparent),
     _Name("*")
   {
   }

                     _Locimp(const _Locimp& _Right)
   : locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
    _Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
     _Name(_Right._Name.c_str())
   {
   _Locimp_ctor(this, _Right);
   }

  void _Addfac(facet *_Pfacet, size_t _Id)
   {
   _Locimp_Addfac(this, _Pfacet, _Id);
   }

  static _Locimp *__cdecl _Makeloc(const _Locinfo&,
   category, _Locimp *, const locale *);

  static void __cdecl _Makewloc(const _Locinfo&,
   category, _Locimp *, const locale *);


  static void __cdecl _Makeushloc(const _Locinfo&,
   category, _Locimp *, const locale *);


  static void __cdecl _Makexloc(const _Locinfo&,
   category, _Locimp *, const locale *);

  facet **_Facetvec;
  size_t _Facetcount;
  category _Catmask;
  bool _Xparent;
  _Yarn<char> _Name;

                          static _Locimp *_Clocptr;

public:
  _Locimp& operator=(const _Locimp&) = delete;
  };

#pragma warning(pop)

 template<class _Elem,
  class _Traits,
  class _Alloc>
  bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
   const basic_string<_Elem, _Traits, _Alloc>& _Right) const
  {
  const ::std:: collate<_Elem>& _Coll_fac =
   use_facet< ::std:: collate<_Elem> >(*this);

  return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
   _Right.c_str(), _Right.c_str() + _Right.size()) < 0);
  }

 template<class _Facet>
  locale combine(const locale& _Loc) const
  {
  _Facet *_Facptr;

  try {
   _Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
  } catch (...) {
   _Xruntime_error("locale::combine facet missing");
  }

  _Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
  _Newimp->_Addfac(_Facptr, _Facet::id);
  _Newimp->_Catmask = 0;
  _Newimp->_Name = "*";
  return (locale(_Newimp));
  }

 template<class _Facet>
  locale(const locale& _Loc, const _Facet *_Facptr)
   : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
  {
  if (_Facptr != 0)
   {
   _Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
   if (_Facet::_Getcat() != (size_t)(-1))
    {
    _Ptr->_Catmask = 0;
    _Ptr->_Name = "*";
    }
   }
  }

 locale(_Uninitialized)
  {
  }
#line 321 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocale"
 locale(const locale& _Right) throw ()
  : _Ptr(_Right._Ptr)
  {
  _Ptr->_Incref();
  }

 locale() throw ()
  : _Ptr(_Init(true))
  {
  }


 locale(const locale& _Loc, const locale& _Other,
  category _Cat)
  : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
  {
  try {
  { _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
   _Locimp::_Makeloc(_Lobj._Addcats(_Cat & _Other._Ptr->_Catmask,
    _Other._Ptr->_Name.c_str()), _Cat, _Ptr, &_Other);
  }
  } catch (...) {
  delete (_Ptr->_Decref());
  throw;
  }
  }

private:
 void _Construct(const string &_Str,
  category _Cat)
  {
  bool _Bad = false;
  try {
  _Init();
  { _Locinfo _Lobj(_Cat, _Str.c_str());
   if (_Badname(_Lobj))
    _Bad = true;
   else
    _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
  }
  } catch (...) {
  delete (_Ptr->_Decref());
  throw;
  }

  if (_Bad)
   {
   delete (_Ptr->_Decref());
   _Xruntime_error("bad locale name");
   }
  }

 void _Construct(const locale& _Loc, const string &_Str,
  category _Cat)
  {
  bool _Bad = false;
  try {
  { _Locinfo _Lobj(_Loc._Ptr->_Catmask, _Loc._Ptr->_Name.c_str());
   bool _Hadname = !_Badname(_Lobj);
   _Lobj._Addcats(_Cat, _Str.c_str());

   if (_Hadname && _Badname(_Lobj))
    _Bad = true;
   else
    _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
  }
  } catch (...) {
  delete (_Ptr->_Decref());
  throw;
  }

  if (_Bad)
   {
   delete (_Ptr->_Decref());
   _Xruntime_error("bad locale name");
   }
  }

public:
 explicit locale(const char *_Locname,
  category _Cat = all)
  : _Ptr(_Locimp::_New_Locimp())
  {


  if (_Locname == 0)
   _Xruntime_error("bad locale name");
  _Construct(_Locname, _Cat);
  }

 locale(const locale& _Loc, const char *_Locname,
  category _Cat)
  : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
  {


  if (_Locname == 0)
   _Xruntime_error("bad locale name");
  _Construct(_Loc, _Locname, _Cat);
  }

 explicit locale(const string& _Str,
  category _Cat = all)
  : _Ptr(_Locimp::_New_Locimp())
  {
  _Construct(_Str, _Cat);
  }

 locale(const locale& _Loc, const string& _Str,
  category _Cat)
  : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
  {
  _Construct(_Loc, _Str, _Cat);
  }


 ~locale() throw ()
  {
  if (_Ptr != 0)
   delete (_Ptr->_Decref());
  }

 locale& operator=(const locale& _Right) throw ()
  {
  if (_Ptr != _Right._Ptr)
   {
   delete (_Ptr->_Decref());
   _Ptr = _Right._Ptr;
   _Ptr->_Incref();
   }
  return (*this);
  }


 string name() const
  {
  return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
  }

 const char *c_str() const
  {
  return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
  }

 const facet *_Getfacet(size_t _Id) const
  {
  const facet *_Facptr = _Id < _Ptr->_Facetcount
   ? _Ptr->_Facetvec[_Id] : 0;
  if (_Facptr != 0 || !_Ptr->_Xparent)
   return (_Facptr);
  else
   {
   locale::_Locimp *_Ptr = _Getgloballocale();
   return (_Id < _Ptr->_Facetcount
    ? _Ptr->_Facetvec[_Id]
    : 0);
   }
  }

 bool operator==(const locale& _Loc) const
  {
  return (_Ptr == _Loc._Ptr
   || (name().compare("*") != 0
    && name().compare(_Loc.name()) == 0));
  }

 bool operator!=(const locale& _Right) const
  {
  return (!(*this == _Right));
  }

 static __declspec(dllimport) const locale& __cdecl
  classic();

 static __declspec(dllimport) locale __cdecl
  global(const locale&);

 static __declspec(dllimport) locale __cdecl
  empty();

private:
 locale(_Locimp *_Ptrimp)
  : _Ptr(_Ptrimp)
  {
  }

    static __declspec(dllimport) _Locimp *__cdecl
  _Init(bool _Do_incref = false);
 static __declspec(dllimport) _Locimp *__cdecl
  _Getgloballocale();
 static __declspec(dllimport) void __cdecl
  _Setgloballocale(void *);

 bool _Badname(const _Locinfo& _Lobj)
  {
  return (:: strcmp(_Lobj._Getname(), "*") == 0);
  }

 _Locimp *_Ptr;
 };
#line 543 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocale"
template<class _Facet>
 struct _Facetptr
 {
                         static const locale::facet *_Psave;
 };

template<class _Facet>
                         const locale::facet *_Facetptr<_Facet>::
  _Psave = 0;






template<class _Facet> inline
 const _Facet& __cdecl use_facet(const locale& _Loc)

 {





 { ::std:: _Lockit _Lock(0);
  const locale::facet *_Psave =
   _Facetptr<_Facet>::_Psave;

  size_t _Id = _Facet::id;
  const locale::facet *_Pf = _Loc._Getfacet(_Id);

  if (_Pf != 0)
   ;
  else if (_Psave != 0)
   _Pf = _Psave;
  else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))



   throw ::std:: bad_cast();





  else
   {
   _Pf = _Psave;
   _Facetptr<_Facet>::_Psave = _Psave;

   locale::facet *_Pfmod = (_Facet *)_Psave;
   _Pfmod->_Incref();





   _Facet_Register(_Pfmod);

   }

  return ((const _Facet&)(*_Pf));
 }

 }


template<class _Elem,
 class _InIt> inline
 int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
  const _Elem *_Ptr)
 {
 for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
  if (_Ptr[_Off] == _Ptr[0])
   ++_Numfields;
 string _Str(_Numfields, '\0');

 int _Ans = -2;
 for (size_t _Column = 1; ; ++_Column, ++_First, _Ans = -1)
  {
  bool _Prefix = false;
  size_t _Off = 0;
  size_t _Field = 0;

  for (; _Field < _Numfields; ++_Field)
   {
   for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
    ;

   if (_Str[_Field] != '\0')
    _Off += _Str[_Field];
   else if (_Ptr[_Off += _Column] == _Ptr[0]
    || _Ptr[_Off] == (_Elem)0)
    {
    _Str[_Field] = (char)(_Column < 127
     ? _Column : 127);
    _Ans = (int)_Field;
    }
   else if (_First == _Last || _Ptr[_Off] != *_First)
    _Str[_Field] = (char)(_Column < 127
     ? _Column : 127);
   else
    _Prefix = true;
   }

  if (!_Prefix || _First == _Last)
   break;
  }
 return (_Ans);
 }





template<class _Elem> inline
 char __cdecl _Maklocbyte(_Elem _Char,
  const _Locinfo::_Cvtvec&)
 {
 return ((char)(unsigned char)_Char);
 }

template<> inline
 char __cdecl _Maklocbyte(wchar_t _Char,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 char _Byte = '\0';
 mbstate_t _Mbst1 = {0};
 _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
 return (_Byte);
 }


template<> inline
 char __cdecl _Maklocbyte(unsigned short _Char,
  const _Locinfo::_Cvtvec &_Cvt)
 {
 char _Byte = '\0';
 mbstate_t _Mbst1 = {0};
 _Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
 return (_Byte);
 }






template<class _Elem> inline
 _Elem __cdecl _Maklocchr(char _Byte, _Elem *,
  const _Locinfo::_Cvtvec&)
 {
 return ((_Elem)(unsigned char)_Byte);
 }

template<> inline
 wchar_t __cdecl _Maklocchr(char _Byte, wchar_t *,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 wchar_t _Wc = L'\0';
 mbstate_t _Mbst1 = {0};
 _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
 return (_Wc);
 }


template<> inline
 unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *,
  const _Locinfo::_Cvtvec &_Cvt)
 {
 unsigned short _Wc = (unsigned short)0;
 mbstate_t _Mbst1 = {0};
 _Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
 return (_Wc);
 }






template<class _Elem> inline
 _Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
  const _Locinfo::_Cvtvec&)
 {
 size_t _Count = :: strlen(_Ptr) + 1;
 _Elem *_Ptrdest = new _Elem[_Count];

#pragma warning(push)
#pragma warning(disable: 6011)
 for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
  *_Ptrnext = (_Elem)(unsigned char)*_Ptr;
#pragma warning(pop)

 return (_Ptrdest);
 }

template<> inline
 wchar_t *__cdecl _Maklocstr(const char *_Ptr, wchar_t *,
  const _Locinfo::_Cvtvec& _Cvt)
 {
 size_t _Count, _Count1;
 size_t _Wchars;
 const char *_Ptr1;
 int _Bytes;
 wchar_t _Wc;
 mbstate_t _Mbst1 = {0};

 _Count1 = :: strlen(_Ptr) + 1;
 for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
  _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
  if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
   break;
 ++_Wchars;

 wchar_t *_Ptrdest = new wchar_t[_Wchars];
 wchar_t *_Ptrnext = _Ptrdest;
 mbstate_t _Mbst2 = {0};

#pragma warning(push)
#pragma warning(disable: 6011)
 for (; 0 < _Wchars;
  _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
  if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
   break;
 *_Ptrnext = L'\0';
#pragma warning(pop)

 return (_Ptrdest);
 }


template<> inline
 unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *,
  const _Locinfo::_Cvtvec &_Cvt)
 {
 size_t _Count, _Count1;
 size_t _Wchars;
 const char *_Ptr1;
 int _Bytes;
 unsigned short _Wc;
 mbstate_t _Mbst1 = {0};

 _Count1 = :: strlen(_Ptr) + 1;
 for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
  _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
  if ((_Bytes =
   _Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
   break;
 ++_Wchars;

 wchar_t *_Ptrdest = new wchar_t[_Wchars];
 wchar_t *_Ptrnext = _Ptrdest;
 mbstate_t _Mbst2 = {0};
 for (; 0 < _Wchars;
  _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
  if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
   break;
 *_Ptrnext = L'\0';
 return ((unsigned short *)_Ptrdest);
 }



#pragma warning(push)
#pragma warning(disable: 4275)

class __declspec(dllimport) codecvt_base
 : public locale::facet
 {
public:
 enum
  {
  ok, partial, error, noconv};
 typedef int result;

                    codecvt_base(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  }

 bool always_noconv() const throw ()
  {
  return (do_always_noconv());
  }

 int max_length() const throw ()
  {
  return (do_max_length());
  }

 int encoding() const throw ()
  {
  return (do_encoding());
  }

                    ~codecvt_base() throw ()
  {
  }

protected:
 virtual bool do_always_noconv() const throw ()
  {
  return (false);
  }

 virtual int do_max_length() const throw ()
  {
  return (1);
  }

 virtual int do_encoding() const throw ()
  {
  return (1);
  }
 };

#pragma warning(pop)


template<class _Elem,
 class _Byte,
 class _Statype>
 class codecvt
  : public codecvt_base
 {
public:
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State, _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

                         static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Locinfo());
  }

                    codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() throw ()
  {
  }

 void _Init(const _Locinfo&)
  {
  }

 virtual bool do_always_noconv() const throw ()
  {
  return (is_same<_Byte, _Elem>::value);
  }

 virtual result do_in(_Statype&,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  if (is_same<_Byte, _Elem>::value)
   return (noconv);
  else
   {
   for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
    *_Mid2 = (_Elem)*_Mid1;
   return (ok);
   }
  }

 virtual result do_out(_Statype&,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  if (is_same<_Byte, _Elem>::value)
   return (noconv);
  else
   {
   for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
    *_Mid2 = (_Byte)*_Mid1;
   return (ok);
   }
  }

 virtual result do_unshift(_Statype&,
  _Byte *_First2, _Byte *, _Byte *&_Mid2) const
  {
  _Mid2 = _First2;
  return (ok);
  }

 virtual int do_length(_Statype&, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return ((int)(_Count < (size_t)(_Last1 - _First1)
   ? _Count : _Last1 - _First1));
  }
 };


template<class _Elem,
 class _Byte,
 class _Statype>
                         locale::id codecvt<_Elem, _Byte, _Statype>::id;
#line 1590 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocale"
template<>
 class __declspec(dllimport) codecvt<wchar_t, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef wchar_t _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

                         static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() throw ()
  {
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Cvt = _Lobj._Getcvt();
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
   _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  result _Ans = _Mid1 == _Last1 ? ok : partial;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
    &_State, &_Cvt))
   {
   case -2:
    _Mid1 = _Last1;
    return (_Ans);

   case -1:
    return (error);

   case 0:
    if (*_Mid2 == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Mid2;
    _Ans = ok;
   }
  return (_Ans);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
   _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  result _Ans = _Mid1 == _Last1 ? ok : partial;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   if ((int)___mb_cur_max_func() <= _Last2 - _Mid2)
    if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else
     ++_Mid1, _Mid2 += _Bytes, _Ans = ok;
   else
    {
    _Byte _Buf[5];
    _Statype _Stsave = _State;

    if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else if (_Last2 - _Mid2 < _Bytes)
     {
     _State = _Stsave;
     return (_Ans);
     }
    else
     {
     :: memcpy(_Mid2, _Buf, _Bytes);
     ++_Mid1, _Mid2 += _Bytes, _Ans = ok;
     }
    }
  return (_Ans);
  }

 virtual result do_unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
  _Mid2 = _First2;
  result _Ans = ok;
  int _Bytes;
  _Byte _Buf[5];
  _Statype _Stsave = _State;

  if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
   _Ans = error;
  else if (_Last2 - _Mid2 < --_Bytes)
   {
   _State = _Stsave;
   _Ans = partial;
   }
  else if (0 < _Bytes)
   {
   :: memcpy(_Mid2, _Buf, _Bytes);
   _Mid2 += _Bytes;
   }
  return (_Ans);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
                               ;
  int _Wchars;
  const _Byte *_Mid1;
  _Statype _Mystate = _State;

  for (_Wchars = 0, _Mid1 = _First1;
   (size_t)_Wchars < _Count && _Mid1 != _Last1; )
   {
   int _Bytes;
   _Elem _Ch;

   switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
    &_Mystate, &_Cvt))
    {
   case -2:
    return (_Wchars);

   case -1:
    return (_Wchars);

   case 0:
    if (_Ch == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Wchars;
    }
   }
  return (_Wchars);
  }

 virtual bool do_always_noconv() const throw ()
  {
  return (false);
  }

 virtual int do_max_length() const throw ()
  {
  return (5);
  }

 virtual int do_encoding() const throw ()
  {
  return (0);
  }

private:
 _Locinfo::_Cvtvec _Cvt;
 };



template<>
 class __declspec(dllimport) codecvt<unsigned short, char, _Mbstatet>
 : public codecvt_base
 {
public:
 typedef unsigned short _Elem;
 typedef char _Byte;
 typedef _Mbstatet _Statype;
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
  _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
  return (do_in(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_out(_State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
  }

 result unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
  return (do_unshift(_State,
   _First2, _Last2, _Mid2));
  }

 int length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
  return (do_length(_State, _First1, _Last1, _Count));
  }

                         static locale::id id;

 explicit codecvt(size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
  : codecvt_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new codecvt<_Elem, _Byte, _Statype>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~codecvt() throw ()
  {
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Cvt = _Lobj._Getcvt();
  }

 virtual result do_in(_Statype& _State,
  const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
   _Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  result _Ans = _Mid1 == _Last1 ? ok : partial;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
    &_State, &_Cvt))
   {
   case -2:
    _Mid1 = _Last1;
    return (_Ans);

   case -1:
    return (error);

   case 0:
    if (*_Mid2 == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Mid2;
    _Ans = ok;
   }
  return (_Ans);
  }

 virtual result do_out(_Statype& _State,
  const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
   _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
                               ;
  _Mid1 = _First1, _Mid2 = _First2;
  result _Ans = _Mid1 == _Last1 ? ok : partial;
  int _Bytes;

  while (_Mid1 != _Last1 && _Mid2 != _Last2)
   if ((int)___mb_cur_max_func() <= _Last2 - _Mid2)
    if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else
     ++_Mid1, _Mid2 += _Bytes, _Ans = ok;
   else
    {
    _Byte _Buf[5];
    _Statype _Stsave = _State;

    if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
     &_State, &_Cvt)) < 0)
     return (error);
    else if (_Last2 - _Mid2 < _Bytes)
     {
     _State = _Stsave;
     return (_Ans);
     }
    else
     {
     :: memcpy(_Mid2, _Buf, _Bytes);
     ++_Mid1, _Mid2 += _Bytes, _Ans = ok;
     }
    }
  return (_Ans);
  }

 virtual result do_unshift(_Statype& _State,
  _Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
  {
                               ;
  _Mid2 = _First2;
  result _Ans = ok;
  int _Bytes;
  _Byte _Buf[5];
  _Statype _Stsave = _State;

  if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
   _Ans = error;
  else if (_Last2 - _Mid2 < --_Bytes)
   {
   _State = _Stsave;
   _Ans = partial;
   }
  else if (0 < _Bytes)
   {
   :: memcpy(_Mid2, _Buf, _Bytes);
   _Mid2 += _Bytes;
   }
  return (_Ans);
  }

 virtual int do_length(_Statype& _State, const _Byte *_First1,
  const _Byte *_Last1, size_t _Count) const
  {
                               ;
  int _Wchars;
  const _Byte *_Mid1;
  _Statype _Mystate = _State;

  for (_Wchars = 0, _Mid1 = _First1;
   (size_t)_Wchars < _Count && _Mid1 != _Last1; )
   {
   int _Bytes;
   _Elem _Ch;

   switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
    &_Mystate, &_Cvt))
    {
   case -2:
    return (_Wchars);

   case -1:
    return (_Wchars);

   case 0:
    if (_Ch == (_Elem)0)
     _Bytes = (int):: strlen(_Mid1) + 1;


   default:
    if (_Bytes == -3)
     _Bytes = 0;
    _Mid1 += _Bytes;
    ++_Wchars;
    }
   }
  return (_Wchars);
  }

 virtual bool do_always_noconv() const throw ()
  {
  return (false);
  }

 virtual int do_max_length() const throw ()
  {
  return (5);
  }

 virtual int do_encoding() const throw ()
  {
  return (0);
  }

private:
 _Locinfo::_Cvtvec _Cvt;
 };



template<class _Elem,
 class _Byte,
 class _Statype>
 class codecvt_byname
  : public codecvt<_Elem, _Byte, _Statype>
 {
public:
 explicit codecvt_byname(const char *_Locname, size_t _Refs = 0)
  : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit codecvt_byname(const string& _Str, size_t _Refs = 0)
  : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

protected:
 virtual ~codecvt_byname() throw ()
  {
  }
 };


#pragma warning(push)
#pragma warning(disable: 4275)

struct __declspec(dllimport) ctype_base
 : public locale::facet
 {
 enum
  {
  alnum = 0x4 | 0x2 | 0x1 | 0x100, alpha = 0x2 | 0x1 | 0x100,
  cntrl = 0x20, digit = 0x4, graph = 0x4 | 0x2 | 0x10 | 0x1 | 0x100,
  lower = 0x2, print = 0x4 | 0x2 | 0x10 | 0x40 | 0x1 | 0x100 | 0x80,
  punct = 0x10, space = 0x8 | 0x40 | 0x000, upper = 0x1,
  xdigit = 0x80, blank = 0x8 | 0x40 | 0x000 | 0x000};
 typedef short mask;

                    ctype_base(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  }

                    ~ctype_base() throw ()
  {
  }
 };

#pragma warning(pop)


template<class _Elem>
 class ctype
  : public ctype_base
 {
public:
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return (do_is(_Maskval, _Ch));
  }

 const _Elem * is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
  return (do_is(_First, _Last, _Dest));
  }

 const _Elem * scan_is(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_is(_Maskval, _First, _Last));
  }

 const _Elem * scan_not(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_not(_Maskval, _First, _Last));
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const char * widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

                         static locale::id id;

 explicit ctype(size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~ctype() throw ()
  {
  if (_Ctype._Delfl)
   free((void *)_Ctype._Table);

  free((void *)_Ctype._LocaleName);
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  _Cvt = _Lobj._Getcvt();
  }

 virtual bool do_is(mask _Maskval, _Elem _Ch) const
  {
  return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
   & _Maskval) != 0);
  }

 virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
                             ;
                       ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
  return (_First);
  }

 virtual const _Elem * do_scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual const _Elem * do_scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Tolower(_Byte, &_Ctype)));
  }

 virtual const _Elem * do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Tolower(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
  if (_Byte == '\0')
   return (_Ch);
  else
   return (widen((char)_Toupper(_Byte, &_Ctype)));
  }

 virtual const _Elem * do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   {
   unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
   if (_Byte != '\0')
    *_First = (widen((char)_Toupper(_Byte, &_Ctype)));
   }
  return ((const _Elem *)_First);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
  }

 virtual const char * do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                             ;
                       ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
  return (_First);
  }

 char _Donarrow(_Elem _Ch, char _Dflt) const
  {
  char _Byte;
  if (_Ch == (_Elem)0)
   return ('\0');
  else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
   return (_Dflt);
  else
   return (_Byte);
  }

 virtual char do_narrow(_Elem _Ch, char _Dflt) const
  {
  return (_Donarrow(_Ch, _Dflt));
  }

 virtual const _Elem * do_narrow(const _Elem *_First,
  const _Elem *_Last, char _Dflt, char *_Dest) const
  {
                             ;
                       ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Donarrow(*_First, _Dflt);
  return (_First);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 _Locinfo::_Cvtvec _Cvt;
 };


template<class _Elem>
 locale::id ctype<_Elem>::id;


template<>
 class __declspec(dllimport) ctype<char>
 : public ctype_base
 {
 typedef ctype<char> _Myt;

public:
 typedef char _Elem;
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
  }

 const _Elem * is(const _Elem *_First,
  const _Elem *_Last, mask *_Dest) const
  {
                             ;
                       ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Ctype._Table[(unsigned char)*_First];
  return (_First);
  }

 const _Elem * scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 const _Elem * scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const _Elem * widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 _Elem narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

                         static locale::id id;

 explicit ctype(const mask *_Table = 0,
  bool _Deletetable = false,
  size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }

  _Tidy();
  if (_Table != 0)
   {
   _Ctype._Table = _Table;
   _Ctype._Delfl = _Deletetable ? -1 : 0;
   }
  else
   {
   _Ctype._Table = classic_table();
   _Ctype._Delfl = 0;
   }
  }

                    ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

 const mask * table() const throw ()
  {
  return (_Ctype._Table);
  }

 static const mask *__cdecl classic_table() throw ()
  {
  const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
  return (_Ctype_fac.table());
  }

          static const size_t table_size =
  1 << 8;

protected:
 virtual ~ctype() throw ()
  {
  _Tidy();
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  }

 void _Tidy()
  {
  if (0 < _Ctype._Delfl)
   free((void *)_Ctype._Table);
  else if (_Ctype._Delfl < 0)
   delete[] (void *)_Ctype._Table;

  free((void *)_Ctype._LocaleName);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
  }

 virtual const _Elem * do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
  }

 virtual const _Elem * do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Byte);
  }

 virtual const _Elem * do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                             ;
                       ;
  :: memcpy(_Dest, _First, _Last - _First);
  return (_Last);
  }

 virtual _Elem do_narrow(_Elem _Ch, char) const
  {
  return (_Ch);
  }

 virtual const _Elem * do_narrow(const _Elem *_First,
  const _Elem *_Last, char, char *_Dest) const
  {
                             ;
                       ;
  :: memcpy(_Dest, _First, _Last - _First);
  return (_Last);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 };


template<>
 class __declspec(dllimport) ctype<wchar_t>
 : public ctype_base
 {
 typedef ctype<wchar_t> _Myt;

public:
 typedef wchar_t _Elem;
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return (do_is(_Maskval, _Ch));
  }

 const _Elem * is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
  return (do_is(_First, _Last, _Dest));
  }

 const _Elem * scan_is(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_is(_Maskval, _First, _Last));
  }

 const _Elem * scan_not(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_not(_Maskval, _First, _Last));
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const char * widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

                         static locale::id id;

 explicit ctype(size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~ctype() throw ()
  {
  if (_Ctype._Delfl)
   free((void *)_Ctype._Table);

  free((void *)_Ctype._LocaleName);
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  _Cvt = _Lobj._Getcvt();
  }

 virtual bool do_is(mask _Maskval, _Elem _Ch) const
  {
  return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
  }

 virtual const _Elem * do_is(const _Elem *_First,
  const _Elem *_Last, mask *_Dest) const
  {
                             ;
                       ;
  return (:: _Getwctypes(_First, _Last, _Dest, &_Ctype));
  }

 virtual const _Elem * do_scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual const _Elem * do_scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  return (_Towlower(_Ch, &_Ctype));
  }

 virtual const _Elem * do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = _Towlower(*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  return (_Towupper(_Ch, &_Ctype));
  }

 virtual const _Elem * do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = _Towupper(*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 _Elem _Dowiden(char _Byte) const
  {
  mbstate_t _Mbst = {0};
  wchar_t _Wc;
  return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
   ? (wchar_t)(wint_t)(0xFFFF) : _Wc);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Dowiden(_Byte));
  }

 virtual const char * do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                             ;
                       ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Dowiden(*_First);
  return (_First);
  }

 char _Donarrow(_Elem _Ch, char _Dflt) const
  {
  char _Buf[5];
  mbstate_t _Mbst = {0};
  return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
   ? _Dflt : _Buf[0]);
  }

 virtual char do_narrow(_Elem _Ch, char _Dflt) const
  {
  return (_Donarrow(_Ch, _Dflt));
  }

 virtual const _Elem * do_narrow(const _Elem *_First,
  const _Elem *_Last, char _Dflt, char *_Dest) const
  {
                             ;
                       ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Donarrow(*_First, _Dflt);
  return (_First);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 _Locinfo::_Cvtvec _Cvt;
 };



template<>
 class __declspec(dllimport) ctype<unsigned short>
 : public ctype_base
 {
 typedef ctype<unsigned short> _Myt;

public:
 typedef unsigned short _Elem;
 typedef _Elem char_type;

 bool is(mask _Maskval, _Elem _Ch) const
  {
  return (do_is(_Maskval, _Ch));
  }

 const _Elem * is(const _Elem *_First, const _Elem *_Last,
  mask *_Dest) const
  {
  return (do_is(_First, _Last, _Dest));
  }

 const _Elem * scan_is(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_is(_Maskval, _First, _Last));
  }

 const _Elem * scan_not(mask _Maskval, const _Elem *_First,
  const _Elem *_Last) const
  {
  return (do_scan_not(_Maskval, _First, _Last));
  }

 _Elem tolower(_Elem _Ch) const
  {
  return (do_tolower(_Ch));
  }

 const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
  {
  return (do_tolower(_First, _Last));
  }

 _Elem toupper(_Elem _Ch) const
  {
  return (do_toupper(_Ch));
  }

 const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
  {
  return (do_toupper(_First, _Last));
  }

 _Elem widen(char _Byte) const
  {
  return (do_widen(_Byte));
  }

 const char * widen(const char *_First, const char *_Last,
  _Elem *_Dest) const
  {
  return (do_widen(_First, _Last, _Dest));
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  return (do_narrow(_Ch, _Dflt));
  }

 const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
  char _Dflt, char *_Dest) const
  {
  return (do_narrow(_First, _Last, _Dflt, _Dest));
  }

                         static locale::id id;

 explicit ctype(size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
  : ctype_base(_Refs)
  {
  _Init(_Lobj);
  }

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new ctype<_Elem>(
    _Locinfo(_Ploc->c_str()));
  return (2);
  }

protected:
 virtual ~ctype() throw ()
  {
  if (_Ctype._Delfl)
   free((void *)_Ctype._Table);

  free((void *)_Ctype._LocaleName);
  }

 void _Init(const _Locinfo& _Lobj)
  {
  _Ctype = _Lobj._Getctype();
  _Cvt = _Lobj._Getcvt();
  }

 virtual bool do_is(mask _Maskval, _Elem _Ch) const
  {
  return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
  }

 virtual const _Elem * do_is(const _Elem *_First,
  const _Elem *_Last, mask *_Dest) const
  {
                             ;
                       ;
  return ((const _Elem *):: _Getwctypes((const wchar_t *)_First,
   (const wchar_t *)_Last, _Dest, &_Ctype));
  }

 virtual const _Elem * do_scan_is(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && !is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual const _Elem * do_scan_not(mask _Maskval,
  const _Elem *_First, const _Elem *_Last) const
  {
                             ;
  for (; _First != _Last && is(_Maskval, *_First); ++_First)
   ;
  return (_First);
  }

 virtual _Elem do_tolower(_Elem _Ch) const
  {
  return (_Towlower(_Ch, &_Ctype));
  }

 virtual const _Elem * do_tolower(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = _Towlower(*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 virtual _Elem do_toupper(_Elem _Ch) const
  {
  return (_Towupper(_Ch, &_Ctype));
  }

 virtual const _Elem * do_toupper(_Elem *_First,
  const _Elem *_Last) const
  {
                                            ;
  for (; _First != _Last; ++_First)
   *_First = _Towupper(*_First, &_Ctype);
  return ((const _Elem *)_First);
  }

 _Elem _Dowiden(char _Byte) const
  {
  mbstate_t _Mbst = {0};
  unsigned short _Wc;
  return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
   ? (unsigned short)(wint_t)(0xFFFF) : _Wc);
  }

 virtual _Elem do_widen(char _Byte) const
  {
  return (_Dowiden(_Byte));
  }

 virtual const char * do_widen(const char *_First,
  const char *_Last, _Elem *_Dest) const
  {
                             ;
                       ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Dowiden(*_First);
  return (_First);
  }

 char _Donarrow(_Elem _Ch, char _Dflt) const
  {
  char _Buf[5];
  mbstate_t _Mbst = {0};
  return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
   ? _Dflt : _Buf[0]);
  }

 virtual char do_narrow(_Elem _Ch, char _Dflt) const
  {
  return (_Donarrow(_Ch, _Dflt));
  }

 virtual const _Elem * do_narrow(const _Elem *_First,
  const _Elem *_Last, char _Dflt, char *_Dest) const
  {
                             ;
                       ;
  for (; _First != _Last; ++_First, ++_Dest)
   *_Dest = _Donarrow(*_First, _Dflt);
  return (_First);
  }

private:
 _Locinfo::_Ctypevec _Ctype;
 _Locinfo::_Cvtvec _Cvt;
 };



template<class _Elem>
 class ctype_byname
 : public ctype<_Elem>
 {
public:
 explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
  : ctype<_Elem>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit ctype_byname(const string& _Str, size_t _Refs = 0)
  : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

protected:
 virtual ~ctype_byname() throw ()
  {
  }
 };


template<>
 class ctype_byname<char>
 : public ctype<char>
 {
public:
 explicit ctype_byname(const char *_Locname, size_t _Refs = 0)
  : ctype<char>(_Locinfo(_Locname), _Refs)
  {
  }

 explicit ctype_byname(const string& _Str, size_t _Refs = 0)
  : ctype<char>(_Locinfo(_Str.c_str()), _Refs)
  {
  }

protected:
 virtual ~ctype_byname() throw ()
  {
  }
 };




template class __declspec(dllimport) codecvt<char, char, _Mbstatet>;


}

#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xiosbase"


#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\system_error"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cerrno"
#line 14 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cerrno"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\errno.h"
#line 21 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\errno.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 21 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\errno.h"



extern "C" {
#line 135 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\errno.h"
}
#line 14 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\cerrno"
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\system_error"




#pragma pack(push,8)
#pragma warning(push, 3)





namespace std {


enum class errc {
 address_family_not_supported = 102,
 address_in_use = 100,
 address_not_available = 101,
 already_connected = 113,
 argument_list_too_long = 7,
 argument_out_of_domain = 33,
 bad_address = 14,
 bad_file_descriptor = 9,
 bad_message = 104,
 broken_pipe = 32,
 connection_aborted = 106,
 connection_already_in_progress = 103,
 connection_refused = 107,
 connection_reset = 108,
 cross_device_link = 18,
 destination_address_required = 109,
 device_or_resource_busy = 16,
 directory_not_empty = 41,
 executable_format_error = 8,
 file_exists = 17,
 file_too_large = 27,
 filename_too_long = 38,
 function_not_supported = 40,
 host_unreachable = 110,
 identifier_removed = 111,
 illegal_byte_sequence = 42,
 inappropriate_io_control_operation = 25,
 interrupted = 4,
 invalid_argument = 22,
 invalid_seek = 29,
 io_error = 5,
 is_a_directory = 21,
 message_size = 115,
 network_down = 116,
 network_reset = 117,
 network_unreachable = 118,
 no_buffer_space = 119,
 no_child_process = 10,
 no_link = 121,
 no_lock_available = 39,
 no_message_available = 120,
 no_message = 122,
 no_protocol_option = 123,
 no_space_on_device = 28,
 no_stream_resources = 124,
 no_such_device_or_address = 6,
 no_such_device = 19,
 no_such_file_or_directory = 2,
 no_such_process = 3,
 not_a_directory = 20,
 not_a_socket = 128,
 not_a_stream = 125,
 not_connected = 126,
 not_enough_memory = 12,
 not_supported = 129,
 operation_canceled = 105,
 operation_in_progress = 112,
 operation_not_permitted = 1,
 operation_not_supported = 130,
 operation_would_block = 140,
 owner_dead = 133,
 permission_denied = 13,
 protocol_error = 134,
 protocol_not_supported = 135,
 read_only_file_system = 30,
 resource_deadlock_would_occur = 36,
 resource_unavailable_try_again = 11,
 result_out_of_range = 34,
 state_not_recoverable = 127,
 stream_timeout = 137,
 text_file_busy = 139,
 timed_out = 138,
 too_many_files_open_in_system = 23,
 too_many_files_open = 24,
 too_many_links = 31,
 too_many_symbolic_link_levels = 114,
 value_too_large = 132,
 wrong_protocol_type = 136
 };

typedef errc generic_errno;



enum class io_errc {
 stream = 1
 };

typedef io_errc _Io_errc;


template<class _Enum>
 struct is_error_code_enum
  : public false_type
 {
 };

template<>
 struct is_error_code_enum<_Io_errc>
  : public true_type
 {
 };


template<class _Enum>
 struct is_error_condition_enum
  : public false_type
 {
 };

template<>
 struct is_error_condition_enum<generic_errno>
  : public true_type
 {
 };

class error_code;
class error_condition;
error_code make_error_code(generic_errno) throw ();
error_code make_error_code(_Io_errc) throw ();
error_condition make_error_condition(generic_errno) throw ();
error_condition make_error_condition(_Io_errc) throw ();


class error_category;

const error_category& generic_category() throw ();
const error_category& iostream_category() throw ();
const error_category& system_category() throw ();

class error_category
 {
public:
 error_category()
  {
  }

 virtual ~error_category() throw ()
  {
  }

 virtual const char *name() const throw () = 0;

 virtual string message(int _Errval) const = 0;

 virtual error_condition
  default_error_condition(int _Errval) const throw ();

 virtual bool equivalent(int _Errval,
  const error_condition& _Cond) const throw ();

 virtual bool equivalent(const error_code& _Code,
  int _Errval) const throw ();

 bool operator==(const error_category& _Right) const throw ()
  {
  return (this == &_Right);
  }

 bool operator!=(const error_category& _Right) const throw ()
  {
  return (!(*this == _Right));
  }

 bool operator<(const error_category& _Right) const throw ()
  {
  return (this < &_Right);
  }

 error_category(const error_category&) = delete;
 error_category& operator=(const error_category&) = delete;
 };


class error_code
 {
public:
 typedef error_code _Myt;

 error_code()
  : _Myval(0),
   _Mycat(&system_category())
  {
  }

 error_code(int _Val, const error_category& _Cat)
  : _Myval(_Val), _Mycat(&_Cat)
  {
  }

 template<class _Enum,
  class = typename enable_if<is_error_code_enum<_Enum>::value,
   void>::type>
  error_code(_Enum _Errcode)
  : _Myval(0), _Mycat(0)
  {
  *this = make_error_code(_Errcode);
  }

 void assign(int _Val, const error_category& _Cat)
  {
  _Myval = _Val;
  _Mycat = &_Cat;
  }

 template<class _Enum>
  typename enable_if<is_error_code_enum<_Enum>::value,
   error_code>::type& operator=(_Enum _Errcode)
  {
  *this = make_error_code(_Errcode);
  return (*this);
  }

 void clear() throw ()
  {
  _Myval = 0;
  _Mycat = &system_category();
  }

 int value() const
  {
  return (_Myval);
  }

 const error_category& category() const
  {
  return (*_Mycat);
  }

 error_condition default_error_condition() const;

 string message() const
  {
  return (category().message(value()));
  }

 explicit operator bool() const throw ()
  {
  return (value() != 0);
  }

 bool operator==(const error_code& _Right) const throw ()
  {
  return (category() == _Right.category()
   && value() == _Right.value());
  }

 bool operator!=(const error_code& _Right) const throw ()
  {
  return (!(*this == _Right));
  }

 bool operator<(const error_code& _Right) const throw ()
  {
  return (category() < _Right.category()
   || (category() == _Right.category()
    && value() < _Right.value()));
  }

private:
 int _Myval;
 const error_category *_Mycat;
 };


class error_condition
 {
public:
 typedef error_condition _Myt;

 error_condition() throw ()
  : _Myval(0),
   _Mycat(&generic_category())
  {
  }

 error_condition(int _Val, const error_category& _Cat) throw ()
  : _Myval(_Val), _Mycat(&_Cat)
  {
  }

 template<class _Enum,
  class = typename enable_if<is_error_condition_enum<_Enum>::value,
   void>::type>
  error_condition(_Enum _Errcode) throw ()
  : _Myval(0), _Mycat(0)
  {
  *this = make_error_condition(_Errcode);
  }

 void assign(int _Val, const error_category& _Cat) throw ()
  {
  _Myval = _Val;
  _Mycat = &_Cat;
  }

 template<class _Enum>
  typename enable_if<is_error_condition_enum<_Enum>::value,
   error_condition>::type& operator=(_Enum _Errcode) throw ()
  {
  *this = make_error_condition(_Errcode);
  return (*this);
  }

 void clear() throw ()
  {
  _Myval = 0;
  _Mycat = &generic_category();
  }

 int value() const throw ()
  {
  return (_Myval);
  }

 const error_category& category() const throw ()
  {
  return (*_Mycat);
  }

 string message() const
  {
  return (category().message(value()));
  }

 explicit operator bool() const throw ()
  {
  return (value() != 0);
  }

 bool operator==(const error_condition& _Right) const throw ()
  {
  return (category() == _Right.category()
   && value() == _Right.value());
  }

 bool operator!=(const error_condition& _Right) const throw ()
  {
  return (!(*this == _Right));
  }

 bool operator<(const error_condition& _Right) const throw ()
  {
  return (category() < _Right.category()
   || (category() == _Right.category()
    && value() < _Right.value()));
  }

private:
 int _Myval;
 const error_category *_Mycat;
 };


inline error_condition
 error_category::default_error_condition(int _Errval) const throw ()
 {
 return (error_condition(_Errval, *this));
 }

inline bool
 error_category::equivalent(int _Errval,
  const error_condition& _Cond) const throw ()
 {
 return (default_error_condition(_Errval) == _Cond);
 }

inline bool
 error_category::equivalent(const error_code& _Code,
  int _Errval) const throw ()
 {
 return (*this == _Code.category() && _Code.value() == _Errval);
 }


inline error_condition error_code::default_error_condition() const
 {
 return (category().default_error_condition(value()));
 }


inline bool operator==(
 const error_code& _Left,
 const error_condition& _Right) throw ()
 {
 return (_Left.category().equivalent(_Left.value(), _Right)
  || _Right.category().equivalent(_Left, _Right.value()));
 }

inline bool operator==(
 const error_condition& _Left,
 const error_code& _Right) throw ()
 {
 return (_Right.category().equivalent(_Right.value(), _Left)
  || _Left.category().equivalent(_Right, _Left.value()));
 }


inline bool operator!=(
 const error_code& _Left,
 const error_condition& _Right) throw ()
 {
 return (!(_Left == _Right));
 }

inline bool operator!=(
 const error_condition& _Left,
 const error_code& _Right) throw ()
 {
 return (!(_Left == _Right));
 }


inline error_code make_error_code(generic_errno _Errno) throw ()
 {
 return (error_code((int)_Errno, generic_category()));
 }

inline error_code make_error_code(_Io_errc _Errno) throw ()
 {
 return (error_code((int)_Errno, iostream_category()));
 }


inline error_condition make_error_condition(generic_errno _Errno) throw ()
 {
 return (error_condition((int)_Errno, generic_category()));
 }

inline error_condition make_error_condition(_Io_errc _Errno) throw ()
 {
 return (error_condition((int)_Errno, iostream_category()));
 }


template<>
 struct hash<error_code>
  : public unary_function<error_code, size_t>
 {
 typedef error_code _Kty;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (hash<int>()(_Keyval.value()));
  }
 };


class _System_error
 : public runtime_error
 {
private:
 static string _Makestr(error_code _Errcode, string _Message)
  {
  if (!_Message.empty())
   _Message.append(": ");
  _Message.append(_Errcode.message());
  return (_Message);
  }

protected:
 _System_error(error_code _Errcode, const string& _Message)
  : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
  {
  }

 error_code _Mycode;
 };

class system_error
 : public _System_error
 {
private:
 typedef _System_error _Mybase;

public:
 explicit system_error(error_code _Errcode)
  : _Mybase(_Errcode, "")
  {
  }

 system_error(error_code _Errcode, const string& _Message)
  : _Mybase(_Errcode, _Message)
  {
  }

 system_error(error_code _Errcode, const char *_Message)
  : _Mybase(_Errcode, _Message)
  {
  }

 system_error(int _Errval, const error_category& _Errcat)
  : _Mybase(error_code(_Errval, _Errcat), "")
  {
  }

 system_error(int _Errval, const error_category& _Errcat,
  const string& _Message)
  : _Mybase(error_code(_Errval, _Errcat), _Message)
  {
  }

 system_error(int _Errval, const error_category& _Errcat,
  const char *_Message)
  : _Mybase(error_code(_Errval, _Errcat), _Message)
  {
  }

 const error_code& code() const throw ()
  {
  return (_Mycode);
  }
#line 543 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\system_error"
 };

__declspec(dllimport) const char *__cdecl _Syserror_map(int);
__declspec(dllimport) const char *__cdecl _Winerror_map(int);


class _Generic_error_category
 : public error_category
 {
public:
 _Generic_error_category()
  {
  }

 virtual const char *name() const throw ()
  {
  return ("generic");
  }

 virtual string message(int _Errcode) const
  {
  const char *_Name = _Syserror_map(_Errcode);
  return (string(_Name != 0 ? _Name : "unknown error"));
  }
 };


class _Iostream_error_category
 : public _Generic_error_category
 {
public:
 _Iostream_error_category()
  {
  }

 virtual const char *name() const throw ()
  {
  return ("iostream");
  }

 virtual string message(int _Errcode) const
  {
  if (_Errcode == (int)io_errc::stream)
   return ("iostream stream error");
  else
   return (_Generic_error_category::message(_Errcode));
  }
 };


class _System_error_category
 : public _Generic_error_category
 {
public:
 _System_error_category()
  {
  }

 virtual const char *name() const throw ()
  {
  return ("system");
  }

 virtual string message(int _Errcode) const
  {
  const char *_Name = _Winerror_map(_Errcode);
  return (string(_Name != 0 ? _Name : "unknown error"));
  }

 virtual error_condition
  default_error_condition(int _Errval) const throw ()
  {
  if (_Syserror_map(_Errval))
   return (error_condition(_Errval, generic_category()));
  else
   return (error_condition(_Errval, system_category()));
  }
 };

template<class _Cat>
 struct _Error_objects
 {
 _Error_objects()
  {
  }

 static _Generic_error_category _Generic_object;
 static _Iostream_error_category _Iostream_object;
 static _System_error_category _System_object;
 };

template<class _Cat>
 _Generic_error_category _Error_objects<_Cat>::_Generic_object;
template<class _Cat>
 _Iostream_error_category _Error_objects<_Cat>::_Iostream_object;
template<class _Cat>
 _System_error_category _Error_objects<_Cat>::_System_object;

inline const error_category& generic_category() throw ()
 {
 return (_Error_objects<int>::_Generic_object);
 }

inline const error_category& iostream_category() throw ()
 {
 return (_Error_objects<int>::_Iostream_object);
 }

inline const error_category& system_category() throw ()
 {
 return (_Error_objects<int>::_System_object);
 }
}

#pragma warning(pop)
#pragma pack(pop)
#line 8 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xiosbase"


#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\share.h"
#line 10 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xiosbase"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4412)



namespace std {
#line 47 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xiosbase"
template<class _Dummy>
 class _Iosb
 {
public:
 enum _Dummy_enum {_Dummy_enum_val = 1};
 enum _Fmtflags
  {
  _Fmtmask = 0xffff, _Fmtzero = 0};

 static const _Fmtflags skipws = (_Fmtflags)0x0001;
 static const _Fmtflags unitbuf = (_Fmtflags)0x0002;
 static const _Fmtflags uppercase = (_Fmtflags)0x0004;
 static const _Fmtflags showbase = (_Fmtflags)0x0008;
 static const _Fmtflags showpoint = (_Fmtflags)0x0010;
 static const _Fmtflags showpos = (_Fmtflags)0x0020;
 static const _Fmtflags left = (_Fmtflags)0x0040;
 static const _Fmtflags right = (_Fmtflags)0x0080;
 static const _Fmtflags internal = (_Fmtflags)0x0100;
 static const _Fmtflags dec = (_Fmtflags)0x0200;
 static const _Fmtflags oct = (_Fmtflags)0x0400;
 static const _Fmtflags hex = (_Fmtflags)0x0800;
 static const _Fmtflags scientific = (_Fmtflags)0x1000;
 static const _Fmtflags fixed = (_Fmtflags)0x2000;

 static const _Fmtflags hexfloat =
  (_Fmtflags)0x3000;

 static const _Fmtflags boolalpha = (_Fmtflags)0x4000;
 static const _Fmtflags _Stdio = (_Fmtflags)0x8000;
 static const _Fmtflags adjustfield = (_Fmtflags)(0x0040
  | 0x0080 | 0x0100);
 static const _Fmtflags basefield = (_Fmtflags)(0x0200
  | 0x0400 | 0x0800);
 static const _Fmtflags floatfield = (_Fmtflags)(0x1000
  | 0x2000);

 enum _Iostate
  {
  _Statmask = 0x17};

 static const _Iostate goodbit = (_Iostate)0x0;
 static const _Iostate eofbit = (_Iostate)0x1;
 static const _Iostate failbit = (_Iostate)0x2;
 static const _Iostate badbit = (_Iostate)0x4;
 static const _Iostate _Hardfail = (_Iostate)0x10;

 enum _Openmode
  {
  _Openmask = 0xff};

 static const _Openmode in = (_Openmode)0x01;
 static const _Openmode out = (_Openmode)0x02;
 static const _Openmode ate = (_Openmode)0x04;
 static const _Openmode app = (_Openmode)0x08;
 static const _Openmode trunc = (_Openmode)0x10;
 static const _Openmode _Nocreate = (_Openmode)0x40;
 static const _Openmode _Noreplace = (_Openmode)0x80;
 static const _Openmode binary = (_Openmode)0x20;

 enum _Seekdir
  {
  _Seekmask = 0x3};

 static const _Seekdir beg = (_Seekdir)0;
 static const _Seekdir cur = (_Seekdir)1;
 static const _Seekdir end = (_Seekdir)2;

 enum
  {
  _Openprot = 0x40};
 };

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags
  _Iosb<_Dummy>::hexfloat;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::_Hardfail;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
 const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;


class __declspec(dllimport) ios_base
 : public _Iosb<int>
 {
public:
 typedef int fmtflags;
 typedef int iostate;
 typedef int openmode;
 typedef int seekdir;

 typedef ::std:: streamoff streamoff;
 typedef ::std:: streampos streampos;

 enum event
  {
  erase_event, imbue_event, copyfmt_event};

 typedef void (__cdecl *event_callback)(event, ios_base&, int);
 typedef unsigned int io_state, open_mode, seek_dir;


 class failure

  : public system_error
  {
 public:
  explicit failure(const string &_Message,
   const error_code& _Errcode = make_error_code(io_errc::stream))
   : system_error(_Errcode, _Message)
   {
   }

  explicit failure(const char *_Message,
   const error_code& _Errcode = make_error_code(io_errc::stream))
   : system_error(_Errcode, _Message)
   {
   }
#line 246 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xiosbase"
  };


 class __declspec(dllimport) Init
  {
 public:
                     Init()
   {
   _Init_ctor(this);
   }

                     ~Init() throw ()
   {
   _Init_dtor(this);
   }

 private:
  static void __cdecl _Init_ctor(Init *);
  static void __cdecl _Init_dtor(Init *);

                          static int _Init_cnt;

  static int& __cdecl _Init_cnt_func();
  };

 explicit operator bool() const
  {
  return (!fail());
  }

 bool operator!() const
  {
  return (fail());
  }

 void clear(iostate _State, bool _Reraise)
  {
  _Mystate = (iostate)(_State & _Statmask);
  if ((_Mystate & _Except) == 0)
   ;
  else if (_Reraise)
   throw;
  else if (_Mystate & _Except & badbit)
   throw failure("ios_base::badbit set");
  else if (_Mystate & _Except & failbit)
   throw failure("ios_base::failbit set");
  else
   throw failure("ios_base::eofbit set");
  }

 void clear(iostate _State = goodbit)
  {
  clear(_State, false);
  }

 void clear(io_state _State)
  {
  clear((iostate)_State);
  }

 iostate rdstate() const
  {
  return (_Mystate);
  }

 void setstate(iostate _State, bool _Exreraise)
  {
  if (_State != goodbit)
   clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
  }

 void setstate(iostate _State)
  {
  if (_State != goodbit)
   clear((iostate)((int)rdstate() | (int)_State), false);
  }

 void setstate(io_state _State)
  {
  setstate((iostate)_State);
  }

 bool good() const
  {
  return (rdstate() == goodbit);
  }

 bool eof() const
  {
  return ((int)rdstate() & (int)eofbit);
  }

 bool fail() const
  {
  return (((int)rdstate()
   & ((int)badbit | (int)failbit)) != 0);
  }

 bool bad() const
  {
  return (((int)rdstate() & (int)badbit) != 0);
  }

 iostate exceptions() const
  {
  return (_Except);
  }

 void exceptions(iostate _Newexcept)
  {
  _Except = (iostate)((int)_Newexcept & (int)_Statmask);
  clear(_Mystate);
  }

 void exceptions(io_state _State)
  {
  exceptions((iostate)_State);
  }

 fmtflags flags() const
  {
  return (_Fmtfl);
  }

 fmtflags flags(fmtflags _Newfmtflags)
  {
  fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
  return (_Oldfmtflags);
  }

 fmtflags setf(fmtflags _Newfmtflags)
  {
  ios_base::fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)((int)_Fmtfl
   | ((int)_Newfmtflags & (int)_Fmtmask));
  return (_Oldfmtflags);
  }

 fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask)
  {
  ios_base::fmtflags _Oldfmtflags = _Fmtfl;
  _Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
   | ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
  return (_Oldfmtflags);
  }

 void unsetf(fmtflags _Mask)
  {
  _Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
  }

 streamsize precision() const
  {
  return (_Prec);
  }

 streamsize precision(streamsize _Newprecision)
  {
  streamsize _Oldprecision = _Prec;
  _Prec = _Newprecision;
  return (_Oldprecision);
  }

 streamsize width() const
  {
  return (_Wide);
  }

 streamsize width(streamsize _Newwidth)
  {
  streamsize _Oldwidth = _Wide;
  _Wide = _Newwidth;
  return (_Oldwidth);
  }

 locale getloc() const
  {
  return (*_Ploc);
  }

 locale imbue(const locale& _Loc)
  {
  locale _Oldlocale = *_Ploc;
  *_Ploc = _Loc;
  _Callfns(imbue_event);
  return (_Oldlocale);
  }

 static int __cdecl xalloc()
  {
  { ::std:: _Lockit _Lock(2);
   return (_Index++);
  }
  }

 long& iword(int _Idx)
  {
  return (_Findarr(_Idx)._Lo);
  }

 void *& pword(int _Idx)
  {
  return (_Findarr(_Idx)._Vp);
  }

 void register_callback(event_callback _Pfn,
  int _Idx)
  {
  _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
  }

 ios_base& copyfmt(const ios_base& _Other)
  {
  if (this != &_Other)
   {
   _Tidy();
   *_Ploc = *_Other._Ploc;
   _Fmtfl = _Other._Fmtfl;
   _Prec = _Other._Prec;
   _Wide = _Other._Wide;
   _Iosarray *_Ptr = _Other._Arr;

   for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
    if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
     {
     iword(_Ptr->_Index) = _Ptr->_Lo;
     pword(_Ptr->_Index) = _Ptr->_Vp;
     }

   for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
    _Pfa = _Pfa->_Next)
    register_callback(_Pfa->_Pfn, _Pfa->_Index);

   _Callfns(copyfmt_event);
   exceptions(_Other._Except);
   }
  return (*this);
  }

 static bool __cdecl sync_with_stdio(bool _Newsync = true)
  {
  { ::std:: _Lockit _Lock(2);
   const bool _Oldsync = _Sync;
   _Sync = _Newsync;
   return (_Oldsync);
  }
  }

 void swap(ios_base& _Right)
  {
  if (this != &_Right)
   {
   ::std:: swap(_Mystate, _Right._Mystate);
   ::std:: swap(_Except, _Right._Except);
   ::std:: swap(_Fmtfl, _Right._Fmtfl);
   ::std:: swap(_Prec, _Right._Prec);
   ::std:: swap(_Wide, _Right._Wide);

   ::std:: swap(_Arr, _Right._Arr);
   ::std:: swap(_Calls, _Right._Calls);
   ::std:: swap(_Ploc, _Right._Ploc);
   }
  }

 virtual ~ios_base() throw ()
  {
  _Ios_base_dtor(this);
  }

 static void __cdecl
  _Addstd(ios_base *);

 size_t _Stdstr;

protected:
                    ios_base()
  {
  }

 void _Init()
  {
  _Ploc = 0;
  _Stdstr = 0;
  _Except = goodbit;
  _Fmtfl = (fmtflags)(skipws | dec);
  _Prec = 6;
  _Wide = 0;
  _Arr = 0;
  _Calls = 0;
  clear(goodbit);
  _Ploc = new locale;
  }

private:

 struct _Iosarray
  {
 public:
                     _Iosarray(int _Idx, _Iosarray *_Link)
   : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
   {
   }

  _Iosarray *_Next;
  int _Index;
  long _Lo;
  void *_Vp;
  };


 struct _Fnarray
  {
                     _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
   : _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
   {
   }

  _Fnarray *_Next;
  int _Index;
  event_callback _Pfn;
  };

 void _Callfns(event _Ev)
  {
  for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
   (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
  }

 _Iosarray& _Findarr(int _Idx)
  {
  _Iosarray *_Ptr1, *_Ptr2;

  for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
   if (_Ptr1->_Index == _Idx)
    return (*_Ptr1);
   else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
    _Ptr2 = _Ptr1;

  if (_Ptr2 != 0)
   {
   _Ptr2->_Index = _Idx;
   return (*_Ptr2);
   }

  _Arr = new _Iosarray(_Idx, _Arr);
  return (*_Arr);
  }

 void _Tidy()
  {
  _Callfns(erase_event);
  _Iosarray *_Ptr1, *_Ptr2;

  for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
   {
   _Ptr2 = _Ptr1->_Next;
   delete (_Ptr1);
   }
  _Arr = 0;

  _Fnarray *_Pfa1, *_Pfa2;
  for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
   {
   _Pfa2 = _Pfa1->_Next;
   delete (_Pfa1);
   }
  _Calls = 0;
  }

 iostate _Mystate;
 iostate _Except;
 fmtflags _Fmtfl;
 streamsize _Prec;
 streamsize _Wide;
 _Iosarray *_Arr;
 _Fnarray *_Calls;
 locale *_Ploc;

                         static int _Index;
                         static bool _Sync;

 static void __cdecl
  _Ios_base_dtor(ios_base *);

public:
 ios_base(const ios_base&) = delete;
 ios_base& operator=(const ios_base&) = delete;
 };





}

#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\streambuf"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4251)

namespace std {

template<class _Elem,
 class _Traits>
 class basic_streambuf
 {
 typedef basic_streambuf<_Elem, _Traits> _Myt;

protected:
                    basic_streambuf()
  : _Plocale(new locale)
  {
  _Init();
  }

                    basic_streambuf(_Uninitialized)
  {
  }

                    basic_streambuf(const _Myt& _Right)
  : _Plocale(new locale(_Right.getloc()))
  {
  _Init();
  setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
  setg(_Right.eback(), _Right.gptr(), _Right.egptr());
  }

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
   setg(_Right.eback(), _Right.gptr(), _Right.egptr());
   pubimbue(_Right.getloc());
   }
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   {
   _Elem *_Pfirst = pbase();
   _Elem *_Pnext = pptr();
   _Elem *_Pend = epptr();
   _Elem *_Gfirst = eback();
   _Elem *_Gnext = gptr();
   _Elem *_Gend = egptr();

   setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
   _Right.setp(_Pfirst, _Pnext, _Pend);

   setg(_Right.eback(), _Right.gptr(), _Right.egptr());
   _Right.setg(_Gfirst, _Gnext, _Gend);

   ::std:: swap(_Plocale, _Right._Plocale);
   }
  }

public:
 typedef _Elem char_type;
 typedef _Traits traits_type;

 virtual ~basic_streambuf() throw ()
  {
  delete (_Plocale);
  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 pos_type pubseekoff(off_type _Off,
  ios_base::seekdir _Way,
  ios_base::openmode _Mode = ios_base::in | ios_base::out)
  {
  return (seekoff(_Off, _Way, _Mode));
  }

 pos_type pubseekoff(off_type _Off,
  ios_base::seek_dir _Way,
  ios_base::open_mode _Mode)
  {
  return (pubseekoff(_Off, (ios_base::seekdir)_Way,
   (ios_base::openmode)_Mode));
  }

 pos_type pubseekpos(pos_type _Pos,
  ios_base::openmode _Mode = ios_base::in | ios_base::out)
  {
  return (seekpos(_Pos, _Mode));
  }

 pos_type pubseekpos(pos_type _Pos,
  ios_base::open_mode _Mode)
  {
  return (seekpos(_Pos, (ios_base::openmode)_Mode));
  }

 _Myt * pubsetbuf(_Elem *_Buffer,
  streamsize _Count)
  {
  return (setbuf(_Buffer, _Count));
  }

 locale pubimbue(const locale &_Newlocale)
  {
  locale _Oldlocale = *_Plocale;
  imbue(_Newlocale);
  *_Plocale = _Newlocale;
  return (_Oldlocale);
  }

 locale getloc() const
  {
  return (*_Plocale);
  }

 streamsize in_avail()
  {
  streamsize _Res = _Gnavail();
  return (0 < _Res ? _Res : showmanyc());
  }

 int pubsync()
  {
  return (sync());
  }

 int_type sbumpc()
  {
  return (0 < _Gnavail()
   ? _Traits::to_int_type(*_Gninc()) : uflow());
  }

 int_type sgetc()
  {
  return (0 < _Gnavail()
   ? _Traits::to_int_type(*gptr()) : underflow());
  }

 streamsize sgetn(_Elem *_Ptr,
  streamsize _Count)
  {
  return (xsgetn(_Ptr, _Count));
  }

 int_type snextc()
  {
  return (1 < _Gnavail()
   ? _Traits::to_int_type(*_Gnpreinc())
   : _Traits::eq_int_type(_Traits::eof(), sbumpc())
    ? _Traits::eof() : sgetc());
  }

 int_type sputbackc(_Elem _Ch)
  {
  return (gptr() != 0 && eback() < gptr()
   && _Traits::eq(_Ch, gptr()[-1])
   ? _Traits::to_int_type(*_Gndec())
   : pbackfail(_Traits::to_int_type(_Ch)));
  }

 void stossc()
  {
  if (0 < _Gnavail())
   _Gninc();
  else
   uflow();
  }

 int_type sungetc()
  {
  return (gptr() != 0 && eback() < gptr()
   ? _Traits::to_int_type(*_Gndec()) : pbackfail());
  }

 int_type sputc(_Elem _Ch)
  {
  return (0 < _Pnavail()
   ? _Traits::to_int_type(*_Pninc() = _Ch)
   : overflow(_Traits::to_int_type(_Ch)));
  }

 streamsize sputn(const _Elem *_Ptr,
  streamsize _Count)
  {
  return (xsputn(_Ptr, _Count));
  }

 virtual void _Lock()
  {
  }

 virtual void _Unlock()
  {
  }

protected:
 _Elem * eback() const
  {
  return (*_IGfirst);
  }

 _Elem * gptr() const
  {
  return (*_IGnext);
  }

 _Elem * pbase() const
  {
  return (*_IPfirst);
  }

 _Elem * pptr() const
  {
  return (*_IPnext);
  }

 _Elem * egptr() const
  {
  return (*_IGnext + *_IGcount);
  }

 void gbump(int _Off)
  {
  *_IGcount -= _Off;
  *_IGnext += _Off;
  }

 void setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
  {
  *_IGfirst = _First;
  *_IGnext = _Next;
  *_IGcount = (int)(_Last - _Next);
  }

 _Elem * epptr() const
  {
  return (*_IPnext + *_IPcount);
  }

 _Elem * _Gndec()
  {
  ++*_IGcount;
  return (--*_IGnext);
  }

 _Elem * _Gninc()
  {
  --*_IGcount;
  return ((*_IGnext)++);
  }

 _Elem * _Gnpreinc()
  {
  --*_IGcount;
  return (++(*_IGnext));
  }

 streamsize _Gnavail() const
  {
  return (*_IGnext != 0 ? *_IGcount : 0);
  }

 void pbump(int _Off)
  {
  *_IPcount -= _Off;
  *_IPnext += _Off;
  }

 void setp(_Elem *_First, _Elem *_Last)
  {
  *_IPfirst = _First;
  *_IPnext = _First;
  *_IPcount = (int)(_Last - _First);
  }

 void setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
  {
  *_IPfirst = _First;
  *_IPnext = _Next;
  *_IPcount = (int)(_Last - _Next);
  }

 _Elem * _Pninc()
  {
  --*_IPcount;
  return ((*_IPnext)++);
  }

 streamsize _Pnavail() const
  {
  return (*_IPnext != 0 ? *_IPcount : 0);
  }

 void _Init()
  {
  _IGfirst = &_Gfirst;
  _IPfirst = &_Pfirst;
  _IGnext = &_Gnext;
  _IPnext = &_Pnext;
  _IGcount = &_Gcount;
  _IPcount = &_Pcount;
  setp(0, 0);
  setg(0, 0, 0);
  }

 void _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
  _Elem **_Pf, _Elem **_Pn, int *_Pc)
  {
  _IGfirst = _Gf;
  _IPfirst = _Pf;
  _IGnext = _Gn;
  _IPnext = _Pn;
  _IGcount = _Gc;
  _IPcount = _Pc;
  }

 virtual int_type overflow(int_type = _Traits::eof())
  {
  return (_Traits::eof());
  }

 virtual int_type pbackfail(int_type = _Traits::eof())
  {
  return (_Traits::eof());
  }

 virtual streamsize showmanyc()
  {
  return (0);
  }

 virtual int_type underflow()
  {
  return (_Traits::eof());
  }

 virtual int_type uflow()
  {
  return (_Traits::eq_int_type(_Traits::eof(), underflow())
   ? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
  }

 virtual streamsize xsgetn(_Elem * _Ptr,
  streamsize _Count)
  {
  int_type _Meta;
  streamsize _Size, _Copied;

  for (_Copied = 0; 0 < _Count; )
   if (0 < (_Size = _Gnavail()))
    {
    if (_Count < _Size)
     _Size = _Count;
    _Traits::copy(_Ptr, gptr(), (size_t)_Size);
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    gbump((int)_Size);
    }
   else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
    break;
   else
    {
    *_Ptr++ = _Traits::to_char_type(_Meta);
    ++_Copied;
    --_Count;
    }

  return (_Copied);
  }

 virtual streamsize xsputn(const _Elem *_Ptr,
  streamsize _Count)
  {
  streamsize _Size, _Copied;

  for (_Copied = 0; 0 < _Count; )
   if (0 < (_Size = _Pnavail()))
    {
    if (_Count < _Size)
     _Size = _Count;
    _Traits::copy(pptr(), _Ptr, (size_t)_Size);
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    pbump((int)_Size);
    }
   else if (_Traits::eq_int_type(_Traits::eof(),
    overflow(_Traits::to_int_type(*_Ptr))))
    break;
   else
    {
    ++_Ptr;
    ++_Copied;
    --_Count;
    }

  return (_Copied);
  }

 virtual pos_type seekoff(off_type,
  ios_base::seekdir,
  ios_base::openmode = ios_base::in | ios_base::out)
  {
  return (streampos(_BADOFF));
  }

 virtual pos_type seekpos(pos_type,
  ios_base::openmode = ios_base::in | ios_base::out)
  {
  return (streampos(_BADOFF));
  }

 virtual _Myt * setbuf(_Elem *, streamsize)
  {
  return (this);
  }

 virtual int sync()
  {
  return (0);
  }

 virtual void imbue(const locale&)
  {
  }

private:
 _Elem *_Gfirst;
 _Elem *_Pfirst;
 _Elem **_IGfirst;
 _Elem **_IPfirst;
 _Elem *_Gnext;
 _Elem *_Pnext;
 _Elem **_IGnext;
 _Elem **_IPnext;

 int _Gcount;
 int _Pcount;
 int *_IGcount;
 int *_IPcount;

protected:
 locale *_Plocale;
 };




template class __declspec(dllimport) basic_streambuf<char, char_traits<char> >;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t> >;
#line 478 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\streambuf"
template<class _Elem,
 class _Traits>
 class istreambuf_iterator
  : public iterator<input_iterator_tag,
   _Elem, typename _Traits::off_type, const _Elem *, _Elem>
 {
 typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf<_Elem, _Traits> streambuf_type;
 typedef basic_istream<_Elem, _Traits> istream_type;

 typedef typename traits_type::int_type int_type;
 typedef const _Elem *pointer;

 istreambuf_iterator(streambuf_type *_Sb = 0) throw ()
  : _Strbuf(_Sb), _Got(_Sb == 0)
  {
  }

 istreambuf_iterator(istream_type& _Istr) throw ()
  : _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
  {
  }

 _Elem operator*() const
  {
  if (!_Got)
   _Peek();






  return (_Val);
  }

 const _Elem *operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {





  _Inc();
  return (*this);
  }

 _Myt operator++(int)
  {
  if (!_Got)
   _Peek();
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 bool equal(const _Myt& _Right) const
  {
  if (!_Got)
   _Peek();
  if (!_Right._Got)
   _Right._Peek();
  return ((_Strbuf == 0 && _Right._Strbuf == 0)
   || (_Strbuf != 0 && _Right._Strbuf != 0));
  }

private:
 void _Inc()
  {
  if (_Strbuf == 0
   || traits_type::eq_int_type(traits_type::eof(),
    _Strbuf->sbumpc()))
   _Strbuf = 0, _Got = true;
  else
   _Got = false;
  }

 _Elem _Peek() const
  {
  int_type _Meta;
  if (_Strbuf == 0
   || traits_type::eq_int_type(traits_type::eof(),
    _Meta = _Strbuf->sgetc()))
   _Strbuf = 0;
  else
   _Val = traits_type::to_char_type(_Meta);
  _Got = true;
  return (_Val);
  }

 mutable streambuf_type *_Strbuf;
 mutable bool _Got;
 mutable _Elem _Val;
 };

template<class _Elem,
 class _Traits>
 struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
  : public true_type
 {
 };


template<class _Elem,
 class _Traits> inline
 bool operator==(
  const istreambuf_iterator<_Elem, _Traits>& _Left,
  const istreambuf_iterator<_Elem, _Traits>& _Right)
 {
 return (_Left.equal(_Right));
 }

template<class _Elem,
 class _Traits> inline
 bool operator!=(
  const istreambuf_iterator<_Elem, _Traits>& _Left,
  const istreambuf_iterator<_Elem, _Traits>& _Right)
 {
 return (!(_Left == _Right));
 }


template<class _Elem,
 class _Traits>
 class ostreambuf_iterator
  : public _Outit
 {
 typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf<_Elem, _Traits> streambuf_type;
 typedef basic_ostream<_Elem, _Traits> ostream_type;

 ostreambuf_iterator(streambuf_type *_Sb) throw ()
  : _Failed(false), _Strbuf(_Sb)
  {
  }

 ostreambuf_iterator(ostream_type& _Ostr) throw ()
  : _Failed(false), _Strbuf(_Ostr.rdbuf())
  {
  }

 _Myt& operator=(_Elem _Right)
  {
  if (_Strbuf == 0
   || traits_type::eq_int_type(_Traits::eof(),
    _Strbuf->sputc(_Right)))
   _Failed = true;
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt& operator++(int)
  {
  return (*this);
  }

 bool failed() const throw ()
  {
  return (_Failed);
  }

private:
 bool _Failed;
 streambuf_type *_Strbuf;
 };

template<class _Elem,
 class _Traits>
 struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
  : public true_type
 {
 };
}


#pragma warning(pop)
#pragma pack(pop)
#line 10 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocnum"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4189 4275)




extern "C" {


extern __declspec(dllimport) float __cdecl _Stofx(const char *,
                                  char **,
 long, int *);
extern __declspec(dllimport) double __cdecl _Stodx(const char *,
                                  char **,
 long, int *);
extern __declspec(dllimport) long double __cdecl _Stoldx(const char *,
                                  char **,
 long, int *);
extern __declspec(dllimport) long __cdecl _Stolx(const char *,
                                  char **,
 int, int *);
extern __declspec(dllimport) unsigned long __cdecl _Stoulx(const char *,
                                  char **,
 int, int *);
extern __declspec(dllimport) __int64 __cdecl _Stollx(const char *,
                                  char **,
 int, int *);
extern __declspec(dllimport) unsigned __int64 __cdecl _Stoullx(const char *,
                                  char **,
 int, int *);


}


namespace std {

template<class _Elem> inline
 size_t _Find_elem(_Elem *_Base, _Elem _Ch)
 {
 _Elem *_Ptr = _Base;
 for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
  ;
 return ((size_t)(_Ptr - _Base));
 }

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
 {
 size_t _Count = :: wcslen(_Ptr) + 1;
 wchar_t *_Ptrdest = new wchar_t[_Count];
 :: wmemcpy(_Ptrdest, _Ptr, _Count);
 return (_Ptrdest);
 }


template<class _Elem>
 class numpunct
  : public locale::facet
 {
public:
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  string_type;
 typedef _Elem char_type;

                         __declspec(dllimport) static locale::id id;

 _Elem decimal_point() const
  {
  return (do_decimal_point());
  }

 _Elem thousands_sep() const
  {
  return (do_thousands_sep());
  }

 string grouping() const
  {
  return (do_grouping());
  }

 string_type falsename() const
  {
  return (do_falsename());
  }

 string_type truename() const
  {
  return (do_truename());
  }

 explicit numpunct(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
   if (_Kseparator == 0)
    _Kseparator =
     _Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
  }
  }

 numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
  : locale::facet(_Refs)
  {
  _Init(_Lobj, _Isdef);
  }

 static size_t _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new numpunct<_Elem>(
    _Locinfo(_Ploc->c_str()), 0, true);
  return (4);
  }

protected:
 virtual ~numpunct() throw ()
  {
  _Tidy();
  }

 numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
  : locale::facet(_Refs)
  {
  { _Locinfo _Lobj(_Locname);
   _Init(_Lobj, _Isdef);
  }
  }

 template<class _Elem2>
  void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
  {
  _Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem2 *)0, _Cvt);
  _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], (_Elem2 *)0, _Cvt);
  }

 template<>
  void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
  {
  _Dp = (_Elem)_Ptr->_W_decimal_point[0];
  _Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
  }

 void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
  {
  const lconv *_Ptr = _Lobj._Getlconv();
  _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();

  _Grouping = 0;
  _Falsename = 0;
  _Truename = 0;

  try {
  _Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, (char *)0, _Lobj._Getcvt());

  _Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Cvt);
  _Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Cvt);
  } catch (...) {
  _Tidy();
  throw;
  }

  if (_Isdef)
   {

   _Dp = _Maklocchr('.', (_Elem *)0, _Cvt);
   _Kseparator = _Maklocchr(',', (_Elem *)0, _Cvt);
   }
  else
   _Getvals((_Elem)0, _Ptr, _Cvt);
  }

 virtual _Elem do_decimal_point() const
  {
  return (_Dp);
  }

 virtual _Elem do_thousands_sep() const
  {
  return (_Kseparator);
  }

 virtual string do_grouping() const
  {
  return (string(_Grouping));
  }

 virtual string_type do_falsename() const
  {
  return (string_type(_Falsename));
  }

 virtual string_type do_truename() const
  {
  return (string_type(_Truename));
  }

private:
 void _Tidy()
  {
  delete[] ((void *)_Grouping);
  delete[] ((void *)_Falsename);
  delete[] ((void *)_Truename);
  }

 const char *_Grouping;
 _Elem _Dp;
 _Elem _Kseparator;
 const _Elem *_Falsename;
 const _Elem *_Truename;
 };


template<class _Elem>
 class numpunct_byname
  : public numpunct<_Elem>
 {
public:
 explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
  : numpunct<_Elem>(_Locname, _Refs)
  {
  }

 explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
  : numpunct<_Elem>(_Str.c_str(), _Refs)
  {
  }

protected:
 virtual ~numpunct_byname() throw ()
  {
  }
 };


template<class _Elem>
                         locale::id numpunct<_Elem>::id;


template<class _Elem,
 class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
 class num_get
  : public locale::facet
 {
public:
 typedef numpunct<_Elem> _Mypunct;
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  _Mystr;

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new num_get<_Elem, _InIt>(
    _Locinfo(_Ploc->c_str()));
  return (4);
  }

                         static locale::id id;

protected:
 virtual ~num_get() throw ()
  {
  }

 void _Init(const _Locinfo&)
  {
  }

public:
 explicit num_get(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  _Init(_Lobj);
  }

 typedef _Elem char_type;
 typedef _InIt iter_type;

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   _Bool& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned short& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned int& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }


 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   __int64& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned __int64& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }


 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   float& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   double& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long double& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

 _InIt get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   void *& _Val) const
  {
  return (do_get(_First, _Last, _Iosbase, _State, _Val));
  }

protected:
 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   _Bool& _Val) const
  {
                             ;
  int _Ans = -1;

  if (_Iosbase.flags() & ios_base::boolalpha)
   {
   typedef typename _Mystr::size_type _Mystrsize;
   const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
   _Mystr _Str((_Mystrsize)1, (char_type)0);
   _Str += _Punct_fac.falsename();
   _Str += (char_type)0;
   _Str += _Punct_fac.truename();
   _Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
   }
  else
   {
   char _Ac[32], *_Ep;
   int _Errno = 0;
   const unsigned long _Ulo = :: _Stoulx(_Ac, &_Ep,
    _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
     _Iosbase.getloc()), &_Errno);
   if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
    _Ans = _Ulo;
   }

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ans < 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans != 0;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned short& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
   _Iosbase.getloc());
  char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ptr || _Errno != 0 || 0xffff < _Ans)
   _State |= ios_base::failbit;
  else
   _Val = (unsigned short)(_Ac[0] == '-'
    ? 0 -_Ans : _Ans);
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned int& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
   _Iosbase.getloc());
  char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ptr || _Errno != 0 || 0xffffffff < _Ans)
   _State |= ios_base::failbit;
  else
   _Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const long _Ans = :: _Stolx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned long& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const unsigned long _Ans = :: _Stoulx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }


 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   __int64& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const __int64 _Ans = :: _Stollx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   unsigned __int64& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;
  const unsigned __int64 _Ans = :: _Stoullx(_Ac, &_Ep,
   _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
    _Iosbase.getloc()), &_Errno);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }


 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   float& _Val) const
  {
                             ;
  char _Ac[8 + 36 + 16], *_Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  float _Ans = :: _Stofx(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 0)
   _Ans = :: ldexpf(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   double& _Val) const
  {
                             ;
  char _Ac[8 + 36 + 16], *_Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  double _Ans = :: _Stodx(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 0)
   _Ans = :: ldexp(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   long double& _Val) const
  {
                             ;
  char _Ac[8 + 36 + 16], *_Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  long double _Ans = :: _Stoldx(_Ac, &_Ep,
   _Getffld(_Ac, _First, _Last,
    _Iosbase, &_Hexexp), &_Errno);

  if (_Hexexp != 0)
   _Ans = :: ldexpl(_Ans, 4 * _Hexexp);

  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = _Ans;
  return (_First);
  }

 virtual _InIt do_get(_InIt _First, _InIt _Last,
  ios_base& _Iosbase, ios_base::iostate& _State,
   void *& _Val) const
  {
                             ;
  char _Ac[32], *_Ep;
  int _Errno = 0;


  int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
   _Iosbase.getloc());
  const unsigned __int64 _Ans =
   (sizeof (void *) == sizeof (unsigned long))
    ? (unsigned __int64):: _Stoulx(_Ac, &_Ep, _Base, &_Errno)
    : :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);







  if (_First == _Last)
   _State |= ios_base::eofbit;
  if (_Ep == _Ac || _Errno != 0)
   _State |= ios_base::failbit;
  else
   _Val = (void *)((char *)0 + _Ans);
  return (_First);
  }

private:
 int __cdecl _Getifld(char *_Ac,
  _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
   const locale& _Loc) const
  {
  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Loc);
  const string _Grouping = _Punct_fac.grouping();
  const _Elem _Kseparator = _Grouping.size() == 0
   ? (_Elem)0 : _Punct_fac.thousands_sep();

  enum {
   _NUMGET_SIGNOFF = 22,
   _NUMGET_XOFF = 24};
  static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};
  _Elem _Atoms[sizeof (_Src) - 1];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Loc);
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src) - 1], _Atoms);

  char *_Ptr = _Ac;

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  _Basefield &= ios_base::basefield;
  int _Base = _Basefield == ios_base::oct ? 8
   : _Basefield == ios_base::hex ? 16
   : _Basefield == ios_base::_Fmtzero ? 0 : 10;

  bool _Seendigit = false;
  bool _Nonzero = false;

  if (_First != _Last && *_First == _Atoms[0])
   {
   _Seendigit = true, ++_First;
   if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
     || *_First == _Atoms[_NUMGET_XOFF])
    && (_Base == 0 || _Base == 16))
    _Base = 16, _Seendigit = false, ++_First;
   else if (_Base == 0)
    _Base = 8;
   }

  size_t _Dlen = _Base == 0 || _Base == 10 ? 10
   : _Base == 8 ? 8 : 16 + 6;
  string _Groups((size_t)1, (char)_Seendigit);
  size_t _Group = 0;

  for (char *const _Pe = &_Ac[32 - 1];
   _First != _Last; ++_First)
   {
   size_t _Idx = _Find_elem(_Atoms, *_First);
   if (_Idx < _Dlen)
    {
    *_Ptr = _Src[_Idx];
    if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
     ++_Ptr, _Nonzero = true;
    _Seendigit = true;
    if (_Groups[_Group] != 127)
     ++_Groups[_Group];
    }
   else if (_Groups[_Group] == '\0'
    || _Kseparator == (_Elem)0
    || *_First != _Kseparator)
    break;
   else
    {
    _Groups.append((string::size_type)1, '\0');
    ++_Group;
    }
   }

  if (_Group == 0)
   ;
  else if ('\0' < _Groups[_Group])
   ++_Group;
  else
   _Seendigit = false;

  for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
   if (*_Pg == 127)
    break;
   else if ((0 < --_Group && *_Pg != _Groups[_Group])
    || (0 == _Group && *_Pg < _Groups[_Group]))
    _Seendigit = false;
   else if ('\0' < _Pg[1])
    ++_Pg;

  if (_Seendigit && !_Nonzero)
   *_Ptr++ = '0';
  else if (!_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  return (_Base);
  }

 int __cdecl _Getffld(char *_Ac,
  _InIt& _First, _InIt &_Last,
  ios_base& _Iosbase, int *_Phexexp) const
  {
  if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
   return (_Getffldx(_Ac, _First, _Last,
    _Iosbase, _Phexexp));

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  char *_Ptr = _Ac;
  bool _Bad = false;

  enum {
   _NUMGET_SIGNOFF = 10,
   _NUMGET_EOFF = 12};
  static const char _Src[] = {"0123456789-+Ee"};
  _Elem _Atoms[sizeof (_Src) - 1];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src) - 1], _Atoms);

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  bool _Seendigit = false;
  int _Significant = 0;
  int _Pten = 0;
  size_t _Idx;

  const char *_Pg = &_Grouping[0];
  if (*_Pg == 127 || *_Pg <= '\0')
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
     _Seendigit = true, ++_First)
    if (36 <= _Significant)
     ++_Pten;
    else if (_Idx == 0 && _Significant == 0)
     ;
    else
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping.size() == 0
    ? (_Elem)0 : _Punct_fac.thousands_sep();
   string _Groups((size_t)1, '\0');
   size_t _Group = 0;

   for (; _First != _Last; ++_First)
    if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
     {
     _Seendigit = true;
     if (36 <= _Significant)
      ++_Pten;
     else if (_Idx == 0 && _Significant == 0)
      ;
     else
      {
      *_Ptr++ = _Src[_Idx];
      ++_Significant;
      }
     if (_Groups[_Group] != 127)
      ++_Groups[_Group];
     }
    else if (_Groups[_Group] == '\0'
     || _Kseparator == (_Elem)0
     || *_First != _Kseparator)
     break;
    else
     {
     _Groups.append((size_t)1, '\0');
     ++_Group;
     }
   if (_Group == 0)
    ;
   else if ('\0' < _Groups[_Group])
    ++_Group;
   else
    _Bad = true;

   while (!_Bad && 0 < _Group)
    if (*_Pg == 127)
     break;
    else if ((0 < --_Group && *_Pg != _Groups[_Group])
     || (0 == _Group && *_Pg < _Groups[_Group]))
     _Bad = true;
    else if ('\0' < _Pg[1])
     ++_Pg;
   }

  if (_Seendigit && _Significant == 0)
   *_Ptr++ = '0';

  if (_First != _Last && *_First == _Punct_fac.decimal_point())
   *_Ptr++ = localeconv()->decimal_point[0], ++_First;

  if (_Significant == 0)
   {
   for (; _First != _Last && *_First == _Atoms[0];
    _Seendigit = true, ++_First)
    --_Pten;
   if (_Pten < 0)
    *_Ptr++ = '0', ++_Pten;
   }

  for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
    _Seendigit = true, ++_First)
   if (_Significant < 36)
    {
    *_Ptr++ = _Src[_Idx];
    ++_Significant;
    }

  if (_Seendigit && _First != _Last
   && (*_First == _Atoms[_NUMGET_EOFF + 1]
    || *_First == _Atoms[_NUMGET_EOFF]))
   {
   *_Ptr++ = 'e', ++_First;
   _Seendigit = false, _Significant = 0;

   if (_First == _Last)
    ;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
    *_Ptr++ = '+', ++_First;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF])
    *_Ptr++ = '-', ++_First;
   for (; _First != _Last && *_First == _Atoms[0]; )
    _Seendigit = true, ++_First;
   if (_Seendigit)
    *_Ptr++ = '0';
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < 10;
    _Seendigit = true, ++_First)
    if (_Significant < 8)
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
   }

  if (_Bad || !_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  return (_Pten);
  }

 int __cdecl _Getffldx(char *_Ac,
  _InIt& _First, _InIt &_Last,
  ios_base& _Iosbase, int *_Phexexp) const
  {
  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();

  enum {
   _NUMGET_SIGNOFF = 22,
   _NUMGET_XOFF = 24,
   _NUMGET_POFF = 26};
  static const char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};
  _Elem _Atoms[sizeof (_Src) - 1];
  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src) - 1], _Atoms);

  char *_Ptr = _Ac;
  bool _Bad = false;
  size_t _Idx;

  if (_First == _Last)
   ;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
   *_Ptr++ = '+', ++_First;
  else if (*_First == _Atoms[_NUMGET_SIGNOFF])
   *_Ptr++ = '-', ++_First;

  *_Ptr++ = '0';
  *_Ptr++ = 'x';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Phex = 0;

  if (_First == _Last || *_First != _Atoms[0])
   ;
  else if (++_First != _Last
   && (*_First == _Atoms[_NUMGET_XOFF + 1]
     || *_First == _Atoms[_NUMGET_XOFF]))
   ++_First;
  else
   _Seendigit = true;

  const char *_Pg = &_Grouping[0];
  if (*_Pg == 127 || *_Pg <= '\0')
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
     _Seendigit = true, ++_First)
    if (36 <= _Significant)
     ++_Phex;
    else if (_Idx == 0 && _Significant == 0)
     ;
    else
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping.size() == 0
    ? (_Elem)0 : _Punct_fac.thousands_sep();
   string _Groups((size_t)1, '\0');
   size_t _Group = 0;

   for (; _First != _Last; ++_First)
    if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
     {
     _Seendigit = true;
     if (36 <= _Significant)
      ++_Phex;
     else if (_Idx == 0 && _Significant == 0)
      ;
     else
      {
      *_Ptr++ = _Src[_Idx];
      ++_Significant;
      }
     if (_Groups[_Group] != 127)
      ++_Groups[_Group];
     }
    else if (_Groups[_Group] == '\0'
     || _Kseparator == (_Elem)0
     || *_First != _Kseparator)
     break;
    else
     {
     _Groups.append((size_t)1, '\0');
     ++_Group;
     }
   if (_Group == 0)
    ;
   else if ('\0' < _Groups[_Group])
    ++_Group;
   else
    _Bad = true;

   while (!_Bad && 0 < _Group)
    if (*_Pg == 127)
     break;
    else if ((0 < --_Group && *_Pg != _Groups[_Group])
     || (0 == _Group && *_Pg < _Groups[_Group]))
     _Bad = true;
    else if ('\0' < _Pg[1])
     ++_Pg;
   }

  if (_Seendigit && _Significant == 0)
   *_Ptr++ = '0';

  if (_First != _Last && *_First == _Punct_fac.decimal_point())
   *_Ptr++ = localeconv()->decimal_point[0], ++_First;

  if (_Significant == 0)
   {
   for (; _First != _Last && *_First == _Atoms[0];
    _Seendigit = true, ++_First)
    --_Phex;
   if (_Phex < 0)
    *_Ptr++ = '0', ++_Phex;
   }

  for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
    _Seendigit = true, ++_First)
   if (_Significant < 36)
    {
    *_Ptr++ = _Src[_Idx];
    ++_Significant;
    }

  if (_Seendigit && _First != _Last
   && (*_First == _Atoms[_NUMGET_POFF + 1]
    || *_First == _Atoms[_NUMGET_POFF]))
   {
   *_Ptr++ = 'p', ++_First;
   _Seendigit = false, _Significant = 0;

   if (_First == _Last)
    ;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
    *_Ptr++ = '+', ++_First;
   else if (*_First == _Atoms[_NUMGET_SIGNOFF])
    *_Ptr++ = '-', ++_First;
   for (; _First != _Last && *_First == _Atoms[0]; )
    _Seendigit = true, ++_First;
   if (_Seendigit)
    *_Ptr++ = '0';
   for (; _First != _Last
    && (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
    _Seendigit = true, ++_First)
    if (_Significant < 8)
     {
     *_Ptr++ = _Src[_Idx];
     ++_Significant;
     }
   }

  if (_Bad || !_Seendigit)
   _Ptr = _Ac;
  *_Ptr = '\0';
  *_Phexexp = _Phex;
  return (0);
  }
 };


template<class _Elem,
 class _InIt>
                         locale::id num_get<_Elem, _InIt>::id;


template<class _Elem,
 class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
 class num_put
  : public locale::facet
 {
public:
 typedef numpunct<_Elem> _Mypunct;
 typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
  _Mystr;

 static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
  const locale *_Ploc = 0)
  {
  if (_Ppf != 0 && *_Ppf == 0)
   *_Ppf = new num_put<_Elem, _OutIt>(
    _Locinfo(_Ploc->c_str()));
  return (4);
  }

                         static locale::id id;

protected:
 virtual ~num_put() throw ()
  {
  }

 void _Init(const _Locinfo&)
  {
  }

public:
 explicit num_put(size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  { _Locinfo _Lobj;
   _Init(_Lobj);
  }
  }

                    num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
  : locale::facet(_Refs)
  {
  _Init(_Lobj);
  }

 typedef _Elem char_type;
 typedef _OutIt iter_type;

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, _Bool _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }


 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }


 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, double _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long double _Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

 _OutIt put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
  {
  return (do_put(_Dest, _Iosbase, _Fill, _Val));
  }

protected:
 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, _Bool _Val) const
  {
                       ;
  if (!(_Iosbase.flags() & ios_base::boolalpha))
   return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
  else
   {
   const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
   _Mystr _Str;
   if (_Val)
    _Str.assign(_Punct_fac.truename());
   else
    _Str.assign(_Punct_fac.falsename());

   size_t _Fillcount = _Iosbase.width() <= 0
    || (size_t)_Iosbase.width() <= _Str.size()
     ? 0 : (size_t)_Iosbase.width() - _Str.size();

   if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
    {
    _Dest = _Rep(_Dest, _Fill, _Fillcount);
    _Fillcount = 0;
    }
   _Dest = _Put(_Dest, _Str.c_str(), _Str.size());
   _Iosbase.width(0);
   return (_Rep(_Dest, _Fill, _Fillcount));
   }
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long _Val) const
  {
  char _Buf[2 * 32], _Fmt[6];

  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
    _Iosbase.flags()), _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
  {
  char _Buf[2 * 32], _Fmt[6];

  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
    _Iosbase.flags()), _Val)));
  }


 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, __int64 _Val) const
  {
  char _Buf[2 * 32], _Fmt[8];

  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
    _Iosbase.flags()), _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, unsigned __int64 _Val) const
  {
  char _Buf[2 * 32], _Fmt[8];

  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
    _Iosbase.flags()), _Val)));
  }


 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, double _Val) const
  {
  char _Buf[8 + 36 + 64], _Fmt[8];
  streamsize _Precision = _Iosbase.precision() <= 0
   && !(_Iosbase.flags() & ios_base::fixed)
    ? 6 : _Iosbase.precision();
  int _Significance = 36 < _Precision
   ? 36 : (int)_Precision;
  _Precision -= _Significance;
  size_t _Beforepoint = 0;
  size_t _Afterpoint = 0;

  if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed
   && _Val * 0.5 != _Val)
   {
   bool _Signed = _Val < 0;
   if (_Signed)
    _Val = -_Val;

   for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
    _Val /= 1e10;

   if (0 < _Val)
    for (; 10 <= _Precision && _Val <= 1e-35
     && _Afterpoint < 5000; _Afterpoint += 10)
     {
     _Val *= 1e10;
     _Precision -= 10;
     }

   if (_Signed)
    _Val = -_Val;
   }

  return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
   _Beforepoint, _Afterpoint, (size_t)_Precision,
    :: sprintf_s(_Buf, sizeof (_Buf),
     _Ffmt(_Fmt, 0, _Iosbase.flags()),
     _Significance, _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, long double _Val) const
  {
  char _Buf[8 + 36 + 64], _Fmt[8];
  streamsize _Precision = _Iosbase.precision() <= 0
   && !(_Iosbase.flags() & ios_base::fixed)
    ? 6 : _Iosbase.precision();
  int _Significance = 36 < _Precision
   ? 36 : (int)_Precision;
  _Precision -= _Significance;
  size_t _Beforepoint = 0;
  size_t _Afterpoint = 0;

  if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed)
   {
   bool _Signed = _Val < 0;
   if (_Signed)
    _Val = -_Val;

   for (; 1e35 <= _Val && _Beforepoint < 5000; _Beforepoint += 10)
    _Val /= 1e10;

   if (0 < _Val)
    for (; 10 <= _Precision && _Val <= 1e-35
     && _Afterpoint < 5000; _Afterpoint += 10)
     {
     _Val *= 1e10;
     _Precision -= 10;
     }

   if (_Signed)
    _Val = -_Val;
   }

  return (_Fput(_Dest, _Iosbase, _Fill, _Buf,
   _Beforepoint, _Afterpoint, (size_t)_Precision,
    :: sprintf_s(_Buf, sizeof (_Buf),
     _Ffmt(_Fmt, 'L', _Iosbase.flags()),
     _Significance, _Val)));
  }

 virtual _OutIt do_put(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
  {
  char _Buf[2 * 32];

  return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
  }

private:
 char *__cdecl _Ffmt(char *_Fmt,
  char _Spec, ios_base::fmtflags _Flags) const
  {
  char *_Ptr = _Fmt;
  *_Ptr++ = '%';

  if (_Flags & ios_base::showpos)
   *_Ptr++ = '+';
  if (_Flags & ios_base::showpoint)
   *_Ptr++ = '#';
  *_Ptr++ = '.';
  *_Ptr++ = '*';
  if (_Spec != '\0')
   *_Ptr++ = _Spec;

  ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
  if (_Flags & ios_base::uppercase)
   *_Ptr++ = _Ffl == ios_base::fixed ? 'f'
    : _Ffl == ios_base::hexfloat ? 'A'
    : _Ffl == ios_base::scientific ? 'E' : 'G';
  else
   *_Ptr++ = _Ffl == ios_base::fixed ? 'f'
    : _Ffl == ios_base::hexfloat ? 'a'
    : _Ffl == ios_base::scientific ? 'e' : 'g';

  *_Ptr = '\0';
  return (_Fmt);
  }

 _OutIt __cdecl _Fput(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
   size_t _Beforepoint, size_t _Afterpoint,
    size_t _Trailing, size_t _Count) const
  {
                       ;
  size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
   ? 1 : 0;

  const char *_Exps;
  if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
   _Exps = "eE";
  else
   {
   _Exps = "pP";
   if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
    && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
    _Prefix += 2;
   }
  const size_t _Eoff =
   :: strcspn(&_Buf[0], _Exps);
  char _Dp[2] = {"."};
  _Dp[0] = :: localeconv()->decimal_point[0];
  const size_t _Poff =
   :: strcspn(&_Buf[0], &_Dp[0]);

  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  const _Elem _E0 = _Ctype_fac.widen('0');
  _Mystr _Groupstring(_Count, _Elem(0));
  _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  const _Elem _Kseparator = _Punct_fac.thousands_sep();

  size_t _Off = _Beforepoint;
  if (_Poff == _Count)
   {
   _Off += _Eoff;
   _Groupstring.insert(_Eoff, _Beforepoint, _E0);
   }
  else
   {
   _Off += _Poff;
   _Groupstring.insert(_Eoff, _Trailing, _E0);
   _Groupstring.insert(_Poff + 1, _Afterpoint, _E0);
   _Groupstring[_Poff] = _Punct_fac.decimal_point();
   _Groupstring.insert(_Poff, _Beforepoint, _E0);
   }

  const char *_Pg = &_Grouping[0];
  while (*_Pg != 127 && '\0' < *_Pg
   && (size_t)*_Pg < _Off - _Prefix)
   {
   _Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
   if ('\0' < _Pg[1])
    ++_Pg;
   }

  _Count = _Groupstring.size();
  size_t _Fillcount = _Iosbase.width() <= 0
   || (size_t)_Iosbase.width() <= _Count
    ? 0 : (size_t)_Iosbase.width() - _Count;

  ios_base::fmtflags _Adjustfield =
   _Iosbase.flags() & ios_base::adjustfield;
  if (_Adjustfield != ios_base::left
   && _Adjustfield != ios_base::internal)
   {
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   }
  else if (_Adjustfield == ios_base::internal)
   {
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   }
  else
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
  _Iosbase.width(0);
  return (_Rep(_Dest, _Fill, _Fillcount));
  }

 char *__cdecl _Ifmt(char *_Fmt,
  const char *_Spec, ios_base::fmtflags _Flags) const
  {
  char *_Ptr = _Fmt;
  *_Ptr++ = '%';

  if (_Flags & ios_base::showpos)
   *_Ptr++ = '+';
  if (_Flags & ios_base::showbase)
   *_Ptr++ = '#';
  if (_Spec[0] != 'L')
   *_Ptr++ = _Spec[0];
  else

   {
   *_Ptr++ = 'I';
   *_Ptr++ = '6';
   *_Ptr++ = '4';
   }

  ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
  *_Ptr++ = _Basefield == ios_base::oct ? 'o'
   : _Basefield != ios_base::hex ? _Spec[1]
   : _Flags & ios_base::uppercase ? 'X' : 'x';
  *_Ptr = '\0';
  return (_Fmt);
  }

 _OutIt __cdecl _Iput(_OutIt _Dest,
  ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
  {
                       ;
  size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
   ? 1 : 0;
  if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
   && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
   && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
   _Prefix += 2;

  const ctype<_Elem>& _Ctype_fac =
   use_facet< ctype<_Elem> >(_Iosbase.getloc());
  _Mystr _Groupstring(_Count, _Elem(0));
  _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

  const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
  const string _Grouping = _Punct_fac.grouping();
  const char *_Pg = &_Grouping[0];
  if (*_Pg != 127 && '\0' < *_Pg)
   {
   const _Elem _Kseparator = _Punct_fac.thousands_sep();
   while (*_Pg != 127 && '\0' < *_Pg
    && (size_t)*_Pg < _Count - _Prefix)
    {
    _Count -= *_Pg;
    _Groupstring.insert(_Count, 1, _Kseparator);
    if ('\0' < _Pg[1])
     ++_Pg;
    }
   }

  _Count = _Groupstring.size();
  size_t _Fillcount = _Iosbase.width() <= 0
   || (size_t)_Iosbase.width() <= _Count
    ? 0 : (size_t)_Iosbase.width() - _Count;

  ios_base::fmtflags _Adjustfield =
   _Iosbase.flags() & ios_base::adjustfield;
  if (_Adjustfield != ios_base::left
   && _Adjustfield != ios_base::internal)
   {
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   }
  else if (_Adjustfield == ios_base::internal)
   {
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
   _Dest = _Rep(_Dest, _Fill, _Fillcount);
   _Fillcount = 0;
   }
  else
   _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
  _Iosbase.width(0);
  return (_Rep(_Dest, _Fill, _Fillcount));
  }

 _OutIt __cdecl _Put(_OutIt _Dest,
  const _Elem *_Ptr, size_t _Count) const
  {
  for (; 0 < _Count; --_Count, ++_Dest, ++_Ptr)
   *_Dest = *_Ptr;
  return (_Dest);
  }

 _OutIt __cdecl _Rep(_OutIt _Dest,
  _Elem _Ch, size_t _Count) const
  {
  for (; 0 < _Count; --_Count, ++_Dest)
   *_Dest = _Ch;
  return (_Dest);
  }
 };


template<class _Elem,
 class _OutIt>
                         locale::id num_put<_Elem, _OutIt>::id;




template locale::id numpunct<char>::id;
template class __declspec(dllimport) num_get<char,
 istreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) num_put<char,
 ostreambuf_iterator<char, char_traits<char> > >;

template locale::id numpunct<wchar_t>::id;
template class __declspec(dllimport) num_get<wchar_t,
 istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class __declspec(dllimport) num_put<wchar_t,
 ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
#line 1593 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xlocnum"
}

#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ios"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4189)

namespace std {

template<class _Elem,
 class _Traits>
 class basic_ios
  : public ios_base
 {
public:
 typedef basic_ios<_Elem, _Traits> _Myt;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef ctype<_Elem> _Ctype;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 explicit basic_ios(_Mysb *_Strbuf)
  {
  init(_Strbuf);
  }

 virtual ~basic_ios() throw ()
  {
  }

 void clear(iostate _State = goodbit,
  bool _Reraise = false)
  {
  ios_base::clear((iostate)(_Mystrbuf == 0
   ? (int)_State | (int)badbit : (int)_State), _Reraise);
  }

 void clear(io_state _State)
  {
  clear((iostate)_State);
  }

 void setstate(iostate _State,
  bool _Reraise = false)
  {
  if (_State != goodbit)
   clear((iostate)((int)rdstate() | (int)_State), _Reraise);
  }

 void setstate(io_state _State)
  {
  setstate((iostate)_State);
  }

 _Myt& copyfmt(const _Myt& _Right)
  {
  _Tiestr = _Right.tie();
  _Fillch = _Right.fill();
  ios_base::copyfmt(_Right);
  return (*this);
  }

 _Myos * tie() const
  {
  return (_Tiestr);
  }

 _Myos * tie(_Myos *_Newtie)
  {
  _Myos *_Oldtie = _Tiestr;
  _Tiestr = _Newtie;
  return (_Oldtie);
  }

 _Mysb * rdbuf() const
  {
  return (_Mystrbuf);
  }

 _Mysb * rdbuf(_Mysb *_Strbuf)
  {
  _Mysb *_Oldstrbuf = _Mystrbuf;
  _Mystrbuf = _Strbuf;
  clear();
  return (_Oldstrbuf);
  }

 locale imbue(const locale& _Loc)
  {
  locale _Oldlocale = ios_base::imbue(_Loc);
  if (rdbuf() != 0)
   rdbuf()->pubimbue(_Loc);
  return (_Oldlocale);
  }

 _Elem fill() const
  {
  return (_Fillch);
  }

 _Elem fill(_Elem _Newfill)
  {
  _Elem _Oldfill = _Fillch;
  _Fillch = _Newfill;
  return (_Oldfill);
  }

 char narrow(_Elem _Ch, char _Dflt = '\0') const
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
  return (_Ctype_fac.narrow(_Ch, _Dflt));
  }

 _Elem widen(char _Byte) const
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
  return (_Ctype_fac.widen(_Byte));
  }

 void move(_Myt& _Right)
  {
  if (this != &_Right)
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this->swap(_Right);
   }
  }

 void move(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this->swap(_Right);
   }
  }

 void swap(_Myt& _Right) throw ()
  {
  ios_base::swap(_Right);
  ::std:: swap(_Fillch, _Right._Fillch);
  ::std:: swap(_Tiestr, _Right._Tiestr);
  }

 void set_rdbuf(_Mysb *_Strbuf)
  {
  _Mystrbuf = _Strbuf;
  }

protected:
 void init(_Mysb *_Strbuf = 0,
  bool _Isstd = false)
  {
  _Init();
  _Mystrbuf = _Strbuf;
  _Tiestr = 0;
  _Fillch = widen(' ');

  if (_Mystrbuf == 0)
   setstate(badbit);

  if (_Isstd)
   _Addstd(this);
  }

                    basic_ios()
  {
  }

private:
 _Mysb *_Mystrbuf;
 _Myos *_Tiestr;
 _Elem _Fillch;

public:
                    basic_ios(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;
 };




template class __declspec(dllimport) basic_ios<char,
 char_traits<char> >;
template class __declspec(dllimport) basic_ios<wchar_t,
 char_traits<wchar_t> >;
#line 209 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ios"
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::boolalpha);
 return (_Iosbase);
 }

inline ios_base& __cdecl dec(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::dec, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl hex(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::hex, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
 return (_Iosbase);
 }

namespace tr1 {
using ::std:: hexfloat;
}

inline ios_base& __cdecl internal(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl left(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::left, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::boolalpha);
 return (_Iosbase);
 }

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showbase);
 return (_Iosbase);
 }

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showpoint);
 return (_Iosbase);
 }

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::showpos);
 return (_Iosbase);
 }

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::skipws);
 return (_Iosbase);
 }

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::unitbuf);
 return (_Iosbase);
 }

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
 {
 _Iosbase.unsetf(ios_base::uppercase);
 return (_Iosbase);
 }

inline ios_base& __cdecl oct(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::oct, ios_base::basefield);
 return (_Iosbase);
 }

inline ios_base& __cdecl right(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::right, ios_base::adjustfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
 return (_Iosbase);
 }

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showbase);
 return (_Iosbase);
 }

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showpoint);
 return (_Iosbase);
 }

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::showpos);
 return (_Iosbase);
 }

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::skipws);
 return (_Iosbase);
 }

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::unitbuf);
 return (_Iosbase);
 }

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
 {
 _Iosbase.setf(ios_base::uppercase);
 return (_Iosbase);
 }
}


#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ostream"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4189 4390)

namespace std {
#line 35 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ostream"
#pragma vtordisp(push, 2)


template<class _Elem,
 class _Traits>
 class basic_ostream
  : virtual public basic_ios<_Elem, _Traits>
 {
public:
 typedef basic_ostream<_Elem, _Traits> _Myt;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
 typedef num_put<_Elem, _Iter> _Nput;

 explicit basic_ostream(
  basic_streambuf<_Elem, _Traits> *_Strbuf,

  bool _Isstd = false)
  {
  _Myios::init(_Strbuf, _Isstd);
  }

                    basic_ostream(_Uninitialized, bool _Addit = true)
  {
  if (_Addit)
   this->_Addstd(this);
  }

protected:
                    basic_ostream(_Myt&& _Right)
  {
  _Myios::init();
  _Myios::move(::std:: move(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   _Myios::swap(_Right);
  }

public:
                    basic_ostream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_ostream() throw ()
  {
  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 class _Sentry_base
  {
 public:
                     _Sentry_base(_Myt& _Ostr)
   : _Myostr(_Ostr)
   {
   if (_Myostr.rdbuf() != 0)
    _Myostr.rdbuf()->_Lock();
   }

                     ~_Sentry_base() throw ()
   {
   if (_Myostr.rdbuf() != 0)
    _Myostr.rdbuf()->_Unlock();
   }

  _Myt& _Myostr;

 private:
  _Sentry_base& operator=(const _Sentry_base&);
  };

 class sentry
  : public _Sentry_base
  {
 public:
  explicit sentry(_Myt& _Ostr)
   : _Sentry_base(_Ostr)
   {
   if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
    _Ostr.tie()->flush();
   _Ok = _Ostr.good();
   }

                     ~sentry() throw ()
   {

   if (!::std:: uncaught_exception())
    this->_Myostr._Osfx();




   }

  explicit operator bool() const
   {
   return (_Ok);
   }

 private:
  bool _Ok;

 public:
                     sentry(const sentry&) = delete;
  sentry& operator=(const sentry&) = delete;
  };

 bool opfx()
  {
  if (this->good() && _Myios::tie() != 0 && _Myios::tie() != this)
   _Myios::tie()->flush();
  return (this->good());
  }

 void osfx()
  {
  _Osfx();
  }

 void _Osfx()
  {
  try {
  if (this->good() && this->flags() & ios_base::unitbuf)
   if (_Myios::rdbuf()->pubsync() == -1)
    _Myios::setstate(ios_base::badbit);
  } catch (...) {
  }
  }
#line 197 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ostream"
 _Myt& operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
  {
                      ;
  return ((*_Pfn)(*this));
  }

 _Myt& operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
  {
                      ;
  (*_Pfn)(*(_Myios *)this);
  return (*this);
  }

 _Myt& operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
  {
                      ;
  (*_Pfn)(*(ios_base *)this);
  return (*this);
  }

 _Myt& operator<<(_Bool _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(short _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
   ios_base::fmtflags _Bfl =
    this->flags() & ios_base::basefield;
   long _Tmp = (_Bfl == ios_base::oct
    || _Bfl == ios_base::hex)
    ? (long)(unsigned short)_Val : (long)_Val;

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Tmp).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }
#line 271 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ostream"
 _Myt& operator<<(unsigned short _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (unsigned long)_Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(int _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
   ios_base::fmtflags _Bfl =
    this->flags() & ios_base::basefield;
   long _Tmp = (_Bfl == ios_base::oct
    || _Bfl == ios_base::hex)
    ? (long)(unsigned int)_Val : (long)_Val;

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Tmp).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(unsigned int _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (unsigned long)_Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(unsigned long _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }


 _Myt& operator<<(__int64 _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(unsigned __int64 _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }


 _Myt& operator<<(float _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), (double)_Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(double _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(long double _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(const void *_Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

   try {
   if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
    _Myios::fill(), _Val).failed())
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator<<(_Mysb *_Strbuf)
  {
  ios_base::iostate _State = ios_base::goodbit;
  bool _Copied = false;
  const sentry _Ok(*this);

  if (_Ok && _Strbuf != 0)
   for (int_type _Meta = _Traits::eof(); ; _Copied = true)
    {
    try {
    _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
     ? _Strbuf->sgetc() : _Strbuf->snextc();
    } catch (...) {
     _Myios::setstate(ios_base::failbit);
     throw;
    }

    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     break;

    try {
     if (_Traits::eq_int_type(_Traits::eof(),
      _Myios::rdbuf()->sputc(
       _Traits::to_char_type(_Meta))))
      {
      _State |= ios_base::badbit;
      break;
      }
    } catch (...) { _Myios::setstate(ios_base::badbit, true); }
    }

  this->width(0);
  _Myios::setstate(_Strbuf == 0 ? ios_base::badbit
   : !_Copied ? _State | ios_base::failbit : _State);
  return (*this);
  }

 _Myt& put(_Elem _Ch)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (!_Ok)
   _State |= ios_base::badbit;
  else
   {
   try {
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sputc(_Ch)))
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& write(const _Elem *_Str,
  streamsize _Count)
  {





  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (!_Ok)
   _State |= ios_base::badbit;
  else
   {
   try {
   if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
    _State |= ios_base::badbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& flush()
  {
  if (_Myios::rdbuf() != 0)
   {
   const sentry _Ok(*this);

   if (_Ok && _Myios::rdbuf()->pubsync() == -1)
    _Myios::setstate(ios_base::badbit);
   }
  return (*this);
  }

 _Myt& seekp(pos_type _Pos)
  {
  const sentry _Ok(*this);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
    ios_base::out) == _BADOFF)
   _Myios::setstate(ios_base::failbit);
  return (*this);
  }

 _Myt& seekp(off_type _Off, ios_base::seekdir _Way)
  {
  const sentry _Ok(*this);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
    ios_base::out) == _BADOFF)
   _Myios::setstate(ios_base::failbit);
  return (*this);
  }

 pos_type tellp()
  {
  const sentry _Ok(*this);

  if (!this->fail())
   return (_Myios::rdbuf()->pubseekoff(0,
    ios_base::cur, ios_base::out));
  else
   return (pos_type(_BADOFF));
  }
 };

#pragma vtordisp(pop)
#line 683 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ostream"
template class __declspec(dllimport) basic_ostream<char,
 char_traits<char> >;
template class __declspec(dllimport) basic_ostream<wchar_t,
 char_traits<wchar_t> >;
#line 697 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\ostream"
template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
 {
 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize):: strlen(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  try {
  const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
 {
 ios_base::iostate _State = ios_base::goodbit;
 const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

 if (_Ok)
  {
  const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr,
  const char *_Val)
 {
 typedef char _Elem;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize)_Traits::length(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
   _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, char _Ch)
 {
 typedef char _Elem;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myos::sentry _Ok(_Ostr);

 if (_Ok)
  {
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ch)))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;

 ios_base::iostate _State = ios_base::goodbit;
 streamsize _Count = (streamsize)_Traits::length(_Val);
 streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
  ? 0 : _Ostr.width() - _Count;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
  try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
   _State |= ios_base::badbit;

  if (_State == ios_base::goodbit)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;

 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myos::sentry _Ok(_Ostr);

 if (_Ok)
  {
  streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

  try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; _State == ios_base::goodbit && 0 < _Pad;
    --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     _State |= ios_base::badbit;

  if (_State == ios_base::goodbit
   && _Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ch)))
   _State |= ios_base::badbit;

  for (; _State == ios_base::goodbit && 0 < _Pad;
   --_Pad)
   if (_Traits::eq_int_type(_Traits::eof(),
    _Ostr.rdbuf()->sputc(_Ostr.fill())))
    _State |= ios_base::badbit;
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.width(0);
 _Ostr.setstate(_State);
 return (_Ostr);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
 {
 return (_Ostr << (const char *)_Val);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
 {
 return (_Ostr << (char)_Ch);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
 {
 return (_Ostr << (const char *)_Val);
 }

template<class _Traits> inline
 basic_ostream<char, _Traits>& operator<<(
  basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
 {
 return (_Ostr << (char)_Ch);
 }

template<class _Elem,
 class _Traits,
 class _Ty> inline
 basic_ostream<_Elem, _Traits>&
  operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
 {
 return (_Ostr << _Val);
 }


template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  __cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.put(_Ostr.widen('\n'));
 _Ostr.flush();
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  __cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.put(_Elem());
 return (_Ostr);
 }

template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  __cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
 {
 _Ostr.flush();
 return (_Ostr);
 }


template<class _Elem,
 class _Traits> inline
 basic_ostream<_Elem, _Traits>&
  operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
   const error_code& _Errcode)
 {
 return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
 }
}


#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\istream"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4189)

namespace std {
#pragma vtordisp(push, 2)


template<class _Elem,
 class _Traits>
 class basic_istream
  : virtual public basic_ios<_Elem, _Traits>
 {
public:
 typedef basic_istream<_Elem, _Traits> _Myt;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef basic_streambuf<_Elem, _Traits> _Mysb;
 typedef istreambuf_iterator<_Elem, _Traits> _Iter;
 typedef ctype<_Elem> _Ctype;
 typedef num_get<_Elem, _Iter> _Nget;
#line 42 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\istream"
 explicit basic_istream(_Mysb *_Strbuf,
  bool _Isstd = false)

  : _Chcount(0)
  {
  _Myios::init(_Strbuf, _Isstd);
  }

                    basic_istream(_Uninitialized)
  {
  this->_Addstd(this);
  }

protected:
                    basic_istream(_Myt&& _Right)
  : _Chcount(_Right._Chcount)
  {
  _Myios::init();
  _Myios::move(::std:: move(_Right));
  _Right._Chcount = 0;
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  _Myios::swap(_Right);
  ::std:: swap(_Chcount, _Right._Chcount);
  }

public:
                    basic_istream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_istream() throw ()
  {
  }

 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;


 class _Sentry_base
  {
 public:
                     _Sentry_base(_Myt& _Istr)
   : _Myistr(_Istr)
   {
   if (_Myistr.rdbuf() != 0)
    _Myistr.rdbuf()->_Lock();
   }

                     ~_Sentry_base() throw ()
   {
   if (_Myistr.rdbuf() != 0)
    _Myistr.rdbuf()->_Unlock();
   }

  _Myt& _Myistr;

 private:
  _Sentry_base& operator=(const _Sentry_base&);
  };

 class sentry
  : public _Sentry_base
  {
 public:
  explicit sentry(_Myt& _Istr, bool _Noskip = false)
   : _Sentry_base(_Istr)
   {
   _Ok = this->_Myistr._Ipfx(_Noskip);
   }

  explicit operator bool() const
   {
   return (_Ok);
   }

 private:
  bool _Ok;

 public:
                     sentry(const sentry&) = delete;
  sentry& operator=(const sentry&) = delete;
  };

 bool _Ipfx(bool _Noskip = false)
  {
  if (this->good())
   {
   if (_Myios::tie() != 0)
    _Myios::tie()->flush();

   if (!_Noskip && this->flags() & ios_base::skipws)
    {
    const _Ctype& _Ctype_fac = use_facet< _Ctype >(this->getloc());

    try {
    int_type _Meta = _Myios::rdbuf()->sgetc();

    for (; ; _Meta = _Myios::rdbuf()->snextc())
     if (_Traits::eq_int_type(_Traits::eof(), _Meta))
      {
      _Myios::setstate(ios_base::eofbit);
      break;
      }
     else if (!_Ctype_fac.is(_Ctype::space,
      _Traits::to_char_type(_Meta)))
      break;
    } catch (...) { _Myios::setstate(ios_base::badbit, true); }
    }

   if (this->good())
    return (true);
   }
  _Myios::setstate(ios_base::failbit);
  return (false);
  }

 bool ipfx(bool _Noskip = false)
  {
  return (_Ipfx(_Noskip));
  }

 void isfx()
  {
  }
#line 198 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\istream"
 _Myt& operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
  {
                      ;
  return ((*_Pfn)(*this));
  }

 _Myt& operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
  {
                      ;
  (*_Pfn)(*(_Myios *)this);
  return (*this);
  }

 _Myt& operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
  {
                      ;
  (*_Pfn)(*(ios_base *)this);
  return (*this);
  }

 _Myt& operator>>(_Bool& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(short& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   long _Tmp = 0;
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Tmp);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }

   if (_State & ios_base::failbit
    || _Tmp < (-32768) || 32767 < _Tmp)
    _State |= ios_base::failbit;
   else
    _Val = (short)_Tmp;
   }

  _Myios::setstate(_State);
  return (*this);
  }
#line 272 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\istream"
 _Myt& operator>>(unsigned short& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(int& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   long _Tmp = 0;
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Tmp);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }

   if (_State & ios_base::failbit
    || _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
    _State |= ios_base::failbit;
   else
    _Val = _Tmp;
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(unsigned int& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(unsigned long& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }


 _Myt& operator>>(__int64& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(unsigned __int64& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }


 _Myt& operator>>(float& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(double& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);
  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(long double& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(void *& _Val)
  {
  ios_base::iostate _State = ios_base::goodbit;
  const sentry _Ok(*this);

  if (_Ok)
   {
   const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

   try {
   _Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
    *this, _State, _Val);
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& operator>>(_Mysb *_Strbuf)
  {
  ios_base::iostate _State = ios_base::goodbit;
  bool _Copied = false;
  const sentry _Ok(*this);

  if (_Ok && _Strbuf != 0)
   {
   try {
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     try {
      if (_Traits::eq_int_type(_Traits::eof(),
       _Strbuf->sputc(_Traits::to_char_type(_Meta))))
       break;
     } catch (...) {
      break;
     }
     _Copied = true;
     }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
  return (*this);
  }

 int_type get()
  {
  int_type _Meta = 0;
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (!_Ok)
   _Meta = _Traits::eof();
  else
   {
   try {
   _Meta = _Myios::rdbuf()->sgetc();

   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    _State |= ios_base::eofbit | ios_base::failbit;
   else
    {
    _Myios::rdbuf()->sbumpc();
    ++_Chcount;
    }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (_Meta);
  }

 _Myt& get(_Elem *_Str, streamsize _Count)
  {
  return (get(_Str, _Count, _Myios::widen('\n')));
  }

 _Myt& get(_Elem *_Str,
  streamsize _Count, _Elem _Delim)
  {
                      ;
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   try {
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (_Traits::to_char_type(_Meta) == _Delim)
     break;
    else
     {
     *_Str++ = _Traits::to_char_type(_Meta);
     ++_Chcount;
     }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_Chcount == 0
   ? _State | ios_base::failbit : _State);
  *_Str = _Elem();
  return (*this);
  }

 _Myt& get(_Elem& _Ch)
  {
  int_type _Meta = get();
  if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
   _Ch = _Traits::to_char_type(_Meta);
  return (*this);
  }

 _Myt& get(_Mysb& _Strbuf)
  {
  return (get(_Strbuf, _Myios::widen('\n')));
  }

 _Myt& get(_Mysb& _Strbuf, _Elem _Delim)
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   try {
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     try {
      _Elem _Ch = _Traits::to_char_type(_Meta);
      if (_Ch == _Delim
       || _Traits::eq_int_type(_Traits::eof(),
        _Strbuf.sputc(_Ch)))
       break;
     } catch (...) {
      break;
     }
     ++_Chcount;
     }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  if (_Chcount == 0)
   _State |= ios_base::failbit;
  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& getline(_Elem *_Str, streamsize _Count)
  {
  return (getline(_Str, _Count, _Myios::widen('\n')));
  }

 _Myt& getline(_Elem *_Str,
  streamsize _Count, _Elem _Delim)
  {
                      ;
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   int_type _Metadelim = _Traits::to_int_type(_Delim);

   try {
   int_type _Meta = _Myios::rdbuf()->sgetc();

   for (; ; _Meta = _Myios::rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (_Meta == _Metadelim)
     {
     ++_Chcount;
     _Myios::rdbuf()->sbumpc();
     break;
     }
    else if (--_Count <= 0)
     {
     _State |= ios_base::failbit;
     break;
     }
    else
     {
     ++_Chcount;
     *_Str++ = _Traits::to_char_type(_Meta);
     }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  *_Str = _Elem();
  _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
  return (*this);
  }

 _Myt& ignore(streamsize _Count = 1,
  int_type _Metadelim = _Traits::eof())
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok && 0 < _Count)
   {
   try {
   for (; ; )
    {
    int_type _Meta;
    if (_Count != 2147483647 && --_Count < 0)
     break;
    else if (_Traits::eq_int_type(_Traits::eof(),
     _Meta = _Myios::rdbuf()->sbumpc()))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else
     {
     ++_Chcount;
     if (_Meta == _Metadelim)
      break;
     }
    }
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& read(_Elem *_Str, streamsize _Count)
  {
                      ;
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   try {
   const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
   _Chcount += _Num;
   if (_Num != _Count)
    _State |= ios_base::eofbit | ios_base::failbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 streamsize readsome(_Elem *_Str,
  streamsize _Count)
  {
                      ;
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  const sentry _Ok(*this, true);
  streamsize _Num;

  if (!_Ok)
   _State |= ios_base::failbit;
  else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
   _State |= ios_base::eofbit;
  else if (0 < _Num)
   read(_Str, _Num < _Count ? _Num : _Count);

  _Myios::setstate(_State);
  return (gcount());
  }

 int_type peek()
  {
  ios_base::iostate _State = ios_base::goodbit;
  _Chcount = 0;
  int_type _Meta = 0;
  const sentry _Ok(*this, true);

  if (!_Ok)
   _Meta = _Traits::eof();
  else
   {
   try {
   if (_Traits::eq_int_type(_Traits::eof(),
    _Meta = _Myios::rdbuf()->sgetc()))
    _State |= ios_base::eofbit;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (_Meta);
  }

 _Myt& putback(_Elem _Ch)
  {
  _Chcount = 0;
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   try {
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sputbackc(_Ch)))
    _State |= ios_base::badbit | _Oldstate;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 _Myt& unget()
  {
  _Chcount = 0;
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (_Ok)
   {
   try {
   if (_Traits::eq_int_type(_Traits::eof(),
    _Myios::rdbuf()->sungetc()))
    _State |= ios_base::badbit | _Oldstate;
   } catch (...) { _Myios::setstate(ios_base::badbit, true); }
   }

  _Myios::setstate(_State);
  return (*this);
  }

 streamsize gcount() const
  {
  return (_Chcount);
  }

 int sync()
  {
  const sentry _Ok(*this, true);

  if (_Myios::rdbuf() == 0)
   return (-1);
  else if (_Myios::rdbuf()->pubsync() == -1)
   {
   _Myios::setstate(ios_base::badbit);
   return (-1);
   }
  else
   return (0);
  }

 _Myt& seekg(pos_type _Pos)
  {
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
    ios_base::in) == _BADOFF)
   _Myios::setstate(_State | ios_base::failbit);
  return (*this);
  }

 _Myt& seekg(off_type _Off, ios_base::seekdir _Way)
  {
  ios_base::iostate _State = ios_base::goodbit;
  ios_base::iostate _Oldstate = _Myios::rdstate();
  _Myios::clear(_Oldstate & ~ios_base::eofbit);
  const sentry _Ok(*this, true);

  if (!this->fail()
   && (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
    ios_base::in) == _BADOFF)
   _Myios::setstate(_State | ios_base::failbit);
  return (*this);
  }

 pos_type tellg()
  {
  const sentry _Ok(*this, true);

  if (!this->fail())
   return (_Myios::rdbuf()->pubseekoff(0,
    ios_base::cur, ios_base::in));
  else
   return (pos_type(_BADOFF));
  }

private:
 streamsize _Chcount;
 };



#pragma vtordisp(pop)
#line 923 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\istream"
template class __declspec(dllimport) basic_istream<char, char_traits<char> >;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >;
#line 934 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\istream"
template<class _Elem,
 class _Traits>
 class basic_iostream
 : public basic_istream<_Elem, _Traits>,
  public basic_ostream<_Elem, _Traits>
 {
public:
 typedef basic_iostream<_Elem, _Traits> _Myt;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef basic_ostream<_Elem, _Traits> _Myos;
 typedef basic_ios<_Elem, _Traits> _Myios;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits::int_type int_type;
 typedef typename _Traits::pos_type pos_type;
 typedef typename _Traits::off_type off_type;

 explicit basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
  : _Myis(_Strbuf, false),
   _Myos(_Noinit, false)
  {
  }

protected:
                    basic_iostream(_Myt&& _Right)
  : _Myis(_Right.rdbuf(), false),
   _Myos(_Noinit, false)
  {
  _Myios::init();
  _Myios::move(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  this->swap(_Right);
  return (*this);
  }

 void swap(_Myt& _Right)
  {
  if (this != &_Right)
   _Myios::swap(_Right);
  }

public:
                    basic_iostream(const _Myt&) = delete;
 _Myt& operator=(const _Myt&) = delete;

 virtual ~basic_iostream() throw ()
  {
  }
 };






template class __declspec(dllimport) basic_iostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t> >;
#line 1004 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\istream"
template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
 {
                     ;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef ctype<_Elem> _Ctype;
 ios_base::iostate _State = ios_base::goodbit;
 _Elem *_Str0 = _Str;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

  try {
  streamsize _Count = 0 < _Istr.width() ? _Istr.width() : 2147483647;
  typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
  _Elem _Ch;
  for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    {
    _State |= ios_base::eofbit;
    break;
    }
   else if (_Ctype_fac.is(_Ctype::space,
    _Ch = _Traits::to_char_type(_Meta))
     || _Ch == _Elem())
    break;
   else
    *_Str++ = _Traits::to_char_type(_Meta);
  } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
  }

 *_Str = _Elem();
 _Istr.width(0);
 _Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
 return (_Istr);
 }

template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;

 typename _Myis::int_type _Meta;
 ios_base::iostate _State = ios_base::goodbit;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  try {
  _Meta = _Istr.rdbuf()->sbumpc();
  if (_Traits::eq_int_type(_Traits::eof(), _Meta))
   _State |= ios_base::eofbit | ios_base::failbit;
  else
   _Ch = _Traits::to_char_type(_Meta);
  } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
  }

 _Istr.setstate(_State);
 return (_Istr);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits>& _Istr, signed char *_Str)
 {
 return (_Istr >> (char *)_Str);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits>& _Istr, signed char& _Ch)
 {
 return (_Istr >> (char&)_Ch);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
 {
 return (_Istr >> (char *)_Str);
 }

template<class _Traits> inline
 basic_istream<char, _Traits>& operator>>(
  basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
 {
 return (_Istr >> (char&)_Ch);
 }

template<class _Elem,
 class _Traits,
 class _Ty> inline
 basic_istream<_Elem, _Traits>&
  operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty& _Val)
 {
 return (_Istr >> _Val);
 }


template<class _Elem,
 class _Traits> inline
 basic_istream<_Elem, _Traits>&
  __cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef ctype<_Elem> _Ctype;

 if (!_Istr.eof())
  {
  ios_base::iostate _State = ios_base::goodbit;
  const typename _Myis::sentry _Ok(_Istr, true);

  if (_Ok)
   {
   const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

   try {
   for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
    _Meta = _Istr.rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (!_Ctype_fac.is(_Ctype::space,
     _Traits::to_char_type(_Meta)))
     break;
   } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
   }

  _Istr.setstate(_State);
  }
 return (_Istr);
 }

__declspec(dllimport) inline basic_istream<char, char_traits<char> >&
 __cdecl ws(basic_istream<char, char_traits<char> >& _Istr)
 {
 typedef char _Elem;
 typedef char_traits<_Elem> _Traits;

 if (!_Istr.eof())
  {
  ios_base::iostate _State = ios_base::goodbit;
  const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

  if (_Ok)
   {
   const ctype<_Elem>& _Ctype_fac =
    use_facet< ctype<_Elem> >(_Istr.getloc());

   try {
   for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
    _Meta = _Istr.rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (!_Ctype_fac.is(ctype<_Elem>::space,
     _Traits::to_char_type(_Meta)))
     break;
   } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
   }

  _Istr.setstate(_State);
  }
 return (_Istr);
 }

__declspec(dllimport) inline basic_istream<wchar_t, char_traits<wchar_t> >&
 __cdecl ws(basic_istream<wchar_t, char_traits<wchar_t> >& _Istr)
 {
 typedef wchar_t _Elem;
 typedef char_traits<_Elem> _Traits;

 if (!_Istr.eof())
  {
  ios_base::iostate _State = ios_base::goodbit;
  const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

  if (_Ok)
   {
   const ctype<_Elem>& _Ctype_fac =
    use_facet< ctype<_Elem> >(_Istr.getloc());

   try {
   for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
    _Meta = _Istr.rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (!_Ctype_fac.is(ctype<_Elem>::space,
     _Traits::to_char_type(_Meta)))
     break;
   } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
   }

  _Istr.setstate(_State);
  }
 return (_Istr);
 }


__declspec(dllimport) inline basic_istream<unsigned short, char_traits<unsigned short> >&
 __cdecl ws(basic_istream<unsigned short, char_traits<unsigned short> >& _Istr)
 {
 typedef unsigned short _Elem;
 typedef char_traits<_Elem> _Traits;

 if (!_Istr.eof())
  {
  ios_base::iostate _State = ios_base::goodbit;
  const basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

  if (_Ok)
   {
   const ctype<_Elem>& _Ctype_fac =
    use_facet< ctype<_Elem> >(_Istr.getloc());

   try {
   for (_Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
    _Meta = _Istr.rdbuf()->snextc())
    if (_Traits::eq_int_type(_Traits::eof(), _Meta))
     {
     _State |= ios_base::eofbit;
     break;
     }
    else if (!_Ctype_fac.is(ctype<_Elem>::space,
     _Traits::to_char_type(_Meta)))
     break;
  } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
   }

  _Istr.setstate(_State);
  }
 return (_Istr);
 }

}


#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\iterator"



#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

template<class _Container>
 class back_insert_iterator
  : public _Outit
 {
public:
 typedef back_insert_iterator<_Container> _Myt;
 typedef _Container container_type;
 typedef typename _Container::value_type _Valty;

 explicit back_insert_iterator(_Container& _Cont)
  : container(::std:: addressof(_Cont))
  {
  }

 _Myt& operator=(const _Valty& _Val)
  {
  container->push_back(_Val);
  return (*this);
  }

 _Myt& operator=(_Valty&& _Val)
  {
  container->push_back(::std:: forward<_Valty>(_Val));
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt operator++(int)
  {
  return (*this);
  }

protected:
 _Container *container;
 };

template<class _Container>
 struct _Is_checked_helper<back_insert_iterator<_Container> >
  : public true_type
 {
 };


template<class _Container> inline
 back_insert_iterator<_Container> back_inserter(_Container& _Cont)
 {
 return (::std:: back_insert_iterator<_Container>(_Cont));
 }


template<class _Container>
 class front_insert_iterator
  : public _Outit
 {
public:
 typedef front_insert_iterator<_Container> _Myt;
 typedef _Container container_type;
 typedef typename _Container::value_type _Valty;

 explicit front_insert_iterator(_Container& _Cont)
  : container(::std:: addressof(_Cont))
  {
  }

 _Myt& operator=(const _Valty& _Val)
  {
  container->push_front(_Val);
  return (*this);
  }

 _Myt& operator=(_Valty&& _Val)
  {
  container->push_front(::std:: forward<_Valty>(_Val));
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt operator++(int)
  {
  return (*this);
  }

protected:
 _Container *container;
 };

template<class _Container>
 struct _Is_checked_helper<front_insert_iterator<_Container> >
  : public true_type
 {
 };


template<class _Container> inline
 front_insert_iterator<_Container> front_inserter(_Container& _Cont)
 {
 return (::std:: front_insert_iterator<_Container>(_Cont));
 }


template<class _Container>
 class insert_iterator
  : public _Outit
 {
public:
 typedef insert_iterator<_Container> _Myt;
 typedef _Container container_type;
 typedef typename _Container::value_type _Valty;

 insert_iterator(_Container& _Cont, typename _Container::iterator _Where)
  : container(::std:: addressof(_Cont)), iter(_Where)
  {
  }

 _Myt& operator=(const _Valty& _Val)
  {
  iter = container->insert(iter, _Val);
  ++iter;
  return (*this);
  }

 _Myt& operator=(_Valty&& _Val)
  {
  iter = container->insert(iter, ::std:: forward<_Valty>(_Val));
  ++iter;
  return (*this);
  }

 _Myt& operator*()
  {
  return (*this);
  }

 _Myt& operator++()
  {
  return (*this);
  }

 _Myt& operator++(int)
  {
  return (*this);
  }

protected:
 _Container *container;
 typename _Container::iterator iter;
 };

template<class _Container>
 struct _Is_checked_helper<insert_iterator<_Container> >
  : public true_type
 {
 };


template<class _Container> inline
 insert_iterator<_Container> inserter(_Container& _Cont,
  typename _Container::iterator _Where)
 {
 return (::std:: insert_iterator<_Container>(_Cont, _Where));
 }



template<class _Ty,
 class _Elem = char,
 class _Traits = char_traits<_Elem>,
 class _Diff = ptrdiff_t>
 class istream_iterator
  : public iterator<input_iterator_tag, _Ty, _Diff,
   const _Ty *, const _Ty&>
 {
 typedef istream_iterator<_Ty, _Elem, _Traits, _Diff> _Myt;
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_istream<_Elem, _Traits> istream_type;

 typedef const _Ty *pointer;

 istream_iterator()
  : _Myistr(0)
  {
  }

 istream_iterator(istream_type& _Istr)
  : _Myistr(&_Istr)
  {
  _Getval();
  }

 const _Ty& operator*() const
  {
  return (_Myval);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {
  _Getval();
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 bool _Equal(const _Myt& _Right) const
  {
  return (_Myistr == _Right._Myistr);
  }

protected:
 void _Getval()
  {
  if (_Myistr != 0 && !(*_Myistr >> _Myval))
   _Myistr = 0;
  }

 istream_type *_Myistr;
 _Ty _Myval;
 };

template<class _Ty,
 class _Elem,
 class _Traits,
 class _Diff>
 struct _Is_checked_helper<istream_iterator<_Ty, _Elem, _Traits, _Diff> >
  : public true_type
 {
 };


template<class _Ty,
 class _Elem,
 class _Traits,
 class _Diff> inline
 bool operator==(
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
 {
 return (_Left._Equal(_Right));
 }

template<class _Ty,
 class _Elem,
 class _Traits,
 class _Diff> inline
 bool operator!=(
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Left,
  const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right)
 {
 return (!(_Left == _Right));
 }



template<class _Ty,
 class _Elem = char,
 class _Traits = char_traits<_Elem> >
 class ostream_iterator
  : public _Outit
 {
public:
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_ostream<_Elem, _Traits> ostream_type;

 ostream_iterator(ostream_type& _Ostr,
  const _Elem *_Delim = 0)
  : _Myostr(&_Ostr), _Mydelim(_Delim)
  {
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator=(const _Ty& _Val)
  {
  *_Myostr << _Val;
  if (_Mydelim != 0)
   *_Myostr << _Mydelim;
  return (*this);
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator*()
  {
  return (*this);
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator++()
  {
  return (*this);
  }

 ostream_iterator<_Ty, _Elem, _Traits>& operator++(int)
  {
  return (*this);
  }

protected:
 const _Elem *_Mydelim;
 ostream_type *_Myostr;
 };

template<class _Ty,
 class _Elem,
 class _Traits>
 struct _Is_checked_helper<ostream_iterator<_Ty, _Elem, _Traits> >
  : public true_type
 {
 };
}

namespace stdext {
using ::std:: iterator_traits;
using ::std:: size_t;


template<class _Iterator>
 class checked_array_iterator
 {
public:
 typedef checked_array_iterator<_Iterator> _Myt;

 typedef typename iterator_traits<_Iterator>::iterator_category
  iterator_category;
 typedef typename iterator_traits<_Iterator>::value_type
  value_type;
 typedef typename iterator_traits<_Iterator>::difference_type
  difference_type;
 typedef typename iterator_traits<_Iterator>::difference_type
  distance_type;
 typedef typename iterator_traits<_Iterator>::pointer
  pointer;
 typedef typename iterator_traits<_Iterator>::reference
  reference;

 checked_array_iterator()
  : _Myarray(), _Mysize(0), _Myindex(0)
  {
  }

 checked_array_iterator(_Iterator _Array, size_t _Size,
  size_t _Index = 0)
  : _Myarray(_Array), _Mysize(_Size), _Myindex(_Index)
  {
  { if (!(_Index <= _Size)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
  }

 _Iterator base() const
  {
  return (_Myarray + _Myindex);
  }

 typedef _Iterator _Unchecked_type;

 _Myt& _Rechecked(_Unchecked_type _Right)
  {
  _Myindex = _Right - _Myarray;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (base());
  }

 reference operator*() const
  {
  { if (!(_Myarray != 0 && _Myindex < _Mysize)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };

  return (_Myarray[_Myindex]);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {
  { if (!(_Myarray != 0 && _Myindex < _Mysize)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };

  ++_Myindex;
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myt& operator--()
  {
  { if (!(_Myarray != 0 && 0 < _Myindex)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };

  --_Myindex;
  return (*this);
  }

 _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myt& operator+=(difference_type _Off)
  {
  { if (!(_Myarray != 0 && _Myindex + _Off <= _Mysize)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };

  _Myindex += _Off;
  return (*this);
  }

 _Myt operator+(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myt& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myt operator-(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myt& _Right) const
  {
  { if (!(_Myarray == _Right._Myarray)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
  return (_Myindex - _Right._Myindex);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myt& _Right) const
  {
  { if (!(_Myarray == _Right._Myarray)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
  return (_Myindex == _Right._Myindex);
  }

 bool operator!=(const _Myt& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myt& _Right) const
  {
  { if (!(_Myarray == _Right._Myarray)) { ((void)0); ::_invalid_parameter_noinfo_noreturn(); } ; };
  return (_Myindex < _Right._Myindex);
  }

 bool operator>(const _Myt& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myt& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myt& _Right) const
  {
  return (!(*this < _Right));
  }

private:
 _Iterator _Myarray;
 size_t _Mysize;
 size_t _Myindex;
 };

template<class _Iterator> inline
 typename checked_array_iterator<_Iterator>::_Unchecked_type
  _Unchecked(checked_array_iterator<_Iterator> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Iterator> inline
 checked_array_iterator<_Iterator>&
  _Rechecked(checked_array_iterator<_Iterator>& _Iter,
   typename checked_array_iterator<_Iterator>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Iterator> inline
 checked_array_iterator<_Iterator> operator+(
  typename checked_array_iterator<_Iterator>::difference_type _Off,
  checked_array_iterator<_Iterator> _Next)
 {
 return (_Next += _Off);
 }

template<class _Iterator> inline
 checked_array_iterator<_Iterator> make_checked_array_iterator(
  _Iterator _Array, size_t _Size, size_t _Index = 0)
 {
 return (checked_array_iterator<_Iterator>(_Array, _Size, _Index));
 }


template<class _Iterator>
 class unchecked_array_iterator
 {
public:
 typedef unchecked_array_iterator<_Iterator> _Myt;

 typedef typename iterator_traits<_Iterator>::iterator_category
  iterator_category;
 typedef typename iterator_traits<_Iterator>::value_type
  value_type;
 typedef typename iterator_traits<_Iterator>::difference_type
  difference_type;
 typedef typename iterator_traits<_Iterator>::difference_type
  distance_type;
 typedef typename iterator_traits<_Iterator>::pointer
  pointer;
 typedef typename iterator_traits<_Iterator>::reference
  reference;

 unchecked_array_iterator()
  : _Myptr()
  {
  }

 explicit unchecked_array_iterator(_Iterator _Ptr)
  : _Myptr(_Ptr)
  {
  }

 _Iterator base() const
  {
  return (_Myptr);
  }

 typedef _Iterator _Unchecked_type;

 _Myt& _Rechecked(_Unchecked_type _Right)
  {
  _Myptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (base());
  }

 reference operator*() const
  {
  return (*_Myptr);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myt& operator++()
  {
  ++_Myptr;
  return (*this);
  }

 _Myt operator++(int)
  {
  _Myt _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myt& operator--()
  {
  --_Myptr;
  return (*this);
  }

 _Myt operator--(int)
  {
  _Myt _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myt& operator+=(difference_type _Off)
  {
  _Myptr += _Off;
  return (*this);
  }

 _Myt operator+(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myt& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myt operator-(difference_type _Off) const
  {
  _Myt _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myt& _Right) const
  {
  return (_Myptr - _Right._Myptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myt& _Right) const
  {
  return (_Myptr == _Right._Myptr);
  }

 bool operator!=(const _Myt& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myt& _Right) const
  {
  return (_Myptr < _Right._Myptr);
  }

 bool operator>(const _Myt& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myt& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myt& _Right) const
  {
  return (!(*this < _Right));
  }

private:
 _Iterator _Myptr;
 };

template<class _Iterator> inline
 typename unchecked_array_iterator<_Iterator>::_Unchecked_type
  _Unchecked(unchecked_array_iterator<_Iterator> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Iterator> inline
 unchecked_array_iterator<_Iterator>&
  _Rechecked(unchecked_array_iterator<_Iterator>& _Iter,
   typename unchecked_array_iterator<_Iterator>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Iterator> inline
 unchecked_array_iterator<_Iterator> operator+(
  typename unchecked_array_iterator<_Iterator>::difference_type _Off,
  unchecked_array_iterator<_Iterator> _Next)
 {
 return (_Next += _Off);
 }

template<class _Iterator> inline
 unchecked_array_iterator<_Iterator> make_unchecked_array_iterator(
  _Iterator _Ptr)
 {
 return (unchecked_array_iterator<_Iterator>(_Ptr));
 }
}


#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string"


#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4189)
#pragma warning(disable: 4172)

namespace std {

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits>&& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 typedef ctype<_Elem> _Ctype;
 typedef basic_istream<_Elem, _Traits> _Myis;
 typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
 typedef typename _Mystr::size_type _Mysizt;

 ios_base::iostate _State = ios_base::goodbit;
 bool _Changed = false;
 const typename _Myis::sentry _Ok(_Istr);

 if (_Ok)
  {
  const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());
  _Str.erase();

  try {
  _Mysizt _Size = 0 < _Istr.width()
   && (_Mysizt)_Istr.width() < _Str.max_size()
    ? (_Mysizt)_Istr.width() : _Str.max_size();
  typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
   if(_Traits::eq_int_type(_Traits::eof(), _Meta))
    {
    _State |= ios_base::eofbit;
    break;
    }
   else if (_Ctype_fac.is(_Ctype::space,
    _Traits::to_char_type(_Meta)))
    break;
   else
    {
    _Str.append(1, _Traits::to_char_type(_Meta));
    _Changed = true;
    }
  } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
  }

 _Istr.width(0);
 if (!_Changed)
  _State |= ios_base::failbit;
 _Istr.setstate(_State);
 return (_Istr);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>&& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str,
  const _Elem _Delim)
 {
 typedef basic_istream<_Elem, _Traits> _Myis;

 ios_base::iostate _State = ios_base::goodbit;
 bool _Changed = false;
 const typename _Myis::sentry _Ok(_Istr, true);

 if (_Ok)
  {
  try {
  _Str.erase();
  const typename _Traits::int_type _Metadelim =
   _Traits::to_int_type(_Delim);
  typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  for (; ; _Meta = _Istr.rdbuf()->snextc())
   if (_Traits::eq_int_type(_Traits::eof(), _Meta))
    {
    _State |= ios_base::eofbit;
    break;
    }
   else if (_Traits::eq_int_type(_Meta, _Metadelim))
    {
    _Changed = true;
    _Istr.rdbuf()->sbumpc();
    break;
    }
   else if (_Str.max_size() <= _Str.size())
    {
    _State |= ios_base::failbit;
    break;
    }
   else
    {
    _Str += _Traits::to_char_type(_Meta);
    _Changed = true;
    }
  } catch (...) { (_Istr).setstate(ios_base::badbit, true); }
  }

 if (!_Changed)
  _State |= ios_base::failbit;
 _Istr.setstate(_State);
 return (_Istr);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>&& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return (getline(_Istr, _Str, _Istr.widen('\n')));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& operator>>(
  basic_istream<_Elem, _Traits>& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return (::std:: move(_Istr) >> _Str);
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str,
  const _Elem _Delim)
 {
 return (getline(::std:: move(_Istr), _Str, _Delim));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_istream<_Elem, _Traits>& getline(
  basic_istream<_Elem, _Traits>& _Istr,
  basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 return (getline(::std:: move(_Istr), _Str, _Istr.widen('\n')));
 }

template<class _Elem,
 class _Traits,
 class _Alloc> inline
 basic_ostream<_Elem, _Traits>& operator<<(
  basic_ostream<_Elem, _Traits>& _Ostr,
  const basic_string<_Elem, _Traits, _Alloc>& _Str)
 {
 typedef basic_ostream<_Elem, _Traits> _Myos;
 typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
 typedef typename _Mystr::size_type _Mysizt;

 ios_base::iostate _State = ios_base::goodbit;
 _Mysizt _Size = _Str.size();
 _Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
  ? 0 : (_Mysizt)_Ostr.width() - _Size;
 const typename _Myos::sentry _Ok(_Ostr);

 if (!_Ok)
  _State |= ios_base::badbit;
 else
  {
 try {
  if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }

  if (_State == ios_base::goodbit
   && _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)
    != (streamsize)_Size)
    _State |= ios_base::badbit;
  else
   for (; 0 < _Pad; --_Pad)
    if (_Traits::eq_int_type(_Traits::eof(),
     _Ostr.rdbuf()->sputc(_Ostr.fill())))
     {
     _State |= ios_base::badbit;
     break;
     }
  _Ostr.width(0);
  } catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
  }

 _Ostr.setstate(_State);
 return (_Ostr);
 }
#line 226 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string"
inline int stoi(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (*_errno()) = 0;
 long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoi argument");
 if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) != 2147483647 < _Ans)
  _Xout_of_range("stoi argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return ((int)_Ans);
 }

inline long stol(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (*_errno()) = 0;
 long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stol argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stol argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline unsigned long stoul(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (*_errno()) = 0;
 unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoul argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stoul argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline _Longlong stoll(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 char *_Eptr;
 (*_errno()) = 0;
 _Longlong _Ans = :: _strtoi64(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoll argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stoll argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline _ULonglong stoull(const string& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const char *_Ptr = _Str.c_str();
 (*_errno()) = 0;
 char *_Eptr;
 _ULonglong _Ans = :: _strtoui64(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoull argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stoull argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline float stof(const string& _Str, size_t *_Idx = 0)
 {
 const char *_Ptr = _Str.c_str();
 (*_errno()) = 0;
 char *_Eptr;
 float _Ans = (float):: strtod(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stof argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stof argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline double stod(const string& _Str, size_t *_Idx = 0)
 {
 const char *_Ptr = _Str.c_str();
 (*_errno()) = 0;
 char *_Eptr;
 double _Ans = :: strtod(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stod argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stod argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline long double stold(const string& _Str, size_t *_Idx = 0)
 {
 const char *_Ptr = _Str.c_str();
 (*_errno()) = 0;
 char *_Eptr;
 long double _Ans = :: strtod(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stold argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stold argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }


inline int stoi(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (*_errno()) = 0;
 long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoi argument");
 if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) != 2147483647 < _Ans)
  _Xout_of_range("stoi argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return ((int)_Ans);
 }

inline long stol(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (*_errno()) = 0;
 long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stol argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stol argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (*_errno()) = 0;
 unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoul argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stoul argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline _Longlong stoll(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 wchar_t *_Eptr;
 (*_errno()) = 0;
 _Longlong _Ans = :: _wcstoi64(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoll argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stoll argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline _ULonglong stoull(const wstring& _Str, size_t *_Idx = 0,
 int _Base = 10)
 {
 const wchar_t *_Ptr = _Str.c_str();
 (*_errno()) = 0;
 wchar_t *_Eptr;
 _ULonglong _Ans = :: _wcstoui64(_Ptr, &_Eptr, _Base);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stoull argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stoull argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline float stof(const wstring& _Str, size_t *_Idx = 0)
 {
 const wchar_t *_Ptr = _Str.c_str();
 (*_errno()) = 0;
 wchar_t *_Eptr;
 float _Ans = (float):: wcstod(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stof argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stof argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline double stod(const wstring& _Str, size_t *_Idx = 0)
 {
 const wchar_t *_Ptr = _Str.c_str();
 (*_errno()) = 0;
 wchar_t *_Eptr;
 double _Ans = :: wcstod(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stod argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stod argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }

inline long double stold(const wstring& _Str, size_t *_Idx = 0)
 {
 const wchar_t *_Ptr = _Str.c_str();
 (*_errno()) = 0;
 wchar_t *_Eptr;
 long double _Ans = :: wcstod(_Ptr, &_Eptr);

 if (_Ptr == _Eptr)
  _Xinvalid_argument("invalid stold argument");
 if ((*_errno()) == 34)
  _Xout_of_range("stold argument out of range");
 if (_Idx != 0)
  *_Idx = (size_t)(_Eptr - _Ptr);
 return (_Ans);
 }
#line 500 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string"
inline string to_string(int _Val)
 {
 char _Buf[2 * 32];

 :: sprintf_s(_Buf, sizeof (_Buf), "%d", _Val);
 return (string(_Buf));
 }

inline string to_string(unsigned int _Val)
 {
 char _Buf[2 * 32];

 :: sprintf_s(_Buf, sizeof (_Buf), "%u", _Val);
 return (string(_Buf));
 }

inline string to_string(long _Val)
 {
 char _Buf[2 * 32];

 :: sprintf_s(_Buf, sizeof (_Buf), "%ld", _Val);
 return (string(_Buf));
 }

inline string to_string(unsigned long _Val)
 {
 char _Buf[2 * 32];

 :: sprintf_s(_Buf, sizeof (_Buf), "%lu", _Val);
 return (string(_Buf));
 }

inline string to_string(_Longlong _Val)
 {
 char _Buf[2 * 32];

 :: sprintf_s(_Buf, sizeof (_Buf), "%I64" "d", _Val);
 return (string(_Buf));
 }

inline string to_string(_ULonglong _Val)
 {
 char _Buf[2 * 32];

 :: sprintf_s(_Buf, sizeof (_Buf), "%I64" "u", _Val);
 return (string(_Buf));
 }

inline string to_string(long double _Val)
 {
 typedef back_insert_iterator<string> _Iter;
 typedef num_put<char, _Iter> _Nput;
 const _Nput& _Nput_fac = use_facet<_Nput>(locale());
 ostream _Ios((streambuf *)0);
 string _Str;

 _Ios.setf(ios_base::fixed);
 _Nput_fac.put(_Iter(_Str), _Ios, ' ', _Val);
 return (_Str);
 }

inline string to_string(double _Val)
 {
 return (to_string((long double)_Val));
 }

inline string to_string(float _Val)
 {
 return (to_string((long double)_Val));
 }
#line 578 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\string"
inline wstring to_wstring(int _Val)
 {
 wchar_t _Buf[2 * 32];

 :: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%d", _Val);
 return (wstring(_Buf));
 }

inline wstring to_wstring(unsigned int _Val)
 {
 wchar_t _Buf[2 * 32];

 :: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%u", _Val);
 return (wstring(_Buf));
 }

inline wstring to_wstring(long _Val)
 {
 wchar_t _Buf[2 * 32];

 :: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%ld", _Val);
 return (wstring(_Buf));
 }

inline wstring to_wstring(unsigned long _Val)
 {
 wchar_t _Buf[2 * 32];

 :: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%lu", _Val);
 return (wstring(_Buf));
 }

inline wstring to_wstring(_Longlong _Val)
 {
 wchar_t _Buf[2 * 32];

 :: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%I64" L"d", _Val);
 return (wstring(_Buf));
 }

inline wstring to_wstring(_ULonglong _Val)
 {
 wchar_t _Buf[2 * 32];

 :: swprintf_s(_Buf, sizeof (_Buf) / sizeof (wchar_t), L"%I64" L"u", _Val);
 return (wstring(_Buf));
 }

inline wstring to_wstring(long double _Val)
 {
 typedef back_insert_iterator<wstring> _Iter;
 typedef num_put<wchar_t, _Iter> _Nput;
 const _Nput& _Nput_fac = use_facet<_Nput>(locale());
 ostream _Ios((streambuf *)0);
 wstring _Str;

 _Ios.setf(ios_base::fixed);
 _Nput_fac.put(_Iter(_Str), _Ios, L' ', _Val);
 return (_Str);
 }

inline wstring to_wstring(double _Val)
 {
 return (to_wstring((long double)_Val));
 }

inline wstring to_wstring(float _Val)
 {
 return (to_wstring((long double)_Val));
 }
}


#pragma warning(pop)
#pragma pack(pop)
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
#line 76 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
class QCharRef;
class QRegExp;
class QRegularExpression;
class QRegularExpressionMatch;
class QString;
class QStringList;
class QTextCodec;
class QStringRef;
template <typename T> class QVector;

class QLatin1String
{
public:
                     inline explicit QLatin1String(const char *s) : m_size(s ? int(strlen(s)) : 0), m_data(s) {}
                     inline explicit QLatin1String(const char *s, int sz) : m_size(sz), m_data(s) {}
    inline explicit QLatin1String(const QByteArray &s) : m_size(int(qstrnlen(s.constData(), s.size()))), m_data(s.constData()) {}

    inline const char *latin1() const { return m_data; }
    inline int size() const { return m_size; }
    inline const char *data() const { return m_data; }

    inline bool operator==(const QString &s) const;
    inline bool operator!=(const QString &s) const;
    inline bool operator>(const QString &s) const;
    inline bool operator<(const QString &s) const;
    inline bool operator>=(const QString &s) const;
    inline bool operator<=(const QString &s) const;


    inline bool operator==(const char *s) const;
    inline bool operator!=(const char *s) const;
    inline bool operator<(const char *s) const;
    inline bool operator>(const char *s) const;
    inline bool operator<=(const char *s) const;
    inline bool operator>=(const char *s) const;

    inline bool operator==(const QByteArray &s) const;
    inline bool operator!=(const QByteArray &s) const;
    inline bool operator<(const QByteArray &s) const;
    inline bool operator>(const QByteArray &s) const;
    inline bool operator<=(const QByteArray &s) const;
    inline bool operator>=(const QByteArray &s) const;


private:
    int m_size;
    const char *m_data;
};
template<> class QTypeInfo<QLatin1String > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QLatin1String)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QLatin1String >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QLatin1String) }; static inline const char *name() { return "QLatin1String"; } };


typedef QLatin1String QLatin1Literal;


typedef QTypedArrayData<ushort> QStringData;
#line 147 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
typedef wchar_t qunicodechar;
#line 156 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
static_assert(bool(sizeof(qunicodechar) == 2), "qunicodechar must typedef an integral type of size 2");
#line 194 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
template <int N>
struct QStaticStringData
{
    QArrayData str;
    qunicodechar data[N + 1];

    QStringData *data_ptr() const
    {
        ((!(str.ref.isStatic())) ? qt_assert("str.ref.isStatic()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h",202) : qt_noop());
        return const_cast<QStringData *>(static_cast<const QStringData*>(&str));
    }
};

struct QStringDataPtr
{
    QStringData *ptr;
};

class __declspec(dllimport) QString
{
public:
    typedef QStringData Data;

    inline QString();
    explicit QString(const QChar *unicode, int size = -1);
    QString(QChar c);
    QString(int size, QChar c);
    inline QString(QLatin1String latin1);
    inline QString(const QString &);
    inline ~QString();
    QString &operator=(QChar c);
    QString &operator=(const QString &);
    inline QString &operator=(QLatin1String latin1);

    inline QString(QString && other) : d(other.d) { other.d = Data::sharedNull(); }
    inline QString &operator=(QString &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QString &other) { qSwap(d, other.d); }
    inline int size() const { return d->size; }
    inline int count() const { return d->size; }
    inline int length() const;
    inline bool isEmpty() const;
    void resize(int size);

    QString &fill(QChar c, int size = -1);
    void truncate(int pos);
    void chop(int n);

    int capacity() const;
    inline void reserve(int size);
    inline void squeeze();

    inline const QChar *unicode() const;
    inline QChar *data();
    inline const QChar *data() const;
    inline const QChar *constData() const;

    inline void detach();
    inline bool isDetached() const;
    inline bool isSharedWith(const QString &other) const { return d == other.d; }
    void clear();

    inline const QChar at(int i) const;
    const QChar operator[](int i) const;
    QCharRef operator[](int i);
    const QChar operator[](uint i) const;
    QCharRef operator[](uint i);

    QString arg(qlonglong a, int fieldwidth=0, int base=10,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(qulonglong a, int fieldwidth=0, int base=10,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(long a, int fieldwidth=0, int base=10,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(ulong a, int fieldwidth=0, int base=10,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(int a, int fieldWidth = 0, int base = 10,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(uint a, int fieldWidth = 0, int base = 10,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(short a, int fieldWidth = 0, int base = 10,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(ushort a, int fieldWidth = 0, int base = 10,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(double a, int fieldWidth = 0, char fmt = 'g', int prec = -1,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(char a, int fieldWidth = 0,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(QChar a, int fieldWidth = 0,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(const QString &a, int fieldWidth = 0,
                QChar fillChar = QLatin1Char(' ')) const ;
    QString arg(const QString &a1, const QString &a2) const ;
    QString arg(const QString &a1, const QString &a2, const QString &a3) const ;
    QString arg(const QString &a1, const QString &a2, const QString &a3,
                const QString &a4) const ;
    QString arg(const QString &a1, const QString &a2, const QString &a3,
                const QString &a4, const QString &a5) const ;
    QString arg(const QString &a1, const QString &a2, const QString &a3,
                const QString &a4, const QString &a5, const QString &a6) const ;
    QString arg(const QString &a1, const QString &a2, const QString &a3,
                const QString &a4, const QString &a5, const QString &a6,
                const QString &a7) const ;
    QString arg(const QString &a1, const QString &a2, const QString &a3,
                const QString &a4, const QString &a5, const QString &a6,
                const QString &a7, const QString &a8) const ;
    QString arg(const QString &a1, const QString &a2, const QString &a3,
                const QString &a4, const QString &a5, const QString &a6,
                const QString &a7, const QString &a8, const QString &a9) const ;

    QString &vsprintf(const char *format, va_list ap) ;
    QString &sprintf(const char *format, ...) ;

    int indexOf(QChar c, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int indexOf(const QString &s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int indexOf(QLatin1String s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int indexOf(const QStringRef &s, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(QChar c, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(const QString &s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(QLatin1String s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(const QStringRef &s, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    inline bool contains(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    inline bool contains(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    inline bool contains(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    inline bool contains(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int count(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int count(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int count(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;


    int indexOf(const QRegExp &, int from = 0) const;
    int lastIndexOf(const QRegExp &, int from = -1) const;
    inline bool contains(const QRegExp &rx) const { return indexOf(rx) != -1; }
    int count(const QRegExp &) const;

    int indexOf(QRegExp &, int from = 0) const;
    int lastIndexOf(QRegExp &, int from = -1) const;
    inline bool contains(QRegExp &rx) const { return indexOf(rx) != -1; }



    int indexOf(const QRegularExpression &re, int from = 0) const;
    int lastIndexOf(const QRegularExpression &re, int from = -1) const;
    bool contains(const QRegularExpression &re) const;
    bool contains(const QRegularExpression &re, QRegularExpressionMatch *match) const;
    int count(const QRegularExpression &re) const;


    enum SectionFlag {
        SectionDefault = 0x00,
        SectionSkipEmpty = 0x01,
        SectionIncludeLeadingSep = 0x02,
        SectionIncludeTrailingSep = 0x04,
        SectionCaseInsensitiveSeps = 0x08
    };
    typedef QFlags<SectionFlag> SectionFlags;

    QString section(QChar sep, int start, int end = -1, SectionFlags flags = SectionDefault) const;
    QString section(const QString &in_sep, int start, int end = -1, SectionFlags flags = SectionDefault) const;

    QString section(const QRegExp &reg, int start, int end = -1, SectionFlags flags = SectionDefault) const;


    QString section(const QRegularExpression &re, int start, int end = -1, SectionFlags flags = SectionDefault) const;

    QString left(int n) const ;
    QString right(int n) const ;
    QString mid(int position, int n = -1) const ;
    QStringRef leftRef(int n) const ;
    QStringRef rightRef(int n) const ;
    QStringRef midRef(int position, int n = -1) const ;

    bool startsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool startsWith(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool startsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool startsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    QString leftJustified(int width, QChar fill = QLatin1Char(' '), bool trunc = false) const ;
    QString rightJustified(int width, QChar fill = QLatin1Char(' '), bool trunc = false) const ;

    QString toLower() const ;
    QString toUpper() const ;
    QString toCaseFolded() const ;

    QString trimmed() const ;
    QString simplified() const ;
    QString toHtmlEscaped() const ;

    QString &insert(int i, QChar c);
    QString &insert(int i, const QChar *uc, int len);
    inline QString &insert(int i, const QString &s) { return insert(i, s.constData(), s.length()); }
    QString &insert(int i, QLatin1String s);
    QString &append(QChar c);
    QString &append(const QChar *uc, int len);
    QString &append(const QString &s);
    QString &append(const QStringRef &s);
    QString &append(QLatin1String s);
    inline QString &prepend(QChar c) { return insert(0, c); }
    inline QString &prepend(const QString &s) { return insert(0, s); }
    inline QString &prepend(QLatin1String s) { return insert(0, s); }

    inline QString &operator+=(QChar c) {
        if (d->ref.isShared() || uint(d->size) + 2u > d->alloc)
            reallocData(uint(d->size) + 2u, true);
        d->data()[d->size++] = c.unicode();
        d->data()[d->size] = '\0';
        return *this;
    }

    inline QString &operator+=(QChar::SpecialCharacter c) { return append(QChar(c)); }
    inline QString &operator+=(const QString &s) { return append(s); }
    inline QString &operator+=(const QStringRef &s) { return append(s); }
    inline QString &operator+=(QLatin1String s) { return append(s); }

    QString &remove(int i, int len);
    QString &remove(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &remove(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(int i, int len, QChar after);
    QString &replace(int i, int len, const QChar *s, int slen);
    QString &replace(int i, int len, const QString &after);
    QString &replace(QChar before, QChar after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(const QChar *before, int blen, const QChar *after, int alen, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(QLatin1String before, QLatin1String after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(QLatin1String before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(const QString &before, QLatin1String after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(const QString &before, const QString &after,
                     Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(QChar c, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QString &replace(QChar c, QLatin1String after, Qt::CaseSensitivity cs = Qt::CaseSensitive);

    QString &replace(const QRegExp &rx, const QString &after);
    inline QString &remove(const QRegExp &rx)
    { return replace(rx, QString()); }


    QString &replace(const QRegularExpression &re, const QString &after);
    inline QString &remove(const QRegularExpression &re)
    { return replace(re, QString()); }


    enum SplitBehavior { KeepEmptyParts, SkipEmptyParts };

    QStringList split(const QString &sep, SplitBehavior behavior = KeepEmptyParts,
                      Qt::CaseSensitivity cs = Qt::CaseSensitive) const ;
    QStringList split(QChar sep, SplitBehavior behavior = KeepEmptyParts,
                      Qt::CaseSensitivity cs = Qt::CaseSensitive) const ;

    QStringList split(const QRegExp &sep, SplitBehavior behavior = KeepEmptyParts) const ;


    QStringList split(const QRegularExpression &sep, SplitBehavior behavior = KeepEmptyParts) const ;

    enum NormalizationForm {
        NormalizationForm_D,
        NormalizationForm_C,
        NormalizationForm_KD,
        NormalizationForm_KC
    };
    QString normalized(NormalizationForm mode, QChar::UnicodeVersion version = QChar::Unicode_Unassigned) const ;

    QString repeated(int times) const;

    const ushort *utf16() const;
#line 478 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
    QByteArray toLatin1() const ;
    QByteArray toUtf8() const ;
    QByteArray toLocal8Bit() const ;

    QVector<uint> toUcs4() const ;


    static inline QString fromLatin1(const char *str, int size = -1)
    {
        QStringDataPtr dataPtr = { fromLatin1_helper(str, (str && size == -1) ? int(strlen(str)) : size) };
        return QString(dataPtr);
    }
    static inline QString fromUtf8(const char *str, int size = -1)
    {
        return fromUtf8_helper(str, (str && size == -1) ? int(strlen(str)) : size);
    }
    static inline QString fromLocal8Bit(const char *str, int size = -1)
    {
        return fromLocal8Bit_helper(str, (str && size == -1) ? int(strlen(str)) : size);
    }
    static inline QString fromLatin1(const QByteArray &str)
    { return fromLatin1(str.data(), qstrnlen(str.constData(), str.size())); }
    static inline QString fromUtf8(const QByteArray &str)
    { return fromUtf8(str.data(), qstrnlen(str.constData(), str.size())); }
    static inline QString fromLocal8Bit(const QByteArray &str)
    { return fromLocal8Bit(str.data(), qstrnlen(str.constData(), str.size())); }
    static QString fromUtf16(const ushort *, int size = -1);
    static QString fromUcs4(const uint *, int size = -1);
    static QString fromRawData(const QChar *, int size);
#line 524 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
    inline int toWCharArray(wchar_t *array) const;
    static inline QString fromWCharArray(const wchar_t *string, int size = -1) ;

    QString &setRawData(const QChar *unicode, int size);
    QString &setUnicode(const QChar *unicode, int size);
    inline QString &setUtf16(const ushort *utf16, int size);

    int compare(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int compare(QLatin1String other, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    static inline int compare(const QString &s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
    { return s1.compare(s2, cs); }

    static inline int compare(const QString &s1, QLatin1String s2,
                              Qt::CaseSensitivity cs = Qt::CaseSensitive)
    { return s1.compare(s2, cs); }
    static inline int compare(QLatin1String s1, const QString &s2,
                              Qt::CaseSensitivity cs = Qt::CaseSensitive)
    { return -s2.compare(s1, cs); }

    int compare(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    static int compare(const QString &s1, const QStringRef &s2,
                       Qt::CaseSensitivity = Qt::CaseSensitive);

    int localeAwareCompare(const QString& s) const;
    static int localeAwareCompare(const QString& s1, const QString& s2)
    { return s1.localeAwareCompare(s2); }

    int localeAwareCompare(const QStringRef &s) const;
    static int localeAwareCompare(const QString& s1, const QStringRef& s2);


    short toShort(bool *ok=0, int base=10) const;
    ushort toUShort(bool *ok=0, int base=10) const;
    int toInt(bool *ok=0, int base=10) const;
    uint toUInt(bool *ok=0, int base=10) const;
    long toLong(bool *ok=0, int base=10) const;
    ulong toULong(bool *ok=0, int base=10) const;
    qlonglong toLongLong(bool *ok=0, int base=10) const;
    qulonglong toULongLong(bool *ok=0, int base=10) const;
    float toFloat(bool *ok=0) const;
    double toDouble(bool *ok=0) const;

    QString &setNum(short, int base=10);
    QString &setNum(ushort, int base=10);
    QString &setNum(int, int base=10);
    QString &setNum(uint, int base=10);
    QString &setNum(long, int base=10);
    QString &setNum(ulong, int base=10);
    QString &setNum(qlonglong, int base=10);
    QString &setNum(qulonglong, int base=10);
    QString &setNum(float, char f='g', int prec=6);
    QString &setNum(double, char f='g', int prec=6);

    static QString number(int, int base=10);
    static QString number(uint, int base=10);
    static QString number(long, int base=10);
    static QString number(ulong, int base=10);
    static QString number(qlonglong, int base=10);
    static QString number(qulonglong, int base=10);
    static QString number(double, char f='g', int prec=6);

    friend __declspec(dllimport) bool operator==(const QString &s1, const QString &s2);
    friend __declspec(dllimport) bool operator<(const QString &s1, const QString &s2);
    friend inline bool operator>(const QString &s1, const QString &s2) { return s2 < s1; }
    friend inline bool operator!=(const QString &s1, const QString &s2) { return !(s1 == s2); }
    friend inline bool operator<=(const QString &s1, const QString &s2) { return !(s1 > s2); }
    friend inline bool operator>=(const QString &s1, const QString &s2) { return !(s1 < s2); }

    bool operator==(QLatin1String s) const;
    bool operator<(QLatin1String s) const;
    bool operator>(QLatin1String s) const;
    inline bool operator!=(QLatin1String s) const { return !operator==(s); }
    inline bool operator<=(QLatin1String s) const { return !operator>(s); }
    inline bool operator>=(QLatin1String s) const { return !operator<(s); }



    inline QString(const char *ch)
        : d(fromAscii_helper(ch, ch ? int(strlen(ch)) : -1))
    {}
    inline QString(const QByteArray &a)
        : d(fromAscii_helper(a.constData(), qstrnlen(a.constData(), a.size())))
    {}
    inline QString &operator=(const char *ch)
    { return (*this = fromUtf8(ch)); }
    inline QString &operator=(const QByteArray &a)
    { return (*this = fromUtf8(a)); }
    inline QString &operator=(char c)
    { return (*this = QChar::fromLatin1(c)); }


    inline QString &prepend(const char *s)
    { return prepend(QString::fromUtf8(s)); }
    inline QString &prepend(const QByteArray &s)
    { return prepend(QString::fromUtf8(s)); }
    inline QString &append(const char *s)
    { return append(QString::fromUtf8(s)); }
    inline QString &append(const QByteArray &s)
    { return append(QString::fromUtf8(s)); }
    inline QString &operator+=(const char *s)
    { return append(QString::fromUtf8(s)); }
    inline QString &operator+=(const QByteArray &s)
    { return append(QString::fromUtf8(s)); }
    inline QString &operator+=(char c)
    { return append(QChar::fromLatin1(c)); }

    inline bool operator==(const char *s) const;
    inline bool operator!=(const char *s) const;
    inline bool operator<(const char *s) const;
    inline bool operator<=(const char *s) const;
    inline bool operator>(const char *s) const;
    inline bool operator>=(const char *s) const;

    inline bool operator==(const QByteArray &s) const;
    inline bool operator!=(const QByteArray &s) const;
    inline bool operator<(const QByteArray &s) const;
    inline bool operator>(const QByteArray &s) const;
    inline bool operator<=(const QByteArray &s) const;
    inline bool operator>=(const QByteArray &s) const;

    friend inline bool operator==(const char *s1, const QString &s2);
    friend inline bool operator!=(const char *s1, const QString &s2);
    friend inline bool operator<(const char *s1, const QString &s2);
    friend inline bool operator>(const char *s1, const QString &s2);
    friend inline bool operator<=(const char *s1, const QString &s2);
    friend inline bool operator>=(const char *s1, const QString &s2);

    friend inline bool operator==(const char *s1, const QStringRef &s2);
    friend inline bool operator!=(const char *s1, const QStringRef &s2);
    friend inline bool operator<(const char *s1, const QStringRef &s2);
    friend inline bool operator>(const char *s1, const QStringRef &s2);
    friend inline bool operator<=(const char *s1, const QStringRef &s2);
    friend inline bool operator>=(const char *s1, const QStringRef &s2);


    typedef QChar *iterator;
    typedef const QChar *const_iterator;
    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    iterator begin();
    const_iterator begin() const;
    const_iterator cbegin() const;
    const_iterator constBegin() const;
    iterator end();
    const_iterator end() const;
    const_iterator cend() const;
    const_iterator constEnd() const;


    typedef int size_type;
    typedef qptrdiff difference_type;
    typedef const QChar & const_reference;
    typedef QChar & reference;
    typedef QChar *pointer;
    typedef const QChar *const_pointer;
    typedef QChar value_type;
    inline void push_back(QChar c) { append(c); }
    inline void push_back(const QString &s) { append(s); }
    inline void push_front(QChar c) { prepend(c); }
    inline void push_front(const QString &s) { prepend(s); }

    static inline QString fromStdString(const std::string &s);
    inline std::string toStdString() const;
    static inline QString fromStdWString(const std::wstring &s);
    inline std::wstring toStdWString() const;
#line 700 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
    struct Null { };
    static const Null null;
    inline QString(const Null &): d(Data::sharedNull()) {}
    inline QString &operator=(const Null &) { *this = QString(); return *this; }
    inline bool isNull() const { return d == Data::sharedNull(); }


    bool isSimpleText() const;
    bool isRightToLeft() const;

    QString(int size, Qt::Initialization);
                     inline QString(QStringDataPtr dd) : d(dd.ptr) {}

private:
#line 723 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h"
    Data *d;

    void reallocData(uint alloc, bool grow = false);
    void expand(int i);
    void updateProperties() const;
    QString multiArg(int numArgs, const QString **args) const;
    static int compare_helper(const QChar *data1, int length1,
                              const QChar *data2, int length2,
                              Qt::CaseSensitivity cs = Qt::CaseSensitive);
    static int compare_helper(const QChar *data1, int length1,
                              const char *data2, int length2,
                              Qt::CaseSensitivity cs = Qt::CaseSensitive);
    static int compare_helper(const QChar *data1, int length1,
                              QLatin1String s2,
                              Qt::CaseSensitivity cs = Qt::CaseSensitive);
    static int localeAwareCompare_helper(const QChar *data1, int length1,
                                         const QChar *data2, int length2);
    static Data *fromLatin1_helper(const char *str, int size = -1);
    static Data *fromAscii_helper(const char *str, int size = -1);
    static QString fromUtf8_helper(const char *str, int size);
    static QString fromLocal8Bit_helper(const char *, int size);
    static QByteArray toLatin1_helper(const QString &);
    static QByteArray toLatin1_helper(const QChar *data, int size);
    static QByteArray toLatin1_helper_inplace(QString &);
    static QByteArray toUtf8_helper(const QString &);
    static QByteArray toLocal8Bit_helper(const QChar *data, int size);
    static int toUcs4_helper(const ushort *uc, int length, uint *out);
    static qlonglong toIntegral_helper(const QChar *data, int len, bool *ok, int base);
    static qulonglong toIntegral_helper(const QChar *data, uint len, bool *ok, int base);
    void replace_helper(uint *indices, int nIndices, int blen, const QChar *after, int alen);
    friend class QCharRef;
    friend class QTextCodec;
    friend class QStringRef;
    friend class QByteArray;
    friend class QCollator;
    friend struct QAbstractConcatenable;

    template <typename T> static
    T toIntegral_helper(const QChar *data, int len, bool *ok, int base)
    {

        const bool isUnsigned = T(0) < T(-1);
        typedef typename QtPrivate::QConditional<isUnsigned, qulonglong, qlonglong>::Type Int64;
        typedef typename QtPrivate::QConditional<isUnsigned, uint, int>::Type Int32;


        Int64 val = toIntegral_helper(data, Int32(len), ok, base);
        if (T(val) != val) {
            if (ok)
                *ok = false;
            val = 0;
        }
        return T(val);
    }

public:
    typedef Data * DataPtr;
    inline DataPtr &data_ptr() { return d; }
};

inline QString::QString(QLatin1String aLatin1) : d(fromLatin1_helper(aLatin1.latin1(), aLatin1.size()))
{ }
inline int QString::length() const
{ return d->size; }
inline const QChar QString::at(int i) const
{ ((!(uint(i) < uint(size()))) ? qt_assert("uint(i) < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h",788) : qt_noop()); return d->data()[i]; }
inline const QChar QString::operator[](int i) const
{ ((!(uint(i) < uint(size()))) ? qt_assert("uint(i) < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h",790) : qt_noop()); return d->data()[i]; }
inline const QChar QString::operator[](uint i) const
{ ((!(i < uint(size()))) ? qt_assert("i < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h",792) : qt_noop()); return d->data()[i]; }
inline bool QString::isEmpty() const
{ return d->size == 0; }
inline const QChar *QString::unicode() const
{ return reinterpret_cast<const QChar*>(d->data()); }
inline const QChar *QString::data() const
{ return reinterpret_cast<const QChar*>(d->data()); }
inline QChar *QString::data()
{ detach(); return reinterpret_cast<QChar*>(d->data()); }
inline const QChar *QString::constData() const
{ return reinterpret_cast<const QChar*>(d->data()); }
inline void QString::detach()
{ if (d->ref.isShared() || (d->offset != sizeof(QStringData))) reallocData(uint(d->size) + 1u); }
inline bool QString::isDetached() const
{ return !d->ref.isShared(); }
inline QString &QString::operator=(QLatin1String s)
{
    *this = fromLatin1(s.latin1(), s.size());
    return *this;
}
inline void QString::clear()
{ if (!isNull()) *this = QString(); }
inline QString::QString(const QString &other) : d(other.d)
{ ((!(&other != this)) ? qt_assert("&other != this","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h",815) : qt_noop()); d->ref.ref(); }
inline int QString::capacity() const
{ return d->alloc ? d->alloc - 1 : 0; }
inline QString &QString::setNum(short n, int base)
{ return setNum(qlonglong(n), base); }
inline QString &QString::setNum(ushort n, int base)
{ return setNum(qulonglong(n), base); }
inline QString &QString::setNum(int n, int base)
{ return setNum(qlonglong(n), base); }
inline QString &QString::setNum(uint n, int base)
{ return setNum(qulonglong(n), base); }
inline QString &QString::setNum(long n, int base)
{ return setNum(qlonglong(n), base); }
inline QString &QString::setNum(ulong n, int base)
{ return setNum(qulonglong(n), base); }
inline QString &QString::setNum(float n, char f, int prec)
{ return setNum(double(n),f,prec); }
inline QString QString::arg(int a, int fieldWidth, int base, QChar fillChar) const
{ return arg(qlonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(uint a, int fieldWidth, int base, QChar fillChar) const
{ return arg(qulonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(long a, int fieldWidth, int base, QChar fillChar) const
{ return arg(qlonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(ulong a, int fieldWidth, int base, QChar fillChar) const
{ return arg(qulonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(short a, int fieldWidth, int base, QChar fillChar) const
{ return arg(qlonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(ushort a, int fieldWidth, int base, QChar fillChar) const
{ return arg(qulonglong(a), fieldWidth, base, fillChar); }
inline QString QString::arg(const QString &a1, const QString &a2) const
{ const QString *args[2] = { &a1, &a2 }; return multiArg(2, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3) const
{ const QString *args[3] = { &a1, &a2, &a3 }; return multiArg(3, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
                            const QString &a4) const
{ const QString *args[4] = { &a1, &a2, &a3, &a4 }; return multiArg(4, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
                            const QString &a4, const QString &a5) const
{ const QString *args[5] = { &a1, &a2, &a3, &a4, &a5 }; return multiArg(5, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
                            const QString &a4, const QString &a5, const QString &a6) const
{ const QString *args[6] = { &a1, &a2, &a3, &a4, &a5, &a6 }; return multiArg(6, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
                            const QString &a4, const QString &a5, const QString &a6,
                            const QString &a7) const
{ const QString *args[7] = { &a1, &a2, &a3, &a4, &a5, &a6, &a7 }; return multiArg(7, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
                            const QString &a4, const QString &a5, const QString &a6,
                            const QString &a7, const QString &a8) const
{ const QString *args[8] = { &a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8 }; return multiArg(8, args); }
inline QString QString::arg(const QString &a1, const QString &a2, const QString &a3,
                            const QString &a4, const QString &a5, const QString &a6,
                            const QString &a7, const QString &a8, const QString &a9) const
{ const QString *args[9] = { &a1, &a2, &a3, &a4, &a5, &a6, &a7, &a8, &a9 }; return multiArg(9, args); }

inline QString QString::section(QChar asep, int astart, int aend, SectionFlags aflags) const
{ return section(QString(asep), astart, aend, aflags); }



#pragma warning(push)
#pragma warning(disable: 4127)


inline int QString::toWCharArray(wchar_t *array) const
{
    if (sizeof(wchar_t) == sizeof(QChar)) {
        memcpy(array, d->data(), sizeof(QChar) * size());
        return size();
    }
    return toUcs4_helper(d->data(), size(), reinterpret_cast<uint *>(array));
}


#pragma warning(pop)


inline QString QString::fromWCharArray(const wchar_t *string, int size)
{
    return sizeof(wchar_t) == sizeof(QChar) ? fromUtf16(reinterpret_cast<const ushort *>(string), size)
                                            : fromUcs4(reinterpret_cast<const uint *>(string), size);
}


class __declspec(dllimport) QCharRef {
    QString &s;
    int i;
    inline QCharRef(QString &str, int idx)
        : s(str),i(idx) {}
    friend class QString;
public:




    inline operator QChar() const
    { return i < s.d->size ? s.d->data()[i] : 0; }
    inline QCharRef &operator=(QChar c)
    { if (i >= s.d->size) s.expand(i); else s.detach();
      s.d->data()[i] = c.unicode(); return *this; }



    inline QCharRef &operator=(char c)
    { return operator=(QChar::fromLatin1(c)); }
    inline QCharRef &operator=(uchar c)
    { return operator=(QChar::fromLatin1(c)); }

    inline QCharRef &operator=(const QCharRef &c) { return operator=(QChar(c)); }
    inline QCharRef &operator=(ushort rc) { return operator=(QChar(rc)); }
    inline QCharRef &operator=(short rc) { return operator=(QChar(rc)); }
    inline QCharRef &operator=(uint rc) { return operator=(QChar(rc)); }
    inline QCharRef &operator=(int rc) { return operator=(QChar(rc)); }


    inline bool isNull() const { return QChar(*this).isNull(); }
    inline bool isPrint() const { return QChar(*this).isPrint(); }
    inline bool isPunct() const { return QChar(*this).isPunct(); }
    inline bool isSpace() const { return QChar(*this).isSpace(); }
    inline bool isMark() const { return QChar(*this).isMark(); }
    inline bool isLetter() const { return QChar(*this).isLetter(); }
    inline bool isNumber() const { return QChar(*this).isNumber(); }
    inline bool isLetterOrNumber() { return QChar(*this).isLetterOrNumber(); }
    inline bool isDigit() const { return QChar(*this).isDigit(); }
    inline bool isLower() const { return QChar(*this).isLower(); }
    inline bool isUpper() const { return QChar(*this).isUpper(); }
    inline bool isTitleCase() const { return QChar(*this).isTitleCase(); }

    inline int digitValue() const { return QChar(*this).digitValue(); }
    QChar toLower() const { return QChar(*this).toLower(); }
    QChar toUpper() const { return QChar(*this).toUpper(); }
    QChar toTitleCase () const { return QChar(*this).toTitleCase(); }

    QChar::Category category() const { return QChar(*this).category(); }
    QChar::Direction direction() const { return QChar(*this).direction(); }
    QChar::JoiningType joiningType() const { return QChar(*this).joiningType(); }

                  QChar::Joining joining() const
    {
        switch (QChar(*this).joiningType()) {
        case QChar::Joining_Causing: return QChar::Center;
        case QChar::Joining_Dual: return QChar::Dual;
        case QChar::Joining_Right: return QChar::Right;
        case QChar::Joining_None:
        case QChar::Joining_Left:
        case QChar::Joining_Transparent:
        default: return QChar::OtherJoining;
        }
    }

    bool hasMirrored() const { return QChar(*this).hasMirrored(); }
    QChar mirroredChar() const { return QChar(*this).mirroredChar(); }
    QString decomposition() const { return QChar(*this).decomposition(); }
    QChar::Decomposition decompositionTag() const { return QChar(*this).decompositionTag(); }
    uchar combiningClass() const { return QChar(*this).combiningClass(); }

    inline QChar::Script script() const { return QChar(*this).script(); }

    QChar::UnicodeVersion unicodeVersion() const { return QChar(*this).unicodeVersion(); }

    inline uchar cell() const { return QChar(*this).cell(); }
    inline uchar row() const { return QChar(*this).row(); }
    inline void setCell(uchar cell);
    inline void setRow(uchar row);




    char toLatin1() const { return QChar(*this).toLatin1(); }
    ushort unicode() const { return QChar(*this).unicode(); }
    ushort& unicode() { return s.data()[i].unicode(); }

};
template<> class QTypeInfo<QCharRef > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QCharRef)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QCharRef >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QCharRef) }; static inline const char *name() { return "QCharRef"; } };

inline void QCharRef::setRow(uchar arow) { QChar(*this).setRow(arow); }
inline void QCharRef::setCell(uchar acell) { QChar(*this).setCell(acell); }


inline QString::QString() : d(Data::sharedNull()) {}
inline QString::~QString() { if (!d->ref.deref()) Data::deallocate(d); }

inline void QString::reserve(int asize)
{
    if (d->ref.isShared() || uint(asize) >= d->alloc)
        reallocData(qMax(asize, d->size) + 1u);

    if (!d->capacityReserved) {

        d->capacityReserved = true;
    }
}

inline void QString::squeeze()
{
    if (d->ref.isShared() || uint(d->size) + 1u < d->alloc)
        reallocData(uint(d->size) + 1u);

    if (d->capacityReserved) {


        d->capacityReserved = false;
    }
}

inline QString &QString::setUtf16(const ushort *autf16, int asize)
{ return setUnicode(reinterpret_cast<const QChar *>(autf16), asize); }
inline QCharRef QString::operator[](int i)
{ ((!(i >= 0)) ? qt_assert("i >= 0","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h",1023) : qt_noop()); return QCharRef(*this, i); }
inline QCharRef QString::operator[](uint i)
{ return QCharRef(*this, i); }
inline QString::iterator QString::begin()
{ detach(); return reinterpret_cast<QChar*>(d->data()); }
inline QString::const_iterator QString::begin() const
{ return reinterpret_cast<const QChar*>(d->data()); }
inline QString::const_iterator QString::cbegin() const
{ return reinterpret_cast<const QChar*>(d->data()); }
inline QString::const_iterator QString::constBegin() const
{ return reinterpret_cast<const QChar*>(d->data()); }
inline QString::iterator QString::end()
{ detach(); return reinterpret_cast<QChar*>(d->data() + d->size); }
inline QString::const_iterator QString::end() const
{ return reinterpret_cast<const QChar*>(d->data() + d->size); }
inline QString::const_iterator QString::cend() const
{ return reinterpret_cast<const QChar*>(d->data() + d->size); }
inline QString::const_iterator QString::constEnd() const
{ return reinterpret_cast<const QChar*>(d->data() + d->size); }
inline bool QString::contains(const QString &s, Qt::CaseSensitivity cs) const
{ return indexOf(s, 0, cs) != -1; }
inline bool QString::contains(const QStringRef &s, Qt::CaseSensitivity cs) const
{ return indexOf(s, 0, cs) != -1; }
inline bool QString::contains(QLatin1String s, Qt::CaseSensitivity cs) const
{ return indexOf(s, 0, cs) != -1; }
inline bool QString::contains(QChar c, Qt::CaseSensitivity cs) const
{ return indexOf(c, 0, cs) != -1; }


inline bool operator==(QString::Null, QString::Null) { return true; }
inline bool operator==(QString::Null, const QString &s) { return s.isNull(); }
inline bool operator==(const QString &s, QString::Null) { return s.isNull(); }
inline bool operator!=(QString::Null, QString::Null) { return false; }
inline bool operator!=(QString::Null, const QString &s) { return !s.isNull(); }
inline bool operator!=(const QString &s, QString::Null) { return !s.isNull(); }

inline bool operator==(QLatin1String s1, QLatin1String s2)
{ return (s1.size() == s2.size() && !memcmp(s1.latin1(), s2.latin1(), s1.size())); }
inline bool operator!=(QLatin1String s1, QLatin1String s2)
{ return (s1.size() != s2.size() || memcmp(s1.latin1(), s2.latin1(), s1.size())); }
inline bool operator<(QLatin1String s1, QLatin1String s2)
{ int r = memcmp(s1.latin1(), s2.latin1(), qMin(s1.size(), s2.size()));
  return (r < 0) || (r == 0 && s1.size() < s2.size()); }
inline bool operator<=(QLatin1String s1, QLatin1String s2)
{ int r = memcmp(s1.latin1(), s2.latin1(), qMin(s1.size(), s2.size()));
  return (r < 0) || (r == 0 && s1.size() <= s2.size()); }
inline bool operator>(QLatin1String s1, QLatin1String s2)
{ int r = memcmp(s1.latin1(), s2.latin1(), qMin(s1.size(), s2.size()));
  return (r > 0) || (r == 0 && s1.size() > s2.size()); }
inline bool operator>=(QLatin1String s1, QLatin1String s2)
{ int r = memcmp(s1.latin1(), s2.latin1(), qMin(s1.size(), s2.size()));
  return (r > 0) || (r == 0 && s1.size() >= s2.size()); }

inline bool QLatin1String::operator==(const QString &s) const
{ return s == *this; }
inline bool QLatin1String::operator!=(const QString &s) const
{ return s != *this; }
inline bool QLatin1String::operator>(const QString &s) const
{ return s < *this; }
inline bool QLatin1String::operator<(const QString &s) const
{ return s > *this; }
inline bool QLatin1String::operator>=(const QString &s) const
{ return s <= *this; }
inline bool QLatin1String::operator<=(const QString &s) const
{ return s >= *this; }


inline bool QString::operator==(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) == 0; }
inline bool QString::operator!=(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) != 0; }
inline bool QString::operator<(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) < 0; }
inline bool QString::operator>(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) > 0; }
inline bool QString::operator<=(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) <= 0; }
inline bool QString::operator>=(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) >= 0; }

inline bool operator==(const char *s1, const QString &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) == 0; }
inline bool operator!=(const char *s1, const QString &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) != 0; }
inline bool operator<(const char *s1, const QString &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) > 0; }
inline bool operator>(const char *s1, const QString &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) < 0; }
inline bool operator<=(const char *s1, const QString &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) >= 0; }
inline bool operator>=(const char *s1, const QString &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) <= 0; }

inline bool operator==(const char *s1, QLatin1String s2)
{ return QString::fromUtf8(s1) == s2; }
inline bool operator!=(const char *s1, QLatin1String s2)
{ return QString::fromUtf8(s1) != s2; }
inline bool operator<(const char *s1, QLatin1String s2)
{ return (QString::fromUtf8(s1) < s2); }
inline bool operator>(const char *s1, QLatin1String s2)
{ return (QString::fromUtf8(s1) > s2); }
inline bool operator<=(const char *s1, QLatin1String s2)
{ return (QString::fromUtf8(s1) <= s2); }
inline bool operator>=(const char *s1, QLatin1String s2)
{ return (QString::fromUtf8(s1) >= s2); }

inline bool QLatin1String::operator==(const char *s) const
{ return QString::fromUtf8(s) == *this; }
inline bool QLatin1String::operator!=(const char *s) const
{ return QString::fromUtf8(s) != *this; }
inline bool QLatin1String::operator<(const char *s) const
{ return QString::fromUtf8(s) > *this; }
inline bool QLatin1String::operator>(const char *s) const
{ return QString::fromUtf8(s) < *this; }
inline bool QLatin1String::operator<=(const char *s) const
{ return QString::fromUtf8(s) >= *this; }
inline bool QLatin1String::operator>=(const char *s) const
{ return QString::fromUtf8(s) <= *this; }

inline bool QLatin1String::operator==(const QByteArray &s) const
{ return QString::fromUtf8(s) == *this; }
inline bool QLatin1String::operator!=(const QByteArray &s) const
{ return QString::fromUtf8(s) != *this; }
inline bool QLatin1String::operator<(const QByteArray &s) const
{ return QString::fromUtf8(s) > *this; }
inline bool QLatin1String::operator>(const QByteArray &s) const
{ return QString::fromUtf8(s) < *this; }
inline bool QLatin1String::operator<=(const QByteArray &s) const
{ return QString::fromUtf8(s) >= *this; }
inline bool QLatin1String::operator>=(const QByteArray &s) const
{ return QString::fromUtf8(s) <= *this; }

inline bool QString::operator==(const QByteArray &s) const
{ return QString::compare_helper(constData(), size(), s.constData(), qstrnlen(s.constData(), s.size())) == 0; }
inline bool QString::operator!=(const QByteArray &s) const
{ return QString::compare_helper(constData(), size(), s.constData(), qstrnlen(s.constData(), s.size())) != 0; }
inline bool QString::operator<(const QByteArray &s) const
{ return QString::compare_helper(constData(), size(), s.constData(), qstrnlen(s.constData(), s.size())) < 0; }
inline bool QString::operator>(const QByteArray &s) const
{ return QString::compare_helper(constData(), size(), s.constData(), qstrnlen(s.constData(), s.size())) > 0; }
inline bool QString::operator<=(const QByteArray &s) const
{ return QString::compare_helper(constData(), size(), s.constData(), qstrnlen(s.constData(), s.size())) <= 0; }
inline bool QString::operator>=(const QByteArray &s) const
{ return QString::compare_helper(constData(), size(), s.constData(), qstrnlen(s.constData(), s.size())) >= 0; }

inline bool QByteArray::operator==(const QString &s) const
{ return QString::compare_helper(s.constData(), s.size(), constData(), qstrnlen(constData(), size())) == 0; }
inline bool QByteArray::operator!=(const QString &s) const
{ return QString::compare_helper(s.constData(), s.size(), constData(), qstrnlen(constData(), size())) != 0; }
inline bool QByteArray::operator<(const QString &s) const
{ return QString::compare_helper(s.constData(), s.size(), constData(), qstrnlen(constData(), size())) < 0; }
inline bool QByteArray::operator>(const QString &s) const
{ return QString::compare_helper(s.constData(), s.size(), constData(), qstrnlen(constData(), size())) > 0; }
inline bool QByteArray::operator<=(const QString &s) const
{ return QString::compare_helper(s.constData(), s.size(), constData(), qstrnlen(constData(), size())) <= 0; }
inline bool QByteArray::operator>=(const QString &s) const
{ return QString::compare_helper(s.constData(), s.size(), constData(), qstrnlen(constData(), size())) >= 0; }



inline QByteArray &QByteArray::append(const QString &s)
{ return append(s.toUtf8()); }
inline QByteArray &QByteArray::insert(int i, const QString &s)
{ return insert(i, s.toUtf8()); }
inline QByteArray &QByteArray::replace(char c, const QString &after)
{ return replace(c, after.toUtf8()); }
inline QByteArray &QByteArray::replace(const QString &before, const char *after)
{ return replace(before.toUtf8(), after); }
inline QByteArray &QByteArray::replace(const QString &before, const QByteArray &after)
{ return replace(before.toUtf8(), after); }
inline QByteArray &QByteArray::operator+=(const QString &s)
{ return operator+=(s.toUtf8()); }
inline int QByteArray::indexOf(const QString &s, int from) const
{ return indexOf(s.toUtf8(), from); }
inline int QByteArray::lastIndexOf(const QString &s, int from) const
{ return lastIndexOf(s.toUtf8(), from); }



inline const QString operator+(const QString &s1, const QString &s2)
{ QString t(s1); t += s2; return t; }
inline const QString operator+(const QString &s1, QChar s2)
{ QString t(s1); t += s2; return t; }
inline const QString operator+(QChar s1, const QString &s2)
{ QString t(s1); t += s2; return t; }

inline const QString operator+(const QString &s1, const char *s2)
{ QString t(s1); t += QString::fromUtf8(s2); return t; }
inline const QString operator+(const char *s1, const QString &s2)
{ QString t = QString::fromUtf8(s1); t += s2; return t; }
inline const QString operator+(char c, const QString &s)
{ QString t = s; t.prepend(QChar::fromLatin1(c)); return t; }
inline const QString operator+(const QString &s, char c)
{ QString t = s; t += QChar::fromLatin1(c); return t; }
inline const QString operator+(const QByteArray &ba, const QString &s)
{ QString t = QString::fromUtf8(ba); t += s; return t; }
inline const QString operator+(const QString &s, const QByteArray &ba)
{ QString t(s); t += QString::fromUtf8(ba); return t; }



inline std::string QString::toStdString() const
{ const QByteArray asc = toUtf8(); return std::string(asc.constData(), asc.length()); }

inline QString QString::fromStdString(const std::string &s)
{ return fromUtf8(s.data(), int(s.size())); }

inline std::wstring QString::toStdWString() const
{
    std::wstring str;
    str.resize(length());



    if (!length())
        return str;


    str.resize(toWCharArray(&(*str.begin())));
    return str;
}

inline QString QString::fromStdWString(const std::wstring &s)
{ return fromWCharArray(s.data(), int(s.size())); }


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QString &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QString &);


template<> class QTypeInfo<QString > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QString)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QString >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QString) }; static inline const char *name() { return "QString"; } }; template <> inline void qSwap<QString>(QString &value1, QString &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QString >(::QString &value1, ::QString &value2) { value1.swap(value2); } }
 inline QFlags<QString::SectionFlags::enum_type> operator|(QString::SectionFlags::enum_type f1, QString::SectionFlags::enum_type f2) { return QFlags<QString::SectionFlags::enum_type>(f1) | f2; } inline QFlags<QString::SectionFlags::enum_type> operator|(QString::SectionFlags::enum_type f1, QFlags<QString::SectionFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QString::SectionFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


class __declspec(dllimport) QStringRef {
    const QString *m_string;
    int m_position;
    int m_size;
public:

    inline QStringRef():m_string(0), m_position(0), m_size(0){}
    inline QStringRef(const QString *string, int position, int size);
    inline QStringRef(const QString *string);


    inline QStringRef(const QStringRef &other)
        :m_string(other.m_string), m_position(other.m_position), m_size(other.m_size)
        {}


    inline ~QStringRef(){}
    inline const QString *string() const { return m_string; }
    inline int position() const { return m_position; }
    inline int size() const { return m_size; }
    inline int count() const { return m_size; }
    inline int length() const { return m_size; }

    inline QStringRef &operator=(const QStringRef &other) {
        m_string = other.m_string; m_position = other.m_position;
        m_size = other.m_size; return *this;
    }

    int indexOf(const QString &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int indexOf(QChar ch, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int indexOf(QLatin1String str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int indexOf(const QStringRef &str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(const QString &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(QChar ch, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(QLatin1String str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int lastIndexOf(const QStringRef &str, int from = -1, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    inline bool contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    inline bool contains(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    inline bool contains(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    inline bool contains(const QStringRef &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    int count(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int count(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int count(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    QStringRef left(int n) const ;
    QStringRef right(int n) const ;
    QStringRef mid(int pos, int n = -1) const ;

    bool startsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool startsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool startsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool startsWith(const QStringRef &c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    bool endsWith(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(QChar c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    bool endsWith(const QStringRef &c, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    inline QStringRef &operator=(const QString *string);

    inline const QChar *unicode() const {
        if (!m_string)
            return reinterpret_cast<const QChar *>(QString::Data::sharedNull()->data());
        return m_string->unicode() + m_position;
    }
    inline const QChar *data() const { return unicode(); }
    inline const QChar *constData() const { return unicode(); }





    QByteArray toLatin1() const ;
    QByteArray toUtf8() const ;
    QByteArray toLocal8Bit() const ;
    QVector<uint> toUcs4() const ;

    inline void clear() { m_string = 0; m_position = m_size = 0; }
    QString toString() const;
    inline bool isEmpty() const { return m_size == 0; }
    inline bool isNull() const { return m_string == 0 || m_string->isNull(); }

    QStringRef appendTo(QString *string) const;

    inline const QChar at(int i) const
        { ((!(uint(i) < uint(size()))) ? qt_assert("uint(i) < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstring.h",1344) : qt_noop()); return m_string->at(i + m_position); }



    inline bool operator==(const char *s) const;
    inline bool operator!=(const char *s) const;
    inline bool operator<(const char *s) const;
    inline bool operator<=(const char *s) const;
    inline bool operator>(const char *s) const;
    inline bool operator>=(const char *s) const;


    int compare(const QString &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int compare(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    int compare(QLatin1String s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    static int compare(const QStringRef &s1, const QString &s2,
                       Qt::CaseSensitivity = Qt::CaseSensitive);
    static int compare(const QStringRef &s1, const QStringRef &s2,
                       Qt::CaseSensitivity = Qt::CaseSensitive);
    static int compare(const QStringRef &s1, QLatin1String s2,
                       Qt::CaseSensitivity cs = Qt::CaseSensitive);

    int localeAwareCompare(const QString &s) const;
    int localeAwareCompare(const QStringRef &s) const;
    static int localeAwareCompare(const QStringRef &s1, const QString &s2);
    static int localeAwareCompare(const QStringRef &s1, const QStringRef &s2);

    QStringRef trimmed() const ;
    short toShort(bool *ok = 0, int base = 10) const;
    ushort toUShort(bool *ok = 0, int base = 10) const;
    int toInt(bool *ok = 0, int base = 10) const;
    uint toUInt(bool *ok = 0, int base = 10) const;
    long toLong(bool *ok = 0, int base = 10) const;
    ulong toULong(bool *ok = 0, int base = 10) const;
    qlonglong toLongLong(bool *ok = 0, int base = 10) const;
    qulonglong toULongLong(bool *ok = 0, int base = 10) const;
    float toFloat(bool *ok = 0) const;
    double toDouble(bool *ok = 0) const;
};
template<> class QTypeInfo<QStringRef > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QStringRef)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QStringRef >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QStringRef) }; static inline const char *name() { return "QStringRef"; } };

inline QStringRef &QStringRef::operator=(const QString *aString)
{ m_string = aString; m_position = 0; m_size = aString?aString->size():0; return *this; }

inline QStringRef::QStringRef(const QString *aString, int aPosition, int aSize)
        :m_string(aString), m_position(aPosition), m_size(aSize){}

inline QStringRef::QStringRef(const QString *aString)
    :m_string(aString), m_position(0), m_size(aString?aString->size() : 0){}

__declspec(dllimport) bool operator==(const QStringRef &s1,const QStringRef &s2);
inline bool operator!=(const QStringRef &s1,const QStringRef &s2)
{ return !(s1 == s2); }
__declspec(dllimport) bool operator==(const QString &s1,const QStringRef &s2);
inline bool operator!=(const QString &s1,const QStringRef &s2)
{ return !(s1 == s2); }
inline bool operator==(const QStringRef &s1,const QString &s2)
{ return s2 == s1; }
inline bool operator!=(const QStringRef &s1,const QString &s2)
{ return s2 != s1; }
__declspec(dllimport) bool operator==(QLatin1String s1, const QStringRef &s2);
inline bool operator!=(QLatin1String s1, const QStringRef &s2)
{ return !(s1 == s2); }
inline bool operator==(const QStringRef &s1, QLatin1String s2)
{ return s2 == s1; }
inline bool operator!=(const QStringRef &s1, QLatin1String s2)
{ return s2 != s1; }

__declspec(dllimport) bool operator<(const QStringRef &s1,const QStringRef &s2);
inline bool operator>(const QStringRef &s1, const QStringRef &s2)
{ return s2 < s1; }
inline bool operator<=(const QStringRef &s1, const QStringRef &s2)
{ return !(s1 > s2); }
inline bool operator>=(const QStringRef &s1, const QStringRef &s2)
{ return !(s1 < s2); }


inline bool QStringRef::operator==(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) == 0; }
inline bool QStringRef::operator!=(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) != 0; }
inline bool QStringRef::operator<(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) < 0; }
inline bool QStringRef::operator<=(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) > 0; }
inline bool QStringRef::operator>(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) <= 0; }
inline bool QStringRef::operator>=(const char *s) const
{ return QString::compare_helper(constData(), size(), s, -1) >= 0; }

inline bool operator==(const char *s1, const QStringRef &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) == 0; }
inline bool operator!=(const char *s1, const QStringRef &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) != 0; }
inline bool operator<(const char *s1, const QStringRef &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) < 0; }
inline bool operator<=(const char *s1, const QStringRef &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) > 0; }
inline bool operator>(const char *s1, const QStringRef &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) <= 0; }
inline bool operator>=(const char *s1, const QStringRef &s2)
{ return QString::compare_helper(s2.constData(), s2.size(), s1, -1) >= 0; }


inline int QString::compare(const QStringRef &s, Qt::CaseSensitivity cs) const
{ return QString::compare_helper(constData(), length(), s.constData(), s.length(), cs); }
inline int QString::compare(const QString &s1, const QStringRef &s2, Qt::CaseSensitivity cs)
{ return QString::compare_helper(s1.constData(), s1.length(), s2.constData(), s2.length(), cs); }
inline int QStringRef::compare(const QString &s, Qt::CaseSensitivity cs) const
{ return QString::compare_helper(constData(), length(), s.constData(), s.length(), cs); }
inline int QStringRef::compare(const QStringRef &s, Qt::CaseSensitivity cs) const
{ return QString::compare_helper(constData(), length(), s.constData(), s.length(), cs); }
inline int QStringRef::compare(QLatin1String s, Qt::CaseSensitivity cs) const
{ return QString::compare_helper(constData(), length(), s, cs); }
inline int QStringRef::compare(const QStringRef &s1, const QString &s2, Qt::CaseSensitivity cs)
{ return QString::compare_helper(s1.constData(), s1.length(), s2.constData(), s2.length(), cs); }
inline int QStringRef::compare(const QStringRef &s1, const QStringRef &s2, Qt::CaseSensitivity cs)
{ return QString::compare_helper(s1.constData(), s1.length(), s2.constData(), s2.length(), cs); }
inline int QStringRef::compare(const QStringRef &s1, QLatin1String s2, Qt::CaseSensitivity cs)
{ return QString::compare_helper(s1.constData(), s1.length(), s2, cs); }

inline int QString::localeAwareCompare(const QStringRef &s) const
{ return localeAwareCompare_helper(constData(), length(), s.constData(), s.length()); }
inline int QString::localeAwareCompare(const QString& s1, const QStringRef& s2)
{ return localeAwareCompare_helper(s1.constData(), s1.length(), s2.constData(), s2.length()); }
inline int QStringRef::localeAwareCompare(const QString &s) const
{ return QString::localeAwareCompare_helper(constData(), length(), s.constData(), s.length()); }
inline int QStringRef::localeAwareCompare(const QStringRef &s) const
{ return QString::localeAwareCompare_helper(constData(), length(), s.constData(), s.length()); }
inline int QStringRef::localeAwareCompare(const QStringRef &s1, const QString &s2)
{ return QString::localeAwareCompare_helper(s1.constData(), s1.length(), s2.constData(), s2.length()); }
inline int QStringRef::localeAwareCompare(const QStringRef &s1, const QStringRef &s2)
{ return QString::localeAwareCompare_helper(s1.constData(), s1.length(), s2.constData(), s2.length()); }

inline bool QStringRef::contains(const QString &s, Qt::CaseSensitivity cs) const
{ return indexOf(s, 0, cs) != -1; }
inline bool QStringRef::contains(QLatin1String s, Qt::CaseSensitivity cs) const
{ return indexOf(s, 0, cs) != -1; }
inline bool QStringRef::contains(QChar c, Qt::CaseSensitivity cs) const
{ return indexOf(c, 0, cs) != -1; }
inline bool QStringRef::contains(const QStringRef &s, Qt::CaseSensitivity cs) const
{ return indexOf(s, 0, cs) != -1; }

namespace Qt {





}
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcoreapplication.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs_impl.h"
#line 57 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs_impl.h"
namespace QtPrivate {
    template <typename T> struct RemoveRef { typedef T Type; };
    template <typename T> struct RemoveRef<T&> { typedef T Type; };
    template <typename T> struct RemoveConstRef { typedef T Type; };
    template <typename T> struct RemoveConstRef<const T&> { typedef T Type; };
#line 75 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs_impl.h"
    template <typename...> struct List {};
    template <typename Head, typename... Tail> struct List<Head, Tail...> { typedef Head Car; typedef List<Tail...> Cdr; };
    template <typename, typename> struct List_Append;
    template <typename... L1, typename...L2> struct List_Append<List<L1...>, List<L2...>> { typedef List<L1..., L2...> Value; };
    template <typename L, int N> struct List_Left {
        typedef typename List_Append<List<typename L::Car>,typename List_Left<typename L::Cdr, N - 1>::Value>::Value Value;
    };
    template <typename L> struct List_Left<L, 0> { typedef List<> Value; };


    template <typename L, int N> struct List_Select { typedef typename List_Select<typename L::Cdr, N - 1>::Value Value; };
    template <typename L> struct List_Select<L,0> { typedef typename L::Car Value; };







    template <typename T>
    struct ApplyReturnValue {
        void *data;
        explicit ApplyReturnValue(void *data_) : data(data_) {}
    };
    template<typename T, typename U>
    void operator,(const T &value, const ApplyReturnValue<U> &container) {
        if (container.data)
            *reinterpret_cast<U*>(container.data) = value;
    }

    template<typename T, typename U>
    void operator,(T &&value, const ApplyReturnValue<U> &container) {
        if (container.data)
            *reinterpret_cast<U*>(container.data) = value;
    }

    template<typename T>
    void operator,(T, const ApplyReturnValue<void> &) {}
#line 489 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs_impl.h"
    template <int...> struct IndexesList {};
    template <typename IndexList, int Right> struct IndexesAppend;
    template <int... Left, int Right> struct IndexesAppend<IndexesList<Left...>, Right>
    { typedef IndexesList<Left..., Right> Value; };
    template <int N> struct Indexes
    { typedef typename IndexesAppend<typename Indexes<N - 1>::Value, N - 1>::Value Value; };
    template <> struct Indexes<0> { typedef IndexesList<> Value; };
    template<typename Func> struct FunctionPointer { enum {ArgumentCount = -1, IsPointerToMemberFunction = false}; };

    template <typename, typename, typename, typename> struct FunctorCall;
    template <int... II, typename... SignalArgs, typename R, typename Function>
    struct FunctorCall<IndexesList<II...>, List<SignalArgs...>, R, Function> {
        static void call(Function f, void **arg) {
            f((*reinterpret_cast<typename RemoveRef<SignalArgs>::Type *>(arg[II+1]))...), ApplyReturnValue<R>(arg[0]);
        }
    };
    template <int... II, typename... SignalArgs, typename R, typename... SlotArgs, typename SlotRet, class Obj>
    struct FunctorCall<IndexesList<II...>, List<SignalArgs...>, R, SlotRet (Obj::*)(SlotArgs...)> {
        static void call(SlotRet (Obj::*f)(SlotArgs...), Obj *o, void **arg) {
            (o->*f)((*reinterpret_cast<typename RemoveRef<SignalArgs>::Type *>(arg[II+1]))...), ApplyReturnValue<R>(arg[0]);
        }
    };
    template <int... II, typename... SignalArgs, typename R, typename... SlotArgs, typename SlotRet, class Obj>
    struct FunctorCall<IndexesList<II...>, List<SignalArgs...>, R, SlotRet (Obj::*)(SlotArgs...) const> {
        static void call(SlotRet (Obj::*f)(SlotArgs...) const, Obj *o, void **arg) {
            (o->*f)((*reinterpret_cast<typename RemoveRef<SignalArgs>::Type *>(arg[II+1]))...), ApplyReturnValue<R>(arg[0]);
        }
    };

    template<class Obj, typename Ret, typename... Args> struct FunctionPointer<Ret (Obj::*) (Args...)>
    {
        typedef Obj Object;
        typedef List<Args...> Arguments;
        typedef Ret ReturnType;
        typedef Ret (Obj::*Function) (Args...);
        enum {ArgumentCount = sizeof...(Args), IsPointerToMemberFunction = true};
        template <typename SignalArgs, typename R>
        static void call(Function f, Obj *o, void **arg) {
            FunctorCall<typename Indexes<ArgumentCount>::Value, SignalArgs, R, Function>::call(f, o, arg);
        }
    };
    template<class Obj, typename Ret, typename... Args> struct FunctionPointer<Ret (Obj::*) (Args...) const>
    {
        typedef Obj Object;
        typedef List<Args...> Arguments;
        typedef Ret ReturnType;
        typedef Ret (Obj::*Function) (Args...) const;
        enum {ArgumentCount = sizeof...(Args), IsPointerToMemberFunction = true};
        template <typename SignalArgs, typename R>
        static void call(Function f, Obj *o, void **arg) {
            FunctorCall<typename Indexes<ArgumentCount>::Value, SignalArgs, R, Function>::call(f, o, arg);
        }
    };

    template<typename Ret, typename... Args> struct FunctionPointer<Ret (*) (Args...)>
    {
        typedef List<Args...> Arguments;
        typedef Ret ReturnType;
        typedef Ret (*Function) (Args...);
        enum {ArgumentCount = sizeof...(Args), IsPointerToMemberFunction = false};
        template <typename SignalArgs, typename R>
        static void call(Function f, void *, void **arg) {
            FunctorCall<typename Indexes<ArgumentCount>::Value, SignalArgs, R, Function>::call(f, arg);
        }
    };

    template<typename Function, int N> struct Functor
    {
        template <typename SignalArgs, typename R>
        static void call(Function &f, void *, void **arg) {
            FunctorCall<typename Indexes<N>::Value, SignalArgs, R, Function>::call(f, arg);
        }
    };







    template<typename A1, typename A2> struct AreArgumentsCompatible {
        static int test(const typename RemoveRef<A2>::Type&);
        static char test(...);
        static const typename RemoveRef<A1>::Type &dummy();
        enum { value = sizeof(test(dummy())) == sizeof(int) };
    };
    template<typename A1, typename A2> struct AreArgumentsCompatible<A1, A2&> { enum { value = false }; };
    template<typename A> struct AreArgumentsCompatible<A&, A&> { enum { value = true }; };

    template<typename A> struct AreArgumentsCompatible<void, A> { enum { value = true }; };
    template<typename A> struct AreArgumentsCompatible<A, void> { enum { value = true }; };
    template<> struct AreArgumentsCompatible<void, void> { enum { value = true }; };
#line 592 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs_impl.h"
    template <typename List1, typename List2> struct CheckCompatibleArguments { enum { value = false }; };
    template <> struct CheckCompatibleArguments<List<>, List<>> { enum { value = true }; };
    template <typename List1> struct CheckCompatibleArguments<List1, List<>> { enum { value = true }; };
    template <typename Arg1, typename Arg2, typename... Tail1, typename... Tail2>
    struct CheckCompatibleArguments<List<Arg1, Tail1...>, List<Arg2, Tail2...>>
    {
        enum { value = AreArgumentsCompatible<typename RemoveConstRef<Arg1>::Type, typename RemoveConstRef<Arg2>::Type>::value
                    && CheckCompatibleArguments<List<Tail1...>, List<Tail2...>>::value };
    };
#line 609 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs_impl.h"
    template <typename Functor, typename ArgList> struct ComputeFunctorArgumentCount;

    template <typename Functor, typename ArgList, bool Done> struct ComputeFunctorArgumentCountHelper
    { enum { Value = -1 }; };
    template <typename Functor, typename First, typename... ArgList>
    struct ComputeFunctorArgumentCountHelper<Functor, List<First, ArgList...>, false>
        : ComputeFunctorArgumentCount<Functor,
            typename List_Left<List<First, ArgList...>, sizeof...(ArgList)>::Value> {};

    template <typename Functor, typename... ArgList> struct ComputeFunctorArgumentCount<Functor, List<ArgList...>>
    {
        template <typename D> static D dummy();
        template <typename F> static auto test(F f) -> decltype(((f.operator()((dummy<ArgList>())...)), int()));
        static char test(...);
        enum {
            Ok = sizeof(test(dummy<Functor>())) == sizeof(int),
            Value = Ok ? int(sizeof...(ArgList)) : int(ComputeFunctorArgumentCountHelper<Functor, List<ArgList...>, Ok>::Value)
        };
    };


    template <typename Functor, typename ArgList> struct FunctorReturnType;
    template <typename Functor, typename ... ArgList> struct FunctorReturnType<Functor, List<ArgList...>> {
        template <typename D> static D dummy();
        typedef decltype(dummy<Functor>().operator()((dummy<ArgList>())...)) Value;
    };


}
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs.h"





class QByteArray;
struct QArrayData;
typedef QArrayData QByteArrayData;

class QString;
#line 135 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs.h"
template <typename T>
inline int qYouForgotTheQ_OBJECT_Macro(T, T) { return 0; }

template <typename T1, typename T2>
inline void qYouForgotTheQ_OBJECT_Macro(T1, T2) {}
#line 211 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs.h"
__declspec(dllimport) const char *qFlagLocation(const char *method);
#line 237 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobjectdefs.h"
class QObject;
class QMetaMethod;
class QMetaEnum;
class QMetaProperty;
class QMetaClassInfo;


class __declspec(dllimport) QGenericArgument
{
public:
    inline QGenericArgument(const char *aName = 0, const void *aData = 0)
        : _data(aData), _name(aName) {}
    inline void *data() const { return const_cast<void *>(_data); }
    inline const char *name() const { return _name; }

private:
    const void *_data;
    const char *_name;
};

class __declspec(dllimport) QGenericReturnArgument: public QGenericArgument
{
public:
    inline QGenericReturnArgument(const char *aName = 0, void *aData = 0)
        : QGenericArgument(aName, aData)
        {}
};

template <class T>
class QArgument: public QGenericArgument
{
public:
    inline QArgument(const char *aName, const T &aData)
        : QGenericArgument(aName, static_cast<const void *>(&aData))
        {}
};
template <class T>
class QArgument<T &>: public QGenericArgument
{
public:
    inline QArgument(const char *aName, T &aData)
        : QGenericArgument(aName, static_cast<const void *>(&aData))
        {}
};


template <typename T>
class QReturnArgument: public QGenericReturnArgument
{
public:
    inline QReturnArgument(const char *aName, T &aData)
        : QGenericReturnArgument(aName, static_cast<void *>(&aData))
        {}
};

struct __declspec(dllimport) QMetaObject
{
    class Connection;
    const char *className() const;
    const QMetaObject *superClass() const;

    QObject *cast(QObject *obj) const;
    const QObject *cast(const QObject *obj) const;


    QString tr(const char *s, const char *c, int n = -1) const;


    int methodOffset() const;
    int enumeratorOffset() const;
    int propertyOffset() const;
    int classInfoOffset() const;

    int constructorCount() const;
    int methodCount() const;
    int enumeratorCount() const;
    int propertyCount() const;
    int classInfoCount() const;

    int indexOfConstructor(const char *constructor) const;
    int indexOfMethod(const char *method) const;
    int indexOfSignal(const char *signal) const;
    int indexOfSlot(const char *slot) const;
    int indexOfEnumerator(const char *name) const;
    int indexOfProperty(const char *name) const;
    int indexOfClassInfo(const char *name) const;

    QMetaMethod constructor(int index) const;
    QMetaMethod method(int index) const;
    QMetaEnum enumerator(int index) const;
    QMetaProperty property(int index) const;
    QMetaClassInfo classInfo(int index) const;
    QMetaProperty userProperty() const;

    static bool checkConnectArgs(const char *signal, const char *method);
    static bool checkConnectArgs(const QMetaMethod &signal,
                                 const QMetaMethod &method);
    static QByteArray normalizedSignature(const char *method);
    static QByteArray normalizedType(const char *type);


    static Connection connect(const QObject *sender, int signal_index,
                        const QObject *receiver, int method_index,
                        int type = 0, int *types = 0);

    static bool disconnect(const QObject *sender, int signal_index,
                           const QObject *receiver, int method_index);
    static bool disconnectOne(const QObject *sender, int signal_index,
                              const QObject *receiver, int method_index);

    static void connectSlotsByName(QObject *o);


    static void activate(QObject *sender, int signal_index, void **argv);
    static void activate(QObject *sender, const QMetaObject *, int local_signal_index, void **argv);
    static void activate(QObject *sender, int signal_offset, int local_signal_index, void **argv);

    static bool invokeMethod(QObject *obj, const char *member,
                             Qt::ConnectionType,
                             QGenericReturnArgument ret,
                             QGenericArgument val0 = QGenericArgument(0),
                             QGenericArgument val1 = QGenericArgument(),
                             QGenericArgument val2 = QGenericArgument(),
                             QGenericArgument val3 = QGenericArgument(),
                             QGenericArgument val4 = QGenericArgument(),
                             QGenericArgument val5 = QGenericArgument(),
                             QGenericArgument val6 = QGenericArgument(),
                             QGenericArgument val7 = QGenericArgument(),
                             QGenericArgument val8 = QGenericArgument(),
                             QGenericArgument val9 = QGenericArgument());

    static inline bool invokeMethod(QObject *obj, const char *member,
                             QGenericReturnArgument ret,
                             QGenericArgument val0 = QGenericArgument(0),
                             QGenericArgument val1 = QGenericArgument(),
                             QGenericArgument val2 = QGenericArgument(),
                             QGenericArgument val3 = QGenericArgument(),
                             QGenericArgument val4 = QGenericArgument(),
                             QGenericArgument val5 = QGenericArgument(),
                             QGenericArgument val6 = QGenericArgument(),
                             QGenericArgument val7 = QGenericArgument(),
                             QGenericArgument val8 = QGenericArgument(),
                             QGenericArgument val9 = QGenericArgument())
    {
        return invokeMethod(obj, member, Qt::AutoConnection, ret, val0, val1, val2, val3,
                val4, val5, val6, val7, val8, val9);
    }

    static inline bool invokeMethod(QObject *obj, const char *member,
                             Qt::ConnectionType type,
                             QGenericArgument val0 = QGenericArgument(0),
                             QGenericArgument val1 = QGenericArgument(),
                             QGenericArgument val2 = QGenericArgument(),
                             QGenericArgument val3 = QGenericArgument(),
                             QGenericArgument val4 = QGenericArgument(),
                             QGenericArgument val5 = QGenericArgument(),
                             QGenericArgument val6 = QGenericArgument(),
                             QGenericArgument val7 = QGenericArgument(),
                             QGenericArgument val8 = QGenericArgument(),
                             QGenericArgument val9 = QGenericArgument())
    {
        return invokeMethod(obj, member, type, QGenericReturnArgument(), val0, val1, val2,
                                 val3, val4, val5, val6, val7, val8, val9);
    }

    static inline bool invokeMethod(QObject *obj, const char *member,
                             QGenericArgument val0 = QGenericArgument(0),
                             QGenericArgument val1 = QGenericArgument(),
                             QGenericArgument val2 = QGenericArgument(),
                             QGenericArgument val3 = QGenericArgument(),
                             QGenericArgument val4 = QGenericArgument(),
                             QGenericArgument val5 = QGenericArgument(),
                             QGenericArgument val6 = QGenericArgument(),
                             QGenericArgument val7 = QGenericArgument(),
                             QGenericArgument val8 = QGenericArgument(),
                             QGenericArgument val9 = QGenericArgument())
    {
        return invokeMethod(obj, member, Qt::AutoConnection, QGenericReturnArgument(), val0,
                val1, val2, val3, val4, val5, val6, val7, val8, val9);
    }

    QObject *newInstance(QGenericArgument val0 = QGenericArgument(0),
                         QGenericArgument val1 = QGenericArgument(),
                         QGenericArgument val2 = QGenericArgument(),
                         QGenericArgument val3 = QGenericArgument(),
                         QGenericArgument val4 = QGenericArgument(),
                         QGenericArgument val5 = QGenericArgument(),
                         QGenericArgument val6 = QGenericArgument(),
                         QGenericArgument val7 = QGenericArgument(),
                         QGenericArgument val8 = QGenericArgument(),
                         QGenericArgument val9 = QGenericArgument()) const;

    enum Call {
        InvokeMetaMethod,
        ReadProperty,
        WriteProperty,
        ResetProperty,
        QueryPropertyDesignable,
        QueryPropertyScriptable,
        QueryPropertyStored,
        QueryPropertyEditable,
        QueryPropertyUser,
        CreateInstance,
        IndexOfMethod,
        RegisterPropertyMetaType,
        RegisterMethodArgumentMetaType
    };

    int static_metacall(Call, int, void **) const;
    static int metacall(QObject *, Call, int, void **);

    struct {
        const QMetaObject *superdata;
        const QByteArrayData *stringdata;
        const uint *data;
        typedef void (*StaticMetacallFunction)(QObject *, QMetaObject::Call, int, void **);
        StaticMetacallFunction static_metacall;
        const QMetaObject * const *relatedMetaObjects;
        void *extradata;
    } d;
};

class __declspec(dllimport) QMetaObject::Connection {
    void *d_ptr;
    explicit Connection(void *data) : d_ptr(data) { }
    friend class QObject;
    friend class QObjectPrivate;
    friend struct QMetaObject;
public:
    ~Connection();
    Connection();
    Connection(const Connection &other);
    Connection &operator=(const Connection &other);



    typedef void *Connection::*RestrictedBool;
    operator RestrictedBool() const { return d_ptr ? &Connection::d_ptr : 0; }



    inline Connection(Connection &&o) : d_ptr(o.d_ptr) { o.d_ptr = 0; }
    inline Connection &operator=(Connection &&other)
    { qSwap(d_ptr, other.d_ptr); return *this; }

};

inline const QMetaObject *QMetaObject::superClass() const
{ return d.superdata; }

namespace QtPrivate {

    template <typename Object> struct HasQ_OBJECT_Macro {
        template <typename T>
        static char test(int (T::*)(QMetaObject::Call, int, void **));
        static int test(int (Object::*)(QMetaObject::Call, int, void **));
        enum { Value = sizeof(test(&Object::qt_metacall)) == sizeof(int) };
    };
}
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qalgorithms.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qalgorithms.h"
namespace QAlgorithmsPrivate {


template <typename RandomAccessIterator, typename T, typename LessThan>
                                 inline void qSortHelper(RandomAccessIterator start, RandomAccessIterator end, const T &t, LessThan lessThan);
template <typename RandomAccessIterator, typename T>
                                 inline void qSortHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &dummy);

template <typename RandomAccessIterator, typename T, typename LessThan>
                                        inline void qStableSortHelper(RandomAccessIterator start, RandomAccessIterator end, const T &t, LessThan lessThan);
template <typename RandomAccessIterator, typename T>
                                        inline void qStableSortHelper(RandomAccessIterator, RandomAccessIterator, const T &);

template <typename RandomAccessIterator, typename T, typename LessThan>
                                        inline RandomAccessIterator qLowerBoundHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan);
template <typename RandomAccessIterator, typename T, typename LessThan>
                                        inline RandomAccessIterator qUpperBoundHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan);
template <typename RandomAccessIterator, typename T, typename LessThan>
                                          inline RandomAccessIterator qBinaryFindHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan);


}


template <typename InputIterator, typename OutputIterator>
                                 inline OutputIterator qCopy(InputIterator begin, InputIterator end, OutputIterator dest)
{
    while (begin != end)
        *dest++ = *begin++;
    return dest;
}

template <typename BiIterator1, typename BiIterator2>
                                          inline BiIterator2 qCopyBackward(BiIterator1 begin, BiIterator1 end, BiIterator2 dest)
{
    while (begin != end)
        *--dest = *--end;
    return dest;
}

template <typename InputIterator1, typename InputIterator2>
                                  inline bool qEqual(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2)
{
    for (; first1 != last1; ++first1, ++first2)
        if (!(*first1 == *first2))
            return false;
    return true;
}

template <typename ForwardIterator, typename T>
                                 inline void qFill(ForwardIterator first, ForwardIterator last, const T &val)
{
    for (; first != last; ++first)
        *first = val;
}

template <typename Container, typename T>
                                 inline void qFill(Container &container, const T &val)
{
    qFill(container.begin(), container.end(), val);
}

template <typename InputIterator, typename T>
                                 inline InputIterator qFind(InputIterator first, InputIterator last, const T &val)
{
    while (first != last && !(*first == val))
        ++first;
    return first;
}

template <typename Container, typename T>
                                 inline typename Container::const_iterator qFind(const Container &container, const T &val)
{
    return qFind(container.constBegin(), container.constEnd(), val);
}

template <typename InputIterator, typename T, typename Size>
                                  inline void qCount(InputIterator first, InputIterator last, const T &value, Size &n)
{
    for (; first != last; ++first)
        if (*first == value)
            ++n;
}

template <typename Container, typename T, typename Size>
                                  inline void qCount(const Container &container, const T &value, Size &n)
{
    qCount(container.constBegin(), container.constEnd(), value, n);
}
#line 155 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qalgorithms.h"
template <typename T>
class qLess
{
public:
    inline bool operator()(const T &t1, const T &t2) const
    {
        return (t1 < t2);
    }
};

template <typename T>
class qGreater
{
public:
    inline bool operator()(const T &t1, const T &t2) const
    {
        return (t2 < t1);
    }
};


template <typename RandomAccessIterator>
                                 inline void qSort(RandomAccessIterator start, RandomAccessIterator end)
{
    if (start != end)
        QAlgorithmsPrivate::qSortHelper(start, end, *start);
}

template <typename RandomAccessIterator, typename LessThan>
                                 inline void qSort(RandomAccessIterator start, RandomAccessIterator end, LessThan lessThan)
{
    if (start != end)
        QAlgorithmsPrivate::qSortHelper(start, end, *start, lessThan);
}

template<typename Container>
                                 inline void qSort(Container &c)
{




    if (!c.empty())
        QAlgorithmsPrivate::qSortHelper(c.begin(), c.end(), *c.begin());
}

template <typename RandomAccessIterator>
                                        inline void qStableSort(RandomAccessIterator start, RandomAccessIterator end)
{
    if (start != end)
        QAlgorithmsPrivate::qStableSortHelper(start, end, *start);
}

template <typename RandomAccessIterator, typename LessThan>
                                        inline void qStableSort(RandomAccessIterator start, RandomAccessIterator end, LessThan lessThan)
{
    if (start != end)
        QAlgorithmsPrivate::qStableSortHelper(start, end, *start, lessThan);
}

template<typename Container>
                                        inline void qStableSort(Container &c)
{




    if (!c.empty())
        QAlgorithmsPrivate::qStableSortHelper(c.begin(), c.end(), *c.begin());
}

template <typename RandomAccessIterator, typename T>
                                        inline RandomAccessIterator qLowerBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
{



    RandomAccessIterator middle;
    int n = end - begin;
    int half;

    while (n > 0) {
        half = n >> 1;
        middle = begin + half;
        if (*middle < value) {
            begin = middle + 1;
            n -= half + 1;
        } else {
            n = half;
        }
    }
    return begin;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
                                        inline RandomAccessIterator qLowerBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
    return QAlgorithmsPrivate::qLowerBoundHelper(begin, end, value, lessThan);
}

template <typename Container, typename T>
                                        inline typename Container::const_iterator qLowerBound(const Container &container, const T &value)
{
    return QAlgorithmsPrivate::qLowerBoundHelper(container.constBegin(), container.constEnd(), value, qLess<T>());
}

template <typename RandomAccessIterator, typename T>
                                        inline RandomAccessIterator qUpperBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
{

    RandomAccessIterator middle;
    int n = end - begin;
    int half;

    while (n > 0) {
        half = n >> 1;
        middle = begin + half;
        if (value < *middle) {
            n = half;
        } else {
            begin = middle + 1;
            n -= half + 1;
        }
    }
    return begin;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
                                        inline RandomAccessIterator qUpperBound(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
    return QAlgorithmsPrivate::qUpperBoundHelper(begin, end, value, lessThan);
}

template <typename Container, typename T>
                                        inline typename Container::const_iterator qUpperBound(const Container &container, const T &value)
{
    return QAlgorithmsPrivate::qUpperBoundHelper(container.constBegin(), container.constEnd(), value, qLess<T>());
}

template <typename RandomAccessIterator, typename T>
                                          inline RandomAccessIterator qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end, const T &value)
{

    RandomAccessIterator it = qLowerBound(begin, end, value);

    if (it == end || value < *it)
        return end;

    return it;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
                                          inline RandomAccessIterator qBinaryFind(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
    return QAlgorithmsPrivate::qBinaryFindHelper(begin, end, value, lessThan);
}

template <typename Container, typename T>
                                          inline typename Container::const_iterator qBinaryFind(const Container &container, const T &value)
{
    return QAlgorithmsPrivate::qBinaryFindHelper(container.constBegin(), container.constEnd(), value, qLess<T>());
}


template <typename ForwardIterator>
inline void qDeleteAll(ForwardIterator begin, ForwardIterator end)
{
    while (begin != end) {
        delete *begin;
        ++begin;
    }
}

template <typename Container>
inline void qDeleteAll(const Container &c)
{
    qDeleteAll(c.begin(), c.end());
}





namespace QAlgorithmsPrivate {



template <typename RandomAccessIterator, typename T, typename LessThan>
                                 inline void qSortHelper(RandomAccessIterator start, RandomAccessIterator end, const T &t, LessThan lessThan)
{
top:
    int span = int(end - start);
    if (span < 2)
        return;

    --end;
    RandomAccessIterator low = start, high = end - 1;
    RandomAccessIterator pivot = start + span / 2;

    if (lessThan(*end, *start))
        qSwap(*end, *start);
    if (span == 2)
        return;

    if (lessThan(*pivot, *start))
        qSwap(*pivot, *start);
    if (lessThan(*end, *pivot))
        qSwap(*end, *pivot);
    if (span == 3)
        return;

    qSwap(*pivot, *end);

    while (low < high) {
        while (low < high && lessThan(*low, *end))
            ++low;

        while (high > low && lessThan(*end, *high))
            --high;

        if (low < high) {
            qSwap(*low, *high);
            ++low;
            --high;
        } else {
            break;
        }
    }

    if (lessThan(*low, *end))
        ++low;

    qSwap(*end, *low);
    qSortHelper(start, low, t, lessThan);

    start = low + 1;
    ++end;
    goto top;
}

template <typename RandomAccessIterator, typename T>
                                 inline void qSortHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &dummy)
{
    qSortHelper(begin, end, dummy, qLess<T>());
}

template <typename RandomAccessIterator>
                                    inline void qReverse(RandomAccessIterator begin, RandomAccessIterator end)
{
    --end;
    while (begin < end)
        qSwap(*begin++, *end--);
}

template <typename RandomAccessIterator>
                                   inline void qRotate(RandomAccessIterator begin, RandomAccessIterator middle, RandomAccessIterator end)
{
    qReverse(begin, middle);
    qReverse(middle, end);
    qReverse(begin, end);
}

template <typename RandomAccessIterator, typename T, typename LessThan>
                                  inline void qMerge(RandomAccessIterator begin, RandomAccessIterator pivot, RandomAccessIterator end, T &t, LessThan lessThan)
{
    const int len1 = pivot - begin;
    const int len2 = end - pivot;

    if (len1 == 0 || len2 == 0)
        return;

    if (len1 + len2 == 2) {
        if (lessThan(*(begin + 1), *(begin)))
            qSwap(*begin, *(begin + 1));
        return;
    }

    RandomAccessIterator firstCut;
    RandomAccessIterator secondCut;
    int len2Half;
    if (len1 > len2) {
        const int len1Half = len1 / 2;
        firstCut = begin + len1Half;
        secondCut = qLowerBound(pivot, end, *firstCut, lessThan);
        len2Half = secondCut - pivot;
    } else {
        len2Half = len2 / 2;
        secondCut = pivot + len2Half;
        firstCut = qUpperBound(begin, pivot, *secondCut, lessThan);
    }

    qRotate(firstCut, pivot, secondCut);
    const RandomAccessIterator newPivot = firstCut + len2Half;
    qMerge(begin, firstCut, newPivot, t, lessThan);
    qMerge(newPivot, secondCut, end, t, lessThan);
}

template <typename RandomAccessIterator, typename T, typename LessThan>
                                        inline void qStableSortHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &t, LessThan lessThan)
{
    const int span = end - begin;
    if (span < 2)
       return;

    const RandomAccessIterator middle = begin + span / 2;
    qStableSortHelper(begin, middle, t, lessThan);
    qStableSortHelper(middle, end, t, lessThan);
    qMerge(begin, middle, end, t, lessThan);
}

template <typename RandomAccessIterator, typename T>
                                        inline void qStableSortHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &dummy)
{
    qStableSortHelper(begin, end, dummy, qLess<T>());
}

template <typename RandomAccessIterator, typename T, typename LessThan>
                                        inline RandomAccessIterator qLowerBoundHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
    RandomAccessIterator middle;
    int n = int(end - begin);
    int half;

    while (n > 0) {
        half = n >> 1;
        middle = begin + half;
        if (lessThan(*middle, value)) {
            begin = middle + 1;
            n -= half + 1;
        } else {
            n = half;
        }
    }
    return begin;
}


template <typename RandomAccessIterator, typename T, typename LessThan>
                                        inline RandomAccessIterator qUpperBoundHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
    RandomAccessIterator middle;
    int n = end - begin;
    int half;

    while (n > 0) {
        half = n >> 1;
        middle = begin + half;
        if (lessThan(value, *middle)) {
            n = half;
        } else {
            begin = middle + 1;
            n -= half + 1;
        }
    }
    return begin;
}

template <typename RandomAccessIterator, typename T, typename LessThan>
                                          inline RandomAccessIterator qBinaryFindHelper(RandomAccessIterator begin, RandomAccessIterator end, const T &value, LessThan lessThan)
{
    RandomAccessIterator it = qLowerBoundHelper(begin, end, value, lessThan);

    if (it == end || lessThan(value, *it))
        return end;

    return it;
}



}
#line 535 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qalgorithms.h"
                 inline uint qPopulationCount(quint32 v)
{




    return
        (((v ) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f +
        (((v >> 12) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f +
        (((v >> 24) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f;

}

                 inline uint qPopulationCount(quint8 v)
{



    return
        (((v ) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f;

}

                 inline uint qPopulationCount(quint16 v)
{



    return
        (((v ) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f +
        (((v >> 12) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f;

}

                 inline uint qPopulationCount(quint64 v)
{



    return
        (((v ) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f +
        (((v >> 12) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f +
        (((v >> 24) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f +
        (((v >> 36) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f +
        (((v >> 48) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f +
        (((v >> 60) & 0xfff) * 0x1001001001001ui64 & 0x84210842108421ui64) % 0x1f;

}

                 inline uint qPopulationCount(long unsigned int v)
{
    return qPopulationCount(static_cast<quint64>(v));
}
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qiterator.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h"




#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\list"








#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4127)
namespace std {

template<class _Mylist,
 class _Base = _Iterator_base0>
 class _List_unchecked_const_iterator
  : public _Iterator012<bidirectional_iterator_tag,
   typename _Mylist::value_type,
   typename _Mylist::difference_type,
   typename _Mylist::const_pointer,
   typename _Mylist::const_reference,
   _Base>
 {
public:
 typedef _List_unchecked_const_iterator<_Mylist, _Base> _Myiter;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::const_pointer pointer;
 typedef typename _Mylist::const_reference reference;

 _List_unchecked_const_iterator()
  : _Ptr(0)
  {
  }

 _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Ptr(_Pnode)
  {
  this->_Adopt(_Plist);
  }

 reference operator*() const
  {
  return (_Mylist::_Myval(_Ptr));
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  _Ptr = _Mylist::_Nextnode(_Ptr);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  _Ptr = _Mylist::_Prevnode(_Ptr);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 _Nodeptr _Mynode() const
  {
  return (_Ptr);
  }

 _Nodeptr _Ptr;
 };


template<class _Mylist>
 class _List_unchecked_iterator
  : public _List_unchecked_const_iterator<_Mylist>
 {
public:
 typedef _List_unchecked_iterator<_Mylist> _Myiter;
 typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::pointer pointer;
 typedef typename _Mylist::reference reference;

 _List_unchecked_iterator()
  {
  }

 _List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };


template<class _Mylist>
 class _List_const_iterator
  : public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
 {
public:
 typedef _List_const_iterator<_Mylist> _Myiter;
 typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::const_pointer pointer;
 typedef typename _Mylist::const_reference reference;

 _List_const_iterator()
  : _Mybase()
  {
  }

 _List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
  }

 reference operator*() const
  {
#line 220 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\list"
  return (_Mylist::_Myval(this->_Ptr));
  }

 _Myiter& operator++()
  {
#line 240 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\list"
  this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
#line 270 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\list"
  this->_Ptr = _Mylist::_Prevnode(this->_Ptr);


  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
#line 298 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\list"
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }
 };

template<class _Mylist> inline
 typename _List_const_iterator<_Mylist>::_Unchecked_type
  _Unchecked(_List_const_iterator<_Mylist> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mylist> inline
 _List_const_iterator<_Mylist>&
  _Rechecked(_List_const_iterator<_Mylist>& _Iter,
   typename _List_const_iterator<_Mylist>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Mylist>
 class _List_iterator
  : public _List_const_iterator<_Mylist>
 {
public:
 typedef _List_iterator<_Mylist> _Myiter;
 typedef _List_const_iterator<_Mylist> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mylist::_Nodeptr _Nodeptr;
 typedef typename _Mylist::value_type value_type;
 typedef typename _Mylist::difference_type difference_type;
 typedef typename _Mylist::pointer pointer;
 typedef typename _Mylist::reference reference;

 _List_iterator()
  {
  }

 _List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };

template<class _Mylist> inline
 typename _List_iterator<_Mylist>::_Unchecked_type
  _Unchecked(_List_iterator<_Mylist> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mylist> inline
 _List_iterator<_Mylist>&
  _Rechecked(_List_iterator<_Mylist>& _Iter,
   typename _List_iterator<_Mylist>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference,
 class _Nodeptr_type>
 struct _List_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 typedef _Nodeptr_type _Nodeptr;
 };

template<class _Value_type,
 class _Voidptr>
 struct _List_node
  {
  _Voidptr _Next;
  _Voidptr _Prev;
  _Value_type _Myval;

 private:
  _List_node& operator=(const _List_node&);
  };

template<class _Value_type>
 struct _List_node<_Value_type, void *>
  {
  typedef _List_node<_Value_type, void *> *_Nodeptr;
  _Nodeptr _Next;
  _Nodeptr _Prev;
  _Value_type _Myval;

 private:
  _List_node& operator=(const _List_node&);
  };

template<class _Ty>
 struct _List_simple_types
  : public _Simple_types<_Ty>
 {
 typedef _List_node<_Ty, void *> _Node;
 typedef _Node *_Nodeptr;
 };

template<class _Ty,
 class _Alloc0>
 struct _List_base_types
 {
 typedef _Alloc0 _Alloc;
 typedef _List_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;


 typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
  _Voidptr;
 typedef _List_node<typename _Alty::value_type,
  _Voidptr> _Node;

 typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
 typedef typename _Alnod_type::pointer _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _List_simple_types<typename _Alty::value_type>,
  _List_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference,
   _Nodeptr> >::type
  _Val_types;
 };


template<class _Val_types>
 class _List_val
  : public _Container_base
 {
public:
 typedef _List_val<_Val_types> _Myt;

 typedef typename _Val_types::_Nodeptr _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _List_const_iterator<_Myt> const_iterator;
 typedef _List_iterator<_Myt> iterator;

 typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
 typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;

 _List_val()
  {
  this->_Myhead = 0;
  this->_Mysize = 0;
  }

 static _Nodepref _Nextnode(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Next);
  }

 static _Nodepref _Prevnode(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Prev);
  }

 static reference _Myval(_Nodeptr _Pnode)
  {
  return ((reference)_Pnode->_Myval);
  }

 _Nodeptr _Myhead;
 size_type _Mysize;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _List_alloc
  : public _List_val<typename _Alloc_types::_Val_types>
 {
public:
 typename _Alloc_types::_Alnod_type _Alnod;

 typedef _List_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;


 _List_alloc(const _Alloc& _Al = _Alloc())
  : _Alnod(_Al)
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_List_alloc() throw ()
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Change_alloc(const _Alty& _Al)
  {
  this->_Alnod = _Al;
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Swap_adl(this->_Alnod, _Right._Alnod);
  }
#line 639 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\list"
 _Nodeptr _Buyheadnode()
  {
  return (_Buynode0(_Nodeptr(), _Nodeptr()));
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  this->_Alnod.destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  this->_Alnod.destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  this->_Alnod.deallocate(_Pnode, 1);
  }

 _Nodeptr _Buynode0(_Nodeptr _Next,
  _Nodeptr _Prev)
  {
  _Nodeptr _Pnode = this->_Alnod.allocate(1);

  if (_Next == _Nodeptr())
   {
   _Next = _Pnode;
   _Prev = _Pnode;
   }
  try {
  this->_Alnod.construct(
   ::std:: addressof(this->_Nextnode(_Pnode)), _Next);
  this->_Alnod.construct(
   ::std:: addressof(this->_Prevnode(_Pnode)), _Prev);
  } catch (...) {
  this->_Alnod.deallocate(_Pnode, 1);
  throw;
  }

  return (_Pnode);
  }

 _Alty& _Getal()
  {
  return (this->_Alnod);
  }

 const _Alty& _Getal() const
  {
  return (this->_Alnod);
  }
 };


template<class _Alloc_types>
 class _List_alloc<false, _Alloc_types>
  : public _List_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _List_alloc<false, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;


 _List_alloc(const _Alloc& = _Alloc())
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_List_alloc() throw ()
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Change_alloc(const _Alty&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
#line 765 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\list"
 _Nodeptr _Buyheadnode()
  {
  return (_Buynode0(_Nodeptr(), _Nodeptr()));
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }

 _Nodeptr _Buynode0(_Nodeptr _Next,
  _Nodeptr _Prev)
  {
  _Nodeptr _Pnode = this->_Getal().allocate(1);

  if (_Next == _Nodeptr())
   {
   _Next = _Pnode;
   _Prev = _Pnode;
   }
  try {
  this->_Getal().construct(
   ::std:: addressof(this->_Nextnode(_Pnode)), _Next);
  this->_Getal().construct(
   ::std:: addressof(this->_Prevnode(_Pnode)), _Prev);
  } catch (...) {
  this->_Getal().deallocate(_Pnode, 1);
  throw;
  }

  return (_Pnode);
  }

 _Alty _Getal() const
  {
  return (_Alty());
  }
 };


template<class _Ty,
 class _Alloc>
 class _List_buy
  : public _List_alloc<!is_empty<_Alloc>::value,
   _List_base_types<_Ty, _Alloc> >
 {
public:
 typedef _List_alloc<!is_empty<_Alloc>::value,
  _List_base_types<_Ty, _Alloc> > _Mybase;
 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Nodeptr _Nodeptr;

 _List_buy(const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
  }

 template<class... _Valty>
  _Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
   _Valty&&... _Val)
  {
  _Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

  try {
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Pnode)),
    ::std:: forward<_Valty>(_Val)...);
  } catch (...) {
  this->_Getal().deallocate(_Pnode, 1);
  throw;
  }

  return (_Pnode);
  }


 void _Freenode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }
 };


template<class _Ty,
 class _Alloc = allocator<_Ty> >
 class list
  : public _List_buy<_Ty, _Alloc>
 {
public:
 typedef list<_Ty, _Alloc> _Myt;
 typedef _List_buy<_Ty, _Alloc> _Mybase;
 typedef typename _Mybase::_Node _Node;
 typedef typename _Mybase::_Nodeptr _Nodeptr;
 typedef typename _Mybase::_Alty _Alty;

 typedef _Alloc allocator_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
 typedef typename _Mybase::value_type value_type;

 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::_Unchecked_const_iterator
  _Unchecked_const_iterator;
 typedef typename _Mybase::_Unchecked_iterator
  _Unchecked_iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 list()
  : _Mybase()
  {
  }

 explicit list(const _Alloc& _Al)
  : _Mybase(_Al)
  {
  }

 explicit list(size_type _Count)
  : _Mybase()
  {
  resize(_Count);
  }

 list(size_type _Count, const _Ty& _Val)
  : _Mybase()
  {
  _Construct_n(_Count, _Val);
  }

 list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct_n(_Count, _Val);
  }

 list(const _Myt& _Right)

  : _Mybase(_Right._Getal().select_on_container_copy_construction())


  {
  try {
  insert(begin(), _Right.begin(), _Right.end());
  } catch (...) {
  _Tidy();
  throw;
  }
  }

 list(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  try {
  insert(begin(), _Right.begin(), _Right.end());
  } catch (...) {
  _Tidy();
  throw;
  }
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>::type>
  list(_Iter _First, _Iter _Last)
  : _Mybase()
  {
  _Construct(_First, _Last);
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>::type>
  list(_Iter _First, _Iter _Last, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct(_First, _Last);
  }

 template<class _Iter>
  void _Construct(_Iter _First, _Iter _Last)
  {
  try {
  insert(begin(), _First, _Last);
  } catch (...) {
  _Tidy();
  throw;
  }
  }

 void _Construct_n(size_type _Count,
  const _Ty& _Val)
  {
  try {
  _Insert_n(_Unchecked_begin(), _Count, _Val);
  } catch (...) {
  _Tidy();
  throw;
  }
  }

 list(_Myt&& _Right)
  : _Mybase(_Right._Getal())
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 list(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   clear();

   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Change_alloc(_Right._Getal());

   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right)
  {
  this->_Swap_all(_Right);
  _Swap_adl(this->_Myhead, _Right._Myhead);
  ::std:: swap(this->_Mysize, _Right._Mysize);
  }

 void push_front(_Ty&& _Val)
  {
  _Insert(_Unchecked_begin(), ::std:: forward<_Ty>(_Val));
  }

 void push_back(_Ty&& _Val)
  {
  _Insert(_Unchecked_end(), ::std:: forward<_Ty>(_Val));
  }

 iterator insert(const_iterator _Where, _Ty&& _Val)
  {
  return (emplace(_Where, ::std:: forward<_Ty>(_Val)));
  }

 template<class... _Valty>
  void emplace_front(_Valty&&... _Val)
  {
  _Insert(_Unchecked_begin(), ::std:: forward<_Valty>(_Val)...);
  }

 template<class... _Valty>
  void emplace_back(_Valty&&... _Val)
  {
  _Insert(_Unchecked_end(), ::std:: forward<_Valty>(_Val)...);
  }

 template<class... _Valty>
  iterator emplace(const_iterator _Where, _Valty&&... _Val)
  {





  _Insert(_Where._Unchecked(), ::std:: forward<_Valty>(_Val)...);
  return (_Make_iter(--_Where));
  }

 template<class... _Valty>
  void _Insert(_Unchecked_const_iterator _Where,
  _Valty&&... _Val)
  {
  _Nodeptr _Pnode = _Where._Mynode();
  _Nodeptr _Newnode =
   this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
    ::std:: forward<_Valty>(_Val)...);
  _Incsize(1);
  this->_Prevnode(_Pnode) = _Newnode;
  this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
  }


 list(::std:: initializer_list<_Ty> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  insert(begin(), _Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<_Ty> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void assign(::std:: initializer_list<_Ty> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<_Ty> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 ~list() throw ()
  {
  _Tidy();
  }

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    clear();
    this->_Change_alloc(_Right._Getal());
    }

   assign(_Right.begin(), _Right.end());
   }
  return (*this);
  }

 iterator begin() throw ()
  {
  return (iterator(this->_Nextnode(this->_Myhead), this));
  }

 const_iterator begin() const throw ()
  {
  return (const_iterator(this->_Nextnode(this->_Myhead), this));
  }

 iterator end() throw ()
  {
  return (iterator(this->_Myhead, this));
  }

 const_iterator end() const throw ()
  {
  return (const_iterator(this->_Myhead, this));
  }

 _Unchecked_iterator _Unchecked_begin()
  {
  return (_Unchecked_iterator(this->_Nextnode(this->_Myhead),
   this));
  }

 _Unchecked_const_iterator _Unchecked_begin() const
  {
  return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead),
   this));
  }

 _Unchecked_iterator _Unchecked_end()
  {
  return (_Unchecked_iterator(this->_Myhead, this));
  }

 _Unchecked_const_iterator _Unchecked_end() const
  {
  return (_Unchecked_const_iterator(this->_Myhead, this));
  }

 iterator _Make_iter(const_iterator _Where) const throw ()
  {
  return (iterator(_Where._Ptr, this));
  }

 iterator _Make_iter(_Unchecked_const_iterator _Where) const
  {
  return (iterator(_Where._Ptr, this));
  }

 reverse_iterator rbegin() throw ()
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const throw ()
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() throw ()
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const throw ()
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const throw ()
  {
  return (((const _Myt *)this)->begin());
  }

 const_iterator cend() const throw ()
  {
  return (((const _Myt *)this)->end());
  }

 const_reverse_iterator crbegin() const throw ()
  {
  return (((const _Myt *)this)->rbegin());
  }

 const_reverse_iterator crend() const throw ()
  {
  return (((const _Myt *)this)->rend());
  }

 void resize(size_type _Newsize)
  {
  if (this->_Mysize < _Newsize)
   {
   size_type _Count = 0;
   try {
   for (; this->_Mysize < _Newsize; ++_Count)
    _Insert(_Unchecked_end());
   } catch (...) {
   for (; 0 < _Count; --_Count)
    pop_back();
   throw;
   }
   }
  else
   while (_Newsize < this->_Mysize)
    pop_back();
  }

 void resize(size_type _Newsize, const _Ty& _Val)
  {
  if (this->_Mysize < _Newsize)
   _Insert_n(_Unchecked_end(), _Newsize - this->_Mysize, _Val);
  else
   while (_Newsize < this->_Mysize)
    pop_back();
  }

 size_type size() const throw ()
  {
  return (this->_Mysize);
  }

 size_type max_size() const throw ()
  {
  return (this->_Getal().max_size());
  }

 bool empty() const throw ()
  {
  return (this->_Mysize == 0);
  }

 allocator_type get_allocator() const throw ()
  {
  return (this->_Getal());
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(--end()));
  }

 const_reference back() const
  {
  return (*(--end()));
  }

 void push_front(const _Ty& _Val)
  {
  _Insert(_Unchecked_begin(), _Val);
  }

 void pop_front()
  {
  erase(begin());
  }

 void push_back(const _Ty& _Val)
  {
  _Insert(_Unchecked_end(), _Val);
  }

 void pop_back()
  {
  erase(--end());
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   void>::type
  assign(_Iter _First, _Iter _Last)
  {
  iterator _Old = begin();
  try {
  for (; _First != _Last && _Old != end(); ++_First, ++_Old)
   _Reusenode(_Old, *_First);
  for (; _First != _Last; ++_First)
   _Insert(_Unchecked_end(), *_First);
  } catch (...) {
  clear();
  throw;
  }
  erase(_Old, end());
  }

 template<class _TArg>
  void _Reusenode(iterator _Where, _TArg&& _Arg)
  {
  try {
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Where._Ptr)));
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Where._Ptr)),
   ::std:: forward<_TArg>(_Arg));
  } catch (...) {
  _Unlinknode(_Where);
  this->_Getal().destroy(
   ::std:: addressof(this->_Nextnode(_Where._Ptr)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Prevnode(_Where._Ptr)));
  this->_Getal().deallocate(_Where._Ptr, 1);
  throw;
  }
  }

 void assign(size_type _Count, const _Ty& _Val)
  {
  clear();
  _Insert_n(_Unchecked_begin(), _Count, _Val);
  }

 iterator insert(const_iterator _Where, const _Ty& _Val)
  {





  _Insert(_Where._Unchecked(), _Val);
  return (_Make_iter(--_Where));
  }

 iterator insert(const_iterator _Where, size_type _Count, const _Ty& _Val)
  {





  iterator _Prev = _Make_iter(_Where);
  if (_Prev == begin())
   {
   _Insert_n(_Where._Unchecked(), _Count, _Val);
   return (begin());
   }
  else
   {
   --_Prev;
   _Insert_n(_Where._Unchecked(), _Count, _Val);
   return (++_Prev);
   }
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   iterator>::type
  insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {





  iterator _Prev = _Make_iter(_Where);
  if (_Prev == begin())
   {
   _Insert_range(_Where._Unchecked(), _First, _Last,
    _Iter_cat(_First));
   return (begin());
   }
  else
   {
   --_Prev;
   _Insert_range(_Where._Unchecked(), _First, _Last,
    _Iter_cat(_First));
   return (++_Prev);
   }
  }

 template<class _Iter>
  void _Insert_range(_Unchecked_const_iterator _Where,
   _Iter _First, _Iter _Last, input_iterator_tag)
  {
  size_type _Num = 0;

  try {
  for (; _First != _Last; ++_First, ++_Num)
   _Insert(_Where, *_First);
  } catch (...) {
  for (; 0 < _Num; --_Num)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
  throw;
  }
  }

 template<class _Iter>
  void _Insert_range(_Unchecked_const_iterator _Where,
   _Iter _First, _Iter _Last, forward_iterator_tag)
  {
                             ;
  _Iter _Next = _First;

  try {
  for (; _First != _Last; ++_First)
   _Insert(_Where, *_First);
  } catch (...) {
  for (; _Next != _First; ++_Next)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
  throw;
  }
  }

 _Nodeptr _Unlinknode(const_iterator _Where)
  {







  _Nodeptr _Pnode = (_Where)._Mynode();


  this->_Nextnode(this->_Prevnode(_Pnode)) =
   this->_Nextnode(_Pnode);
  this->_Prevnode(this->_Nextnode(_Pnode)) =
   this->_Prevnode(_Pnode);

  --this->_Mysize;
  return (_Pnode);
  }

 iterator erase(const_iterator _Where)
  {
  _Nodeptr _Pnode = _Unlinknode(_Where++);
  this->_Freenode(_Pnode);
  return (_Make_iter(_Where));
  }

 void _Unchecked_erase(_Unchecked_const_iterator _Where)
  {
  _Nodeptr _Pnode = _Where._Mynode();

  this->_Nextnode(this->_Prevnode(_Pnode)) =
   this->_Nextnode(_Pnode);
  this->_Prevnode(this->_Nextnode(_Pnode)) =
   this->_Prevnode(_Pnode);
  this->_Freenode(_Pnode);
  --this->_Mysize;
  }

 iterator erase(const_iterator _First, const_iterator _Last)
  {
  if (_First == begin() && _Last == end())
   {
   clear();
   return (end());
   }
  else
   {
   while (_First != _Last)
    _First = erase(_First);
   return (_Make_iter(_Last));
   }
  }

 void clear() throw ()
  {




  _Nodeptr _Pnode = this->_Nextnode(this->_Myhead);
  this->_Nextnode(this->_Myhead) = this->_Myhead;
  this->_Prevnode(this->_Myhead) = this->_Myhead;
  this->_Mysize = 0;

  for (_Nodeptr _Pnext; _Pnode != this->_Myhead; _Pnode = _Pnext)
   {
   _Pnext = this->_Nextnode(_Pnode);
   this->_Freenode(_Pnode);
   }
  }

 void swap(_Myt& _Right)
  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }

  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }

  else





   ::std:: terminate();

  }

 void splice(const_iterator _Where, _Myt& _Right)
  {
  if (this != &_Right && !_Right.empty())
   {
   _Splice(_Where, _Right, _Right.begin(), _Right.end(),
    _Right._Mysize);
   }
  }

 void splice(const_iterator _Where, _Myt&& _Right)
  {
  splice(_Where, (_Myt&)_Right);
  }

 void splice(const_iterator _Where, _Myt& _Right,
  const_iterator _First)
  {






  if (_First != _Right.end())


   {
   const_iterator _Last = _First;
   ++_Last;
   if (this != &_Right
    || (_Where != _First && _Where != _Last))
    _Splice(_Where, _Right, _First, _Last, 1);
   }
  }

 void splice(const_iterator _Where, _Myt&& _Right,
  const_iterator _First)
  {
  splice(_Where, (_Myt&)_Right, _First);
  }

 void splice(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last)
  {
  if (_First != _Last && (this != &_Right || _Where != _Last))
   {
   size_type _Count = 0;

   if (this == &_Right)
    ;
   else if (_First == _Right.begin() && _Last == _Right.end())
    _Count = _Right._Mysize;
   else
    {
    const_iterator _Next = _First;

    for (; _Next != _Last; ++_Next, ++_Count)
     if (_Next == _Right.end())
      _Xlength_error("list<T> bad splice");
    }
   _Splice(_Where, _Right, _First, _Last, _Count);
   }
  }

 void splice(const_iterator _Where,
  _Myt&& _Right, const_iterator _First, const_iterator _Last)
  {
  splice(_Where, (_Myt&)_Right, _First, _Last);
  }

 void remove(const _Ty& _Val)
  {
  iterator _Val_it = end();

  for (iterator _First = begin(); _First != end(); )
   if (*_First == _Val)
    if (::std:: addressof(*_First) == ::std:: addressof(_Val))
     _Val_it = _First++;
    else
     _First = erase(_First);
   else
    ++_First;

  if (_Val_it != end())
   erase(_Val_it);
  }

 template<class _Pr1>
  void remove_if(_Pr1 _Pred)
  {
  for (iterator _First = begin(); _First != end(); )
   if (_Pred(*_First))
    _First = erase(_First);
   else
    ++_First;
  }

 void unique()
  {
  unique(equal_to<>());
  }

 template<class _Pr2>
  void unique(_Pr2 _Pred)
  {
  const _Nodeptr _Phead = this->_Myhead;
  _Nodeptr _Pprev = this->_Nextnode(_Phead);
  _Nodeptr _Pnode = this->_Nextnode(_Pprev);

  while (_Pnode != _Phead)
   if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
    {
    const _Nodeptr _Perase = _Pnode;
    _Pnode = this->_Nextnode(_Pnode);

    this->_Nextnode(_Pprev) = _Pnode;
    this->_Prevnode(_Pnode) = _Pprev;
    this->_Freenode(_Perase);

    --this->_Mysize;
    }
   else
    {
    _Pprev = _Pnode;
    _Pnode = this->_Nextnode(_Pnode);
    }
  }

 void merge(_Myt& _Right)
  {
  merge(_Right, less<>());
  }

 void merge(_Myt&& _Right)
  {
  merge((_Myt&)_Right);
  }

 template<class _Pr2>
  void merge(_Myt& _Right, _Pr2 _Pred)
  {
  if (&_Right != this)
   {
   iterator _First1 = begin(), _Last1 = end();
   iterator _First2 = _Right.begin(), _Last2 = _Right.end();
                                            ;
                                            ;

   while (_First1 != _Last1 && _First2 != _Last2)
    if (_Pred(*_First2, *_First1))
     {
     iterator _Mid2 = _First2;
     _Splice(_First1, _Right, _First2, ++_Mid2, 1);
     _First2 = _Mid2;
     }
    else
     ++_First1;

   if (_First2 != _Last2)
    _Splice(_Last1, _Right, _First2, _Last2,
     _Right._Mysize);
   }
  }

 template<class _Pr2>
  void merge(_Myt&& _Right, _Pr2 _Pred)
  {
  merge((_Myt&)_Right, _Pred);
  }

 void sort()
  {
  sort(less<>());
  }

 template<class _Pr2>
  void sort(_Pr2 _Pred)
  {
  if (2 <= this->_Mysize)
   {
   const size_t _MAXBINS = 25;
   _Myt _Templist(this->_Getal()), _Binlist[_MAXBINS + 1];
   size_t _Maxbin = 0;

   while (!empty())
    {
    _Templist._Splice_same(_Templist.begin(), *this, begin(),
     ++begin(), 1);

    size_t _Bin;
    for (_Bin = 0; _Bin < _Maxbin && !_Binlist[_Bin].empty();
     ++_Bin)
     {
     _Binlist[_Bin].merge(_Templist, _Pred);
     _Binlist[_Bin].swap(_Templist);
     }

    if (_Bin == _MAXBINS)
     _Binlist[_Bin - 1].merge(_Templist, _Pred);
    else
     {
     _Binlist[_Bin].swap(_Templist);
     if (_Bin == _Maxbin)
      ++_Maxbin;
     }
    }

   for (size_t _Bin = 1; _Bin < _Maxbin; ++_Bin)
    _Binlist[_Bin].merge(_Binlist[_Bin - 1],
     _Pred);

                                 ;

   splice(begin(), _Binlist[_Maxbin - 1]);
   }
  }

 void reverse() throw ()
  {
  const _Nodeptr _Phead = this->_Myhead;
  _Nodeptr _Pnode = _Phead;

  for (; ; )
   {
   const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
   this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
   this->_Prevnode(_Pnode) = _Pnext;

   if (_Pnext == _Phead)
    break;
   _Pnode = _Pnext;
   }
  }

 void _Splice(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last,
  size_type _Count)
  {
#line 1831 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\list"
  if (this->_Getal() != _Right._Getal())
   ::std:: terminate();


  _Splice_same(_Where, _Right, _First, _Last, _Count);
  }

 void _Splice_same(const_iterator _Where,
  _Myt& _Right, const_iterator _First, const_iterator _Last,
  size_type _Count)
  {
  if (this != &_Right)
   {
   _Incsize(_Count);
   _Right._Mysize -= _Count;
   }
  this->_Nextnode(this->_Prevnode(_First._Mynode())) =
   _Last._Mynode();
  this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
   _Where._Mynode();
  this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
   _First._Mynode();

  _Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
  this->_Prevnode(_Where._Mynode()) =
   this->_Prevnode(_Last._Mynode());
  this->_Prevnode(_Last._Mynode()) =
   this->_Prevnode(_First._Mynode());
  this->_Prevnode(_First._Mynode()) = _Pnode;
  }

 void _Unchecked_splice(_Unchecked_const_iterator _Where,
  _Unchecked_const_iterator _First,
  _Unchecked_const_iterator _Last)
  {
  this->_Nextnode(this->_Prevnode(_First._Mynode())) =
   _Last._Mynode();
  this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
   _Where._Mynode();
  this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
   _First._Mynode();

  _Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
  this->_Prevnode(_Where._Mynode()) =
   this->_Prevnode(_Last._Mynode());
  this->_Prevnode(_Last._Mynode()) =
   this->_Prevnode(_First._Mynode());
  this->_Prevnode(_First._Mynode()) = _Pnode;
  }

 void _Tidy()
  {
  clear();
  }

 void _Insert_n(_Unchecked_const_iterator _Where,
  size_type _Count, const _Ty& _Val)
  {
  size_type _Countsave = _Count;

  try {
  for (; 0 < _Count; --_Count)
   _Insert(_Where, _Val);
  } catch (...) {
  for (; _Count < _Countsave; ++_Count)
   {
   _Unchecked_const_iterator _Before = _Where;
   _Unchecked_erase(--_Before);
   }
  throw;
  }
  }

 void _Incsize(size_type _Count)
  {
  if (max_size() - this->_Mysize - 1 < _Count)
   _Xlength_error("list<T> too long");
  this->_Mysize += _Count;
  }
#line 1928 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\list"
 };



template<class _Ty,
 class _Alloc> inline
 void swap(list<_Ty, _Alloc>& _Left, list<_Ty, _Alloc>& _Right)
 {
 _Left.swap(_Right);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator==(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (_Left.size() == _Right.size()
  && equal(_Left.begin(), _Left.end(), _Right.begin()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator!=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (lexicographical_compare(_Left.begin(), _Left.end(),
  _Right.begin(), _Right.end()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>=(const list<_Ty, _Alloc>& _Left,
  const list<_Ty, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }
}

#pragma warning(pop)
#pragma pack(pop)
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h"
#line 62 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h"
#pragma warning(push)
#pragma warning(disable: 4127)





template <typename T> class QVector;
template <typename T> class QSet;

struct __declspec(dllimport) QListData {
    struct Data {
        QtPrivate::RefCount ref;
        int alloc, begin, end;
        void *array[1];
    };
    enum { DataHeaderSize = sizeof(Data) - sizeof(void *) };

    Data *detach(int alloc);
    Data *detach_grow(int *i, int n);
    void realloc(int alloc);
    inline void dispose() { dispose(d); }
    static void dispose(Data *d);
    static const Data shared_null;
    Data *d;
    void **erase(void **xi);
    void **append(int n);
    void **append();
    void **append(const QListData &l);
    void **prepend();
    void **insert(int i);
    void remove(int i);
    void remove(int i, int n);
    void move(int from, int to);
    inline int size() const { return d->end - d->begin; }
    inline bool isEmpty() const { return d->end == d->begin; }
    inline void **at(int i) const { return d->array + d->begin + i; }
    inline void **begin() const { return d->array + d->begin; }
    inline void **end() const { return d->array + d->end; }
};

template <typename T>
class QList
{
    struct Node { void *v;



        inline T &t()
        { return *reinterpret_cast<T*>(QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic
                                       ? v : this); }

    };

    union { QListData p; QListData::Data *d; };

public:
    inline QList() : d(const_cast<QListData::Data *>(&QListData::shared_null)) { }
    QList(const QList<T> &l);
    ~QList();
    QList<T> &operator=(const QList<T> &l);

    inline QList(QList<T> &&other) : d(other.d) { other.d = const_cast<QListData::Data *>(&QListData::shared_null); }
    inline QList &operator=(QList<T> &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QList<T> &other) { qSwap(d, other.d); }





    bool operator==(const QList<T> &l) const;
    inline bool operator!=(const QList<T> &l) const { return !(*this == l); }

    inline int size() const { return p.size(); }

    inline void detach() { if (d->ref.isShared()) detach_helper(); }

    inline void detachShared()
    {

        if (d->ref.isShared() && this->d != &QListData::shared_null)
            detach_helper();
    }

    inline bool isDetached() const { return !d->ref.isShared(); }

    inline void setSharable(bool sharable)
    {
        if (sharable == d->ref.isSharable())
            return;
        if (!sharable)
            detach();
        if (d != &QListData::shared_null)
            d->ref.setSharable(sharable);
    }

    inline bool isSharedWith(const QList<T> &other) const { return d == other.d; }

    inline bool isEmpty() const { return p.isEmpty(); }

    void clear();

    const T &at(int i) const;
    const T &operator[](int i) const;
    T &operator[](int i);

    void reserve(int size);
    void append(const T &t);
    void append(const QList<T> &t);
    void prepend(const T &t);
    void insert(int i, const T &t);
    void replace(int i, const T &t);
    void removeAt(int i);
    int removeAll(const T &t);
    bool removeOne(const T &t);
    T takeAt(int i);
    T takeFirst();
    T takeLast();
    void move(int from, int to);
    void swap(int i, int j);
    int indexOf(const T &t, int from = 0) const;
    int lastIndexOf(const T &t, int from = -1) const;
    bool contains(const T &t) const;
    int count(const T &t) const;

    class const_iterator;

    class iterator {
    public:
        Node *i;
        typedef std::random_access_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;

        inline iterator() : i(0) {}
        inline iterator(Node *n) : i(n) {}
        inline iterator(const iterator &o): i(o.i){}
        inline T &operator*() const { return i->t(); }
        inline T *operator->() const { return &i->t(); }
        inline T &operator[](int j) const { return i[j].t(); }
        inline bool operator==(const iterator &o) const { return i == o.i; }
        inline bool operator!=(const iterator &o) const { return i != o.i; }
        inline bool operator<(const iterator& other) const { return i < other.i; }
        inline bool operator<=(const iterator& other) const { return i <= other.i; }
        inline bool operator>(const iterator& other) const { return i > other.i; }
        inline bool operator>=(const iterator& other) const { return i >= other.i; }

        inline bool operator==(const const_iterator &o) const
            { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const
            { return i != o.i; }
        inline bool operator<(const const_iterator& other) const
            { return i < other.i; }
        inline bool operator<=(const const_iterator& other) const
            { return i <= other.i; }
        inline bool operator>(const const_iterator& other) const
            { return i > other.i; }
        inline bool operator>=(const const_iterator& other) const
            { return i >= other.i; }

        inline iterator &operator++() { ++i; return *this; }
        inline iterator operator++(int) { Node *n = i; ++i; return n; }
        inline iterator &operator--() { i--; return *this; }
        inline iterator operator--(int) { Node *n = i; i--; return n; }
        inline iterator &operator+=(int j) { i+=j; return *this; }
        inline iterator &operator-=(int j) { i-=j; return *this; }
        inline iterator operator+(int j) const { return iterator(i+j); }
        inline iterator operator-(int j) const { return iterator(i-j); }
        inline int operator-(iterator j) const { return int(i - j.i); }
    };
    friend class iterator;

    class const_iterator {
    public:
        Node *i;
        typedef std::random_access_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef const T *pointer;
        typedef const T &reference;

        inline const_iterator() : i(0) {}
        inline const_iterator(Node *n) : i(n) {}
        inline const_iterator(const const_iterator &o): i(o.i) {}



        inline const_iterator(const iterator &o): i(o.i) {}

        inline const T &operator*() const { return i->t(); }
        inline const T *operator->() const { return &i->t(); }
        inline const T &operator[](int j) const { return i[j].t(); }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }
        inline bool operator<(const const_iterator& other) const { return i < other.i; }
        inline bool operator<=(const const_iterator& other) const { return i <= other.i; }
        inline bool operator>(const const_iterator& other) const { return i > other.i; }
        inline bool operator>=(const const_iterator& other) const { return i >= other.i; }
        inline const_iterator &operator++() { ++i; return *this; }
        inline const_iterator operator++(int) { Node *n = i; ++i; return n; }
        inline const_iterator &operator--() { i--; return *this; }
        inline const_iterator operator--(int) { Node *n = i; i--; return n; }
        inline const_iterator &operator+=(int j) { i+=j; return *this; }
        inline const_iterator &operator-=(int j) { i-=j; return *this; }
        inline const_iterator operator+(int j) const { return const_iterator(i+j); }
        inline const_iterator operator-(int j) const { return const_iterator(i-j); }
        inline int operator-(const_iterator j) const { return int(i - j.i); }
    };
    friend class const_iterator;


    inline iterator begin() { detach(); return reinterpret_cast<Node *>(p.begin()); }
    inline const_iterator begin() const { return reinterpret_cast<Node *>(p.begin()); }
    inline const_iterator cbegin() const { return reinterpret_cast<Node *>(p.begin()); }
    inline const_iterator constBegin() const { return reinterpret_cast<Node *>(p.begin()); }
    inline iterator end() { detach(); return reinterpret_cast<Node *>(p.end()); }
    inline const_iterator end() const { return reinterpret_cast<Node *>(p.end()); }
    inline const_iterator cend() const { return reinterpret_cast<Node *>(p.end()); }
    inline const_iterator constEnd() const { return reinterpret_cast<Node *>(p.end()); }
    iterator insert(iterator before, const T &t);
    iterator erase(iterator pos);
    iterator erase(iterator first, iterator last);


    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    inline int count() const { return p.size(); }
    inline int length() const { return p.size(); }
    inline T& first() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",294) : qt_noop()); return *begin(); }
    inline const T& first() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",295) : qt_noop()); return at(0); }
    T& last() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",296) : qt_noop()); return *(--end()); }
    const T& last() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",297) : qt_noop()); return at(count() - 1); }
    inline void removeFirst() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",298) : qt_noop()); erase(begin()); }
    inline void removeLast() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",299) : qt_noop()); erase(--end()); }
    inline bool startsWith(const T &t) const { return !isEmpty() && first() == t; }
    inline bool endsWith(const T &t) const { return !isEmpty() && last() == t; }
    QList<T> mid(int pos, int length = -1) const;

    T value(int i) const;
    T value(int i, const T &defaultValue) const;


    inline void push_back(const T &t) { append(t); }
    inline void push_front(const T &t) { prepend(t); }
    inline T& front() { return first(); }
    inline const T& front() const { return first(); }
    inline T& back() { return last(); }
    inline const T& back() const { return last(); }
    inline void pop_front() { removeFirst(); }
    inline void pop_back() { removeLast(); }
    inline bool empty() const { return isEmpty(); }
    typedef int size_type;
    typedef T value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;
    typedef qptrdiff difference_type;


    QList<T> &operator+=(const QList<T> &l);
    inline QList<T> operator+(const QList<T> &l) const
    { QList n = *this; n += l; return n; }
    inline QList<T> &operator+=(const T &t)
    { append(t); return *this; }
    inline QList<T> &operator<< (const T &t)
    { append(t); return *this; }
    inline QList<T> &operator<<(const QList<T> &l)
    { *this += l; return *this; }

    QVector<T> toVector() const;
    QSet<T> toSet() const;

    static QList<T> fromVector(const QVector<T> &vector);
    static QList<T> fromSet(const QSet<T> &set);

    static inline QList<T> fromStdList(const std::list<T> &list)
    { QList<T> tmp; std::copy(list.begin(), list.end(), std::back_inserter(tmp)); return tmp; }
    inline std::list<T> toStdList() const
    { std::list<T> tmp; std::copy(constBegin(), constEnd(), std::back_inserter(tmp)); return tmp; }

private:
    Node *detach_helper_grow(int i, int n);
    void detach_helper(int alloc);
    void detach_helper();
    void dealloc(QListData::Data *d);

    void node_construct(Node *n, const T &t);
    void node_destruct(Node *n);
    void node_copy(Node *from, Node *to, Node *src);
    void node_destruct(Node *from, Node *to);

    bool isValidIterator(const iterator &i) const
    {
        return (constBegin().i <= i.i) && (i.i <= constEnd().i);
    }
};







template <typename T>
inline void QList<T>::node_construct(Node *n, const T &t)
{
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) n->v = new T(t);
    else if (QTypeInfo<T>::isComplex) new (n) T(t);







    else ::memcpy(n, static_cast<const void *>(&t), sizeof(T));

}

template <typename T>
inline void QList<T>::node_destruct(Node *n)
{
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) delete reinterpret_cast<T*>(n->v);
    else if (QTypeInfo<T>::isComplex) reinterpret_cast<T*>(n)->~T();
}

template <typename T>
inline void QList<T>::node_copy(Node *from, Node *to, Node *src)
{
    Node *current = from;
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
        try {
            while(current != to) {
                current->v = new T(*reinterpret_cast<T*>(src->v));
                ++current;
                ++src;
            }
        } catch (...) {
            while (current-- != from)
                delete reinterpret_cast<T*>(current->v);
            throw;
        }

    } else if (QTypeInfo<T>::isComplex) {
        try {
            while(current != to) {
                new (current) T(*reinterpret_cast<T*>(src));
                ++current;
                ++src;
            }
        } catch (...) {
            while (current-- != from)
                (reinterpret_cast<T*>(current))->~T();
            throw;
        }
    } else {
        if (src != from && to - from > 0)
            memcpy(from, src, (to - from) * sizeof(Node));
    }
}

template <typename T>
inline void QList<T>::node_destruct(Node *from, Node *to)
{
    if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic)
        while(from != to) --to, delete reinterpret_cast<T*>(to->v);
    else if (QTypeInfo<T>::isComplex)
        while (from != to) --to, reinterpret_cast<T*>(to)->~T();
}

template <typename T>
inline QList<T> &QList<T>::operator=(const QList<T> &l)
{
    if (d != l.d) {
        QList<T> tmp(l);
        tmp.swap(*this);
    }
    return *this;
}
template <typename T>
inline typename QList<T>::iterator QList<T>::insert(iterator before, const T &t)
{
    ((!(isValidIterator(before))) ? qt_assert_x("QList::insert", "The specified iterator argument 'before' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",449) : qt_noop());

    int iBefore = int(before.i - reinterpret_cast<Node *>(p.begin()));
    Node *n = 0;
    if (d->ref.isShared())
        n = detach_helper_grow(iBefore, 1);
    else
        n = reinterpret_cast<Node *>(p.insert(iBefore));
    try {
        node_construct(n, t);
    } catch (...) {
        p.remove(iBefore);
        throw;
    }
    return n;
}
template <typename T>
inline typename QList<T>::iterator QList<T>::erase(iterator it)
{
    ((!(isValidIterator(it))) ? qt_assert_x("QList::erase", "The specified iterator argument 'it' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",468) : qt_noop());
    if (d->ref.isShared()) {
        int offset = int(it.i - reinterpret_cast<Node *>(p.begin()));
        it = begin();
        it += offset;
    }
    node_destruct(it.i);
    return reinterpret_cast<Node *>(p.erase(reinterpret_cast<void**>(it.i)));
}
template <typename T>
inline const T &QList<T>::at(int i) const
{ ((!(i >= 0 && i < p.size())) ? qt_assert_x("QList<T>::at", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",479) : qt_noop());
 return reinterpret_cast<Node *>(p.at(i))->t(); }
template <typename T>
inline const T &QList<T>::operator[](int i) const
{ ((!(i >= 0 && i < p.size())) ? qt_assert_x("QList<T>::operator[]", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",483) : qt_noop());
 return reinterpret_cast<Node *>(p.at(i))->t(); }
template <typename T>
inline T &QList<T>::operator[](int i)
{ ((!(i >= 0 && i < p.size())) ? qt_assert_x("QList<T>::operator[]", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",487) : qt_noop());
  detach(); return reinterpret_cast<Node *>(p.at(i))->t(); }
template <typename T>
inline void QList<T>::removeAt(int i)
{ if(i >= 0 && i < p.size()) { detach();
 node_destruct(reinterpret_cast<Node *>(p.at(i))); p.remove(i); } }
template <typename T>
inline T QList<T>::takeAt(int i)
{ ((!(i >= 0 && i < p.size())) ? qt_assert_x("QList<T>::take", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",495) : qt_noop());
 detach(); Node *n = reinterpret_cast<Node *>(p.at(i)); T t = n->t(); node_destruct(n);
 p.remove(i); return t; }
template <typename T>
inline T QList<T>::takeFirst()
{ T t = first(); removeFirst(); return t; }
template <typename T>
inline T QList<T>::takeLast()
{ T t = last(); removeLast(); return t; }

template <typename T>
inline void QList<T>::reserve(int alloc)
{
    if (d->alloc < alloc) {
        if (d->ref.isShared())
            detach_helper(alloc);
        else
            p.realloc(alloc);
    }
}

template <typename T>
inline void QList<T>::append(const T &t)
{
    if (d->ref.isShared()) {
        Node *n = detach_helper_grow(2147483647, 1);
        try {
            node_construct(n, t);
        } catch (...) {
            --d->end;
            throw;
        }
    } else {
        if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
            Node *n = reinterpret_cast<Node *>(p.append());
            try {
                node_construct(n, t);
            } catch (...) {
                --d->end;
                throw;
            }
        } else {
            Node *n, copy;
            node_construct(&copy, t);
            try {
                n = reinterpret_cast<Node *>(p.append());;
            } catch (...) {
                node_destruct(&copy);
                throw;
            }
            *n = copy;
        }
    }
}

template <typename T>
inline void QList<T>::prepend(const T &t)
{
    if (d->ref.isShared()) {
        Node *n = detach_helper_grow(0, 1);
        try {
            node_construct(n, t);
        } catch (...) {
            ++d->begin;
            throw;
        }
    } else {
        if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
            Node *n = reinterpret_cast<Node *>(p.prepend());
            try {
                node_construct(n, t);
            } catch (...) {
                ++d->begin;
                throw;
            }
        } else {
            Node *n, copy;
            node_construct(&copy, t);
            try {
                n = reinterpret_cast<Node *>(p.prepend());;
            } catch (...) {
                node_destruct(&copy);
                throw;
            }
            *n = copy;
        }
    }
}

template <typename T>
inline void QList<T>::insert(int i, const T &t)
{
    if (d->ref.isShared()) {
        Node *n = detach_helper_grow(i, 1);
        try {
            node_construct(n, t);
        } catch (...) {
            p.remove(i);
            throw;
        }
    } else {
        if (QTypeInfo<T>::isLarge || QTypeInfo<T>::isStatic) {
            Node *n = reinterpret_cast<Node *>(p.insert(i));
            try {
                node_construct(n, t);
            } catch (...) {
                p.remove(i);
                throw;
            }
        } else {
            Node *n, copy;
            node_construct(&copy, t);
            try {
                n = reinterpret_cast<Node *>(p.insert(i));;
            } catch (...) {
                node_destruct(&copy);
                throw;
            }
            *n = copy;
        }
    }
}

template <typename T>
inline void QList<T>::replace(int i, const T &t)
{
    ((!(i >= 0 && i < p.size())) ? qt_assert_x("QList<T>::replace", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",621) : qt_noop());
    detach();
    reinterpret_cast<Node *>(p.at(i))->t() = t;
}

template <typename T>
inline void QList<T>::swap(int i, int j)
{
    ((!(i >= 0 && i < p.size() && j >= 0 && j < p.size())) ? qt_assert_x("QList<T>::swap", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",630) : qt_noop());

    detach();
    void *t = d->array[d->begin + i];
    d->array[d->begin + i] = d->array[d->begin + j];
    d->array[d->begin + j] = t;
}

template <typename T>
inline void QList<T>::move(int from, int to)
{
    ((!(from >= 0 && from < p.size() && to >= 0 && to < p.size())) ? qt_assert_x("QList<T>::move", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",641) : qt_noop());

    detach();
    p.move(from, to);
}

template<typename T>
inline QList<T> QList<T>::mid(int pos, int alength) const
{
    if (alength < 0 || pos > size() - alength)
        alength = size() - pos;
    if (pos == 0 && alength == size())
        return *this;
    QList<T> cpy;
    if (alength <= 0)
        return cpy;
    cpy.reserve(alength);
    cpy.d->end = alength;
    try {
        cpy.node_copy(reinterpret_cast<Node *>(cpy.p.begin()),
                      reinterpret_cast<Node *>(cpy.p.end()),
                      reinterpret_cast<Node *>(p.begin() + pos));
    } catch (...) {

        cpy.d->end = 0;
        throw;
    }
    return cpy;
}

template<typename T>
inline T QList<T>::value(int i) const
{
    if (i < 0 || i >= p.size()) {
        return T();
    }
    return reinterpret_cast<Node *>(p.at(i))->t();
}

template<typename T>
inline T QList<T>::value(int i, const T& defaultValue) const
{
    return ((i < 0 || i >= p.size()) ? defaultValue : reinterpret_cast<Node *>(p.at(i))->t());
}

template <typename T>
inline typename QList<T>::Node *QList<T>::detach_helper_grow(int i, int c)
{
    Node *n = reinterpret_cast<Node *>(p.begin());
    QListData::Data *x = p.detach_grow(&i, c);
    try {
        node_copy(reinterpret_cast<Node *>(p.begin()),
                  reinterpret_cast<Node *>(p.begin() + i), n);
    } catch (...) {
        p.dispose();
        d = x;
        throw;
    }
    try {
        node_copy(reinterpret_cast<Node *>(p.begin() + i + c),
                  reinterpret_cast<Node *>(p.end()), n + i);
    } catch (...) {
        node_destruct(reinterpret_cast<Node *>(p.begin()),
                      reinterpret_cast<Node *>(p.begin() + i));
        p.dispose();
        d = x;
        throw;
    }

    if (!x->ref.deref())
        dealloc(x);

    return reinterpret_cast<Node *>(p.begin() + i);
}

template <typename T>
inline void QList<T>::detach_helper(int alloc)
{
    Node *n = reinterpret_cast<Node *>(p.begin());
    QListData::Data *x = p.detach(alloc);
    try {
        node_copy(reinterpret_cast<Node *>(p.begin()), reinterpret_cast<Node *>(p.end()), n);
    } catch (...) {
        p.dispose();
        d = x;
        throw;
    }

    if (!x->ref.deref())
        dealloc(x);
}

template <typename T>
inline void QList<T>::detach_helper()
{
    detach_helper(d->alloc);
}

template <typename T>
inline QList<T>::QList(const QList<T> &l)
    : d(l.d)
{
    if (!d->ref.ref()) {
        p.detach(d->alloc);

        try {
            node_copy(reinterpret_cast<Node *>(p.begin()),
                    reinterpret_cast<Node *>(p.end()),
                    reinterpret_cast<Node *>(l.p.begin()));
        } catch (...) {
            QListData::dispose(d);
            throw;
        }
    }
}

template <typename T>
inline QList<T>::~QList()
{
    if (!d->ref.deref())
        dealloc(d);
}

template <typename T>
inline bool QList<T>::operator==(const QList<T> &l) const
{
    if (p.size() != l.p.size())
        return false;
    if (d == l.d)
        return true;
    Node *i = reinterpret_cast<Node *>(p.end());
    Node *b = reinterpret_cast<Node *>(p.begin());
    Node *li = reinterpret_cast<Node *>(l.p.end());
    while (i != b) {
        --i; --li;
        if (!(i->t() == li->t()))
            return false;
    }
    return true;
}

template <typename T>
inline void QList<T>::dealloc(QListData::Data *data)
{
    node_destruct(reinterpret_cast<Node *>(data->array + data->begin),
                  reinterpret_cast<Node *>(data->array + data->end));
    QListData::dispose(data);
}


template <typename T>
inline void QList<T>::clear()
{
    *this = QList<T>();
}

template <typename T>
inline int QList<T>::removeAll(const T &_t)
{
    int index = indexOf(_t);
    if (index == -1)
        return 0;

    const T t = _t;
    detach();

    Node *i = reinterpret_cast<Node *>(p.at(index));
    Node *e = reinterpret_cast<Node *>(p.end());
    Node *n = i;
    node_destruct(i);
    while (++i != e) {
        if (i->t() == t)
            node_destruct(i);
        else
            *n++ = *i;
    }

    int removedCount = e - n;
    d->end -= removedCount;
    return removedCount;
}

template <typename T>
inline bool QList<T>::removeOne(const T &_t)
{
    int index = indexOf(_t);
    if (index != -1) {
        removeAt(index);
        return true;
    }
    return false;
}

template <typename T>
inline typename QList<T>::iterator QList<T>::erase(typename QList<T>::iterator afirst,
                                                                 typename QList<T>::iterator alast)
{
    ((!(isValidIterator(afirst))) ? qt_assert_x("QList::erase", "The specified iterator argument 'afirst' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",837) : qt_noop());
    ((!(isValidIterator(alast))) ? qt_assert_x("QList::erase", "The specified iterator argument 'alast' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",838) : qt_noop());

    if (d->ref.isShared()) {

        int offsetfirst = int(afirst.i - reinterpret_cast<Node *>(p.begin()));
        int offsetlast = int(alast.i - reinterpret_cast<Node *>(p.begin()));
        afirst = begin();
        alast = afirst;
        afirst += offsetfirst;
        alast += offsetlast;
    }

    for (Node *n = afirst.i; n < alast.i; ++n)
        node_destruct(n);
    int idx = afirst - begin();
    p.remove(idx, alast - afirst);
    return begin() + idx;
}

template <typename T>
inline QList<T> &QList<T>::operator+=(const QList<T> &l)
{
    if (!l.isEmpty()) {
        if (isEmpty()) {
            *this = l;
        } else {
            Node *n = (d->ref.isShared())
                      ? detach_helper_grow(2147483647, l.size())
                      : reinterpret_cast<Node *>(p.append(l.p));
            try {
                node_copy(n, reinterpret_cast<Node *>(p.end()),
                          reinterpret_cast<Node *>(l.p.begin()));
            } catch (...) {

                d->end -= int(reinterpret_cast<Node *>(p.end()) - n);
                throw;
            }
        }
    }
    return *this;
}

template <typename T>
inline void QList<T>::append(const QList<T> &t)
{
    *this += t;
}

template <typename T>
inline int QList<T>::indexOf(const T &t, int from) const
{
    if (from < 0)
        from = qMax(from + p.size(), 0);
    if (from < p.size()) {
        Node *n = reinterpret_cast<Node *>(p.at(from -1));
        Node *e = reinterpret_cast<Node *>(p.end());
        while (++n != e)
            if (n->t() == t)
                return int(n - reinterpret_cast<Node *>(p.begin()));
    }
    return -1;
}

template <typename T>
inline int QList<T>::lastIndexOf(const T &t, int from) const
{
    if (from < 0)
        from += p.size();
    else if (from >= p.size())
        from = p.size()-1;
    if (from >= 0) {
        Node *b = reinterpret_cast<Node *>(p.begin());
        Node *n = reinterpret_cast<Node *>(p.at(from + 1));
        while (n-- != b) {
            if (n->t() == t)
                return n - b;
        }
    }
    return -1;
}

template <typename T>
inline bool QList<T>::contains(const T &t) const
{
    Node *b = reinterpret_cast<Node *>(p.begin());
    Node *i = reinterpret_cast<Node *>(p.end());
    while (i-- != b)
        if (i->t() == t)
            return true;
    return false;
}

template <typename T>
inline int QList<T>::count(const T &t) const
{
    int c = 0;
    Node *b = reinterpret_cast<Node *>(p.begin());
    Node *i = reinterpret_cast<Node *>(p.end());
    while (i-- != b)
        if (i->t() == t)
            ++c;
    return c;
}

template <class T> class QListIterator { typedef typename QList<T>::const_iterator const_iterator; QList<T> c; const_iterator i; public: inline QListIterator(const QList<T> &container) : c(container), i(c.constBegin()) {} inline QListIterator &operator=(const QList<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };
template <class T> class QMutableListIterator { typedef typename QList<T>::iterator iterator; typedef typename QList<T>::const_iterator const_iterator; QList<T> *c; iterator i, n; inline bool item_exists() const { return const_iterator(n) != c->constEnd(); } public: inline QMutableListIterator(QList<T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableListIterator() { c->setSharable(true); } inline QMutableListIterator &operator=(QList<T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = i; } inline bool hasNext() const { return c->constEnd() != const_iterator(i); } inline T &next() { n = i++; return *n; } inline T &peekNext() const { return *i; } inline bool hasPrevious() const { return c->constBegin() != const_iterator(i); } inline T &previous() { n = --i; return *n; } inline T &peekPrevious() const { iterator p = i; return *--p; } inline void remove() { if (c->constEnd() != const_iterator(n)) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) const { if (c->constEnd() != const_iterator(n)) *n = t; } inline T &value() { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",943) : qt_noop()); return *n; } inline const T &value() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlist.h",943) : qt_noop()); return *n; } inline void insert(const T &t) { n = i = c->insert(i, t); ++i; } inline bool findNext(const T &t) { while (c->constEnd() != const_iterator(n = i)) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (c->constBegin() != const_iterator(i)) if (*(n = --i) == t) return true; n = c->end(); return false; } };




#pragma warning(pop)
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"




#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qscopedpointer.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qscopedpointer.h"
template <typename T>
struct QScopedPointerDeleter
{
    static inline void cleanup(T *pointer)
    {



        typedef char IsIncompleteType[ sizeof(T) ? 1 : -1 ];
        (void) sizeof(IsIncompleteType);

        delete pointer;
    }
};

template <typename T>
struct QScopedPointerArrayDeleter
{
    static inline void cleanup(T *pointer)
    {



        typedef char IsIncompleteType[ sizeof(T) ? 1 : -1 ];
        (void) sizeof(IsIncompleteType);

        delete [] pointer;
    }
};

struct QScopedPointerPodDeleter
{
    static inline void cleanup(void *pointer) { if (pointer) free(pointer); }
};


template <typename T>
struct QScopedPointerObjectDeleteLater
{
    static inline void cleanup(T *pointer) { if (pointer) pointer->deleteLater(); }
};

class QObject;
typedef QScopedPointerObjectDeleteLater<QObject> QScopedPointerDeleteLater;


template <typename T, typename Cleanup = QScopedPointerDeleter<T> >
class QScopedPointer
{
    typedef T *QScopedPointer:: *RestrictedBool;
public:
    explicit inline QScopedPointer(T *p = 0) : d(p)
    {
    }

    inline ~QScopedPointer()
    {
        T *oldD = this->d;
        Cleanup::cleanup(oldD);
    }

    inline T &operator*() const
    {
        ((!(d)) ? qt_assert("d","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qscopedpointer.h",114) : qt_noop());
        return *d;
    }

    inline T *operator->() const
    {
        ((!(d)) ? qt_assert("d","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qscopedpointer.h",120) : qt_noop());
        return d;
    }

    inline bool operator!() const
    {
        return !d;
    }







    inline operator RestrictedBool() const
    {
        return isNull() ? 0 : &QScopedPointer::d;
    }


    inline T *data() const
    {
        return d;
    }

    inline bool isNull() const
    {
        return !d;
    }

    inline void reset(T *other = 0)
    {
        if (d == other)
            return;
        T *oldD = d;
        d = other;
        Cleanup::cleanup(oldD);
    }

    inline T *take()
    {
        T *oldD = d;
        d = 0;
        return oldD;
    }

    inline void swap(QScopedPointer<T, Cleanup> &other)
    {
        qSwap(d, other.d);
    }

    typedef T *pointer;

protected:
    T *d;

private:
    QScopedPointer(const QScopedPointer &) = delete; QScopedPointer &operator=(const QScopedPointer &) = delete;
};

template <class T, class Cleanup>
inline bool operator==(const QScopedPointer<T, Cleanup> &lhs, const QScopedPointer<T, Cleanup> &rhs)
{
    return lhs.data() == rhs.data();
}

template <class T, class Cleanup>
inline bool operator!=(const QScopedPointer<T, Cleanup> &lhs, const QScopedPointer<T, Cleanup> &rhs)
{
    return lhs.data() != rhs.data();
}

template <class T, class Cleanup>
inline void qSwap(QScopedPointer<T, Cleanup> &p1, QScopedPointer<T, Cleanup> &p2)
{ p1.swap(p2); }


namespace std {
    template <class T, class Cleanup>
    inline void swap(::QScopedPointer<T, Cleanup> &p1, ::QScopedPointer<T, Cleanup> &p2)
    { p1.swap(p2); }
}




namespace QtPrivate {
    template <typename X, typename Y> struct QScopedArrayEnsureSameType;
    template <typename X> struct QScopedArrayEnsureSameType<X,X> { typedef X* Type; };
    template <typename X> struct QScopedArrayEnsureSameType<const X, X> { typedef X* Type; };
}

template <typename T, typename Cleanup = QScopedPointerArrayDeleter<T> >
class QScopedArrayPointer : public QScopedPointer<T, Cleanup>
{
public:
    inline QScopedArrayPointer() : QScopedPointer<T, Cleanup>(0) {}

    template <typename D>
    explicit inline QScopedArrayPointer(D *p, typename QtPrivate::QScopedArrayEnsureSameType<T,D>::Type = 0)
        : QScopedPointer<T, Cleanup>(p)
    {
    }

    inline T &operator[](int i)
    {
        return this->d[i];
    }

    inline const T &operator[](int i) const
    {
        return this->d[i];
    }

private:
    explicit inline QScopedArrayPointer(void *) {
#line 245 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qscopedpointer.h"
    }

    QScopedArrayPointer(const QScopedArrayPointer &) = delete; QScopedArrayPointer &operator=(const QScopedArrayPointer &) = delete;
};
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontainerfwd.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontainerfwd.h"
template <class Key, class T> class QCache;
template <class Key, class T> class QHash;
template <class T> class QLinkedList;
template <class T> class QList;
template <class Key, class T> class QMap;
template <class Key, class T> class QMultiHash;
template <class Key, class T> class QMultiMap;
template <class T1, class T2> struct QPair;
template <class T> class QQueue;
template <class T> class QSet;
template <class T> class QStack;
template<class T, int Prealloc = 256> class QVarLengthArray;
template <class T> class QVector;
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h"
#line 57 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h"
template<class T, int Prealloc>
class QPodList;


template<class T, int Prealloc>
class QVarLengthArray
{
public:
    inline explicit QVarLengthArray(int size = 0);

    inline QVarLengthArray(const QVarLengthArray<T, Prealloc> &other)
        : a(Prealloc), s(0), ptr(reinterpret_cast<T *>(array))
    {
        append(other.constData(), other.size());
    }

    inline ~QVarLengthArray() {
        if (QTypeInfo<T>::isComplex) {
            T *i = ptr + s;
            while (i-- != ptr)
                i->~T();
        }
        if (ptr != reinterpret_cast<T *>(array))
            free(ptr);
    }
    inline QVarLengthArray<T, Prealloc> &operator=(const QVarLengthArray<T, Prealloc> &other)
    {
        if (this != &other) {
            clear();
            append(other.constData(), other.size());
        }
        return *this;
    }

    inline void removeLast() {
        ((!(s > 0)) ? qt_assert("s > 0","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",92) : qt_noop());
        realloc(s - 1, a);
    }
    inline int size() const { return s; }
    inline int count() const { return s; }
    inline int length() const { return s; }
    inline T& first() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",98) : qt_noop()); return *begin(); }
    inline const T& first() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",99) : qt_noop()); return *begin(); }
    T& last() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",100) : qt_noop()); return *(end() - 1); }
    const T& last() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",101) : qt_noop()); return *(end() - 1); }
    inline bool isEmpty() const { return (s == 0); }
    inline void resize(int size);
    inline void clear() { resize(0); }
    inline void squeeze();

    inline int capacity() const { return a; }
    inline void reserve(int size);

    inline int indexOf(const T &t, int from = 0) const;
    inline int lastIndexOf(const T &t, int from = -1) const;
    inline bool contains(const T &t) const;

    inline T &operator[](int idx) {
        ((!(idx >= 0 && idx < s)) ? qt_assert("idx >= 0 && idx < s","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",115) : qt_noop());
        return ptr[idx];
    }
    inline const T &operator[](int idx) const {
        ((!(idx >= 0 && idx < s)) ? qt_assert("idx >= 0 && idx < s","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",119) : qt_noop());
        return ptr[idx];
    }
    inline const T &at(int idx) const { return operator[](idx); }

    T value(int i) const;
    T value(int i, const T &defaultValue) const;

    inline void append(const T &t) {
        if (s == a)
            realloc(s, s<<1);
        const int idx = s++;
        if (QTypeInfo<T>::isComplex) {
            new (ptr + idx) T(t);
        } else {
            ptr[idx] = t;
        }
    }
    void append(const T *buf, int size);
    inline QVarLengthArray<T, Prealloc> &operator<<(const T &t)
    { append(t); return *this; }
    inline QVarLengthArray<T, Prealloc> &operator+=(const T &t)
    { append(t); return *this; }

    void prepend(const T &t);
    void insert(int i, const T &t);
    void insert(int i, int n, const T &t);
    void replace(int i, const T &t);
    void remove(int i);
    void remove(int i, int n);


    inline T *data() { return ptr; }
    inline const T *data() const { return ptr; }
    inline const T * constData() const { return ptr; }
    typedef int size_type;
    typedef T value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;
    typedef qptrdiff difference_type;


    typedef T* iterator;
    typedef const T* const_iterator;

    inline iterator begin() { return ptr; }
    inline const_iterator begin() const { return ptr; }
    inline const_iterator cbegin() const { return ptr; }
    inline const_iterator constBegin() const { return ptr; }
    inline iterator end() { return ptr + s; }
    inline const_iterator end() const { return ptr + s; }
    inline const_iterator cend() const { return ptr + s; }
    inline const_iterator constEnd() const { return ptr + s; }
    iterator insert(const_iterator before, int n, const T &x);
    inline iterator insert(const_iterator before, const T &x) { return insert(before, 1, x); }
    iterator erase(const_iterator begin, const_iterator end);
    inline iterator erase(const_iterator pos) { return erase(pos, pos+1); }


    inline bool empty() const { return isEmpty(); }
    inline void push_back(const T &t) { append(t); }
    inline void pop_back() { removeLast(); }
    inline T &front() { return first(); }
    inline const T &front() const { return first(); }
    inline T &back() { return last(); }
    inline const T &back() const { return last(); }

private:
    friend class QPodList<T, Prealloc>;
    void realloc(int size, int alloc);

    int a;
    int s;
    T *ptr;
    union {
        char array[Prealloc * sizeof(T)];
        qint64 q_for_alignment_1;
        double q_for_alignment_2;
    };

    bool isValidIterator(const const_iterator &i) const
    {
        return (i <= constEnd()) && (constBegin() <= i);
    }
};

template <class T, int Prealloc>
inline QVarLengthArray<T, Prealloc>::QVarLengthArray(int asize)
    : s(asize) {
    static_assert(bool(Prealloc > 0), "QVarLengthArray Prealloc must be greater than 0.");
    ((!(s >= 0)) ? qt_assert_x("QVarLengthArray::QVarLengthArray()", "Size must be greater than or equal to 0.","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",211) : qt_noop());
    if (s > Prealloc) {
        ptr = reinterpret_cast<T *>(malloc(s * sizeof(T)));
        do { if (!(ptr)) qBadAlloc(); } while (0);
        a = s;
    } else {
        ptr = reinterpret_cast<T *>(array);
        a = Prealloc;
    }
    if (QTypeInfo<T>::isComplex) {
        T *i = ptr + s;
        while (i != ptr)
            new (--i) T;
    }
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::resize(int asize)
{ realloc(asize, qMax(asize, a)); }

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::reserve(int asize)
{ if (asize > a) realloc(s, asize); }

template <class T, int Prealloc>
inline int QVarLengthArray<T, Prealloc>::indexOf(const T &t, int from) const
{
    if (from < 0)
        from = qMax(from + s, 0);
    if (from < s) {
        T *n = ptr + from - 1;
        T *e = ptr + s;
        while (++n != e)
            if (*n == t)
                return n - ptr;
    }
    return -1;
}

template <class T, int Prealloc>
inline int QVarLengthArray<T, Prealloc>::lastIndexOf(const T &t, int from) const
{
    if (from < 0)
        from += s;
    else if (from >= s)
        from = s - 1;
    if (from >= 0) {
        T *b = ptr;
        T *n = ptr + from + 1;
        while (n != b) {
            if (*--n == t)
                return n - b;
        }
    }
    return -1;
}

template <class T, int Prealloc>
inline bool QVarLengthArray<T, Prealloc>::contains(const T &t) const
{
    T *b = ptr;
    T *i = ptr + s;
    while (i != b) {
        if (*--i == t)
            return true;
    }
    return false;
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::append(const T *abuf, int increment)
{
    ((!(abuf)) ? qt_assert("abuf","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",283) : qt_noop());
    if (increment <= 0)
        return;

    const int asize = s + increment;

    if (asize >= a)
        realloc(s, qMax(s*2, asize));

    if (QTypeInfo<T>::isComplex) {

        while (s < asize)
            new (ptr+(s++)) T(*abuf++);
    } else {
        memcpy(&ptr[s], abuf, increment * sizeof(T));
        s = asize;
    }
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::squeeze()
{ realloc(s, s); }

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::realloc(int asize, int aalloc)
{
    ((!(aalloc >= asize)) ? qt_assert("aalloc >= asize","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",309) : qt_noop());
    T *oldPtr = ptr;
    int osize = s;

    const int copySize = qMin(asize, osize);
    if (aalloc != a) {
        if (aalloc > Prealloc) {
            T* newPtr = reinterpret_cast<T *>(malloc(aalloc * sizeof(T)));
            do { if (!(newPtr)) qBadAlloc(); } while (0);

            ptr = newPtr;
            a = aalloc;
        } else {
            ptr = reinterpret_cast<T *>(array);
            a = Prealloc;
        }
        s = 0;
        if (QTypeInfo<T>::isStatic) {
            try {

                while (s < copySize) {
                    new (ptr+s) T(*(oldPtr+s));
                    (oldPtr+s)->~T();
                    s++;
                }
            } catch (...) {

                int sClean = s;
                while (sClean < osize)
                    (oldPtr+(sClean++))->~T();
                if (oldPtr != reinterpret_cast<T *>(array) && oldPtr != ptr)
                    free(oldPtr);
                throw;
            }
        } else {
            memcpy(ptr, oldPtr, copySize * sizeof(T));
        }
    }
    s = copySize;

    if (QTypeInfo<T>::isComplex) {

        while (osize > asize)
            (oldPtr+(--osize))->~T();
    }

    if (oldPtr != reinterpret_cast<T *>(array) && oldPtr != ptr)
        free(oldPtr);

    if (QTypeInfo<T>::isComplex) {

        while (s < asize)
            new (ptr+(s++)) T;
    } else {
        s = asize;
    }
}

template <class T, int Prealloc>
inline T QVarLengthArray<T, Prealloc>::value(int i) const
{
    if (uint(i) >= uint(size())) {
        return T();
    }
    return at(i);
}
template <class T, int Prealloc>
inline T QVarLengthArray<T, Prealloc>::value(int i, const T &defaultValue) const
{
    return (uint(i) >= uint(size())) ? defaultValue : at(i);
}

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::insert(int i, const T &t)
{ ((!(i >= 0 && i <= s)) ? qt_assert_x("QVarLengthArray::insert", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",383) : qt_noop());
  insert(begin() + i, 1, t); }
template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::insert(int i, int n, const T &t)
{ ((!(i >= 0 && i <= s)) ? qt_assert_x("QVarLengthArray::insert", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",387) : qt_noop());
  insert(begin() + i, n, t); }
template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::remove(int i, int n)
{ ((!(i >= 0 && n >= 0 && i + n <= s)) ? qt_assert_x("QVarLengthArray::remove", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",391) : qt_noop());
  erase(begin() + i, begin() + i + n); }
template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::remove(int i)
{ ((!(i >= 0 && i < s)) ? qt_assert_x("QVarLengthArray::remove", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",395) : qt_noop());
  erase(begin() + i, begin() + i + 1); }
template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::prepend(const T &t)
{ insert(begin(), 1, t); }

template <class T, int Prealloc>
inline void QVarLengthArray<T, Prealloc>::replace(int i, const T &t)
{
    ((!(i >= 0 && i < s)) ? qt_assert_x("QVarLengthArray::replace", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",404) : qt_noop());
    const T copy(t);
    data()[i] = copy;
}


template <class T, int Prealloc>
inline typename QVarLengthArray<T, Prealloc>::iterator QVarLengthArray<T, Prealloc>::insert(const_iterator before, size_type n, const T &t)
{
    ((!(isValidIterator(before))) ? qt_assert_x("QVarLengthArray::insert", "The specified const_iterator argument 'before' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",413) : qt_noop());

    int offset = int(before - ptr);
    if (n != 0) {
        resize(s + n);
        const T copy(t);
        if (QTypeInfo<T>::isStatic) {
            T *b = ptr + offset;
            T *j = ptr + s;
            T *i = j - n;
            while (i != b)
                *--j = *--i;
            i = b + n;
            while (i != b)
                *--i = copy;
        } else {
            T *b = ptr + offset;
            T *i = b + n;
            memmove(i, b, (s - offset - n) * sizeof(T));
            while (i != b)
                new (--i) T(copy);
        }
    }
    return ptr + offset;
}

template <class T, int Prealloc>
inline typename QVarLengthArray<T, Prealloc>::iterator QVarLengthArray<T, Prealloc>::erase(const_iterator abegin, const_iterator aend)
{
    ((!(isValidIterator(abegin))) ? qt_assert_x("QVarLengthArray::insert", "The specified const_iterator argument 'abegin' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",442) : qt_noop());
    ((!(isValidIterator(aend))) ? qt_assert_x("QVarLengthArray::insert", "The specified const_iterator argument 'aend' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvarlengtharray.h",443) : qt_noop());

    int f = int(abegin - ptr);
    int l = int(aend - ptr);
    int n = l - f;
    if (QTypeInfo<T>::isComplex) {
        std::copy(ptr + l, ptr + s, ptr + f);
        T *i = ptr + s;
        T *b = ptr + s - n;
        while (i != b) {
            --i;
            i->~T();
        }
    } else {
        memmove(ptr + f, ptr + l, (s - l) * sizeof(T));
    }
    s -= n;
    return ptr + f;
}

template <typename T, int Prealloc1, int Prealloc2>
bool operator==(const QVarLengthArray<T, Prealloc1> &l, const QVarLengthArray<T, Prealloc2> &r)
{
    if (l.size() != r.size())
        return false;
    for (int i = 0; i < l.size(); i++) {
        if (l.at(i) != r.at(i))
            return false;
    }
    return true;
}

template <typename T, int Prealloc1, int Prealloc2>
bool operator!=(const QVarLengthArray<T, Prealloc1> &l, const QVarLengthArray<T, Prealloc2> &r)
{
    return !(l == r);
}
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qisenum.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"






#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"








#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4127)
#pragma warning(disable: 4244)

namespace std {



template<class _Myvec>
 class _Vector_const_iterator
  : public _Iterator012<random_access_iterator_tag,
   typename _Myvec::value_type,
   typename _Myvec::difference_type,
   typename _Myvec::const_pointer,
   typename _Myvec::const_reference,
   _Iterator_base>
 {
public:
 typedef _Vector_const_iterator<_Myvec> _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Myvec::value_type value_type;
 typedef typename _Myvec::difference_type difference_type;
 typedef typename _Myvec::const_pointer pointer;
 typedef typename _Myvec::const_reference reference;
 typedef typename _Myvec::pointer _Tptr;

 _Vector_const_iterator()
  : _Ptr()
  {
  }

 _Vector_const_iterator(_Tptr _Parg, const _Container_base *_Pvector)
  : _Ptr(_Parg)
  {
  this->_Adopt(_Pvector);
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = (_Tptr)_Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
#line 84 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
                                          ;

  return (*this->_Ptr);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
#line 112 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
  ++this->_Ptr;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
#line 141 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
  --this->_Ptr;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
#line 170 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
  _Ptr += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr - _Right._Ptr);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Myiter& _Right) const
  {
  _Compat(_Right);
  return (this->_Ptr < _Right._Ptr);
  }

 bool operator>(const _Myiter& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Myiter& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Myiter& _Right) const
  {
  return (!(*this < _Right));
  }
#line 253 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
 void _Compat(const _Myiter&) const
  {
  }


 _Tptr _Ptr;
 };

template<class _Myvec> inline
 typename _Vector_const_iterator<_Myvec>::_Unchecked_type
  _Unchecked(_Vector_const_iterator<_Myvec> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Myvec> inline
 _Vector_const_iterator<_Myvec>&
  _Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
   typename _Vector_const_iterator<_Myvec>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Myvec> inline
 _Vector_const_iterator<_Myvec> operator+(
  typename _Vector_const_iterator<_Myvec>::difference_type _Off,
  _Vector_const_iterator<_Myvec> _Next)
 {
 return (_Next += _Off);
 }


template<class _Myvec>
 class _Vector_iterator
  : public _Vector_const_iterator<_Myvec>
 {
public:
 typedef _Vector_iterator<_Myvec> _Myiter;
 typedef _Vector_const_iterator<_Myvec> _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Myvec::value_type value_type;
 typedef typename _Myvec::difference_type difference_type;
 typedef typename _Myvec::pointer pointer;
 typedef typename _Myvec::reference reference;

 _Vector_iterator()
  {
  }

 _Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
  : _Mybase(_Parg, _Pvector)
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Myiter& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Myiter operator+(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Myiter& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Myiter operator-(difference_type _Off) const
  {
  _Myiter _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Myvec> inline
 typename _Vector_iterator<_Myvec>::_Unchecked_type
  _Unchecked(_Vector_iterator<_Myvec> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Myvec> inline
 _Vector_iterator<_Myvec>&
  _Rechecked(_Vector_iterator<_Myvec>& _Iter,
   typename _Vector_iterator<_Myvec>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }

template<class _Myvec> inline
 _Vector_iterator<_Myvec> operator+(
  typename _Vector_iterator<_Myvec>::difference_type _Off,
  _Vector_iterator<_Myvec> _Next)
 {
 return (_Next += _Off);
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference>
 struct _Vec_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 };

template<class _Ty,
 class _Alloc0>
 struct _Vec_base_types
 {
 typedef _Alloc0 _Alloc;
 typedef _Vec_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;


 typedef typename _Alty::pointer _Tptr;
 typedef typename _Alty::template rebind<_Tptr>::other _Alpty;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Simple_types<typename _Alty::value_type>,
  _Vec_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference> >::type
  _Val_types;
 };


template<class _Val_types>
 class _Vector_val
  : public _Container_base
 {
public:
 typedef _Vector_val<_Val_types> _Myt;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _Vector_iterator<_Myt> iterator;
 typedef _Vector_const_iterator<_Myt> const_iterator;

 _Vector_val()
  {
  _Myfirst = pointer();
  _Mylast = pointer();
  _Myend = pointer();
  }

 pointer _Myfirst;
 pointer _Mylast;
 pointer _Myend;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _Vector_alloc
  : public _Vector_val<typename _Alloc_types::_Val_types>
 {
public:
 typename _Alloc_types::_Alty _Alval;

 typedef _Vector_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc;
 typedef typename _Alloc_types::_Alty _Alty;


 _Vector_alloc(const _Alloc& _Al = _Alloc())
  : _Alval(_Al)
  {
  }

 void _Change_alloc(const _Alty& _Al)
  {
  this->_Alval = _Al;
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Swap_adl(this->_Alval, _Right._Alval);
  }
#line 566 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
 _Alty& _Getal()
  {
  return (this->_Alval);
  }

 const _Alty& _Getal() const
  {
  return (this->_Alval);
  }
 };

template<class _Alloc_types>
 class _Vector_alloc<false, _Alloc_types>
  : public _Vector_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _Vector_alloc<false, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc;

 typedef typename _Alloc_types::_Alty _Alty;


 _Vector_alloc(const _Alloc& = _Alloc())
  {
  }

 void _Change_alloc(const _Alty&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
#line 640 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
 _Alty _Getal() const
  {
  return (_Alty());
  }
 };


template<class _Ty,
 class _Alloc = allocator<_Ty> >
 class vector
  : public _Vector_alloc<!is_empty<_Alloc>::value,
   _Vec_base_types<_Ty, _Alloc> >
 {
public:
 typedef vector<_Ty, _Alloc> _Myt;
 typedef _Vector_alloc<!is_empty<_Alloc>::value,
  _Vec_base_types<_Ty, _Alloc> > _Mybase;
 typedef _Alloc allocator_type;

 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;




 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 vector()
  : _Mybase()
  {
  }

 explicit vector(const _Alloc& _Al)
  : _Mybase(_Al)
  {
  }

 explicit vector(size_type _Count)
  : _Mybase()
  {
  if (_Buy(_Count))
   {
   _Alty _Alval(this->_Getal());
   try {
   _Uninitialized_default_fill_n(this->_Myfirst, _Count, _Alval);
   this->_Mylast += _Count;
   } catch (...) {
   _Tidy();
   throw;
   }
   }
  }

 vector(size_type _Count, const value_type& _Val)
  : _Mybase()
  {
  _Construct_n(_Count, ::std:: addressof(_Val));
  }

 vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct_n(_Count, ::std:: addressof(_Val));
  }

 vector(const _Myt& _Right)

  : _Mybase(_Right._Getal().select_on_container_copy_construction())


  {
  if (_Buy(_Right.size()))
   try {
   this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
    this->_Myfirst);
   } catch (...) {
   _Tidy();
   throw;
   }
  }

 vector(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  if (_Buy(_Right.size()))
   try {
   this->_Mylast = _Ucopy(_Right.begin(), _Right.end(),
    this->_Myfirst);
   } catch (...) {
   _Tidy();
   throw;
   }
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>:: type>
  vector(_Iter _First, _Iter _Last)
  : _Mybase()
  {
  _Construct(_First, _Last);
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>:: type>
  vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Construct(_First, _Last);
  }

 template<class _Iter>
  void _Construct(_Iter _First, _Iter _Last)
  {
  _Construct(_First, _Last, _Iter_cat(_First));
  }

 template<class _Iter>
  void _Construct(_Iter _First, _Iter _Last, input_iterator_tag)
  {
  try {

  for (; _First != _Last; ++_First)
   emplace_back(*_First);

  } catch (...) {
  _Tidy();
  throw;
  }
  }

 template<class _Iter>
  void _Construct(_Iter _First, _Iter _Last, forward_iterator_tag)
  {
  if (_Buy(::std:: distance(_First, _Last)))
   {
   try {
   this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
   } catch (...) {
   _Tidy();
   throw;
   }
   }
  }

 void _Construct_n(size_type _Count, const value_type *_Pval)
  {
  if (_Buy(_Count))
   {
   try {
   this->_Mylast = _Ufill(this->_Myfirst, _Count, _Pval);
   } catch (...) {
   _Tidy();
   throw;
   }
   }
  }

 vector(_Myt&& _Right)
  : _Mybase(_Right._Getal())
  {
  _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  }

 vector(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(_Al)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   _Tidy();
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Change_alloc(_Right._Getal());

   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right, true_type)
  {
  this->_Swap_all((_Myt&)_Right);
  this->_Myfirst = _Right._Myfirst;
  this->_Mylast = _Right._Mylast;
  this->_Myend = _Right._Myend;

  _Right._Myfirst = pointer();
  _Right._Mylast = pointer();
  _Right._Myend = pointer();
  }

 void _Assign_rv(_Myt&& _Right, false_type)
  {
  if (get_allocator() == _Right.get_allocator())
   _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  else
   _Construct(::std:: make_move_iterator(_Right.begin()),
    ::std:: make_move_iterator(_Right.end()));
  }

 void _Assign_rv(_Myt&& _Right)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right),
   typename _Alty::propagate_on_container_move_assignment());
  }


 void push_back(value_type&& _Val)
  {
  if (_Inside(::std:: addressof(_Val)))
   {
   size_type _Idx = ::std:: addressof(_Val) - this->_Myfirst;
   if (this->_Mylast == this->_Myend)
    _Reserve(1);
   _Orphan_range(this->_Mylast, this->_Mylast);
   this->_Getal().construct(this->_Mylast,
    ::std:: forward<value_type>(this->_Myfirst[_Idx]));
   ++this->_Mylast;
   }
  else
   {
   if (this->_Mylast == this->_Myend)
    _Reserve(1);
   _Orphan_range(this->_Mylast, this->_Mylast);
   this->_Getal().construct(this->_Mylast,
    ::std:: forward<value_type>(_Val));
   ++this->_Mylast;
   }
  }

 iterator insert(const_iterator _Where, _Ty&& _Val)
  {
  return (emplace(_Where, ::std:: move(_Val)));
  }

 template<class... _Valty>
  void emplace_back(_Valty&&... _Val)
  {
  if (this->_Mylast == this->_Myend)
   _Reserve(1);
  _Orphan_range(this->_Mylast, this->_Mylast);
  this->_Getal().construct(this->_Mylast,
   ::std:: forward<_Valty>(_Val)...);
  ++this->_Mylast;
  }

 template<class... _Valty>
  iterator emplace(const_iterator _Where, _Valty&&... _Val)
  {
  size_type _Off = (_Where)._Ptr - this->_Myfirst;






  emplace_back(::std:: forward<_Valty>(_Val)...);
  ::std:: rotate(begin() + _Off, end() - 1, end());
  return (begin() + _Off);
  }


 vector(::std:: initializer_list<value_type> _Ilist,
  const _Alloc& _Al = allocator_type())
  : _Mybase(_Al)
  {
  insert(begin(), _Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<value_type> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void assign(::std:: initializer_list<value_type> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const_iterator _Where,
  ::std:: initializer_list<value_type> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 ~vector() throw ()
  {
  _Tidy();
  }

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    {
    _Tidy();
    this->_Change_alloc(_Right._Getal());
    }

   this->_Orphan_all();

   if (_Right.empty())
    clear();
   else if (_Right.size() <= size())
    {
    pointer _Ptr = _Copy_impl(_Right._Myfirst,
     _Right._Mylast, this->_Myfirst);
    _Destroy(_Ptr, this->_Mylast);
    this->_Mylast = this->_Myfirst + _Right.size();
    }
   else if (_Right.size() <= capacity())
    {
    pointer _Ptr = _Right._Myfirst + size();
    _Copy_impl(_Right._Myfirst,
     _Ptr, this->_Myfirst);
    this->_Mylast = _Ucopy(_Ptr, _Right._Mylast, this->_Mylast);
    }
   else
    {
    if (this->_Myfirst != pointer())
     {
     _Destroy(this->_Myfirst, this->_Mylast);
     this->_Getal().deallocate(this->_Myfirst,
      this->_Myend - this->_Myfirst);
     }
    if (_Buy(_Right.size()))
     try {
     this->_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
      this->_Myfirst);
     } catch (...) {
     _Tidy();
     throw;
     }
    }
   }
  return (*this);
  }

 void reserve(size_type _Count)
  {
  if (capacity() < _Count)
   {
   if (max_size() < _Count)
    _Xlen();
   _Reallocate(_Count);
   }
  }

 size_type capacity() const throw ()
  {
  return (this->_Myend - this->_Myfirst);
  }

 size_type _Unused_capacity() const throw ()
  {
  return (this->_Myend - this->_Mylast);
  }

 size_type _Has_unused_capacity() const throw ()
  {
  return (this->_Myend != this->_Mylast);
  }

 iterator begin() throw ()
  {
  return (iterator(this->_Myfirst, this));
  }

 const_iterator begin() const throw ()
  {
  return (const_iterator(this->_Myfirst, this));
  }

 iterator end() throw ()
  {
  return (iterator(this->_Mylast, this));
  }

 const_iterator end() const throw ()
  {
  return (const_iterator(this->_Mylast, this));
  }

 iterator _Make_iter(const_iterator _Where) const
  {
  return (iterator(_Where._Ptr, this));
  }

 reverse_iterator rbegin() throw ()
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const throw ()
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() throw ()
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const throw ()
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const throw ()
  {
  return (((const _Myt *)this)->begin());
  }

 const_iterator cend() const throw ()
  {
  return (((const _Myt *)this)->end());
  }

 const_reverse_iterator crbegin() const throw ()
  {
  return (((const _Myt *)this)->rbegin());
  }

 const_reverse_iterator crend() const throw ()
  {
  return (((const _Myt *)this)->rend());
  }

 void shrink_to_fit()
  {
  if (_Has_unused_capacity())
   {
   if (empty())
    _Tidy();
   else
    _Reallocate(size());
   }
  }

 void resize(size_type _Newsize)
  {
  if (_Newsize < size())
   _Pop_back_n(size() - _Newsize);
  else if (size() < _Newsize)
   {
   _Alty _Alval(this->_Getal());
   _Reserve(_Newsize - size());
   try {
   _Uninitialized_default_fill_n(this->_Mylast, _Newsize - size(),
    _Alval);
   } catch (...) {
   _Tidy();
   throw;
   }
   this->_Mylast += _Newsize - size();
   }
  }

 void resize(size_type _Newsize, const value_type& _Val)
  {
  if (_Newsize < size())
   _Pop_back_n(size() - _Newsize);
  else if (size() < _Newsize)
   {
   const value_type *_Ptr = ::std:: addressof(_Val);

   if (_Inside(_Ptr))
    {
    const difference_type _Idx = _Ptr
     - ::std:: addressof(*this->_Myfirst);
    _Reserve(_Newsize - size());
    _Ptr = ::std:: addressof(*this->_Myfirst) + _Idx;
    }
   else
    _Reserve(_Newsize - size());

   try {
   _Ufill(this->_Mylast, _Newsize - size(), _Ptr);
   } catch (...) {
   _Tidy();
   throw;
   }
   this->_Mylast += _Newsize - size();
   }
  }

 size_type size() const throw ()
  {
  return (this->_Mylast - this->_Myfirst);
  }

 size_type max_size() const throw ()
  {
  return (this->_Getal().max_size());
  }

 bool empty() const throw ()
  {
  return (this->_Myfirst == this->_Mylast);
  }

 _Alloc get_allocator() const throw ()
  {
  return (this->_Getal());
  }

 const_reference at(size_type _Pos) const
  {
  if (size() <= _Pos)
   _Xran();
  return (*(this->_Myfirst + _Pos));
  }

 reference at(size_type _Pos)
  {
  if (size() <= _Pos)
   _Xran();
  return (*(this->_Myfirst + _Pos));
  }

 const_reference operator[](size_type _Pos) const
  {
#line 1193 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
  return (*(this->_Myfirst + _Pos));
  }

 reference operator[](size_type _Pos)
  {
#line 1209 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
  return (*(this->_Myfirst + _Pos));
  }

 pointer data() throw ()
  {
  return (this->_Myfirst);
  }

 const_pointer data() const throw ()
  {
  return (this->_Myfirst);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

 void push_back(const value_type& _Val)
  {
  if (_Inside(::std:: addressof(_Val)))
   {
   size_type _Idx = ::std:: addressof(_Val) - this->_Myfirst;
   if (this->_Mylast == this->_Myend)
    _Reserve(1);
   _Orphan_range(this->_Mylast, this->_Mylast);
   this->_Getal().construct(this->_Mylast,
    this->_Myfirst[_Idx]);
   ++this->_Mylast;
   }
  else
   {
   if (this->_Mylast == this->_Myend)
    _Reserve(1);
   _Orphan_range(this->_Mylast, this->_Mylast);
   this->_Getal().construct(this->_Mylast,
    _Val);
   ++this->_Mylast;
   }
  }
#line 1279 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
 void pop_back()
  {
  this->_Getal().destroy(this->_Mylast - 1);
  --this->_Mylast;
  }


 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   void>::type
  assign(_Iter _First, _Iter _Last)
  {
  clear();
  _Assign(_First, _Last, _Iter_cat(_First));
  }

 template<class _Iter>
  void _Assign(_Iter _First, _Iter _Last, input_iterator_tag)
  {
  for (; _First != _Last; ++_First)
   emplace_back(*_First);
  }

 template<class _Iter>
  void _Assign(_Iter _First, _Iter _Last, forward_iterator_tag)
  {
  if (_First == _Last)
   return;

  size_type _Newsize = ::std:: distance(_First, _Last);

  if (capacity() < _Newsize)
   {
   size_type _Newcapacity = _Grow_to(_Newsize);
   _Tidy();
   _Buy(_Newcapacity);
   }

  this->_Mylast = _Ucopy(_First, _Last, this->_Myfirst);
  }

 void assign(size_type _Count, const value_type& _Val)
  {
  clear();
  insert(begin(), _Count, _Val);
  }

 iterator insert(const_iterator _Where, const _Ty& _Val)
  {
  return (_Insert_n(_Where, (size_type)1, _Val));
  }

 iterator insert(const_iterator _Where, size_type _Count,
  const _Ty& _Val)
  {
  return (_Insert_n(_Where, _Count, _Val));
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   iterator>::type
  insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = (_Where)._Ptr - this->_Myfirst;
  _Insert(_Where, _First, _Last, _Iter_cat(_First));
  return (begin() + _Off);
  }

 template<class _Iter>
  void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
   input_iterator_tag)
  {
  size_type _Off = (_Where)._Ptr - this->_Myfirst;






  if (_First != _Last)
   {
   size_type _Oldsize = size();

   try {
   for (; _First != _Last; ++_First)
    push_back(*_First);

   } catch (...) {
   erase(begin() + _Oldsize, end());
   throw;
   }

   ::std:: rotate(begin() + _Off, begin() + _Oldsize, end());
   }
  }

 template<class _Iter>
  void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
   forward_iterator_tag)
  {
#line 1387 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
  size_type _Count = 0;
  _Distance(_First, _Last, _Count);

  if (_Count == 0)
   ;
  else if (_Unused_capacity() < _Count)
   {
   if (max_size() - size() < _Count)
    _Xlen();

   size_type _Capacity = _Grow_to(size() + _Count);
   pointer _Newvec = this->_Getal().allocate(_Capacity);
   pointer _Ptr = _Newvec;

   try {
   _Ptr = _Umove(this->_Myfirst, (_Where)._Ptr,
    _Newvec);
   _Ptr = _Ucopy(_First, _Last, _Ptr);
   _Umove((_Where)._Ptr, this->_Mylast,
    _Ptr);
   } catch (...) {
   _Destroy(_Newvec, _Ptr);
   this->_Getal().deallocate(_Newvec, _Capacity);
   throw;
   }

   _Count += size();
   if (this->_Myfirst != pointer())
    {
    _Destroy(this->_Myfirst, this->_Mylast);
    this->_Getal().deallocate(this->_Myfirst,
     this->_Myend - this->_Myfirst);
    }

   this->_Orphan_all();
   this->_Myend = _Newvec + _Capacity;
   this->_Mylast = _Newvec + _Count;
   this->_Myfirst = _Newvec;
   }
  else
   {
   _Ucopy(_First, _Last, this->_Mylast);
   ::std:: rotate((_Where)._Ptr, this->_Mylast,
    this->_Mylast + _Count);
   this->_Mylast += _Count;
   _Orphan_range((_Where)._Ptr, this->_Mylast);
   }
  }
#line 1451 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
 iterator erase(const_iterator _Where)
  {
  _Move((_Where)._Ptr + 1, this->_Mylast,
   (_Where)._Ptr);
  _Destroy(this->_Mylast - 1, this->_Mylast);
  --this->_Mylast;
  return (_Make_iter(_Where));
  }


 iterator erase(const_iterator _First_arg,
  const_iterator _Last_arg)
  {
  if (_First_arg == begin() && _Last_arg == end())
   clear();
  else if (_First_arg != _Last_arg)
   {
   iterator _First = _Make_iter(_First_arg);
   iterator _Last = _Make_iter(_Last_arg);

   if (_First != _Last)
    {
#line 1483 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
    pointer _Ptr = _Move((_Last)._Ptr, this->_Mylast,
     (_First)._Ptr);


    _Destroy(_Ptr, this->_Mylast);
    this->_Mylast = _Ptr;
    }
   }
  return (_Make_iter(_First_arg));
  }

 void _Pop_back_n(size_type _Count)
  {
  pointer _Ptr = this->_Mylast - _Count;





  _Destroy(_Ptr, this->_Mylast);
  this->_Mylast = _Ptr;
  }

 void clear() throw ()
  {
  this->_Orphan_all();
  _Destroy(this->_Myfirst, this->_Mylast);
  this->_Mylast = this->_Myfirst;
  }

 void swap(_Myt& _Right)
  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   _Swap_adl(this->_Myfirst, _Right._Myfirst);
   _Swap_adl(this->_Mylast, _Right._Mylast);
   _Swap_adl(this->_Myend, _Right._Myend);
   }

  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   _Swap_adl(this->_Myfirst, _Right._Myfirst);
   _Swap_adl(this->_Mylast, _Right._Mylast);
   _Swap_adl(this->_Myend, _Right._Myend);
   }

  else
   {




   ::std:: terminate();

   }
  }

protected:
 bool _Buy(size_type _Capacity)
  {
  this->_Myfirst = pointer();
  this->_Mylast = pointer();
  this->_Myend = pointer();

  if (_Capacity == 0)
   return (false);
  else if (max_size() < _Capacity)
   _Xlen();
  else
   {
   this->_Myfirst = this->_Getal().allocate(_Capacity);
   this->_Mylast = this->_Myfirst;
   this->_Myend = this->_Myfirst + _Capacity;
   }
  return (true);
  }

 void _Destroy(pointer _First, pointer _Last)
  {
  _Alty _Alval(this->_Getal());
  _Destroy_range(_First, _Last, _Alval);
  }

 size_type _Grow_to(size_type _Count) const
  {
  size_type _Capacity = capacity();

  _Capacity = max_size() - _Capacity / 2 < _Capacity
   ? 0 : _Capacity + _Capacity / 2;
  if (_Capacity < _Count)
   _Capacity = _Count;
  return (_Capacity);
  }

 bool _Inside(const value_type *_Ptr) const
  {
  return (_Ptr < this->_Mylast && this->_Myfirst <= _Ptr);
  }

 void _Reallocate(size_type _Count)
  {
  pointer _Ptr = this->_Getal().allocate(_Count);

  try {
  _Umove(this->_Myfirst, this->_Mylast, _Ptr);
  } catch (...) {
  this->_Getal().deallocate(_Ptr, _Count);
  throw;
  }

  size_type _Size = size();
  if (this->_Myfirst != pointer())
   {
   _Destroy(this->_Myfirst, this->_Mylast);
   this->_Getal().deallocate(this->_Myfirst,
    this->_Myend - this->_Myfirst);
   }

  this->_Orphan_all();
  this->_Myend = _Ptr + _Count;
  this->_Mylast = _Ptr + _Size;
  this->_Myfirst = _Ptr;
  }

 void _Reserve(size_type _Count)
  {
  if (_Unused_capacity() < _Count)
   {
   if (max_size() - size() < _Count)
    _Xlen();
   _Reallocate(_Grow_to(size() + _Count));
   }
  }

 void _Tidy()
  {
  if (this->_Myfirst != pointer())
   {
   this->_Orphan_all();
   _Destroy(this->_Myfirst, this->_Mylast);
   this->_Getal().deallocate(this->_Myfirst,
    this->_Myend - this->_Myfirst);
   this->_Myfirst = pointer();
   this->_Mylast = pointer();
   this->_Myend = pointer();
   }
  }

 template<class _Iter>
  pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
  {
  _Alty _Alval(this->_Getal());
  return (_Uninitialized_copy(_First, _Last,
   _Ptr, _Alval));
  }

 template<class _Iter>
  pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
  {
  _Alty _Alval(this->_Getal());
  return (_Uninitialized_move(_First, _Last,
   _Ptr, _Alval));
  }

 iterator _Insert_n(const_iterator _Where,
  size_type _Count, const value_type& _Val)
  {







  size_type _Off = (_Where)._Ptr - this->_Myfirst;
  if (_Count == 0)
   ;
  else if (_Unused_capacity() < _Count)
   {
   if (max_size() - size() < _Count)
    _Xlen();

   size_type _Capacity = _Grow_to(size() + _Count);
   pointer _Newvec = this->_Getal().allocate(_Capacity);
   size_type _Whereoff = (_Where)._Ptr - this->_Myfirst;
   int _Ncopied = 0;

   try {
   _Ufill(_Newvec + _Whereoff, _Count,
    ::std:: addressof(_Val));
   ++_Ncopied;
   _Umove(this->_Myfirst, (_Where)._Ptr,
    _Newvec);
   ++_Ncopied;
   _Umove((_Where)._Ptr, this->_Mylast,
    _Newvec + (_Whereoff + _Count));
   } catch (...) {
   if (1 < _Ncopied)
    _Destroy(_Newvec, _Newvec + _Whereoff);
   if (0 < _Ncopied)
    _Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
   this->_Getal().deallocate(_Newvec, _Capacity);
   throw;
   }

   _Count += size();
   if (this->_Myfirst != pointer())
    {
    _Destroy(this->_Myfirst, this->_Mylast);
    this->_Getal().deallocate(this->_Myfirst,
     this->_Myend - this->_Myfirst);
    }

   this->_Orphan_all();
   this->_Myend = _Newvec + _Capacity;
   this->_Mylast = _Newvec + _Count;
   this->_Myfirst = _Newvec;
   }
  else if ((size_type)(this->_Mylast - (_Where)._Ptr)
   < _Count)
   {
   value_type _Tmp = _Val;

   _Umove((_Where)._Ptr, this->_Mylast,
    (_Where)._Ptr + _Count);

   try {
   _Ufill(this->_Mylast,
    _Count - (this->_Mylast - (_Where)._Ptr),
    ::std:: addressof(_Tmp));
   } catch (...) {
   _Destroy((_Where)._Ptr + _Count,
    this->_Mylast + _Count);
   throw;
   }

   this->_Mylast += _Count;
   _Orphan_range((_Where)._Ptr, this->_Mylast);
   ::std:: fill((_Where)._Ptr, this->_Mylast - _Count,
    _Tmp);
   }
  else
   {
   value_type _Tmp = _Val;

   pointer _Oldend = this->_Mylast;
   this->_Mylast = _Umove(_Oldend - _Count, _Oldend,
    this->_Mylast);

   _Orphan_range((_Where)._Ptr, this->_Mylast);
   _Copy_backward((_Where)._Ptr, _Oldend - _Count,
    _Oldend);
   ::std:: fill((_Where)._Ptr,
    (_Where)._Ptr + _Count, _Tmp);
   }
  return (begin() + _Off);
  }

 pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
  {
  _Alty _Alval(this->_Getal());
  _Uninitialized_fill_n(_Ptr, _Count, _Pval, _Alval);
  return (_Ptr + _Count);
  }

 __declspec(noreturn) void _Xlen() const
  {
  _Xlength_error("vector<T> too long");
  }

 __declspec(noreturn) void _Xran() const
  {
  _Xout_of_range("invalid vector<T> subscript");
  }
#line 1779 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
 void _Orphan_range(pointer, pointer) const
  {
  }

 };



template<class _Ty,
 class _Alloc> inline
 void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
 {
 _Left.swap(_Right);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator==(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (_Left.size() == _Right.size()
  && equal(_Left.begin(), _Left.end(), _Right.begin()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator!=(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (lexicographical_compare(_Left.begin(), _Left.end(),
  _Right.begin(), _Right.end()));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Ty,
 class _Alloc> inline
 bool operator<=(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Ty,
 class _Alloc> inline
 bool operator>=(const vector<_Ty, _Alloc>& _Left,
  const vector<_Ty, _Alloc>& _Right)
 {
 return (!(_Left < _Right));
 }




typedef unsigned int _Vbase;
const int _VBITS = 8 * sizeof (_Vbase);


template<class _Alloc>
 class _Vb_iter_base
  : public _Iterator012<random_access_iterator_tag,
   _Bool,
   typename _Alloc::difference_type,
   bool *,
   bool,
   _Iterator_base>
 {
public:
 typedef typename _Alloc::size_type _Sizet;
 typedef vector<_Bool, _Alloc> _Mycont;

 _Vb_iter_base()
  : _Myptr(0), _Myoff(0)
  {
  }

 _Vb_iter_base(const _Vbase *_Ptr, _Sizet _Off,
  const _Container_base *_Mypvbool)
  : _Myptr(_Ptr), _Myoff(_Off)
  {
  this->_Adopt(_Mypvbool);
  }

 void _Advance(_Sizet _Off)
  {
  _Myoff += _Off;
  _Myptr += _Myoff / _VBITS;
  _Myoff %= _VBITS;
  }

 int _Valid(_Sizet _Inc) const
  {
#line 1895 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
  return (-1);

  }

 const _Vbase *_Myptr;
 _Sizet _Myoff;
 };


template<class _Alloc>
 class _Vb_reference
  : public _Vb_iter_base<_Alloc>
 {
 typedef _Vb_iter_base<_Alloc> _Mybase;
 typedef _Vb_reference<_Alloc> _Mytype;

 _Vb_reference() throw ()
  {
  }

public:
 _Vb_reference(const _Mybase& _Right)
  : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
  {
  }

 _Mytype& operator=(const _Mytype& _Right) throw ()
  {
  return (*this = bool(_Right));
  }

 _Mytype& operator=(bool _Val) throw ()
  {
  if (_Val)
   *(_Vbase *)_Getptr() |= _Mask();
  else
   *(_Vbase *)_Getptr() &= (~_Mask());
  return (*this);
  }

 void flip() throw ()
  {
  *(_Vbase *)_Getptr() ^= _Mask();
  }

 operator bool() const throw ()
  {
  return ((*_Getptr() & _Mask()) != 0);
  }

 const _Vbase *_Getptr() const
  {
#line 1961 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
  return (this->_Myptr);
  }

protected:
 _Vbase _Mask() const
  {
  return ((_Vbase)(1 << this->_Myoff));
  }
 };

template<class _Alloc> inline
 void swap(_Vb_reference<_Alloc> _Left,
  _Vb_reference<_Alloc> _Right)
 {
 bool _Val = _Left;
 _Left = _Right;
 _Right = _Val;
 }


template<class _Alloc>
 class _Vb_const_iterator
  : public _Vb_iter_base<_Alloc>
 {
public:
 typedef _Vb_iter_base<_Alloc> _Mybase;
 typedef _Vb_const_iterator<_Alloc> _Mytype;

 typedef _Vb_reference<_Alloc> _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef _Bool value_type;
 typedef typename _Alloc::size_type size_type;
 typedef typename _Alloc::difference_type difference_type;
 typedef const_reference *pointer;
 typedef const_reference reference;

 _Vb_const_iterator()
  {
  }

 _Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
  : _Mybase(_Ptr, 0, _Mypvbool)
  {
  }

 const_reference operator*() const
  {
  return (_Reft(*this));
  }

 _Mytype& operator++()
  {
  _Inc();
  return (*this);
  }

 _Mytype operator++(int)
  {
  _Mytype _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Mytype& operator--()
  {
  _Dec();
  return (*this);
  }

 _Mytype operator--(int)
  {
  _Mytype _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Mytype& operator+=(difference_type _Off)
  {
  if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
   {
   this->_Myoff += _Off;
   this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
   this->_Myoff %= _VBITS;
   }
  else
   {
   this->_Myoff += _Off;
   this->_Myptr += this->_Myoff / _VBITS;
   this->_Myoff %= _VBITS;
   }
  return (*this);
  }

 _Mytype operator+(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Mytype& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Mytype operator-(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(
  const _Mytype& _Right) const
  {
  _Compat(_Right);
  return (_VBITS * (this->_Myptr - _Right._Myptr)
   + (difference_type)this->_Myoff
   - (difference_type)_Right._Myoff);
  }

 const_reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }

 bool operator==(const _Mytype& _Right) const
  {
  _Compat(_Right);
  return (this->_Myptr == _Right._Myptr
   && this->_Myoff == _Right._Myoff);
  }

 bool operator!=(const _Mytype& _Right) const
  {
  return (!(*this == _Right));
  }

 bool operator<(const _Mytype& _Right) const
  {
  _Compat(_Right);
  return (this->_Myptr < _Right._Myptr
   || (this->_Myptr == _Right._Myptr
    && this->_Myoff < _Right._Myoff));
  }

 bool operator>(const _Mytype& _Right) const
  {
  return (_Right < *this);
  }

 bool operator<=(const _Mytype& _Right) const
  {
  return (!(_Right < *this));
  }

 bool operator>=(const _Mytype& _Right) const
  {
  return (!(*this < _Right));
  }
#line 2138 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
 void _Compat(const _Mytype&) const
  {
  }


 void _Dec()
  {
  if (this->_Myoff != 0)
   --this->_Myoff;
  else
   {
#line 2161 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
   this->_Myoff = _VBITS - 1;
   --this->_Myptr;
   }
  }

 void _Inc()
  {
  if (this->_Myoff < _VBITS - 1)
   ++this->_Myoff;
  else
   {
#line 2184 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
   this->_Myoff = 0;
   ++this->_Myptr;
   }
  }
 };

template<class _Alloc> inline
 _Vb_const_iterator<_Alloc> operator+(
  typename _Alloc::difference_type _Off,
  _Vb_const_iterator<_Alloc> _Right)
  {
  return (_Right += _Off);
  }

template<class _Alloc>
 struct _Is_checked_helper<_Vb_const_iterator<_Alloc> >
  : public true_type
 {
 };


template<class _Alloc>
 class _Vb_iterator
  : public _Vb_const_iterator<_Alloc>
 {
public:
 typedef _Vb_const_iterator<_Alloc> _Mybase;
 typedef _Vb_iterator<_Alloc> _Mytype;

 typedef _Vb_reference<_Alloc> _Reft;
 typedef bool const_reference;

 typedef random_access_iterator_tag iterator_category;
 typedef _Bool value_type;
 typedef typename _Alloc::size_type size_type;
 typedef typename _Alloc::difference_type difference_type;
 typedef _Reft *pointer;
 typedef _Reft reference;

 _Vb_iterator()
  {
  }

 _Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
  : _Mybase(_Ptr, _Mypvbool)
  {
  }

 reference operator*() const
  {
  return (_Reft(*this));
  }

 _Mytype& operator++()
  {
  ++*(_Mybase *)this;
  return (*this);
  }

 _Mytype operator++(int)
  {
  _Mytype _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Mytype& operator--()
  {
  --*(_Mybase *)this;
  return (*this);
  }

 _Mytype operator--(int)
  {
  _Mytype _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 _Mytype& operator+=(difference_type _Off)
  {
  *(_Mybase *)this += _Off;
  return (*this);
  }

 _Mytype operator+(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp += _Off);
  }

 _Mytype& operator-=(difference_type _Off)
  {
  return (*this += -_Off);
  }

 _Mytype operator-(difference_type _Off) const
  {
  _Mytype _Tmp = *this;
  return (_Tmp -= _Off);
  }

 difference_type operator-(const _Mybase& _Right) const
  {
  return (*(_Mybase *)this - _Right);
  }

 reference operator[](difference_type _Off) const
  {
  return (*(*this + _Off));
  }
 };

template<class _Alloc> inline
 _Vb_iterator<_Alloc> operator+(typename _Alloc::difference_type _Off,
  _Vb_iterator<_Alloc> _Right)
  {
  return (_Right += _Off);
  }

template<class _Alloc>
 struct _Is_checked_helper<_Vb_iterator<_Alloc> >
  : public true_type
 {
 };


template<class _Alloc>
 class _Vb_val
  : public _Container_base
 {
public:
 typedef ::std:: vector<_Vbase, _Alloc> _Vectype;
 typedef typename _Vectype::_Alty _Alty;
 typedef typename _Alty::size_type size_type;

 _Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
  : _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
  {
  _Alloc_proxy();
  _Mysize = 0;
  }

 _Vb_val(const _Vb_val& _Right)
  : _Myvec(_Right._Myvec),
   _Mysize(_Right._Mysize)
  {
  _Alloc_proxy();
  }

 _Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
  : _Myvec(_Right._Myvec, _Al),
   _Mysize(_Right._Mysize)
  {
  _Alloc_proxy();
  }

 _Vb_val(_Vb_val&& _Right)
  : _Myvec(::std:: forward<_Vectype>(_Right._Myvec)),
   _Mysize(_Right._Mysize)
  {
  _Right._Mysize = 0;
  _Alloc_proxy();
  }

 _Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
  : _Myvec(::std:: forward<_Vectype>(_Right._Myvec), _Al),
   _Mysize(_Right._Mysize)
  {
  _Right._Mysize = 0;
  _Alloc_proxy();
  }

 ~_Vb_val() throw ()
  {
  _Free_proxy();
  }


 void _Swap_alloc(_Vb_val&)
  {
  }

 void _Alloc_proxy()
  {
  }

 void _Free_proxy()
  {
  }
#line 2401 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
 static size_type _Nw(size_type _Count)
  {
  return ((_Count + _VBITS - 1) / _VBITS);
  }

 _Vectype _Myvec;
 typename _Alty::size_type _Mysize;
 };



template<class _Alloc>
 class vector<_Bool, _Alloc>
  : public _Vb_val<_Alloc>
 {
public:
 typedef ::std:: vector<_Bool, _Alloc> _Myt;
 typedef _Vb_val<_Alloc> _Mybase;
 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Vectype _Vectype;

 typedef typename _Alty::size_type size_type;
 typedef typename _Alty::difference_type difference_type;
 typedef _Bool _Ty;
 typedef _Alloc allocator_type;

 typedef _Vb_reference<_Alty> reference;
 typedef bool const_reference;
 typedef bool value_type;

 typedef reference _Reft;
 typedef _Vb_const_iterator<_Alty> const_iterator;
 typedef _Vb_iterator<_Alty> iterator;

 typedef iterator pointer;
 typedef const_iterator const_pointer;
 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 static const int _VBITS = ::std:: _VBITS;
 enum {_EEN_VBITS = _VBITS};
 vector()
  : _Mybase(0, false)
  {
  }

 explicit vector(const _Alloc& _Al)
  : _Mybase(0, false, _Al)
  {
  }

 explicit vector(size_type _Count, const bool& _Val = false)
  : _Mybase(_Count, _Val)
  {
  _Trim(_Count);
  }

 vector(size_type _Count, const bool& _Val, const _Alloc& _Al)
  : _Mybase(_Count, _Val, _Al)
  {
  _Trim(_Count);
  }

 vector(const _Myt& _Right)
  : _Mybase(_Right)
  {
  }

 vector(const _Myt& _Right, const _Alloc& _Al)
  : _Mybase(_Right, _Al)
  {
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>::type>
  vector(_Iter _First, _Iter _Last)
  : _Mybase(0, false)
  {
  _BConstruct(_First, _Last);
  }

 template<class _Iter,
  class = typename enable_if<_Is_iterator<_Iter>::value,
   void>::type>
  vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
  : _Mybase(0, false, _Al)
  {
  _BConstruct(_First, _Last);
  }

 template<class _Iter>
  void _BConstruct(_Iter _First, _Iter _Last)
  {
  insert(begin(), _First, _Last);
  }

 vector(_Myt&& _Right)
  : _Mybase(::std:: forward<_Myt>(_Right))
  {
  }

 vector(_Myt&& _Right, const _Alloc& _Al)
  : _Mybase(::std:: forward<_Myt>(_Right), _Al)
  {
  }

 _Myt& operator=(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   clear();

   if (_Alty::propagate_on_container_move_assignment::value
    && this->get_allocator() != _Right.get_allocator())
    {
    this->_Free_proxy();
    this->_Myvec = ::std:: move(_Right._Myvec);
    this->_Alloc_proxy();
    }
   else
    this->_Myvec = ::std:: move(_Right._Myvec);


   this->_Mysize = _Right._Mysize;
   _Right._Mysize = 0;
   }
  return (*this);
  }

 vector(::std:: initializer_list<bool> _Ilist,
   const _Alloc& _Al = allocator_type())
  : _Mybase(0, false, _Al)
  {
  insert(begin(), _Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<bool> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void assign(::std:: initializer_list<bool> _Ilist)
  {
  assign(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const_iterator _Where,
   ::std:: initializer_list<bool> _Ilist)
  {
  return (insert(_Where, _Ilist.begin(), _Ilist.end()));
  }

 ~vector() throw ()
  {
  this->_Mysize = 0;
  }

 _Myt& operator=(const _Myt& _Right)
  {
  this->_Mysize = _Right._Mysize;
  this->_Myvec = _Right._Myvec;
  return (*this);
  }

 void reserve(size_type _Count)
  {
  this->_Myvec.reserve(this->_Nw(_Count));
  }

 size_type capacity() const throw ()
  {
  return (this->_Myvec.capacity() * _VBITS);
  }

 iterator begin() throw ()
  {
  return (iterator((_Vbase *)this->_Myvec._Myfirst, this));
  }

 const_iterator begin() const throw ()
  {
  return (const_iterator((_Vbase *)this->_Myvec._Myfirst, this));
  }

 iterator end() throw ()
  {
  iterator _Tmp = begin();
  if (0 < this->_Mysize)
   _Tmp += this->_Mysize;
  return (_Tmp);
  }

 const_iterator end() const throw ()
  {
  const_iterator _Tmp = begin();
  if (0 < this->_Mysize)
   _Tmp += this->_Mysize;
  return (_Tmp);
  }

 const_iterator cbegin() const throw ()
  {
  return (((const _Myt *)this)->begin());
  }

 const_iterator cend() const throw ()
  {
  return (((const _Myt *)this)->end());
  }

 const_reverse_iterator crbegin() const throw ()
  {
  return (((const _Myt *)this)->rbegin());
  }

 const_reverse_iterator crend() const throw ()
  {
  return (((const _Myt *)this)->rend());
  }

 void shrink_to_fit()
  {
  if (this->_Myvec._Has_unused_capacity())
   {
   _Myt _Tmp(*this);
   swap(_Tmp);
   }
  }

 iterator _Make_iter(const_iterator _Where)
  {
  iterator _Tmp = begin();
  if (0 < this->_Mysize)
   _Tmp += _Where - begin();
  return (_Tmp);
  }

 reverse_iterator rbegin() throw ()
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const throw ()
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() throw ()
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const throw ()
  {
  return (const_reverse_iterator(begin()));
  }

 void resize(size_type _Newsize, bool _Val = false)
  {
  if (size() < _Newsize)
   _Insert_n(end(), _Newsize - size(), _Val);
  else if (_Newsize < size())
   erase(begin() + _Newsize, end());
  }

 size_type size() const throw ()
  {
  return (this->_Mysize);
  }

 size_type max_size() const throw ()
  {
  const size_type _Maxsize = this->_Myvec.max_size();
  return (_Maxsize < (size_type)(-1) / _VBITS
   ? _Maxsize * _VBITS : (size_type)(-1));
  }

 bool empty() const throw ()
  {
  return (size() == 0);
  }

 _Alloc get_allocator() const throw ()
  {
  return (this->_Myvec.get_allocator());
  }

 const_reference at(size_type _Off) const
  {
  if (size() <= _Off)
   _Xran();
  return ((*this)[_Off]);
  }

 reference at(size_type _Off)
  {
  if (size() <= _Off)
   _Xran();
  return ((*this)[_Off]);
  }

 const_reference operator[](size_type _Off) const
  {
  const_iterator _It = begin();
  _It._Advance(_Off);
  return (*_It);
  }

 reference operator[](size_type _Off)
  {
  iterator _It = begin();
  _It._Advance(_Off);
  return (*_It);
  }

 reference front()
  {
  return (*begin());
  }

 const_reference front() const
  {
  return (*begin());
  }

 reference back()
  {
  return (*(end() - 1));
  }

 const_reference back() const
  {
  return (*(end() - 1));
  }

 void push_back(const bool& _Val)
  {
  insert(end(), _Val);
  }

 void pop_back()
  {
  erase(end() - 1);
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   void>::type
  assign(_Iter _First, _Iter _Last)
  {
  erase(begin(), end());
  insert(begin(), _First, _Last);
  }

 void assign(size_type _Count, const bool& _Val)
  {
  erase(begin(), end());
  _Insert_n(begin(), _Count, _Val);
  }

 iterator insert(const_iterator _Where, const bool& _Val)
  {
  return (_Insert_n(_Where, (size_type)1, _Val));
  }

 iterator insert(const_iterator _Where, size_type _Count,
  const bool& _Val)
  {
  return (_Insert_n(_Where, _Count, _Val));
  }

 template<class _Iter>
  typename enable_if<_Is_iterator<_Iter>::value,
   iterator>::type
  insert(const_iterator _Where, _Iter _First, _Iter _Last)
  {
  size_type _Off = _Where - begin();
  _Insert(_Where, _First, _Last, _Iter_cat(_First));
  return (begin() + _Off);
  }

 template<class _Iter>
  void _Insert(const_iterator _Where, _Iter _First, _Iter _Last,
   input_iterator_tag)
  {
  size_type _Off = _Where - begin();

  for (; _First != _Last; ++_First, ++_Off)
   insert(begin() + _Off, *_First);
  }

 template<class _Iter>
  void _Insert(const_iterator _Where,
   _Iter _First, _Iter _Last,
   forward_iterator_tag)
  {
                             ;
  size_type _Count = 0;
  _Distance(_First, _Last, _Count);

  size_type _Off = _Insert_x(_Where, _Count);
  ::std:: copy(_First, _Last, begin() + _Off);
  }

 iterator erase(const_iterator _Where_arg)
  {
  iterator _Where = _Make_iter(_Where_arg);
  size_type _Off = _Where - begin();
#line 2819 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
  ::std:: copy(_Where + 1, end(), _Where);


  _Trim(this->_Mysize - 1);
  return (begin() + _Off);
  }

 iterator erase(const_iterator _First_arg, const_iterator _Last_arg)
  {
  iterator _First = _Make_iter(_First_arg);
  iterator _Last = _Make_iter(_Last_arg);
  size_type _Off = _First - begin();

  if (_First != _Last)
   {
#line 2843 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
   iterator _Next = ::std:: copy(_Last, end(), _First);
   _Trim(_Next - begin());

   }
  return (begin() + _Off);
  }

 void clear() throw ()
  {
  erase(begin(), end());
  }

 void flip() throw ()
  {
  for (typename _Vectype::iterator _Next = this->_Myvec.begin();
   _Next != this->_Myvec.end(); ++_Next)
   *_Next = (_Vbase)~*_Next;
  _Trim(this->_Mysize);
  }

 void swap(_Myt& _Right)
  {
  if (this == &_Right)
   ;
  else if (this->get_allocator() == _Right.get_allocator())
   {
   this->_Swap_all(_Right);
   this->_Myvec.swap(_Right._Myvec);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }

  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   this->_Myvec.swap(_Right._Myvec);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }

  else
   {




   ::std:: terminate();

   }
  }

 static void swap(reference _Left, reference _Right) throw ()
  {
  bool _Val = _Left;

  _Left = _Right;
  _Right = _Val;
  }

 size_t hash() const
  {
  return (_Hash_seq((const unsigned char *)this->_Myvec.data(),
   this->_Myvec.size() * sizeof (_Vbase)));
  }

 iterator _Insert_n(const_iterator _Where,
  size_type _Count, const bool& _Val)
  {
  size_type _Off = _Insert_x(_Where, _Count);
  ::std:: fill(begin() + _Off, begin() + (_Off + _Count), _Val);
  return (begin() + _Off);
  }

 size_type _Insert_x(const_iterator _Where, size_type _Count)
  {
  size_type _Off = _Where - begin();







  if (_Count == 0)
   ;
  else if (max_size() - size() < _Count)
   _Xlen();
  else
   {
   this->_Myvec.resize(this->_Nw(size() + _Count), 0);
   if (empty())
    this->_Mysize += _Count;
   else
    {
    iterator _Oldend = end();
    this->_Mysize += _Count;
    ::std:: copy_backward(begin() + _Off, _Oldend, end());
    }




   }
  return (_Off);
  }
#line 2972 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\vector"
 void _Orphan_range(size_type, size_type) const
  {
  }


 void _Trim(size_type _Size)
  {
  if (max_size() < _Size)
   _Xlen();
  size_type _Words = this->_Nw(_Size);

  if (_Words < this->_Myvec.size())
   this->_Myvec.erase(this->_Myvec.begin() + _Words,
    this->_Myvec.end());
  this->_Mysize = _Size;
  _Size %= _VBITS;
  if (0 < _Size)
   this->_Myvec[_Words - 1] &= (_Vbase)((1 << _Size) - 1);
  }

 __declspec(noreturn) void _Xlen() const
  {
  _Xlength_error("vector<bool> too long");
  }

 __declspec(noreturn) void _Xran() const
  {
  _Xout_of_range("invalid vector<bool> subscript");
  }
 };

template<class _Alloc> inline
 bool operator==(const vector<bool, _Alloc>& _Left,
  const vector<bool, _Alloc>& _Right)
 {
 return (_Left.size() == _Right.size()
  && equal(_Left._Myvec.begin(), _Left._Myvec.end(),
   _Right._Myvec.begin()));
 }

template<class _Alloc> inline
 bool operator!=(const vector<bool, _Alloc>& _Left,
  const vector<bool, _Alloc>& _Right)
 {
 return (!(_Left == _Right));
 }


template<class _Alloc>
 struct hash<vector<_Bool, _Alloc> >
  : public unary_function<vector<_Bool, _Alloc>, size_t>
 {
 typedef vector<_Bool, _Alloc> _Kty;

 size_t operator()(const _Kty& _Keyval) const
  {
  return (_Keyval.hash());
  }
 };
}


#pragma warning(pop)
#pragma pack(pop)
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"


#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\map"





#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtree"








#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4127)
namespace std {

template<class _Mytree,
 class _Base = _Iterator_base0>
 class _Tree_unchecked_const_iterator
  : public _Iterator012<bidirectional_iterator_tag,
   typename _Mytree::value_type,
   typename _Mytree::difference_type,
   typename _Mytree::const_pointer,
   typename _Mytree::const_reference,
   _Base>
 {
public:
 typedef _Tree_unchecked_const_iterator<_Mytree, _Base> _Myiter;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;
 typedef typename _Mytree::const_pointer pointer;
 typedef typename _Mytree::const_reference reference;

 _Tree_unchecked_const_iterator()
  : _Ptr(0)
  {
  }

 _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Ptr(_Pnode)
  {
  this->_Adopt(_Plist);
  }

 reference operator*() const
  {
  return (_Mytree::_Myval(_Ptr));
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  if (_Mytree::_Isnil(_Ptr))
   ;
  else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
   _Ptr = _Mytree::_Min(
    _Mytree::_Right(_Ptr));
  else
   {
   _Nodeptr _Pnode;
   while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
    && _Ptr == _Mytree::_Right(_Pnode))
    _Ptr = _Pnode;
   _Ptr = _Pnode;
   }
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  if (_Mytree::_Isnil(_Ptr))
   _Ptr = _Mytree::_Right(_Ptr);
  else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
   _Ptr = _Mytree::_Max(
    _Mytree::_Left(_Ptr));
  else
   {
   _Nodeptr _Pnode;
   while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
    && _Ptr == _Mytree::_Left(_Pnode))
    _Ptr = _Pnode;
   if (_Mytree::_Isnil(_Ptr))
    ;
   else
    _Ptr = _Pnode;
   }
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
  return (_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }

 _Nodeptr _Mynode() const
  {
  return (_Ptr);
  }

 _Nodeptr _Ptr;
 };


template<class _Mytree>
 class _Tree_unchecked_iterator
  : public _Tree_unchecked_const_iterator<_Mytree>
 {
public:
 typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
 typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;
 typedef typename _Mytree::pointer pointer;
 typedef typename _Mytree::reference reference;

 _Tree_unchecked_iterator()
  {
  }

 _Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };


template<class _Mytree>
 class _Tree_const_iterator
  : public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
 {
public:
 typedef _Tree_const_iterator<_Mytree> _Myiter;
 typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;
 typedef typename _Mytree::const_pointer pointer;
 typedef typename _Mytree::const_reference reference;

 _Tree_const_iterator()
  : _Mybase()
  {
  }

 _Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
  }

 reference operator*() const
  {
#line 247 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtree"
  return (_Mytree::_Myval(this->_Ptr));
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
#line 271 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtree"
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
#line 308 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtree"
  --(*(_Mybase *)this);


  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }

 bool operator==(const _Myiter& _Right) const
  {
#line 336 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtree"
  return (this->_Ptr == _Right._Ptr);
  }

 bool operator!=(const _Myiter& _Right) const
  {
  return (!(*this == _Right));
  }
 };

template<class _Mytree> inline
 typename _Tree_const_iterator<_Mytree>::_Unchecked_type
  _Unchecked(_Tree_const_iterator<_Mytree> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mytree> inline
 _Tree_const_iterator<_Mytree>&
  _Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
   typename _Tree_const_iterator<_Mytree>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Mytree>
 class _Tree_iterator
  : public _Tree_const_iterator<_Mytree>
 {
public:
 typedef _Tree_iterator<_Mytree> _Myiter;
 typedef _Tree_const_iterator<_Mytree> _Mybase;
 typedef bidirectional_iterator_tag iterator_category;

 typedef typename _Mytree::_Nodeptr _Nodeptr;
 typedef typename _Mytree::value_type value_type;
 typedef typename _Mytree::difference_type difference_type;

 typedef typename _Mytree::pointer pointer;
 typedef typename _Mytree::reference reference;

 _Tree_iterator()
  {
  }

 _Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
  : _Mybase(_Pnode, _Plist)
  {
  }

 typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;

 _Myiter& _Rechecked(_Unchecked_type _Right)
  {
  this->_Ptr = _Right._Ptr;
  return (*this);
  }

 _Unchecked_type _Unchecked() const
  {
  return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
  }

 reference operator*() const
  {
  return ((reference)**(_Mybase *)this);
  }

 pointer operator->() const
  {
  return (::std:: pointer_traits<pointer>::pointer_to(**this));
  }

 _Myiter& operator++()
  {
  ++(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator++(int)
  {
  _Myiter _Tmp = *this;
  ++*this;
  return (_Tmp);
  }

 _Myiter& operator--()
  {
  --(*(_Mybase *)this);
  return (*this);
  }

 _Myiter operator--(int)
  {
  _Myiter _Tmp = *this;
  --*this;
  return (_Tmp);
  }
 };

template<class _Mytree> inline
 typename _Tree_iterator<_Mytree>::_Unchecked_type
  _Unchecked(_Tree_iterator<_Mytree> _Iter)
 {
 return (_Iter._Unchecked());
 }

template<class _Mytree> inline
 _Tree_iterator<_Mytree>&
  _Rechecked(_Tree_iterator<_Mytree>& _Iter,
   typename _Tree_iterator<_Mytree>
    ::_Unchecked_type _Right)
 {
 return (_Iter._Rechecked(_Right));
 }


template<class _Value_type,
 class _Size_type,
 class _Difference_type,
 class _Pointer,
 class _Const_pointer,
 class _Reference,
 class _Const_reference,
 class _Nodeptr_type>
 struct _Tree_iter_types
 {
 typedef _Value_type value_type;
 typedef _Size_type size_type;
 typedef _Difference_type difference_type;
 typedef _Pointer pointer;
 typedef _Const_pointer const_pointer;
 typedef _Reference reference;
 typedef _Const_reference const_reference;
 typedef _Nodeptr_type _Nodeptr;
 };

template<class _Value_type,
 class _Voidptr>
 struct _Tree_node
  {
  _Voidptr _Left;
  _Voidptr _Parent;
  _Voidptr _Right;
  char _Color;
  char _Isnil;
  _Value_type _Myval;

 private:
  _Tree_node& operator=(const _Tree_node&);
  };

template<class _Value_type>
 struct _Tree_node<_Value_type, void *>
  {
  typedef _Tree_node<_Value_type, void *> *_Nodeptr;
  _Nodeptr _Left;
  _Nodeptr _Parent;
  _Nodeptr _Right;
  char _Color;
  char _Isnil;
  _Value_type _Myval;

 private:
  _Tree_node& operator=(const _Tree_node&);
  };

template<class _Ty>
 struct _Tree_simple_types
  : public _Simple_types<_Ty>
 {
 typedef _Tree_node<_Ty, void *> _Node;
 typedef _Node *_Nodeptr;
 };

template<class _Ty,
 class _Alloc0>
 struct _Tree_base_types
 {
 typedef _Alloc0 _Alloc;
 typedef _Tree_base_types<_Ty, _Alloc> _Myt;

 typedef _Wrap_alloc<_Alloc> _Alty0;
 typedef typename _Alty0::template rebind<_Ty>::other _Alty;


 typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
  _Voidptr;
 typedef _Tree_node<typename _Alty::value_type,
  _Voidptr> _Node;

 typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
 typedef typename _Alnod_type::pointer _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _If<_Is_simple_alloc<_Alty>::value,
  _Tree_simple_types<typename _Alty::value_type>,
  _Tree_iter_types<typename _Alty::value_type,
   typename _Alty::size_type,
   typename _Alty::difference_type,
   typename _Alty::pointer,
   typename _Alty::const_pointer,
   typename _Alty::reference,
   typename _Alty::const_reference,
   _Nodeptr> >::type
  _Val_types;
 };


template<class _Val_types>
 class _Tree_val
  : public _Container_base
 {
public:
 typedef _Tree_val<_Val_types> _Myt;

 typedef typename _Val_types::_Nodeptr _Nodeptr;
 typedef _Nodeptr& _Nodepref;

 typedef typename _Val_types::value_type value_type;
 typedef typename _Val_types::size_type size_type;
 typedef typename _Val_types::difference_type difference_type;
 typedef typename _Val_types::pointer pointer;
 typedef typename _Val_types::const_pointer const_pointer;
 typedef typename _Val_types::reference reference;
 typedef typename _Val_types::const_reference const_reference;

 typedef _Tree_const_iterator<_Myt> const_iterator;
 typedef _Tree_iterator<_Myt> iterator;

 _Tree_val()
  {
  this->_Myhead = 0;
  this->_Mysize = 0;
  }

 enum _Redbl
  {
  _Red, _Black};

 static char& _Color(_Nodeptr _Pnode)
  {
  return ((char&)_Pnode->_Color);
  }

 static char& _Isnil(_Nodeptr _Pnode)
  {
  return ((char&)_Pnode->_Isnil);
  }

 static _Nodepref _Left(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Left);
  }

 static _Nodepref _Parent(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Parent);
  }

 static _Nodepref _Right(_Nodeptr _Pnode)
  {
  return ((_Nodepref)_Pnode->_Right);
  }

 static reference _Myval(_Nodeptr _Pnode)
  {
  return ((reference)_Pnode->_Myval);
  }

 static _Nodeptr _Max(_Nodeptr _Pnode)
  {
  while (!_Isnil(_Right(_Pnode)))
   _Pnode = _Right(_Pnode);
  return (_Pnode);
  }

 static _Nodeptr _Min(_Nodeptr _Pnode)
  {
  while (!_Isnil(_Left(_Pnode)))
   _Pnode = _Left(_Pnode);
  return (_Pnode);
  }

 _Nodeptr _Myhead;
 size_type _Mysize;
 };


template<bool _Al_has_storage,
 class _Alloc_types>
 class _Tree_alloc
  : public _Tree_val<typename _Alloc_types::_Val_types>
 {
public:
 typename _Alloc_types::_Alnod_type _Alnod;

 typedef _Tree_alloc<_Al_has_storage, _Alloc_types> _Myt;
 typedef typename _Alloc_types::_Alloc _Alloc;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;


 _Tree_alloc(const _Alloc& _Al = _Alloc())
  : _Alnod(_Al)
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_Tree_alloc() throw ()
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Change_alloc(const _Alty& _Al)
  {
  this->_Alnod = _Al;
  }

 void _Swap_alloc(_Myt& _Right)
  {
  _Swap_adl(this->_Alnod, _Right._Alnod);
  }
#line 714 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtree"
 _Nodeptr _Buyheadnode()
  {
  _Nodeptr _Pnode = this->_Alnod.allocate(1);

  try {
  this->_Alnod.construct(
   ::std:: addressof(this->_Left(_Pnode)), _Pnode);
  this->_Alnod.construct(
   ::std:: addressof(this->_Parent(_Pnode)), _Pnode);
  this->_Alnod.construct(
   ::std:: addressof(this->_Right(_Pnode)), _Pnode);
  } catch (...) {
  this->_Alnod.deallocate(_Pnode, 1);
  throw;
  }

  this->_Color(_Pnode) = this->_Black;
  this->_Isnil(_Pnode) = true;
  return (_Pnode);
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  this->_Alnod.destroy(
   ::std:: addressof(this->_Left(_Pnode)));
  this->_Alnod.destroy(
   ::std:: addressof(this->_Parent(_Pnode)));
  this->_Alnod.destroy(
   ::std:: addressof(this->_Right(_Pnode)));
  this->_Alnod.deallocate(_Pnode, 1);
  }

 _Alty& _Getal()
  {
  return (this->_Alnod);
  }

 const _Alty& _Getal() const
  {
  return (this->_Alnod);
  }
 };


template<class _Alloc_types>
 class _Tree_alloc<false, _Alloc_types>
  : public _Tree_val<typename _Alloc_types::_Val_types>
 {
public:
 typedef _Tree_alloc<false, _Alloc_types> _Myt;
 typedef _Tree_val<typename _Alloc_types::_Val_types> _Mybase;
 typedef typename _Alloc_types::_Alloc _Alloc;
 typedef typename _Alloc_types::_Alnod_type _Alty;
 typedef typename _Alloc_types::_Node _Node;
 typedef typename _Alloc_types::_Nodeptr _Nodeptr;


 _Tree_alloc(const _Alloc& = _Alloc())
  {
  this->_Myhead = _Buyheadnode();
  }

 ~_Tree_alloc() throw ()
  {
  _Freeheadnode(this->_Myhead);
  }

 void _Change_alloc(const _Alty&)
  {
  }

 void _Swap_alloc(_Myt&)
  {
  }
#line 835 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtree"
 _Nodeptr _Buyheadnode()
  {
  _Nodeptr _Pnode = this->_Getal().allocate(1);

  try {
  this->_Getal().construct(
   ::std:: addressof(this->_Left(_Pnode)), _Pnode);
  this->_Getal().construct(
   ::std:: addressof(this->_Parent(_Pnode)), _Pnode);
  this->_Getal().construct(
   ::std:: addressof(this->_Right(_Pnode)), _Pnode);
  } catch (...) {
  this->_Getal().deallocate(_Pnode, 1);
  throw;
  }

  this->_Color(_Pnode) = this->_Black;
  this->_Isnil(_Pnode) = true;
  return (_Pnode);
  }

 void _Freeheadnode(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Left(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Parent(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Right(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }

 _Alty _Getal() const
  {
  return (_Alty());
  }
 };


template<class _Ty,
 class _Alloc>
 class _Tree_buy
  : public _Tree_alloc<!is_empty<_Alloc>::value,
   _Tree_base_types<_Ty, _Alloc> >
 {
public:
 typedef _Tree_alloc<!is_empty<_Alloc>::value,
  _Tree_base_types<_Ty, _Alloc> > _Mybase;
 typedef typename _Mybase::_Alty _Alty;
 typedef typename _Mybase::_Nodeptr _Nodeptr;
 typedef typename _Mybase::value_type value_type;

 _Tree_buy(const _Alloc& _Al = _Alloc())
  : _Mybase(_Al)
  {
  }

 _Nodeptr _Buynode0()
  {
  _Nodeptr _Pnode = this->_Getal().allocate(1);

  try {
  this->_Getal().construct(
   ::std:: addressof(this->_Left(_Pnode)), this->_Myhead);
  this->_Getal().construct(
   ::std:: addressof(this->_Parent(_Pnode)), this->_Myhead);
  this->_Getal().construct(
   ::std:: addressof(this->_Right(_Pnode)), this->_Myhead);
  } catch (...) {
  this->_Getal().deallocate(_Pnode, 1);
  throw;
  }

  return (_Pnode);
  }

 void _Freenode0(_Nodeptr _Pnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Left(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Parent(_Pnode)));
  this->_Getal().destroy(
   ::std:: addressof(this->_Right(_Pnode)));
  this->_Getal().deallocate(_Pnode, 1);
  }

 template<class... _Valty>
  _Nodeptr _Buynode(_Valty&&... _Val)
  {
  _Nodeptr _Pnode = _Buynode0();

  this->_Color(_Pnode) = this->_Red;
  this->_Isnil(_Pnode) = false;

  try {
  this->_Getal().construct(
   ::std:: addressof(this->_Myval(_Pnode)),
    ::std:: forward<_Valty>(_Val)...);
  } catch (...) {
  _Freenode0(_Pnode);
  throw;
  }

  return (_Pnode);
  }

 };


template<bool _Pr_has_storage,
 class _Traits>
 class _Tree_comp
  : public _Tree_buy<typename _Traits::value_type,
   typename _Traits::allocator_type>
 {
public:
 typedef _Tree_comp<_Pr_has_storage, _Traits> _Myt;
 typedef _Tree_buy<typename _Traits::value_type,
  typename _Traits::allocator_type> _Mybase;

 typedef typename _Traits::allocator_type allocator_type;
 typedef typename _Traits::key_compare key_compare;

 _Tree_comp(const key_compare& _Parg, const allocator_type& _Al)
  : _Mybase(_Al), comp(_Parg)
  {
  }

 key_compare& _Getcomp()
  {
  return (comp);
  }

 const key_compare& _Getcomp() const
  {
  return (comp);
  }

 void _Setcomp(const key_compare& _Right)
  {
  comp = _Right;
  }

 void _Swapcomp(key_compare& _Right)
  {
  _Swap_adl(comp, _Right);
  }

 key_compare comp;
 };

template<class _Traits>
 class _Tree_comp<false, _Traits>
  : public _Tree_buy<typename _Traits::value_type,
   typename _Traits::allocator_type>
 {
public:
 typedef _Tree_comp<false, _Traits> _Myt;
 typedef _Tree_buy<typename _Traits::value_type,
  typename _Traits::allocator_type> _Mybase;

 typedef typename _Traits::allocator_type allocator_type;
 typedef typename _Traits::key_compare key_compare;

 _Tree_comp(const key_compare&, const allocator_type& _Al)
  : _Mybase(_Al)
  {
  }

 key_compare _Getcomp() const
  {
  return (key_compare());
  }

 void _Setcomp(const key_compare&)
  {
  }

 void _Swapcomp(const key_compare&)
  {
  }
 };


template<class _Traits>
 class _Tree
  : public _Tree_comp<
   !is_empty<typename _Traits::key_compare>::value, _Traits>
 {
public:
 typedef _Tree<_Traits> _Myt;
 typedef _Tree_comp<
  !is_empty<typename _Traits::key_compare>::value, _Traits> _Mybase;

 typedef typename _Traits::key_type key_type;
 typedef typename _Traits::value_compare value_compare;
 enum
  {
  _Multi = _Traits::_Multi};

 typedef typename _Mybase::_Node _Node;
 typedef typename _Mybase::_Nodeptr _Nodeptr;
 typedef typename _Mybase::_Alty _Alty;

 typedef typename _Mybase::key_compare key_compare;
 typedef typename _Mybase::allocator_type allocator_type;

 typedef typename _Mybase::value_type value_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;

 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _If<is_same<key_type, value_type>::value,
  typename _Mybase::const_iterator,
  typename _Mybase::iterator>::type iterator;

 typedef ::std:: reverse_iterator<iterator> reverse_iterator;
 typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

 typedef pair<iterator, bool> _Pairib;
 typedef pair<iterator, iterator> _Pairii;
 typedef pair<const_iterator, const_iterator> _Paircc;

 _Tree(const key_compare& _Parg,
  const allocator_type& _Al)
  : _Mybase(_Parg, _Al)
  {
  }

 _Tree(const value_type *_First, const value_type *_Last,
  const key_compare& _Parg, const allocator_type& _Al)
  : _Mybase(_Parg, _Al)
  {
  try {
  insert(_First, _Last);
  } catch (...) {
  _Tidy();
  throw;
  }
  }

 _Tree(const _Myt& _Right, const allocator_type& _Al)
  : _Mybase(_Right.key_comp(), _Al)
  {
  try {
  _Copy(_Right, false_type());
  } catch (...) {
  _Tidy();
  throw;
  }
  }

 _Tree(_Myt&& _Right)
  : _Mybase(_Right.key_comp(), _Right._Getal())
  {
  _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  }

 _Tree(_Myt&& _Right, const allocator_type& _Al)
  : _Mybase(_Right.key_comp(), _Al)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right));
  }

 _Myt& operator=(_Myt&& _Right)
  {
  if (this != &_Right)
   {
   clear();
   if (_Alty::propagate_on_container_move_assignment::value
    && this->_Getal() != _Right._Getal())
    this->_Change_alloc(_Right._Getal());

   _Assign_rv(::std:: forward<_Myt>(_Right));
   }
  return (*this);
  }

 void _Assign_rv(_Myt&& _Right, true_type)
  {
  this->_Swap_all(_Right);
  this->_Swapcomp(_Right._Getcomp());
  _Swap_adl(this->_Myhead, _Right._Myhead);
  ::std:: swap(this->_Mysize, _Right._Mysize);
  }

 void _Assign_rv(_Myt&& _Right, false_type)
  {
  if (get_allocator() == _Right.get_allocator())
   _Assign_rv(::std:: forward<_Myt>(_Right), true_type());
  else
   _Copy(_Right, true_type());
  }

 void _Assign_rv(_Myt&& _Right)
  {
  _Assign_rv(::std:: forward<_Myt>(_Right),
   typename _Alty::propagate_on_container_move_assignment());
  }


 _Pairib insert(value_type&& _Val)
  {
  return (_Insert_nohint(false,
   ::std:: forward<value_type>(_Val), _Nil_obj));
  }

 iterator insert(const_iterator _Where, value_type&& _Val)
  {
  return (_Insert_hint(_Where,
   ::std:: forward<value_type>(_Val), _Nil_obj));
  }

 template<class _Valty>
  typename enable_if<is_convertible<_Valty, value_type>::value,
   _Pairib>::type
  insert(_Valty&& _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
  return (_Insert_nohint(false,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class _Valty>
  typename enable_if<is_convertible<_Valty, value_type>::value,
   iterator>::type
  insert(const_iterator _Where, _Valty&& _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val));
  return (_Insert_hint(_Where,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class... _Valty>
  _Pairib emplace(_Valty&&... _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
  return (_Insert_nohint(false,
   this->_Myval(_Newnode), _Newnode));
  }

 template<class... _Valty>
  iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
  {
  _Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
  return (_Insert_hint(_Where,
   this->_Myval(_Newnode), _Newnode));
  }


 ~_Tree() throw ()
  {
  _Tidy();
  }

 _Myt& operator=(const _Myt& _Right)
  {
  if (this != &_Right)
   {
   clear();
   if (this->_Getal() != _Right._Getal()
    && _Alty::propagate_on_container_copy_assignment::value)
    this->_Change_alloc(_Right._Getal());

   this->_Setcomp(_Right._Getcomp());
   _Copy(_Right, false_type());
   }
  return (*this);
  }

 iterator begin() throw ()
  {
  return (iterator(_Lmost(), this));
  }

 const_iterator begin() const throw ()
  {
  return (const_iterator(_Lmost(), this));
  }

 iterator end() throw ()
  {
  return (iterator(this->_Myhead, this));
  }

 const_iterator end() const throw ()
  {
  return (const_iterator(this->_Myhead, this));
  }

 reverse_iterator rbegin() throw ()
  {
  return (reverse_iterator(end()));
  }

 const_reverse_iterator rbegin() const throw ()
  {
  return (const_reverse_iterator(end()));
  }

 reverse_iterator rend() throw ()
  {
  return (reverse_iterator(begin()));
  }

 const_reverse_iterator rend() const throw ()
  {
  return (const_reverse_iterator(begin()));
  }

 const_iterator cbegin() const throw ()
  {
  return (((const _Myt *)this)->begin());
  }

 const_iterator cend() const throw ()
  {
  return (((const _Myt *)this)->end());
  }

 const_reverse_iterator crbegin() const throw ()
  {
  return (((const _Myt *)this)->rbegin());
  }

 const_reverse_iterator crend() const throw ()
  {
  return (((const _Myt *)this)->rend());
  }

 size_type size() const throw ()
  {
  return (this->_Mysize);
  }

 size_type max_size() const throw ()
  {
  return (this->_Getal().max_size());
  }

 bool empty() const throw ()
  {
  return (size() == 0);
  }

 allocator_type get_allocator() const throw ()
  {
  return (this->_Getal());
  }

 key_compare key_comp() const
  {
  return (this->_Getcomp());
  }

 value_compare value_comp() const
  {
  return (value_compare(key_comp()));
  }

 _Pairib insert(const value_type& _Val)
  {
  return (_Insert_nohint(false,
   _Val, _Nil_obj));
  }

 iterator insert(const_iterator _Where,
  const value_type& _Val)
  {
  return (_Insert_hint(_Where,
   _Val, _Nil_obj));
  }

 template<class _Iter>
  void insert(_Iter _First, _Iter _Last)
  {
                             ;
  for (; _First != _Last; ++_First)

   emplace_hint(end(), *_First);
  }

 void insert(::std:: initializer_list<value_type> _Ilist)
  {
  insert(_Ilist.begin(), _Ilist.end());
  }

 iterator erase(const_iterator _Where)
  {
#line 1337 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtree"
  _Nodeptr _Erasednode = _Where._Mynode();
  ++_Where;


  _Nodeptr _Fixnode;
  _Nodeptr _Fixnodeparent;
  _Nodeptr _Pnode = _Erasednode;

  if (this->_Isnil(this->_Left(_Pnode)))
   _Fixnode = this->_Right(_Pnode);
  else if (this->_Isnil(this->_Right(_Pnode)))
   _Fixnode = this->_Left(_Pnode);
  else
   {
   _Pnode = _Where._Mynode();
   _Fixnode = this->_Right(_Pnode);
   }

  if (_Pnode == _Erasednode)
   {
   _Fixnodeparent = this->_Parent(_Erasednode);
   if (!this->_Isnil(_Fixnode))
    this->_Parent(_Fixnode) = _Fixnodeparent;

   if (_Root() == _Erasednode)
    _Root() = _Fixnode;
   else if (this->_Left(_Fixnodeparent) == _Erasednode)
    this->_Left(_Fixnodeparent) = _Fixnode;
   else
    this->_Right(_Fixnodeparent) =
     _Fixnode;

   if (_Lmost() == _Erasednode)
    _Lmost() = this->_Isnil(_Fixnode)
     ? _Fixnodeparent
     : this->_Min(_Fixnode);

   if (_Rmost() == _Erasednode)
    _Rmost() = this->_Isnil(_Fixnode)
     ? _Fixnodeparent
     : this->_Max(_Fixnode);
   }
  else
   {
   this->_Parent(this->_Left(_Erasednode)) =
    _Pnode;
   this->_Left(_Pnode) =
    this->_Left(_Erasednode);

   if (_Pnode == this->_Right(_Erasednode))
    _Fixnodeparent = _Pnode;
   else
    {
    _Fixnodeparent =
     this->_Parent(_Pnode);
    if (!this->_Isnil(_Fixnode))
     this->_Parent(_Fixnode) = _Fixnodeparent;
    this->_Left(_Fixnodeparent) = _Fixnode;
    this->_Right(_Pnode) =
     this->_Right(_Erasednode);
    this->_Parent(this->_Right(_Erasednode)) =
     _Pnode;
    }

   if (_Root() == _Erasednode)
    _Root() = _Pnode;
   else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
    this->_Left(this->_Parent(_Erasednode)) =
     _Pnode;
   else
    this->_Right(this->_Parent(_Erasednode)) =
     _Pnode;

   this->_Parent(_Pnode) =
    this->_Parent(_Erasednode);
   ::std:: swap(this->_Color(_Pnode),
    this->_Color(_Erasednode));
   }

  if (this->_Color(_Erasednode) == this->_Black)
   {
   for (; _Fixnode != _Root()
    && this->_Color(_Fixnode) == this->_Black;
    _Fixnodeparent = this->_Parent(_Fixnode))
    if (_Fixnode == this->_Left(_Fixnodeparent))
     {
     _Pnode = this->_Right(_Fixnodeparent);
     if (this->_Color(_Pnode) == this->_Red)
      {
      this->_Color(_Pnode) = this->_Black;
      this->_Color(_Fixnodeparent) = this->_Red;
      _Lrotate(_Fixnodeparent);
      _Pnode = this->_Right(_Fixnodeparent);
      }

     if (this->_Isnil(_Pnode))
      _Fixnode = _Fixnodeparent;
     else if (this->_Color(this->_Left(_Pnode)) == this->_Black
      && this->_Color(this->_Right(_Pnode)) == this->_Black)
      {
      this->_Color(_Pnode) = this->_Red;
      _Fixnode = _Fixnodeparent;
      }
     else
      {
      if (this->_Color(this->_Right(_Pnode))
       == this->_Black)
       {
       this->_Color(this->_Left(_Pnode)) = this->_Black;
       this->_Color(_Pnode) = this->_Red;
       _Rrotate(_Pnode);
       _Pnode = this->_Right(_Fixnodeparent);
       }

      this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
      this->_Color(_Fixnodeparent) = this->_Black;
      this->_Color(this->_Right(_Pnode)) = this->_Black;
      _Lrotate(_Fixnodeparent);
      break;
      }
     }
    else
     {
     _Pnode = this->_Left(_Fixnodeparent);
     if (this->_Color(_Pnode) == this->_Red)
      {
      this->_Color(_Pnode) = this->_Black;
      this->_Color(_Fixnodeparent) = this->_Red;
      _Rrotate(_Fixnodeparent);
      _Pnode = this->_Left(_Fixnodeparent);
      }

     if (this->_Isnil(_Pnode))
      _Fixnode = _Fixnodeparent;
     else if (this->_Color(this->_Right(_Pnode)) ==
      this->_Black
      && this->_Color(this->_Left(_Pnode)) == this->_Black)
      {
      this->_Color(_Pnode) = this->_Red;
      _Fixnode = _Fixnodeparent;
      }
     else
      {
      if (this->_Color(this->_Left(_Pnode)) == this->_Black)
       {
       this->_Color(this->_Right(_Pnode)) = this->_Black;
       this->_Color(_Pnode) = this->_Red;
       _Lrotate(_Pnode);
       _Pnode = this->_Left(_Fixnodeparent);
       }

      this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
      this->_Color(_Fixnodeparent) = this->_Black;
      this->_Color(this->_Left(_Pnode)) = this->_Black;
      _Rrotate(_Fixnodeparent);
      break;
      }
     }

   this->_Color(_Fixnode) = this->_Black;
   }

  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Erasednode)));

  this->_Getal().deallocate(_Erasednode, 1);

  if (0 < this->_Mysize)
   --this->_Mysize;

  return (iterator(_Where._Ptr, this));
  }

 iterator erase(const_iterator _First, const_iterator _Last)
  {
  if (_First == begin() && _Last == end())
   {
   clear();
   return (begin());
   }
  else
   {
   while (_First != _Last)
    erase(_First++);
   return (iterator(_First._Ptr, this));
   }
  }

 size_type erase(const key_type& _Keyval)
  {
  _Pairii _Where = equal_range(_Keyval);
  size_type _Num = 0;
  _Distance(_Where.first, _Where.second, _Num);
  erase(_Where.first, _Where.second);
  return (_Num);
  }

 void clear() throw ()
  {




  _Erase(_Root());
  _Root() = this->_Myhead;
  _Lmost() = this->_Myhead;
  _Rmost() = this->_Myhead;
  this->_Mysize = 0;
  }

 iterator find(const key_type& _Keyval)
  {
  iterator _Where = lower_bound(_Keyval);
  return (_Where == end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode()))

     ? end() : _Where);
  }

 const_iterator find(const key_type& _Keyval) const
  {
  const_iterator _Where = lower_bound(_Keyval);
  return (_Where == end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode()))

     ? end() : _Where);
  }

 size_type count(const key_type& _Keyval) const
  {
  _Paircc _Ans = equal_range(_Keyval);
  size_type _Num = 0;
  _Distance(_Ans.first, _Ans.second, _Num);
  return (_Num);
  }

 iterator lower_bound(const key_type& _Keyval)
  {
  return (iterator(_Lbound(_Keyval), this));
  }

 const_iterator lower_bound(const key_type& _Keyval) const
  {
  return (const_iterator(_Lbound(_Keyval), this));
  }

 iterator upper_bound(const key_type& _Keyval)
  {
  return (iterator(_Ubound(_Keyval), this));
  }

 const_iterator upper_bound(const key_type& _Keyval) const
  {
  return (const_iterator(_Ubound(_Keyval), this));
  }

 _Pairii equal_range(const key_type& _Keyval)
  {
  return (_Eqrange(_Keyval));
  }

 _Paircc equal_range(const key_type& _Keyval) const
  {
  return (_Eqrange(_Keyval));
  }

 void swap(_Myt& _Right)
  {
  if (this == &_Right)
   ;
  else if (this->_Getal() == _Right._Getal())
   {
   this->_Swap_all(_Right);
   this->_Swapcomp(_Right._Getcomp());
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }

  else if (_Alty::propagate_on_container_swap::value)
   {
   this->_Swap_alloc(_Right);
   this->_Swapcomp(_Right._Getcomp());
   _Swap_adl(this->_Myhead, _Right._Myhead);
   ::std:: swap(this->_Mysize, _Right._Mysize);
   }

  else
   {




   ::std:: terminate();

   }
  }

protected:
 template<class _Valty>
  _Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
  {
  return (_Node);
  }

 template<class _Valty>
  _Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
  {
  return (this->_Buynode(::std:: forward<_Valty>(_Val)));
  }

 void _Destroy_if_not_nil(_Nodeptr _Newnode)
  {
  this->_Getal().destroy(
   ::std:: addressof(this->_Myval(_Newnode)));

  this->_Getal().deallocate(_Newnode, 1);
  }

 void _Destroy_if_not_nil(_Nil)
  {
  }

 template<class _Valty,
  class _Nodety>
  iterator _Insert_hint(const_iterator _Where,
   _Valty&& _Val, _Nodety _Newnode)
  {
  const_iterator _Next;
  bool _Leftish = false;

  try {






  if (size() == 0)
   return (_Insert_at(true, this->_Myhead,
    ::std:: forward<_Valty>(_Val), _Newnode));
  else if (this->_Multi)
   {
   if (_Where == begin())
    {
    if (!this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val)))

     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    _Leftish = true;
    }
   else if (_Where == end())
    {
    if (!this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Rmost())))

     return (_Insert_at(false, _Rmost(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (!this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val))

    && !this->_Getcomp()(this->_Kfn(_Val), this->_Key((--(_Next = _Where))._Mynode())))


    {
    if (this->_Isnil(this->_Right(_Next._Mynode())))
     return (_Insert_at(false, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (!this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Where._Mynode()))

    && (++(_Next = _Where) == end()
     || !this->_Getcomp()(this->_Key(_Next._Mynode()), this->_Kfn(_Val))))

    {
    if (this->_Isnil(this->_Right(_Where._Mynode())))
     return (_Insert_at(false, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else
    _Leftish = true;
   }
  else
   {
   if (_Where == begin())
    {
    if (this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Where._Mynode())))

     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (_Where == end())
    {
    if (this->_Getcomp()(this->_Key(_Rmost()), this->_Kfn(_Val)))

     return (_Insert_at(false, _Rmost(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Where._Mynode()))

    && this->_Getcomp()(this->_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val)))


    {
    if (this->_Isnil(this->_Right(_Next._Mynode())))
     return (_Insert_at(false, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   else if (this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val))

    && (++(_Next = _Where) == end()
     || this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Next._Mynode()))))

    {
    if (this->_Isnil(this->_Right(_Where._Mynode())))
     return (_Insert_at(false, _Where._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    else
     return (_Insert_at(true, _Next._Mynode(),
      ::std:: forward<_Valty>(_Val), _Newnode));
    }
   }
  } catch (...) {
  _Destroy_if_not_nil(_Newnode);
  throw;
  }

  return (_Insert_nohint(_Leftish,
   ::std:: forward<_Valty>(_Val), _Newnode).first);
  }

 template<class _Valty,
  class _Nodety>
  _Pairib _Insert_nohint(bool _Leftish,
   _Valty&& _Val, _Nodety _Newnode)
  {
  try {
  _Nodeptr _Trynode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;
  bool _Addleft = true;

  while (!this->_Isnil(_Trynode))
   {
   _Wherenode = _Trynode;
   if (_Leftish)
    _Addleft = !this->_Getcomp()(this->_Key(_Trynode), this->_Kfn(_Val));


   else
    _Addleft = this->_Getcomp()(this->_Kfn(_Val), this->_Key(_Trynode));


   _Trynode = _Addleft ? this->_Left(_Trynode)
    : this->_Right(_Trynode);
   }

  if (this->_Multi)
   return (_Pairib(_Insert_at(_Addleft, _Wherenode,
    ::std:: forward<_Valty>(_Val), _Newnode), true));
  else
   {
   iterator _Where = iterator(_Wherenode, this);
   if (!_Addleft)
    ;
   else if (_Where == begin())
    return (_Pairib(_Insert_at(true, _Wherenode,
     ::std:: forward<_Valty>(_Val), _Newnode), true));
   else
    --_Where;

   if (this->_Getcomp()(this->_Key(_Where._Mynode()), this->_Kfn(_Val)))


    return (_Pairib(_Insert_at(_Addleft, _Wherenode,
     ::std:: forward<_Valty>(_Val), _Newnode), true));
   else
    {
    _Destroy_if_not_nil(_Newnode);
    return (_Pairib(_Where, false));
    }
   }
  } catch (...) {
  _Destroy_if_not_nil(_Newnode);
  throw;
  }
  }

 template<class _Valty,
  class _Nodety>
  iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
  _Valty&& _Val, _Nodety _Node)
  {
  if (max_size() - 1 <= this->_Mysize)
   {
   _Destroy_if_not_nil(_Node);
   _Xlength_error("map/set<T> too long");
   }
  _Nodeptr _Newnode = _Buynode_if_nil(_Node,
   ::std:: forward<_Valty>(_Val));

  ++this->_Mysize;
  _Newnode->_Parent = _Wherenode;

  if (_Wherenode == this->_Myhead)
   {
   _Root() = _Newnode;
   _Lmost() = _Newnode;
   _Rmost() = _Newnode;
   }
  else if (_Addleft)
   {
   this->_Left(_Wherenode) = _Newnode;
   if (_Wherenode == _Lmost())
    _Lmost() = _Newnode;
   }
  else
   {
   this->_Right(_Wherenode) = _Newnode;
   if (_Wherenode == _Rmost())
    _Rmost() = _Newnode;
   }

  for (_Nodeptr _Pnode = _Newnode;
   this->_Color(this->_Parent(_Pnode)) == this->_Red; )
   if (this->_Parent(_Pnode)
    == this->_Left(this->_Parent(this->_Parent(_Pnode))))
    {
    _Wherenode =
     this->_Right(this->_Parent(this->_Parent(_Pnode)));
    if (this->_Color(_Wherenode) == this->_Red)
     {
     this->_Color(this->_Parent(_Pnode)) = this->_Black;
     this->_Color(_Wherenode) = this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode)))
      = this->_Red;
     _Pnode = this->_Parent(this->_Parent(_Pnode));
     }
    else
     {
     if (_Pnode == this->_Right(this->_Parent(_Pnode)))
      {
      _Pnode = this->_Parent(_Pnode);
      _Lrotate(_Pnode);
      }
     this->_Color(this->_Parent(_Pnode)) =
      this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode))) =
      this->_Red;
     _Rrotate(this->_Parent(this->_Parent(_Pnode)));
     }
    }
   else
    {
    _Wherenode =
     this->_Left(this->_Parent(this->_Parent(_Pnode)));
    if (this->_Color(_Wherenode) == this->_Red)
     {
     this->_Color(this->_Parent(_Pnode)) = this->_Black;
     this->_Color(_Wherenode) = this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode))) =
      this->_Red;
     _Pnode = this->_Parent(this->_Parent(_Pnode));
     }
    else
     {
     if (_Pnode == this->_Left(this->_Parent(_Pnode)))
      {
      _Pnode = this->_Parent(_Pnode);
      _Rrotate(_Pnode);
      }
     this->_Color(this->_Parent(_Pnode)) =
      this->_Black;
     this->_Color(this->_Parent(this->_Parent(_Pnode))) =
      this->_Red;
     _Lrotate(this->_Parent(this->_Parent(_Pnode)));
     }
    }

  this->_Color(_Root()) = this->_Black;
  return (iterator(_Newnode, this));
  }

 template<class _Moveit>
  void _Copy(const _Myt& _Right,
   _Moveit _Movefl)
  {
  _Root() = _Copy_nodes(_Right._Root(), this->_Myhead, _Movefl);
  this->_Mysize = _Right.size();
  if (!this->_Isnil(_Root()))
   {
   _Lmost() = this->_Min(_Root());
   _Rmost() = this->_Max(_Root());
   }
  else
   {
   _Lmost() = this->_Myhead;
   _Rmost() = this->_Myhead;
   }
  }

 template<class _Want_to_move,
  class _Can_move,
  class _Is_set,
  class _Dummy>
  _Nodeptr _Copy_or_move(_Nodeptr _Rootnode, _Want_to_move,
   _Can_move, _Is_set, _Dummy)
  {
  return (this->_Buynode(this->_Myval(_Rootnode)));
  }

 template<class _Dummy>
  _Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
   true_type, true_type, _Dummy)
  {
  return (this->_Buynode(
   ::std:: forward<value_type>(this->_Myval(_Rootnode))));
  }

 template<class _Dummy>
  _Nodeptr _Copy_or_move(_Nodeptr _Rootnode, true_type,
   true_type, false_type, _Dummy)
  {
  return (this->_Buynode(
   ::std:: forward<key_type>(const_cast<key_type&>(
    this->_Myval(_Rootnode).first)),
   ::std:: forward<typename value_type::second_type>(this->_Myval(
    _Rootnode).second)));
  }

 template<class _Moveit>
  _Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
   _Moveit _Movefl)
  {
  _Nodeptr _Newroot = this->_Myhead;

  if (!this->_Isnil(_Rootnode))
   {
   _Nodeptr _Pnode = _Copy_or_move(_Rootnode, _Movefl,
    typename is_move_constructible<value_type>::type(),
    typename is_same<key_type, value_type>::type(), 0);
   _Pnode->_Parent = _Wherenode;
   _Pnode->_Color = this->_Color(_Rootnode);
   if (this->_Isnil(_Newroot))
    _Newroot = _Pnode;

   try {
   this->_Left(_Pnode) =
    _Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
   this->_Right(_Pnode) =
    _Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
   } catch (...) {
   _Erase(_Newroot);
   throw;
   }
   }

  return (_Newroot);
  }

 _Paircc _Eqrange(const key_type& _Keyval) const
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Lonode = this->_Myhead;
  _Nodeptr _Hinode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(this->_Key(_Pnode), _Keyval))
    _Pnode = this->_Right(_Pnode);
   else
    {
    if (this->_Isnil(_Hinode)
      && this->_Getcomp()(_Keyval, this->_Key(_Pnode)))

     _Hinode = _Pnode;
    _Lonode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }

  _Pnode = this->_Isnil(_Hinode) ? _Root()
   : this->_Left(_Hinode);
  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(_Keyval, this->_Key(_Pnode)))
    {
    _Hinode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }
   else
    _Pnode = this->_Right(_Pnode);

  const_iterator _First = const_iterator(_Lonode, this);
  const_iterator _Last = const_iterator(_Hinode, this);
  return (_Paircc(_First, _Last));
  }

 _Pairii _Eqrange(const key_type& _Keyval)
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Lonode = this->_Myhead;
  _Nodeptr _Hinode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(this->_Key(_Pnode), _Keyval))
    _Pnode = this->_Right(_Pnode);
   else
    {
    if (this->_Isnil(_Hinode)
      && this->_Getcomp()(_Keyval, this->_Key(_Pnode)))

     _Hinode = _Pnode;
    _Lonode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }

  _Pnode = this->_Isnil(_Hinode) ? _Root()
   : this->_Left(_Hinode);
  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(_Keyval, this->_Key(_Pnode)))
    {
    _Hinode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }
   else
    _Pnode = this->_Right(_Pnode);

  iterator _First = iterator(_Lonode, this);
  iterator _Last = iterator(_Hinode, this);
  return (_Pairii(_First, _Last));
  }

 void _Erase(_Nodeptr _Rootnode)
  {
  for (_Nodeptr _Pnode = _Rootnode;
   !this->_Isnil(_Pnode); _Rootnode = _Pnode)
   {
   _Erase(this->_Right(_Pnode));
   _Pnode = this->_Left(_Pnode);
   this->_Getal().destroy(
    ::std:: addressof(this->_Myval(_Rootnode)));

   this->_Getal().deallocate(_Rootnode, 1);
   }
  }

 _Nodeptr _Lbound(const key_type& _Keyval) const
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(this->_Key(_Pnode), _Keyval))
    _Pnode = this->_Right(_Pnode);
   else
    {
    _Wherenode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }

  return (_Wherenode);
  }

 _Nodeptr _Lbound(const key_type& _Keyval)
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(this->_Key(_Pnode), _Keyval))
    _Pnode = this->_Right(_Pnode);
   else
    {
    _Wherenode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }

  return (_Wherenode);
  }

 _Nodeptr& _Lmost() const
  {
  return (this->_Left(this->_Myhead));
  }

 void _Lrotate(_Nodeptr _Wherenode)
  {
  _Nodeptr _Pnode = this->_Right(_Wherenode);
  this->_Right(_Wherenode) = this->_Left(_Pnode);

  if (!this->_Isnil(this->_Left(_Pnode)))
   this->_Parent(this->_Left(_Pnode)) = _Wherenode;
  this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  if (_Wherenode == _Root())
   _Root() = _Pnode;
  else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
   this->_Left(this->_Parent(_Wherenode)) = _Pnode;
  else
   this->_Right(this->_Parent(_Wherenode)) = _Pnode;

  this->_Left(_Pnode) = _Wherenode;
  this->_Parent(_Wherenode) = _Pnode;
  }

 _Nodeptr& _Rmost() const
  {
  return (this->_Right(this->_Myhead));
  }

 _Nodeptr& _Root() const
  {
  return (this->_Parent(this->_Myhead));
  }

 void _Rrotate(_Nodeptr _Wherenode)
  {
  _Nodeptr _Pnode = this->_Left(_Wherenode);
  this->_Left(_Wherenode) = this->_Right(_Pnode);

  if (!this->_Isnil(this->_Right(_Pnode)))
   this->_Parent(this->_Right(_Pnode)) = _Wherenode;
  this->_Parent(_Pnode) = this->_Parent(_Wherenode);

  if (_Wherenode == _Root())
   _Root() = _Pnode;
  else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
   this->_Right(this->_Parent(_Wherenode)) = _Pnode;
  else
   this->_Left(this->_Parent(_Wherenode)) = _Pnode;

  this->_Right(_Pnode) = _Wherenode;
  this->_Parent(_Wherenode) = _Pnode;
  }

 _Nodeptr _Ubound(const key_type& _Keyval) const
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(_Keyval, this->_Key(_Pnode)))
    {
    _Wherenode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }
   else
    _Pnode = this->_Right(_Pnode);

  return (_Wherenode);
  }

 _Nodeptr _Ubound(const key_type& _Keyval)
  {
  _Nodeptr _Pnode = _Root();
  _Nodeptr _Wherenode = this->_Myhead;

  while (!this->_Isnil(_Pnode))
   if (this->_Getcomp()(_Keyval, this->_Key(_Pnode)))
    {
    _Wherenode = _Pnode;
    _Pnode = this->_Left(_Pnode);
    }
   else
    _Pnode = this->_Right(_Pnode);

  return (_Wherenode);
  }
#line 2228 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\xtree"
 void _Tidy()
  {
  erase(begin(), end());
  }

 const key_type& _Kfn(const value_type& _Val) const
  {
  return (_Traits::_Kfn(_Val));
  }

 const key_type& _Key(_Nodeptr _Pnode) const
  {
  return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));
  }
 };


template<class _Traits> inline
 bool operator==(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (_Left.size() == _Right.size()
  && equal(_Left.begin(), _Left.end(), _Right.begin()));
 }

template<class _Traits> inline
 bool operator!=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class _Traits> inline
 bool operator<(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (lexicographical_compare(_Left.begin(), _Left.end(),
  _Right.begin(), _Right.end()));
 }

template<class _Traits> inline
 bool operator>(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (_Right < _Left);
 }

template<class _Traits> inline
 bool operator<=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class _Traits> inline
 bool operator>=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
 {
 return (!(_Left < _Right));
 }
}


#pragma warning(pop)
#pragma pack(pop)
#line 6 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\map"


#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\tuple"
#line 10 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\tuple"
#pragma pack(push,8)
#pragma warning(push, 3)



#pragma warning(disable: 4100 4521 4522)

namespace std {

template<class _Src,
 class _Dest>
 struct _Tuple_enable
 {
 };

template<>
 struct _Tuple_enable<tuple<>, tuple<> >
 {
 typedef void ** type;
 };

template<class _Src0,
 class... _Types1,
 class _Dest0,
 class... _Types2>
 struct _Tuple_enable<tuple<_Src0, _Types1...>,
  tuple<_Dest0, _Types2...> >
 : _If<is_convertible<_Src0, _Dest0>::value,
  _Tuple_enable<tuple<_Types1...>, tuple<_Types2...> >,
  _Tuple_enable<int, int>
 >::type
 {
 };



class _Ignore
 {
public:
 _Ignore()
  {
  }

 template<class _Ty>
  void operator=(const _Ty&) const
  {
  }
 };

const _Ignore ignore;


struct _Tuple_alloc_t
 {
 };

const _Tuple_alloc_t _Tuple_alloc = _Tuple_alloc_t();


template<class _Ty>
 struct _Tuple_val
 {
 _Tuple_val()
  : _Val()
  {
  }

 template<class _Other>
  _Tuple_val(_Other&& _Arg)
  : _Val(::std:: forward<_Other>(_Arg))
  {
  }

 template<class _Other>
  _Tuple_val& operator=(_Other&& _Right)
  {
  _Val = ::std:: forward<_Other>(_Right);
  return (*this);
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc&,
   typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
    _Tuple_alloc_t>::type, _Other&&... _Arg)
  : _Val(::std:: forward<_Other>(_Arg)...)
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc& _Al,
   typename enable_if<uses_allocator<_Ty, _Alloc>::value
    && is_constructible<_Ty,
     allocator_arg_t, _Alloc>::value,
    _Tuple_alloc_t>::type, _Other&&... _Arg)
  : _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...)
  {
  }

 template<class _Alloc,
  class... _Other>
  _Tuple_val(const _Alloc& _Al,
   typename enable_if<uses_allocator<_Ty, _Alloc>::value
    && !is_constructible<_Ty,
     allocator_arg_t, _Alloc>::value,
    _Tuple_alloc_t>::type, _Other&&... _Arg)
  : _Val(::std:: forward<_Other>(_Arg)..., _Al)
  {
  }


 _Ty _Val;
 };


template<class... _Types>
 class tuple;

template<>
 class tuple<>
 {
public:
 typedef tuple<> _Myt;

 tuple()
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc&) throw ()
  {
  }

 tuple(const tuple&) throw ()
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc&, const tuple&) throw ()
  {
  }

 void swap(_Myt&) throw ()
  {
  }

 bool _Equals(const _Myt&) const throw ()
  {
  return (true);
  }

 bool _Less(const _Myt&) const throw ()
  {
  return (false);
  }
 };

template<class _This,
 class... _Rest>
 class tuple<_This, _Rest...>
  : private tuple<_Rest...>
 {
public:
 typedef _This _This_type;
 typedef tuple<_This, _Rest...> _Myt;
 typedef tuple<_Rest...> _Mybase;
 static const size_t _Mysize = 1 + sizeof...(_Rest);

 tuple()
  : _Mybase(),
   _Myfirst()
  {
  }

 template<class... _Rest2>
  explicit tuple(_Tuple_alloc_t, _Rest2&&... _Rest_arg)
   : _Mybase(::std:: forward<_Rest2>(_Rest_arg)...),
    _Myfirst(allocator_arg)
  {
  }

 template<class... _Other,
  class = typename _Tuple_enable<
   tuple<const _Other&...>, _Myt>::type>
  tuple(const tuple<_Other...>& _Right)
  : _Mybase(_Right._Get_rest()), _Myfirst(_Right._Myfirst._Val)
  {
  }

 template<class _Alloc,
  class... _Other,
  class = typename _Tuple_enable<
   tuple<const _Other&...>, _Myt>::type>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const tuple<_Other...>& _Right)
  : _Mybase(allocator_arg, _Al, _Right._Get_rest()),
   _Myfirst(_Al, _Tuple_alloc,
    _Right._Myfirst._Val)
  {
  }

 explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)
  : _Mybase(_Rest_arg...),
   _Myfirst(_This_arg)
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const _This& _This_arg, const _Rest&... _Rest_arg)
  : _Mybase(allocator_arg, _Al, _Rest_arg...),
   _Myfirst(_Al, _Tuple_alloc, _This_arg)
  {
  }

 template<class _This2,
  class... _Rest2,
  class = typename _Tuple_enable<
   tuple<_This2, _Rest2...>, _Myt>::type>
  explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)
  : _Mybase(::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(::std:: forward<_This2>(_This_arg))
  {
  }

 template<class _Alloc,
  class _This2,
  class... _Rest2,
  class = typename _Tuple_enable<
   tuple<_This2, _Rest2...>, _Myt>::type>
  tuple(allocator_arg_t, const _Alloc& _Al,
   _This2&& _This_arg, _Rest2&&... _Rest_arg)
  : _Mybase(allocator_arg, _Al,
    ::std:: forward<_Rest2>(_Rest_arg)...),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<_This2>(_This_arg))
  {
  }

 template<class... _Other,
  class = typename _Tuple_enable<
   tuple<_Other...>, _Myt>::type>
  tuple(tuple<_Other...>&& _Right)
  : _Mybase(::std:: forward<typename tuple<_Other...>::_Mybase>
   (_Right._Get_rest())),
   _Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>
    (_Right._Myfirst._Val))
  {
  }

 template<class _Alloc,
  class... _Other,
  class = typename _Tuple_enable<
   tuple<_Other...>, _Myt>::type>
  tuple(allocator_arg_t, const _Alloc& _Al,
   tuple<_Other...>&& _Right)
  : _Mybase(allocator_arg, _Al,
    ::std:: forward<typename tuple<_Other...>::_Mybase>
     (_Right._Get_rest())),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<typename tuple<_Other...>::_This_type>
     (_Right._Myfirst._Val))
  {
  }

 template<class... _Other>
  _Myt& operator=(const tuple<_Other...>& _Right)
  {
  _Myfirst._Val = _Right._Myfirst._Val;
  (_Mybase&)*this = _Right._Get_rest();
  return (*this);
  }

 template<class... _Other>
  _Myt& operator=(tuple<_Other...>&& _Right)
  {
  _Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>
   (_Right._Myfirst._Val);
  (_Mybase&)*this = ::std:: forward<typename tuple<_Other...>::_Mybase>
   (_Right._Get_rest());
  return (*this);
  }

 template<class... _Other>
  bool _Equals(const tuple<_Other...>& _Right) const
  {
  static_assert(_Mysize == sizeof...(_Other),
   "comparing tuple to object with different size");
  return (_Myfirst._Val == _Right._Myfirst._Val
   && _Mybase::_Equals(_Right._Get_rest()));
  }

 template<class... _Other>
  bool _Less(const tuple<_Other...>& _Right) const
  {
  static_assert(_Mysize == sizeof...(_Other),
   "comparing tuple to object with different size");
  return (_Myfirst._Val < _Right._Myfirst._Val
   || (!(_Right._Myfirst._Val < _Myfirst._Val)
    && _Mybase::_Less(_Right._Get_rest())));
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al)
  : _Mybase(allocator_arg, _Al),
   _Myfirst(_Al, _Tuple_alloc)
  {
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const _Myt& _Right)
  : _Mybase(allocator_arg, _Al, _Right._Get_rest()),
   _Myfirst(_Al, _Tuple_alloc,
    _Right._Myfirst._Val)
  {
  }

 template<class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<const _First&, const _Second&>, _Myt>::type>
  tuple(const pair<_First, _Second>& _Right)

  : _Mybase(tuple<_Second>(_Right.second)),
   _Myfirst(_Right.first)
  {

  }

 template<class _Alloc,
  class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<const _First&, const _Second&>, _Myt>::type>
  tuple(allocator_arg_t, const _Alloc& _Al,
   const pair<_First, _Second>& _Right)

  : _Mybase(allocator_arg, _Al, tuple<_Second>(_Right.second)),
   _Myfirst(_Al, _Tuple_alloc,
    _Right.first)
  {

  }

 _Myt& operator=(const _Myt& _Right)
  {
  _Myfirst._Val = _Right._Myfirst._Val;
  (_Mybase&)*this = _Right._Get_rest();
  return (*this);
  }

 template<class _First,
  class _Second>
  _Myt& operator=(const pair<_First, _Second>& _Right)
  {
  static_assert(_Mysize == 2,
   "assigning to tuple from object with different size");
  _Myfirst._Val = _Right.first;
  (_Mybase&)*this = tuple<_Second>(_Right.second);
  return (*this);
  }

 template<class _Alloc>
  tuple(allocator_arg_t, const _Alloc& _Al,
   _Myt&& _Right)
  : _Mybase(allocator_arg, _Al,
    ::std:: forward<_Mybase>(_Right._Get_rest())),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<_This>(_Right._Myfirst._Val))
  {
  }

 template<class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<_First, _Second>, _Myt>::type>
  tuple(pair<_First, _Second>&& _Right)

  : _Mybase(tuple<_Second>(::std:: forward<_Second>(_Right.second))),
   _Myfirst(::std:: forward<_First>(_Right.first))
  {

  }

 template<class _Alloc,
  class _First,
  class _Second,
  class = typename _Tuple_enable<
   tuple<_First, _Second>, _Myt>::type>
  tuple(allocator_arg_t, const _Alloc& _Al,
   pair<_First, _Second>&& _Right)

  : _Mybase(allocator_arg, _Al,
    tuple<_Second>(::std:: forward<_Second>(_Right.second))),
   _Myfirst(_Al, _Tuple_alloc,
    ::std:: forward<_First>(_Right.first))
  {

  }

 _Myt& operator=(_Myt&& _Right)


  {
  _Myfirst = ::std:: forward<_This>(_Right._Myfirst._Val);
  (_Mybase&)*this = ::std:: forward<_Mybase>(_Right._Get_rest());
  return (*this);
  }

 template<class _First,
  class _Second>
  _Myt& operator=(pair<_First, _Second>&& _Right)




  {
  static_assert(_Mysize == 2,
   "assigning to tuple from object with different size");
  _Myfirst._Val = ::std:: forward<_First>(_Right.first);
  (_Mybase&)*this =
   tuple<_Second>(::std:: forward<_Second>(_Right.second));
  return (*this);
  }

 _Mybase& _Get_rest()
  {
  return (*this);
  }

 const _Mybase& _Get_rest() const
  {
  return (*this);
  }

 void swap(tuple& _Right)



  {
  _Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
  _Mybase::swap((_Mybase&)_Right);
  }

 _Tuple_val<_This> _Myfirst;
 };




template<class... _Types1,
 class... _Types2> inline
 bool operator==(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Left._Equals(_Right));
 }

template<class... _Types1,
 class... _Types2> inline
 bool operator!=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Left == _Right));
 }

template<class... _Types1,
 class... _Types2> inline
 bool operator<(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Left._Less(_Right));
 }

template<class... _Types1,
 class... _Types2> inline
 bool operator>=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Left < _Right));
 }

template<class... _Types1,
 class... _Types2> inline
 bool operator>(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (_Right < _Left);
 }

template<class... _Types1,
 class... _Types2> inline
 bool operator<=(const tuple<_Types1...>& _Left,
  const tuple<_Types2...>& _Right)
 {
 return (!(_Right < _Left));
 }

template<class... _Types> inline
 void swap(tuple<_Types...>& _Left,
  tuple<_Types...>& _Right)

 {
 return (_Left.swap(_Right));
 }



template<size_t _Index,
 class _Tuple>
 struct tuple_element;

template<class _This,
 class... _Rest>
 struct tuple_element<0, tuple<_This, _Rest...> >
 {
 typedef _This type;
 typedef typename add_lvalue_reference<const _This>::type _Ctype;
 typedef typename add_lvalue_reference<_This>::type _Rtype;
 typedef typename add_rvalue_reference<_This>::type _RRtype;
 typedef tuple<_This, _Rest...> _Ttype;
 };

template<size_t _Index,
 class _This,
 class... _Rest>
 struct tuple_element<_Index, tuple<_This, _Rest...> >
  : public tuple_element<_Index - 1, tuple<_Rest...> >
 {
 };


template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const _Tuple>
 : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_const<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, volatile _Tuple>
 : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_volatile<typename _Mybase::type>::type type;
 };

template<size_t _Index,
 class _Tuple>
 struct tuple_element<_Index, const volatile _Tuple>
 : public tuple_element<_Index, _Tuple>
 {
 typedef tuple_element<_Index, _Tuple> _Mybase;
 typedef typename add_cv<typename _Mybase::type>::type type;
 };


template<size_t _Index,
 class... _Types> inline
 typename tuple_element<_Index, tuple<_Types...> >::_Rtype
  get(tuple<_Types...>& _Tuple)
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<size_t _Index,
 class... _Types> inline
 typename tuple_element<_Index, tuple<_Types...> >::_Ctype
  get(const tuple<_Types...>& _Tuple)
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 return (((_Ttype&)_Tuple)._Myfirst._Val);
 }

template<size_t _Index,
 class... _Types> inline
 typename tuple_element<_Index, tuple<_Types...> >::_RRtype
  get(tuple<_Types...>&& _Tuple)
 {
 typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
  _Ttype;
 typedef typename tuple_element<_Index, tuple<_Types...> >::_RRtype
  _RRtype;
 return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
 }


template<class... _Types> inline
 tuple<typename _Unrefwrap<_Types>::type...>
  make_tuple(_Types&&... _Args)
 {
 typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
 return (_Ttype(::std:: forward<_Types>(_Args)...));
 }


template<class... _Types> inline
 tuple<_Types&...>
  tie(_Types&... _Args) throw ()
 {
 typedef tuple<_Types&...> _Ttype;
 return (_Ttype(_Args...));
 }




template<class... _Types> inline
 tuple<_Types&&...>
  forward_as_tuple(_Types&&... _Args) throw ()
 {
 return (tuple<_Types&&...>(::std:: forward<_Types>(_Args)...));
 }



template<class _Arg_idx_type,
 class... _Types>
 struct _Make_arg_idx1
 {
 typedef _Arg_idx_type type;
 };

template<size_t... _Indexes,
 class _Ty,
 class... _Types>
 struct _Make_arg_idx1<_Arg_idx<_Indexes...>, _Ty, _Types...>
  : _Make_arg_idx1<_Arg_idx<sizeof...(_Types), _Indexes...>, _Types...>
 {
 };

template<class... _Types>
 struct _Make_arg_idx
  : _Make_arg_idx1<_Arg_idx<>, _Types...>
 {
 };

template<class _Arg_idx_type1,
 class _Arg_idx_type2>
 struct _Cat_arg_idx;

template<size_t... _Indexes1,
 size_t... _Indexes2>
 struct _Cat_arg_idx<_Arg_idx<_Indexes1...>, _Arg_idx<_Indexes2...> >
 {
 typedef _Arg_idx<_Indexes1..., _Indexes2...> type;
 };

template<size_t _Nx,
 class _Ty>
 struct _Repeat_for
  : integral_constant<size_t, _Nx>
 {
 };


template<class _Ret,
 class _Kx_arg,
 class _Ix_arg,
 size_t _Ix_next,
 class... _Tuples>
 struct _Tuple_cat2
 {
 static_assert(sizeof...(_Tuples) == 0,
  "Unsupported tuple_cat arguments.");
 typedef _Ret type;
 typedef _Kx_arg _Kx_arg_idx;
 typedef _Ix_arg _Ix_arg_idx;
 };

template<class... _Types1,
 class _Kx_arg,
 size_t... _Ix,
 size_t _Ix_next,
 class... _Types2,
 class... _Rest>
 struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, _Arg_idx<_Ix...>, _Ix_next,
  tuple<_Types2...>, _Rest...>
  : _Tuple_cat2<
   tuple<_Types1..., _Types2...>,
   typename _Cat_arg_idx<_Kx_arg,
    typename _Make_arg_idx<_Types2...>::type>::type,
   _Arg_idx<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
   _Ix_next + 1,
   _Rest...>
 {
 };

template<class... _Tuples>
 struct _Tuple_cat1
  : _Tuple_cat2<tuple<>, _Arg_idx<>, _Arg_idx<>, 0,
   typename decay<_Tuples>::type...>
 {
 };

template<class _Ret,
 size_t... _Kx,
 size_t... _Ix,
 class _Ty> inline
 _Ret _Tuple_cat(_Arg_idx<_Kx...>, _Arg_idx<_Ix...>, _Ty&& _Arg)
 {
 return (_Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...));
 }

template<class... _Tuples> inline
 typename _Tuple_cat1<_Tuples...>::type
  tuple_cat(_Tuples&&... _Tpls)
 {
 typedef _Tuple_cat1<_Tuples...> _Cat1;
 return (_Tuple_cat<typename _Cat1::type>(
  typename _Cat1::_Kx_arg_idx(), typename _Cat1::_Ix_arg_idx(),
  ::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...)));
 }



template<class _Ty1,
 class _Ty2>
 template<class _Tuple1,
  class _Tuple2,
  size_t... _Indexes1,
  size_t... _Indexes2> inline
  pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
   _Tuple2& _Val2,
   _Arg_idx<_Indexes1...>,
   _Arg_idx<_Indexes2...>)
  : first(::std:: get<_Indexes1>(::std:: move(_Val1))...),
   second(::std:: get<_Indexes2>(::std:: move(_Val2))...)
  {
  }


template<class _Ty1,
 class _Ty2>
 template<class... _Types1,
  class... _Types2> inline
  pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
   tuple<_Types1...> _Val1,
   tuple<_Types2...> _Val2)


  : pair(_Val1, _Val2,
   typename _Make_arg_idx<_Types1...>::type(),
   typename _Make_arg_idx<_Types2...>::type())
  {
  }
}

namespace std {

template<class... _Types,
 class _Alloc>
 struct uses_allocator<tuple<_Types...>, _Alloc>
  : true_type
 {
 };

}

namespace std {
namespace tr1 {
using ::std:: get;
using ::std:: ignore;
using ::std:: make_tuple;
using ::std:: ref;
using ::std:: tie;
using ::std:: tuple;
using ::std:: tuple_element;
}
}


#pragma warning(pop)
#pragma pack(pop)
#line 8 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\map"


#pragma pack(push,8)
#pragma warning(push, 3)



namespace std {

template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc,
 bool _Mfl>
 class _Tmap_traits
 {
public:
 typedef _Kty key_type;
 typedef pair<const _Kty, _Ty> value_type;
 typedef _Pr key_compare;
 typedef _Alloc allocator_type;

 enum
  {
  _Multi = _Mfl};

 class value_compare
  : public binary_function<value_type, value_type, bool>
  {
  friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;

 public:
  bool operator()(const value_type& _Left,
   const value_type& _Right) const
   {
   return (comp(_Left.first, _Right.first));
   }

  value_compare(key_compare _Pred)
   : comp(_Pred)
   {
   }

 protected:
  key_compare comp;
  };

 template<class _Ty1,
  class _Ty2>
  static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)
  {
  return (_Val.first);
  }
 };


template<class _Kty,
 class _Ty,
 class _Pr = less<_Kty>,
 class _Alloc = allocator<pair<const _Kty, _Ty> > >
 class map
  : public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
 {
public:
 typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
 typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
 typedef _Kty key_type;
 typedef _Ty mapped_type;
 typedef _Ty referent_type;
 typedef _Pr key_compare;
 typedef typename _Mybase::value_compare value_compare;
 typedef typename _Mybase::allocator_type allocator_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _Mybase::reverse_iterator reverse_iterator;
 typedef typename _Mybase::const_reverse_iterator
  const_reverse_iterator;
 typedef typename _Mybase::value_type value_type;

 map()
  : _Mybase(key_compare(), allocator_type())
  {
  }

 explicit map(const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  }

 map(const _Myt& _Right)

  : _Mybase(_Right,
   _Right._Getal().select_on_container_copy_construction())


  {
  }

 map(const _Myt& _Right, const allocator_type& _Al)
  : _Mybase(_Right, _Al)
  {
  }

 explicit map(const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  }

 map(const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  }

 template<class _Iter>
  map(_Iter _First, _Iter _Last)
  : _Mybase(key_compare(), allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  map(_Iter _First, _Iter _Last,
   const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  map(_Iter _First, _Iter _Last,
   const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  _Mybase::insert(_First, _Last);
  }

 _Myt& operator=(const _Myt& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 map(_Myt&& _Right)
  : _Mybase(::std:: move(_Right))
  {
  }

 map(_Myt&& _Right, const allocator_type& _Al)
  : _Mybase(::std:: move(_Right), _Al)
  {
  }

 _Myt& operator=(_Myt&& _Right)
  {
  _Mybase::operator=(::std:: move(_Right));
  return (*this);
  }

 mapped_type& operator[](key_type&& _Keyval)
  {
  iterator _Where = this->lower_bound(_Keyval);
  if (_Where == this->end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

   _Where = this->emplace_hint(_Where,
    piecewise_construct,
    ::std:: forward_as_tuple(::std:: move(_Keyval)),
    tuple<>());


  return (_Where->second);
  }

 void swap(_Myt& _Right)
  {
  _Mybase::swap(_Right);
  }

 map(::std:: initializer_list<value_type> _Ilist)
  : _Mybase(key_compare(), allocator_type())
  {
  this->insert(_Ilist.begin(), _Ilist.end());
  }

 map(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  this->insert(_Ilist.begin(), _Ilist.end());
  }

 map(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  this->insert(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<value_type> _Ilist)
  {
  this->clear();
  this->insert(_Ilist.begin(), _Ilist.end());
  return (*this);
  }






 mapped_type& operator[](const key_type& _Keyval)
  {
  iterator _Where = this->lower_bound(_Keyval);
  if (_Where == this->end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))

   _Where = this->emplace_hint(_Where,
    piecewise_construct,
    ::std:: forward_as_tuple(_Keyval),
    tuple<>());


  return (_Where->second);
  }

 mapped_type& at(const key_type& _Keyval)
  {
  iterator _Where = this->lower_bound(_Keyval);
  if (_Where == this->end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))
   _Xout_of_range("invalid map<K, T> key");
  return (_Where->second);
  }

 const mapped_type& at(const key_type& _Keyval) const
  {
  const_iterator _Where = this->lower_bound(_Keyval);
  if (_Where == this->end()
   || this->_Getcomp()(_Keyval, this->_Key(_Where._Mynode())))
   _Xout_of_range("invalid map<K, T> key");
  return (_Where->second);
  }
 };

template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc> inline
 void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left,
  map<_Kty, _Ty, _Pr, _Alloc>& _Right)
 {
 _Left.swap(_Right);
 }


template<class _Kty,
 class _Ty,
 class _Pr = less<_Kty>,
 class _Alloc = allocator<pair<const _Kty, _Ty> > >
 class multimap
  : public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
 {
public:
 typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
 typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> > _Mybase;
 typedef _Kty key_type;
 typedef _Ty mapped_type;
 typedef _Ty referent_type;
 typedef _Pr key_compare;
 typedef typename _Mybase::value_compare value_compare;
 typedef typename _Mybase::allocator_type allocator_type;
 typedef typename _Mybase::size_type size_type;
 typedef typename _Mybase::difference_type difference_type;
 typedef typename _Mybase::pointer pointer;
 typedef typename _Mybase::const_pointer const_pointer;
 typedef typename _Mybase::reference reference;
 typedef typename _Mybase::const_reference const_reference;
 typedef typename _Mybase::iterator iterator;
 typedef typename _Mybase::const_iterator const_iterator;
 typedef typename _Mybase::reverse_iterator reverse_iterator;
 typedef typename _Mybase::const_reverse_iterator
  const_reverse_iterator;
 typedef typename _Mybase::value_type value_type;

 multimap()
  : _Mybase(key_compare(), allocator_type())
  {
  }

 explicit multimap(const allocator_type& _Al)
  : _Mybase(key_compare(), _Al)
  {
  }

 multimap(const _Myt& _Right)

  : _Mybase(_Right,
   _Right._Getal().select_on_container_copy_construction())


  {
  }

 multimap(const _Myt& _Right, const allocator_type& _Al)
  : _Mybase(_Right, _Al)
  {
  }

 explicit multimap(const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  }

 multimap(const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  }

 template<class _Iter>
  multimap(_Iter _First, _Iter _Last)
  : _Mybase(key_compare(), allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  multimap(_Iter _First, _Iter _Last,
   const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  _Mybase::insert(_First, _Last);
  }

 template<class _Iter>
  multimap(_Iter _First, _Iter _Last,
   const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  _Mybase::insert(_First, _Last);
  }

 _Myt& operator=(const _Myt& _Right)
  {
  _Mybase::operator=(_Right);
  return (*this);
  }

 multimap(_Myt&& _Right)
  : _Mybase(::std:: move(_Right))
  {
  }

 multimap(_Myt&& _Right, const allocator_type& _Al)
  : _Mybase(::std:: move(_Right), _Al)
  {
  }

 _Myt& operator=(_Myt&& _Right)
  {
  _Mybase::operator=(::std:: move(_Right));
  return (*this);
  }

 template<class _Valty>
  typename enable_if<is_convertible<_Valty, value_type>::value,
   iterator>::type
  insert(_Valty&& _Val)
  {
  return (_Mybase::insert(::std:: forward<_Valty>(_Val)).first);
  }

 template<class _Valty>
  typename enable_if<is_convertible<_Valty, value_type>::value,
   iterator>::type
  insert(const_iterator _Where, _Valty&& _Val)
  {
  return (_Mybase::insert(_Where, ::std:: forward<_Valty>(_Val)));
  }

 template<class... _Valty>
  iterator emplace(_Valty&&... _Val)
  {
  return (_Mybase::emplace(::std:: forward<_Valty>(_Val)...).first);
  }


 void swap(_Myt& _Right)
  {
  _Mybase::swap(_Right);
  }

 multimap(::std:: initializer_list<value_type> _Ilist)
  : _Mybase(key_compare(), allocator_type())
  {
  this->insert(_Ilist.begin(), _Ilist.end());
  }

 multimap(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred)
  : _Mybase(_Pred, allocator_type())
  {
  this->insert(_Ilist.begin(), _Ilist.end());
  }

 multimap(::std:: initializer_list<value_type> _Ilist,
  const key_compare& _Pred, const allocator_type& _Al)
  : _Mybase(_Pred, _Al)
  {
  this->insert(_Ilist.begin(), _Ilist.end());
  }

 _Myt& operator=(::std:: initializer_list<value_type> _Ilist)
  {
  this->clear();
  this->insert(_Ilist.begin(), _Ilist.end());
  return (*this);
  }

 void insert(::std:: initializer_list<value_type> _Ilist)
  {
  this->insert(_Ilist.begin(), _Ilist.end());
  }

 iterator insert(const value_type& _Val)
  {
  return (_Mybase::insert(_Val).first);
  }

 iterator insert(const_iterator _Where, const value_type& _Val)
  {
  return (_Mybase::insert(_Where, _Val));
  }

 template<class _Iter>
  void insert(_Iter _First, _Iter _Last)
  {
  _Mybase::insert(_First, _Last);
  }
 };

template<class _Kty,
 class _Ty,
 class _Pr,
 class _Alloc> inline
 void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left,
  multimap<_Kty, _Ty, _Pr, _Alloc>& _Right)
 {
 _Left.swap(_Right);
 }
}

#pragma warning(pop)
#pragma pack(pop)
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"








template <typename T>
struct QMetaTypeId2;

template <typename T>
inline int qMetaTypeId();
#line 214 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"
class QDataStream;
class QMetaTypeInterface;
struct QMetaObject;

namespace QtPrivate
{




template<typename From, typename To>
To convertImplicit(const From& from)
{
    return from;
}


struct AbstractDebugStreamFunction
{
    typedef void (*Stream)(const AbstractDebugStreamFunction *, QDebug&, const void *);
    typedef void (*Destroy)(AbstractDebugStreamFunction *);
    explicit AbstractDebugStreamFunction(Stream s = 0, Destroy d = 0)
        : stream(s), destroy(d) {}
    AbstractDebugStreamFunction(const AbstractDebugStreamFunction &) = delete; AbstractDebugStreamFunction &operator=(const AbstractDebugStreamFunction &) = delete;
    Stream stream;
    Destroy destroy;
};

template<typename T>
struct BuiltInDebugStreamFunction : public AbstractDebugStreamFunction
{
    BuiltInDebugStreamFunction()
        : AbstractDebugStreamFunction(stream, destroy) {}
    static void stream(const AbstractDebugStreamFunction *, QDebug& dbg, const void *r)
    {
        const T *rhs = static_cast<const T *>(r);
        operator<<(dbg, *rhs);
    }

    static void destroy(AbstractDebugStreamFunction *_this)
    {
        delete static_cast<BuiltInDebugStreamFunction *>(_this);
    }
};


struct AbstractComparatorFunction
{
    typedef bool (*LessThan)(const AbstractComparatorFunction *, const void *, const void *);
    typedef bool (*Equals)(const AbstractComparatorFunction *, const void *, const void *);
    typedef void (*Destroy)(AbstractComparatorFunction *);
    explicit AbstractComparatorFunction(LessThan lt = 0, Equals e = 0, Destroy d = 0)
        : lessThan(lt), equals(e), destroy(d) {}
    AbstractComparatorFunction(const AbstractComparatorFunction &) = delete; AbstractComparatorFunction &operator=(const AbstractComparatorFunction &) = delete;
    LessThan lessThan;
    Equals equals;
    Destroy destroy;
};

template<typename T>
struct BuiltInComparatorFunction : public AbstractComparatorFunction
{
    BuiltInComparatorFunction()
        : AbstractComparatorFunction(lessThan, equals, destroy) {}
    static bool lessThan(const AbstractComparatorFunction *, const void *l, const void *r)
    {
        const T *lhs = static_cast<const T *>(l);
        const T *rhs = static_cast<const T *>(r);
        return *lhs < *rhs;
    }

    static bool equals(const AbstractComparatorFunction *, const void *l, const void *r)
    {
        const T *lhs = static_cast<const T *>(l);
        const T *rhs = static_cast<const T *>(r);
        return *lhs == *rhs;
    }

    static void destroy(AbstractComparatorFunction *_this)
    {
        delete static_cast<BuiltInComparatorFunction *>(_this);
    }
};

struct AbstractConverterFunction
{
    typedef bool (*Converter)(const AbstractConverterFunction *, const void *, void*);
    explicit AbstractConverterFunction(Converter c = 0)
        : convert(c) {}
    AbstractConverterFunction(const AbstractConverterFunction &) = delete; AbstractConverterFunction &operator=(const AbstractConverterFunction &) = delete;
    Converter convert;
};

template<typename From, typename To>
struct ConverterMemberFunction : public AbstractConverterFunction
{
    explicit ConverterMemberFunction(To(From::*function)() const)
        : AbstractConverterFunction(convert),
          m_function(function) {}
    ~ConverterMemberFunction();
    static bool convert(const AbstractConverterFunction *_this, const void *in, void *out)
    {
        const From *f = static_cast<const From *>(in);
        To *t = static_cast<To *>(out);
        const ConverterMemberFunction *_typedThis =
            static_cast<const ConverterMemberFunction *>(_this);
        *t = (f->*_typedThis->m_function)();
        return true;
    }

    To(From::* const m_function)() const;
};

template<typename From, typename To>
struct ConverterMemberFunctionOk : public AbstractConverterFunction
{
    explicit ConverterMemberFunctionOk(To(From::*function)(bool *) const)
        : AbstractConverterFunction(convert),
          m_function(function) {}
    ~ConverterMemberFunctionOk();
    static bool convert(const AbstractConverterFunction *_this, const void *in, void *out)
    {
        const From *f = static_cast<const From *>(in);
        To *t = static_cast<To *>(out);
        bool ok = false;
        const ConverterMemberFunctionOk *_typedThis =
            static_cast<const ConverterMemberFunctionOk *>(_this);
        *t = (f->*_typedThis->m_function)(&ok);
        if (!ok)
            *t = To();
        return ok;
    }

    To(From::* const m_function)(bool*) const;
};

template<typename From, typename To, typename UnaryFunction>
struct ConverterFunctor : public AbstractConverterFunction
{
    explicit ConverterFunctor(UnaryFunction function)
        : AbstractConverterFunction(convert),
          m_function(function) {}
    ~ConverterFunctor();
    static bool convert(const AbstractConverterFunction *_this, const void *in, void *out)
    {
        const From *f = static_cast<const From *>(in);
        To *t = static_cast<To *>(out);
        const ConverterFunctor *_typedThis =
            static_cast<const ConverterFunctor *>(_this);
        *t = _typedThis->m_function(*f);
        return true;
    }

    UnaryFunction m_function;
};

    template<typename T, bool>
    struct ValueTypeIsMetaType;
    template<typename T, bool>
    struct AssociativeValueTypeIsMetaType;
    template<typename T, bool>
    struct IsMetaTypePair;
    template<typename, typename>
    struct MetaTypeSmartPointerHelper;
}

class __declspec(dllimport) QMetaType {
    enum ExtensionFlag { NoExtensionFlags,
                         CreateEx = 0x1, DestroyEx = 0x2,
                         ConstructEx = 0x4, DestructEx = 0x8,
                         NameEx = 0x10, SizeEx = 0x20,
                         CtorEx = 0x40, DtorEx = 0x80,
                         FlagsEx = 0x100, MetaObjectEx = 0x200
                       };
public:


    enum Type {

        Void = 43, Bool = 1, Int = 2, UInt = 3, LongLong = 4, ULongLong = 5, Double = 6, Long = 32, Short = 33, Char = 34, ULong = 35, UShort = 36, UChar = 37, Float = 38, SChar = 40, VoidStar = 31, QChar = 7, QString = 10, QStringList = 11, QByteArray = 12, QBitArray = 13, QDate = 14, QTime = 15, QDateTime = 16, QUrl = 17, QLocale = 18, QRect = 19, QRectF = 20, QSize = 21, QSizeF = 22, QLine = 23, QLineF = 24, QPoint = 25, QPointF = 26, QRegExp = 27, QEasingCurve = 29, QUuid = 30, QVariant = 41, QModelIndex = 42, QRegularExpression = 44, QJsonValue = 45, QJsonObject = 46, QJsonArray = 47, QJsonDocument = 48, QObjectStar = 39, QVariantMap = 8, QVariantList = 9, QVariantHash = 28, QFont = 64, QPixmap = 65, QBrush = 66, QColor = 67, QPalette = 68, QIcon = 69, QImage = 70, QPolygon = 71, QRegion = 72, QBitmap = 73, QCursor = 74, QKeySequence = 75, QPen = 76, QTextLength = 77, QTextFormat = 78, QMatrix = 79, QTransform = 80, QMatrix4x4 = 81, QVector2D = 82, QVector3D = 83, QVector4D = 84, QQuaternion = 85, QPolygonF = 86, QSizePolicy = 121,

        FirstCoreType = Bool,
        LastCoreType = QJsonDocument,
        FirstGuiType = QFont,
        LastGuiType = QPolygonF,
        FirstWidgetsType = QSizePolicy,
        LastWidgetsType = QSizePolicy,
        HighestInternalId = LastWidgetsType,

        QReal = sizeof(qreal) == sizeof(double) ? Double : Float,

        UnknownType = 0,
        User = 1024
    };
#line 435 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"
    enum TypeFlag {
        NeedsConstruction = 0x1,
        NeedsDestruction = 0x2,
        MovableType = 0x4,
        PointerToQObject = 0x8,
        IsEnumeration = 0x10,
        SharedPointerToQObject = 0x20,
        WeakPointerToQObject = 0x40,
        TrackingPointerToQObject = 0x80,
        WasDeclaredAsMetaType = 0x100
    };
    typedef QFlags<TypeFlag> TypeFlags;

    typedef void (*Deleter)(void *);
    typedef void *(*Creator)(const void *);

    typedef void (*Destructor)(void *);
    typedef void *(*Constructor)(void *, const void *);

    typedef void (*SaveOperator)(QDataStream &, const void *);
    typedef void (*LoadOperator)(QDataStream &, void *);

    static void registerStreamOperators(const char *typeName, SaveOperator saveOp,
                                        LoadOperator loadOp);
    static void registerStreamOperators(int type, SaveOperator saveOp,
                                        LoadOperator loadOp);

    static int registerType(const char *typeName, Deleter deleter,
                            Creator creator);
    static int registerType(const char *typeName, Deleter deleter,
                            Creator creator,
                            Destructor destructor,
                            Constructor constructor,
                            int size,
                            QMetaType::TypeFlags flags,
                            const QMetaObject *metaObject);
    static int registerNormalizedType(const ::QByteArray &normalizedTypeName, Deleter deleter,
                            Creator creator,
                            Destructor destructor,
                            Constructor constructor,
                            int size,
                            QMetaType::TypeFlags flags,
                            const QMetaObject *metaObject);
    static int registerTypedef(const char *typeName, int aliasId);
    static int registerNormalizedTypedef(const ::QByteArray &normalizedTypeName, int aliasId);
    static int type(const char *typeName);
    static const char *typeName(int type);
    static int sizeOf(int type);
    static TypeFlags typeFlags(int type);
    static const QMetaObject *metaObjectForType(int type);
    static bool isRegistered(int type);
    static void *create(int type, const void *copy = 0);




    static void destroy(int type, void *data);
    static void *construct(int type, void *where, const void *copy);
    static void destruct(int type, void *where);


    static bool save(QDataStream &stream, int type, const void *data);
    static bool load(QDataStream &stream, int type, void *data);


    explicit QMetaType(const int type);
    inline ~QMetaType();

    inline bool isValid() const;
    inline bool isRegistered() const;
    inline int sizeOf() const;
    inline TypeFlags flags() const;
    inline const QMetaObject *metaObject() const;

    inline void *create(const void *copy = 0) const;
    inline void destroy(void *data) const;
    inline void *construct(void *where, const void *copy = 0) const;
    inline void destruct(void *data) const;

public:
    template<typename T>
    static bool registerComparators()
    {
        static_assert(bool((!QMetaTypeId2<T>::IsBuiltIn)), "QMetaType::registerComparators: The type must be a custom type.");


        const int typeId = qMetaTypeId<T>();
        static const QtPrivate::BuiltInComparatorFunction<T> f;
        return registerComparatorFunction( &f, typeId);
    }
    template<typename T>
    static bool hasRegisteredComparators()
    {
        return hasRegisteredComparators(qMetaTypeId<T>());
    }
    static bool hasRegisteredComparators(int typeId);



    template<typename T>
    static bool registerDebugStreamOperator()
    {
        static_assert(bool((!QMetaTypeId2<T>::IsBuiltIn)), "QMetaType::registerDebugStreamOperator: The type must be a custom type.");


        const int typeId = qMetaTypeId<T>();
        static const QtPrivate::BuiltInDebugStreamFunction<T> f;
        return registerDebugStreamOperatorFunction(&f, typeId);
    }
    template<typename T>
    static bool hasRegisteredDebugStreamOperator()
    {
        return hasRegisteredDebugStreamOperator(qMetaTypeId<T>());
    }
    static bool hasRegisteredDebugStreamOperator(int typeId);



    template<typename From, typename To>
    static bool registerConverter()
    {
        return registerConverter<From, To>(QtPrivate::convertImplicit<From, To>);
    }







    template<typename From, typename To>
    static bool registerConverter(To(From::*function)() const)
    {
        static_assert(bool((!QMetaTypeId2<To>::IsBuiltIn || !QMetaTypeId2<From>::IsBuiltIn)), "QMetaType::registerConverter: At least one of the types must be a custom type.");


        const int fromTypeId = qMetaTypeId<From>();
        const int toTypeId = qMetaTypeId<To>();
        static const QtPrivate::ConverterMemberFunction<From, To> f(function);
        return registerConverterFunction(&f, fromTypeId, toTypeId);
    }


    template<typename From, typename To>
    static bool registerConverter(To(From::*function)(bool*) const)
    {
        static_assert(bool((!QMetaTypeId2<To>::IsBuiltIn || !QMetaTypeId2<From>::IsBuiltIn)), "QMetaType::registerConverter: At least one of the types must be a custom type.");


        const int fromTypeId = qMetaTypeId<From>();
        const int toTypeId = qMetaTypeId<To>();
        static const QtPrivate::ConverterMemberFunctionOk<From, To> f(function);
        return registerConverterFunction(&f, fromTypeId, toTypeId);
    }


    template<typename From, typename To, typename UnaryFunction>
    static bool registerConverter(UnaryFunction function)
    {
        static_assert(bool((!QMetaTypeId2<To>::IsBuiltIn || !QMetaTypeId2<From>::IsBuiltIn)), "QMetaType::registerConverter: At least one of the types must be a custom type.");


        const int fromTypeId = qMetaTypeId<From>();
        const int toTypeId = qMetaTypeId<To>();
        static const QtPrivate::ConverterFunctor<From, To, UnaryFunction> f(function);
        return registerConverterFunction(&f, fromTypeId, toTypeId);
    }


    static bool convert(const void *from, int fromTypeId, void *to, int toTypeId);
    static bool compare(const void *lhs, const void *rhs, int typeId, int* result);
    static bool debugStream(QDebug& dbg, const void *rhs, int typeId);

    template<typename From, typename To>
    static bool hasRegisteredConverterFunction()
    {
        return hasRegisteredConverterFunction(qMetaTypeId<From>(), qMetaTypeId<To>());
    }

    static bool hasRegisteredConverterFunction(int fromTypeId, int toTypeId);

private:
    static QMetaType typeInfo(const int type);
    inline QMetaType(const ExtensionFlag extensionFlags, const QMetaTypeInterface *info,
                     Creator creator,
                     Deleter deleter,
                     SaveOperator saveOp,
                     LoadOperator loadOp,
                     Constructor constructor,
                     Destructor destructor,
                     uint sizeOf,
                     uint theTypeFlags,
                     int typeId,
                     const QMetaObject *metaObject);
    QMetaType(const QMetaType &other);
    QMetaType &operator =(const QMetaType &);
    inline bool isExtended(const ExtensionFlag flag) const { return m_extensionFlags & flag; }


    void ctor(const QMetaTypeInterface *info);
    void dtor();
    uint sizeExtended() const;
    QMetaType::TypeFlags flagsExtended() const;
    const QMetaObject *metaObjectExtended() const;
    void *createExtended(const void *copy = 0) const;
    void destroyExtended(void *data) const;
    void *constructExtended(void *where, const void *copy = 0) const;
    void destructExtended(void *data) const;

    static bool registerComparatorFunction(const QtPrivate::AbstractComparatorFunction *f, int type);

    static bool registerDebugStreamOperatorFunction(const QtPrivate::AbstractDebugStreamFunction *f, int type);
#line 664 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"
public:

    static bool registerConverterFunction(const QtPrivate::AbstractConverterFunction *f, int from, int to);
    static void unregisterConverterFunction(int from, int to);
private:

    Creator m_creator;
    Deleter m_deleter;
    SaveOperator m_saveOp;
    LoadOperator m_loadOp;
    Constructor m_constructor;
    Destructor m_destructor;
    void *m_extension;
    uint m_size;
    uint m_typeFlags;
    uint m_extensionFlags;
    int m_typeId;
    const QMetaObject *m_metaObject;
};



 inline QFlags<QMetaType::TypeFlags::enum_type> operator|(QMetaType::TypeFlags::enum_type f1, QMetaType::TypeFlags::enum_type f2) { return QFlags<QMetaType::TypeFlags::enum_type>(f1) | f2; } inline QFlags<QMetaType::TypeFlags::enum_type> operator|(QMetaType::TypeFlags::enum_type f1, QFlags<QMetaType::TypeFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QMetaType::TypeFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

namespace QtPrivate {

template<typename From, typename To>
ConverterMemberFunction<From, To>::~ConverterMemberFunction()
{
    QMetaType::unregisterConverterFunction(qMetaTypeId<From>(), qMetaTypeId<To>());
}
template<typename From, typename To>
ConverterMemberFunctionOk<From, To>::~ConverterMemberFunctionOk()
{
    QMetaType::unregisterConverterFunction(qMetaTypeId<From>(), qMetaTypeId<To>());
}
template<typename From, typename To, typename UnaryFunction>
ConverterFunctor<From, To, UnaryFunction>::~ConverterFunctor()
{
    QMetaType::unregisterConverterFunction(qMetaTypeId<From>(), qMetaTypeId<To>());
}

}

namespace QtMetaTypePrivate {
template <typename T, bool Accepted = true>
struct QMetaTypeFunctionHelper {
    static void Delete(void *t)
    {
        delete static_cast<T*>(t);
    }

    static void *Create(const void *t)
    {
        if (t)
            return new T(*static_cast<const T*>(t));
        return new T();
    }

    static void Destruct(void *t)
    {
        (void)t;
        static_cast<T*>(t)->~T();
    }

    static void *Construct(void *where, const void *t)
    {
        if (t)
            return new (where) T(*static_cast<const T*>(t));
        return new (where) T;
    }

    static void Save(QDataStream &stream, const void *t)
    {
        stream << *static_cast<const T*>(t);
    }

    static void Load(QDataStream &stream, void *t)
    {
        stream >> *static_cast<T*>(t);
    }

};

template <typename T>
struct QMetaTypeFunctionHelper<T, false> {
    static void Delete(void *) {}
    static void *Create(const void *) { return 0; }
    static void Destruct(void *) {}
    static void *Construct(void *, const void *) { return 0; }

    static void Save(QDataStream &, const void *) {}
    static void Load(QDataStream &, void *) {}

};
template <>
struct QMetaTypeFunctionHelper<void, true>
        : public QMetaTypeFunctionHelper<void, false>
{};

struct VariantData
{
    VariantData(const int metaTypeId_,
                const void *data_,
                const uint flags_)
      : metaTypeId(metaTypeId_)
      , data(data_)
      , flags(flags_)
    {
    }
    VariantData(const VariantData &other)
        : metaTypeId(other.metaTypeId), data(other.data), flags(other.flags){}
    const int metaTypeId;
    const void *data;
    const uint flags;
private:

    VariantData &operator=(const VariantData &) = delete;
};

template<typename const_iterator>
struct IteratorOwner
{
    static void assign(void **ptr, const_iterator iterator)
    {
        *ptr = new const_iterator(iterator);
    }
    static void assign(void **ptr, void * const * src)
    {
        *ptr = new const_iterator(*static_cast<const_iterator*>(*src));
    }

    static void advance(void **iterator, int step)
    {
        const_iterator &it = *static_cast<const_iterator*>(*iterator);
        std::advance(it, step);
    }

    static void destroy(void **ptr)
    {
        delete static_cast<const_iterator*>(*ptr);
    }

    static const void *getData(void * const *iterator)
    {
        return &**static_cast<const_iterator*>(*iterator);
    }

    static const void *getData(const_iterator it)
    {
        return &*it;
    }

    static bool equal(void * const *it, void * const *other)
    {
        return *static_cast<const_iterator*>(*it) == *static_cast<const_iterator*>(*other);
    }
};
template<typename value_type>
struct IteratorOwner<const value_type*>
{
    static void assign(void **ptr, const value_type *iterator )
    {
        *ptr = const_cast<value_type*>(iterator);
    }
    static void assign(void **ptr, void * const * src)
    {
        *ptr = static_cast<value_type*>(*src);
    }

    static void advance(void **iterator, int step)
    {
        value_type *it = static_cast<value_type*>(*iterator);
        std::advance(it, step);
        *iterator = it;
    }

    static void destroy(void **)
    {
    }

    static const void *getData(void * const *iterator)
    {
        return *iterator;
    }

    static const void *getData(const value_type *it)
    {
        return it;
    }

    static bool equal(void * const *it, void * const *other)
    {
        return static_cast<value_type*>(*it) == static_cast<value_type*>(*other);
    }
};

enum IteratorCapability
{
    ForwardCapability = 1,
    BiDirectionalCapability = 2,
    RandomAccessCapability = 4
};

template<typename T, typename Category = typename std::iterator_traits<typename T::const_iterator>::iterator_category>
struct CapabilitiesImpl;

template<typename T>
struct CapabilitiesImpl<T, std::forward_iterator_tag>
{ enum { IteratorCapabilities = ForwardCapability }; };
template<typename T>
struct CapabilitiesImpl<T, std::bidirectional_iterator_tag>
{ enum { IteratorCapabilities = BiDirectionalCapability | ForwardCapability }; };
template<typename T>
struct CapabilitiesImpl<T, std::random_access_iterator_tag>
{ enum { IteratorCapabilities = RandomAccessCapability | BiDirectionalCapability | ForwardCapability }; };

template<typename T>
struct ContainerAPI : CapabilitiesImpl<T>
{
    static int size(const T *t) { return int(std::distance(t->begin(), t->end())); }
};

template<typename T>
struct ContainerAPI<QList<T> > : CapabilitiesImpl<QList<T> >
{ static int size(const QList<T> *t) { return t->size(); } };

template<typename T>
struct ContainerAPI<QVector<T> > : CapabilitiesImpl<QVector<T> >
{ static int size(const QVector<T> *t) { return t->size(); } };

template<typename T>
struct ContainerAPI<std::vector<T> > : CapabilitiesImpl<std::vector<T> >
{ static int size(const std::vector<T> *t) { return t->size(); } };

template<typename T>
struct ContainerAPI<std::list<T> > : CapabilitiesImpl<std::list<T> >
{ static int size(const std::list<T> *t) { return t->size(); } };

class QSequentialIterableImpl
{
public:
    const void * _iterable;
    void *_iterator;
    int _metaType_id;
    uint _metaType_flags;
    uint _iteratorCapabilities;
    typedef int(*sizeFunc)(const void *p);
    typedef const void * (*atFunc)(const void *p, int);
    typedef void (*moveIteratorFunc)(const void *p, void **);
    typedef void (*advanceFunc)(void **p, int);
    typedef VariantData (*getFunc)( void * const *p, int metaTypeId, uint flags);
    typedef void (*destroyIterFunc)(void **p);
    typedef bool (*equalIterFunc)(void * const *p, void * const *other);
    typedef void (*copyIterFunc)(void **, void * const *);

    sizeFunc _size;
    atFunc _at;
    moveIteratorFunc _moveToBegin;
    moveIteratorFunc _moveToEnd;
    advanceFunc _advance;
    getFunc _get;
    destroyIterFunc _destroyIter;
    equalIterFunc _equalIter;
    copyIterFunc _copyIter;

    template<class T>
    static int sizeImpl(const void *p)
    { return ContainerAPI<T>::size(static_cast<const T*>(p)); }

    template<class T>
    static const void* atImpl(const void *p, int idx)
    {
        typename T::const_iterator i = static_cast<const T*>(p)->begin();
        std::advance(i, idx);
        return IteratorOwner<typename T::const_iterator>::getData(i);
    }

    template<class T>
    static void moveToBeginImpl(const void *container, void **iterator)
    { IteratorOwner<typename T::const_iterator>::assign(iterator, static_cast<const T*>(container)->begin()); }

    template<class T>
    static void moveToEndImpl(const void *container, void **iterator)
    { IteratorOwner<typename T::const_iterator>::assign(iterator, static_cast<const T*>(container)->end()); }

    template<class T>
    static VariantData getImpl(void * const *iterator, int metaTypeId, uint flags)
    { return VariantData(metaTypeId, IteratorOwner<typename T::const_iterator>::getData(iterator), flags); }

public:
    template<class T> QSequentialIterableImpl(const T*p)
      : _iterable(p)
      , _iterator(0)
      , _metaType_id(qMetaTypeId<typename T::value_type>())
      , _metaType_flags(QTypeInfo<typename T::value_type>::isPointer)
      , _iteratorCapabilities(ContainerAPI<T>::IteratorCapabilities)
      , _size(sizeImpl<T>)
      , _at(atImpl<T>)
      , _moveToBegin(moveToBeginImpl<T>)
      , _moveToEnd(moveToEndImpl<T>)
      , _advance(IteratorOwner<typename T::const_iterator>::advance)
      , _get(getImpl<T>)
      , _destroyIter(IteratorOwner<typename T::const_iterator>::destroy)
      , _equalIter(IteratorOwner<typename T::const_iterator>::equal)
      , _copyIter(IteratorOwner<typename T::const_iterator>::assign)
    {
    }

    QSequentialIterableImpl()
      : _iterable(0)
      , _iterator(0)
      , _metaType_id(QMetaType::UnknownType)
      , _metaType_flags(0)
      , _iteratorCapabilities(0)
      , _size(0)
      , _at(0)
      , _moveToBegin(0)
      , _moveToEnd(0)
      , _advance(0)
      , _get(0)
      , _destroyIter(0)
      , _equalIter(0)
      , _copyIter(0)
    {
    }

    inline void moveToBegin() { _moveToBegin(_iterable, &_iterator); }
    inline void moveToEnd() { _moveToEnd(_iterable, &_iterator); }
    inline bool equal(const QSequentialIterableImpl&other) const { return _equalIter(&_iterator, &other._iterator); }
    inline QSequentialIterableImpl &advance(int i) {
      ((!(i > 0 || _iteratorCapabilities & BiDirectionalCapability)) ? qt_assert("i > 0 || _iteratorCapabilities & BiDirectionalCapability","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",995) : qt_noop());
      _advance(&_iterator, i);
      return *this;
    }

    inline VariantData getCurrent() const { return _get(&_iterator, _metaType_id, _metaType_flags); }

    VariantData at(int idx) const
    { return VariantData(_metaType_id, _at(_iterable, idx), _metaType_flags); }

    int size() const { ((!(_iterable)) ? qt_assert("_iterable","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1005) : qt_noop()); return _size(_iterable); }

    inline void destroyIter() { _destroyIter(&_iterator); }

    void copy(const QSequentialIterableImpl &other)
    {
      *this = other;
      _copyIter(&_iterator, &other._iterator);
    }
};

template<typename From>
struct QSequentialIterableConvertFunctor
{
    QSequentialIterableImpl operator()(const From &f) const
    {
        return QSequentialIterableImpl(&f);
    }
};
}

namespace QtMetaTypePrivate {
template<typename T, bool = QtPrivate::is_same<typename T::const_iterator::value_type, typename T::mapped_type>::value>
struct AssociativeContainerAccessor
{
    static const typename T::key_type& getKey(const typename T::const_iterator &it)
    {
        return it.key();
    }

    static const typename T::mapped_type& getValue(const typename T::const_iterator &it)
    {
        return it.value();
    }
};

template<typename T, bool = QtPrivate::is_same<typename T::const_iterator::value_type, std::pair<const typename T::key_type, typename T::mapped_type> >::value>
struct StlStyleAssociativeContainerAccessor;

template<typename T>
struct StlStyleAssociativeContainerAccessor<T, true>
{
    static const typename T::key_type& getKey(const typename T::const_iterator &it)
    {
        return it->first;
    }

    static const typename T::mapped_type& getValue(const typename T::const_iterator &it)
    {
        return it->second;
    }
};

template<typename T>
struct AssociativeContainerAccessor<T, false> : public StlStyleAssociativeContainerAccessor<T>
{
};

class QAssociativeIterableImpl
{
public:
    const void *_iterable;
    void *_iterator;
    int _metaType_id_key;
    uint _metaType_flags_key;
    int _metaType_id_value;
    uint _metaType_flags_value;
    typedef int(*sizeFunc)(const void *p);
    typedef void (*findFunc)(const void *container, const void *p, void **iterator);
    typedef void (*beginFunc)(const void *p, void **);
    typedef void (*advanceFunc)(void **p, int);
    typedef VariantData (*getFunc)(void * const *p, int metaTypeId, uint flags);
    typedef void (*destroyIterFunc)(void **p);
    typedef bool (*equalIterFunc)(void * const *p, void * const *other);
    typedef void (*copyIterFunc)(void **, void * const *);

    sizeFunc _size;
    findFunc _find;
    beginFunc _begin;
    beginFunc _end;
    advanceFunc _advance;
    getFunc _getKey;
    getFunc _getValue;
    destroyIterFunc _destroyIter;
    equalIterFunc _equalIter;
    copyIterFunc _copyIter;

    template<class T>
    static int sizeImpl(const void *p)
    { return int(std::distance(static_cast<const T*>(p)->begin(),
                               static_cast<const T*>(p)->end())); }

    template<class T>
    static void findImpl(const void *container, const void *p, void **iterator)
    { IteratorOwner<typename T::const_iterator>::assign(iterator,
                                                        static_cast<const T*>(container)->find(*static_cast<const typename T::key_type*>(p))); }

    template<class T>
    static void advanceImpl(void **p, int step)
    { std::advance(*static_cast<typename T::const_iterator*>(*p), step); }

    template<class T>
    static void beginImpl(const void *container, void **iterator)
    { IteratorOwner<typename T::const_iterator>::assign(iterator, static_cast<const T*>(container)->begin()); }

    template<class T>
    static void endImpl(const void *container, void **iterator)
    { IteratorOwner<typename T::const_iterator>::assign(iterator, static_cast<const T*>(container)->end()); }

    template<class T>
    static VariantData getKeyImpl(void * const *iterator, int metaTypeId, uint flags)
    { return VariantData(metaTypeId, &AssociativeContainerAccessor<T>::getKey(*static_cast<typename T::const_iterator*>(*iterator)), flags); }

    template<class T>
    static VariantData getValueImpl(void * const *iterator, int metaTypeId, uint flags)
    { return VariantData(metaTypeId, &AssociativeContainerAccessor<T>::getValue(*static_cast<typename T::const_iterator*>(*iterator)), flags); }

public:
    template<class T> QAssociativeIterableImpl(const T*p)
      : _iterable(p)
      , _metaType_id_key(qMetaTypeId<typename T::key_type>())
      , _metaType_flags_key(QTypeInfo<typename T::key_type>::isPointer)
      , _metaType_id_value(qMetaTypeId<typename T::mapped_type>())
      , _metaType_flags_value(QTypeInfo<typename T::mapped_type>::isPointer)
      , _size(sizeImpl<T>)
      , _find(findImpl<T>)
      , _begin(beginImpl<T>)
      , _end(endImpl<T>)
      , _advance(advanceImpl<T>)
      , _getKey(getKeyImpl<T>)
      , _getValue(getValueImpl<T>)
      , _destroyIter(IteratorOwner<typename T::const_iterator>::destroy)
      , _equalIter(IteratorOwner<typename T::const_iterator>::equal)
      , _copyIter(IteratorOwner<typename T::const_iterator>::assign)
    {
    }

    QAssociativeIterableImpl()
      : _iterable(0)
      , _metaType_id_key(QMetaType::UnknownType)
      , _metaType_flags_key(0)
      , _metaType_id_value(QMetaType::UnknownType)
      , _metaType_flags_value(0)
      , _size(0)
      , _find(0)
      , _begin(0)
      , _end(0)
      , _advance(0)
      , _getKey(0)
      , _getValue(0)
      , _destroyIter(0)
      , _equalIter(0)
      , _copyIter(0)
    {
    }

    inline void begin() { _begin(_iterable, &_iterator); }
    inline void end() { _end(_iterable, &_iterator); }
    inline bool equal(const QAssociativeIterableImpl&other) const { return _equalIter(&_iterator, &other._iterator); }
    inline QAssociativeIterableImpl &advance(int i) { _advance(&_iterator, i); return *this; }

    inline void destroyIter() { _destroyIter(&_iterator); }

    inline VariantData getCurrentKey() const { return _getKey(&_iterator, _metaType_id_key, _metaType_flags_value); }
    inline VariantData getCurrentValue() const { return _getValue(&_iterator, _metaType_id_value, _metaType_flags_value); }

    inline void find(const VariantData &key)
    { _find(_iterable, key.data, &_iterator); }

    int size() const { ((!(_iterable)) ? qt_assert("_iterable","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1174) : qt_noop()); return _size(_iterable); }

    void copy(const QAssociativeIterableImpl &other)
    {
      *this = other;
      _copyIter(&_iterator, &other._iterator);
    }
};

template<typename From>
struct QAssociativeIterableConvertFunctor
{
    QAssociativeIterableImpl operator()(const From& f) const
    {
        return QAssociativeIterableImpl(&f);
    }
};

class QPairVariantInterfaceImpl
{
    const void *_pair;
    int _metaType_id_first;
    uint _metaType_flags_first;
    int _metaType_id_second;
    uint _metaType_flags_second;

    typedef VariantData (*getFunc)(const void * const *p, int metaTypeId, uint flags);

    getFunc _getFirst;
    getFunc _getSecond;

    template<class T>
    static VariantData getFirstImpl(const void * const *pair, int metaTypeId, uint flags)
    { return VariantData(metaTypeId, &static_cast<const T*>(*pair)->first, flags); }
    template<class T>
    static VariantData getSecondImpl(const void * const *pair, int metaTypeId, uint flags)
    { return VariantData(metaTypeId, &static_cast<const T*>(*pair)->second, flags); }

public:
    template<class T> QPairVariantInterfaceImpl(const T*p)
      : _pair(p)
      , _metaType_id_first(qMetaTypeId<typename T::first_type>())
      , _metaType_flags_first(QTypeInfo<typename T::first_type>::isPointer)
      , _metaType_id_second(qMetaTypeId<typename T::second_type>())
      , _metaType_flags_second(QTypeInfo<typename T::second_type>::isPointer)
      , _getFirst(getFirstImpl<T>)
      , _getSecond(getSecondImpl<T>)
    {
    }

    QPairVariantInterfaceImpl()
      : _pair(0)
      , _getFirst(0)
      , _getSecond(0)
    {
    }

    inline VariantData first() const { return _getFirst(&_pair, _metaType_id_first, _metaType_flags_first); }
    inline VariantData second() const { return _getSecond(&_pair, _metaType_id_second, _metaType_flags_second); }
};

template<typename From>
struct QPairVariantInterfaceConvertFunctor;

template<typename T, typename U>
struct QPairVariantInterfaceConvertFunctor<QPair<T, U> >
{
    QPairVariantInterfaceImpl operator()(const QPair<T, U>& f) const
    {
        return QPairVariantInterfaceImpl(&f);
    }
};

template<typename T, typename U>
struct QPairVariantInterfaceConvertFunctor<std::pair<T, U> >
{
    QPairVariantInterfaceImpl operator()(const std::pair<T, U>& f) const
    {
        return QPairVariantInterfaceImpl(&f);
    }
};

}

class QObject;
class QWidget;




template <class T> class QSharedPointer; template <class T> class QWeakPointer; template <class T> class QPointer;

namespace QtPrivate
{
    template<typename T>
    struct IsPointerToTypeDerivedFromQObject
    {
        enum { Value = false };
    };


    template<>
    struct IsPointerToTypeDerivedFromQObject<void*>
    {
        enum { Value = false };
    };
    template<>
    struct IsPointerToTypeDerivedFromQObject<QObject*>
    {
        enum { Value = true };
    };

    template<typename T>
    struct IsPointerToTypeDerivedFromQObject<T*>
    {
        typedef qint8 yes_type;
        typedef qint64 no_type;


        static yes_type checkType(QObject* );

        static no_type checkType(...);
        static_assert(bool(sizeof(T)), "Type argument of Q_DECLARE_METATYPE(T*) must be fully defined");
        enum { Value = sizeof(checkType(static_cast<T*>(0))) == sizeof(yes_type) };
    };

    template<typename T, bool = IsPointerToTypeDerivedFromQObject<T>::Value>
    struct MetaObjectForType
    {
        static inline const QMetaObject *value() { return 0; }
    };

    template<typename T>
    struct MetaObjectForType<T*, true>
    {
        static inline const QMetaObject *value() { return &T::staticMetaObject; }
    };

    template<typename T>
    struct IsSharedPointerToTypeDerivedFromQObject
    {
        enum { Value = false };
    };

    template<typename T>
    struct IsSharedPointerToTypeDerivedFromQObject<QSharedPointer<T> > : IsPointerToTypeDerivedFromQObject<T*>
    {
    };

    template<typename T>
    struct IsWeakPointerToTypeDerivedFromQObject
    {
        enum { Value = false };
    };

    template<typename T>
    struct IsWeakPointerToTypeDerivedFromQObject<QWeakPointer<T> > : IsPointerToTypeDerivedFromQObject<T*>
    {
    };

    template<typename T>
    struct IsTrackingPointerToTypeDerivedFromQObject
    {
        enum { Value = false };
    };

    template<typename T>
    struct IsTrackingPointerToTypeDerivedFromQObject<QPointer<T> >
    {
        enum { Value = true };
    };

    template<typename T>
    struct IsSequentialContainer
    {
        enum { Value = false };
    };

    template<typename T>
    struct IsAssociativeContainer
    {
        enum { Value = false };
    };

    template<typename T, bool = QtPrivate::IsSequentialContainer<T>::Value>
    struct SequentialContainerConverterHelper
    {
        static bool registerConverter(int)
        {
            return false;
        }
    };

    template<typename T, bool = QMetaTypeId2<typename T::value_type>::Defined>
    struct ValueTypeIsMetaType
    {
        static bool registerConverter(int)
        {
            return false;
        }
    };

    template<typename T>
    struct SequentialContainerConverterHelper<T, true> : ValueTypeIsMetaType<T>
    {
    };

    template<typename T, bool = QtPrivate::IsAssociativeContainer<T>::Value>
    struct AssociativeContainerConverterHelper
    {
        static bool registerConverter(int)
        {
            return false;
        }
    };

    template<typename T, bool = QMetaTypeId2<typename T::mapped_type>::Defined>
    struct AssociativeValueTypeIsMetaType
    {
        static bool registerConverter(int)
        {
            return false;
        }
    };

    template<typename T, bool = QMetaTypeId2<typename T::key_type>::Defined>
    struct KeyAndValueTypeIsMetaType
    {
        static bool registerConverter(int)
        {
            return false;
        }
    };

    template<typename T>
    struct KeyAndValueTypeIsMetaType<T, true> : AssociativeValueTypeIsMetaType<T>
    {
    };

    template<typename T>
    struct AssociativeContainerConverterHelper<T, true> : KeyAndValueTypeIsMetaType<T>
    {
    };

    template<typename T, bool = QMetaTypeId2<typename T::first_type>::Defined
                                && QMetaTypeId2<typename T::second_type>::Defined>
    struct IsMetaTypePair
    {
        static bool registerConverter(int)
        {
            return false;
        }
    };

    template<typename T>
    struct IsMetaTypePair<T, true>
    {
        inline static bool registerConverter(int id);
    };

    template<typename T>
    struct IsPair
    {
        static bool registerConverter(int)
        {
            return false;
        }
    };
    template<typename T, typename U>
    struct IsPair<QPair<T, U> > : IsMetaTypePair<QPair<T, U> > {};
    template<typename T, typename U>
    struct IsPair<std::pair<T, U> > : IsMetaTypePair<std::pair<T, U> > {};

    template<typename T>
    struct MetaTypePairHelper : IsPair<T> {};

    template<typename T, typename = void>
    struct MetaTypeSmartPointerHelper
    {
        static bool registerConverter(int) { return false; }
    };

    __declspec(dllimport) bool isBuiltinType(const QByteArray &type);
}

template <typename T, bool = QtPrivate::IsPointerToTypeDerivedFromQObject<T>::Value>
struct QMetaTypeIdQObject
{
    enum {
        Defined = 0
    };
};

template <typename T>
struct QMetaTypeId : public QMetaTypeIdQObject<T>
{
};

template <typename T>
struct QMetaTypeId2
{
    enum { Defined = QMetaTypeId<T>::Defined, IsBuiltIn=false };
    static inline int qt_metatype_id() { return QMetaTypeId<T>::qt_metatype_id(); }
};

template <typename T>
struct QMetaTypeId2<const T&> : QMetaTypeId2<T> {};

namespace QtPrivate {
    template <typename T, bool Defined = QMetaTypeId2<T>::Defined>
    struct QMetaTypeIdHelper {
        static inline int qt_metatype_id()
        { return QMetaTypeId2<T>::qt_metatype_id(); }
    };
    template <typename T> struct QMetaTypeIdHelper<T, false> {
        static inline int qt_metatype_id()
        { return -1; }
    };
#line 1500 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"
    template <typename Result, typename... Args>
    struct IsPointerToTypeDerivedFromQObject<Result(*)(Args...)> { enum { Value = false }; };


    template<typename T>
    struct QMetaTypeTypeFlags
    {
        enum { Flags = (!QTypeInfo<T>::isStatic ? QMetaType::MovableType : 0)
                     | (QTypeInfo<T>::isComplex ? QMetaType::NeedsConstruction : 0)
                     | (QTypeInfo<T>::isComplex ? QMetaType::NeedsDestruction : 0)
                     | (IsPointerToTypeDerivedFromQObject<T>::Value ? QMetaType::PointerToQObject : 0)
                     | (IsSharedPointerToTypeDerivedFromQObject<T>::Value ? QMetaType::SharedPointerToQObject : 0)
                     | (IsWeakPointerToTypeDerivedFromQObject<T>::Value ? QMetaType::WeakPointerToQObject : 0)
                     | (IsTrackingPointerToTypeDerivedFromQObject<T>::Value ? QMetaType::TrackingPointerToQObject : 0)
                     | (__is_enum(T) ? QMetaType::IsEnumeration : 0)
             };
    };

    template<typename T, bool defined>
    struct MetaTypeDefinedHelper
    {
        enum DefinedType { Defined = defined };
    };

    template<typename SmartPointer>
    struct QSmartPointerConvertFunctor
    {
        QObject* operator()(const SmartPointer &p) const
        {
            return p.operator->();
        }
    };

    template<typename T>
    struct QSmartPointerConvertFunctor<QWeakPointer<T> >
    {
        QObject* operator()(const QWeakPointer<T> &p) const
        {
            return p.data();
        }
    };
}

template <typename T>
int qRegisterNormalizedMetaType(const ::QByteArray &normalizedTypeName

    , T * dummy = 0
    , typename QtPrivate::MetaTypeDefinedHelper<T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::DefinedType defined = QtPrivate::MetaTypeDefinedHelper<T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::Defined

)
{

    ((!(normalizedTypeName == QMetaObject::normalizedType(normalizedTypeName.constData()))) ? qt_assert_x("qRegisterNormalizedMetaType", "qRegisterNormalizedMetaType was called with a not normalized type name, please call qRegisterMetaType instead.","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1552) : qt_noop());

    const int typedefOf = dummy ? -1 : QtPrivate::QMetaTypeIdHelper<T>::qt_metatype_id();
    if (typedefOf != -1)
        return QMetaType::registerNormalizedTypedef(normalizedTypeName, typedefOf);

    QMetaType::TypeFlags flags(QtPrivate::QMetaTypeTypeFlags<T>::Flags);

    if (defined)
        flags |= QMetaType::WasDeclaredAsMetaType;

    const int id = QMetaType::registerNormalizedType(normalizedTypeName,
                                   QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Delete,
                                   QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Create,
                                   QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Destruct,
                                   QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Construct,
                                   int(sizeof(T)),
                                   flags,
                                   QtPrivate::MetaObjectForType<T>::value());

    if (id > 0) {
        QtPrivate::SequentialContainerConverterHelper<T>::registerConverter(id);
        QtPrivate::AssociativeContainerConverterHelper<T>::registerConverter(id);
        QtPrivate::MetaTypePairHelper<T>::registerConverter(id);
        QtPrivate::MetaTypeSmartPointerHelper<T>::registerConverter(id);
    }

    return id;
}

template <typename T>
int qRegisterMetaType(const char *typeName

    , T * dummy = 0
    , typename QtPrivate::MetaTypeDefinedHelper<T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::DefinedType defined = QtPrivate::MetaTypeDefinedHelper<T, QMetaTypeId2<T>::Defined && !QMetaTypeId2<T>::IsBuiltIn>::Defined

)
{



    ::QByteArray normalizedTypeName = QMetaObject::normalizedType(typeName);

    return qRegisterNormalizedMetaType<T>(normalizedTypeName, dummy, defined);
}


template <typename T>
void qRegisterMetaTypeStreamOperators(const char *typeName

    , T * = 0

)
{
    qRegisterMetaType<T>(typeName);
    QMetaType::registerStreamOperators(typeName, QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Save,
                                                 QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Load);
}


template <typename T>
inline int qMetaTypeId()
{
    static_assert(bool(QMetaTypeId2<T>::Defined), "Type is not registered, please use the Q_DECLARE_METATYPE macro to make it known to Qt's meta-object system");
    return QMetaTypeId2<T>::qt_metatype_id();
}

template <typename T>
inline int qRegisterMetaType()
{
    return qMetaTypeId<T>();
}



template <typename T>
              inline int qMetaTypeId(T *)
{ return qMetaTypeId<T>(); }

template <typename T>
              inline int qRegisterMetaType(T *)
{ return qRegisterMetaType<T>(); }



template <typename T>
struct QMetaTypeIdQObject<T*, true>
{
    enum {
        Defined = 1
    };

    static int qt_metatype_id()
    {
        static QBasicAtomicInt metatype_id = { (0) };
        if (const int id = metatype_id.loadAcquire())
            return id;
        const char * const cName = T::staticMetaObject.className();
        QByteArray typeName;
        typeName.reserve(int(strlen(cName)) + 1);
        typeName.append(cName).append('*');
        const int newId = qRegisterNormalizedMetaType<T*>(
                        typeName,
                        reinterpret_cast<T**>(quintptr(-1)));
        metatype_id.storeRelease(newId);
        return newId;
    }
};


template <typename T>
inline int qRegisterMetaTypeStreamOperators()
{
    int id = qMetaTypeId<T>();
    QMetaType::registerStreamOperators(id, QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Save,
                                           QtMetaTypePrivate::QMetaTypeFunctionHelper<T>::Load);
    return id;
}
#line 1715 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"
class QChar; class QString; class QStringList; class QByteArray; class QBitArray; class QDate; class QTime; class QDateTime; class QUrl; class QLocale; class QRect; class QRectF; class QSize; class QSizeF; class QLine; class QLineF; class QPoint; class QPointF; class QRegExp; class QEasingCurve; class QUuid; class QVariant; class QModelIndex; class QRegularExpression; class QJsonValue; class QJsonObject; class QJsonArray; class QJsonDocument;
class QFont; class QPixmap; class QBrush; class QColor; class QPalette; class QIcon; class QImage; class QPolygon; class QRegion; class QBitmap; class QCursor; class QKeySequence; class QPen; class QTextLength; class QTextFormat; class QMatrix; class QTransform; class QMatrix4x4; class QVector2D; class QVector3D; class QVector4D; class QQuaternion; class QPolygonF;
class QSizePolicy;



typedef QList<QVariant> QVariantList;
typedef QMap<QString, QVariant> QVariantMap;
typedef QHash<QString, QVariant> QVariantHash;
#line 1799 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"
namespace QtPrivate {

template<typename T, bool = false>
struct SharedPointerMetaTypeIdHelper
{
    enum {
        Defined = 0
    };
    static int qt_metatype_id()
    {
        return -1;
    }
};

}
#line 1875 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"
 template <class T> class QList; template <typename T> struct QMetaTypeId< QList<T> > { enum { Defined = QMetaTypeId2<T>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.load()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1875) : qt_noop()); const int tNameLen = int(qstrlen(tName)); QByteArray typeName; typeName.reserve(int(sizeof("QList")) + 1 + tNameLen + 1 + 1); typeName.append("QList", int(sizeof("QList")) - 1) .append('<').append(tName, tNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< QList<T> >( typeName, reinterpret_cast< QList<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; namespace QtPrivate { template<typename T> struct IsSequentialContainer<QList<T> > { enum { Value = true }; }; } template <class T> class QVector; template <typename T> struct QMetaTypeId< QVector<T> > { enum { Defined = QMetaTypeId2<T>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.load()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1875) : qt_noop()); const int tNameLen = int(qstrlen(tName)); QByteArray typeName; typeName.reserve(int(sizeof("QVector")) + 1 + tNameLen + 1 + 1); typeName.append("QVector", int(sizeof("QVector")) - 1) .append('<').append(tName, tNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< QVector<T> >( typeName, reinterpret_cast< QVector<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; namespace QtPrivate { template<typename T> struct IsSequentialContainer<QVector<T> > { enum { Value = true }; }; } template <class T> class QQueue; template <typename T> struct QMetaTypeId< QQueue<T> > { enum { Defined = QMetaTypeId2<T>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.load()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1875) : qt_noop()); const int tNameLen = int(qstrlen(tName)); QByteArray typeName; typeName.reserve(int(sizeof("QQueue")) + 1 + tNameLen + 1 + 1); typeName.append("QQueue", int(sizeof("QQueue")) - 1) .append('<').append(tName, tNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< QQueue<T> >( typeName, reinterpret_cast< QQueue<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; namespace QtPrivate { template<typename T> struct IsSequentialContainer<QQueue<T> > { enum { Value = true }; }; } template <class T> class QStack; template <typename T> struct QMetaTypeId< QStack<T> > { enum { Defined = QMetaTypeId2<T>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.load()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1875) : qt_noop()); const int tNameLen = int(qstrlen(tName)); QByteArray typeName; typeName.reserve(int(sizeof("QStack")) + 1 + tNameLen + 1 + 1); typeName.append("QStack", int(sizeof("QStack")) - 1) .append('<').append(tName, tNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< QStack<T> >( typeName, reinterpret_cast< QStack<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; namespace QtPrivate { template<typename T> struct IsSequentialContainer<QStack<T> > { enum { Value = true }; }; } template <class T> class QSet; template <typename T> struct QMetaTypeId< QSet<T> > { enum { Defined = QMetaTypeId2<T>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.load()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1875) : qt_noop()); const int tNameLen = int(qstrlen(tName)); QByteArray typeName; typeName.reserve(int(sizeof("QSet")) + 1 + tNameLen + 1 + 1); typeName.append("QSet", int(sizeof("QSet")) - 1) .append('<').append(tName, tNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< QSet<T> >( typeName, reinterpret_cast< QSet<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; namespace QtPrivate { template<typename T> struct IsSequentialContainer<QSet<T> > { enum { Value = true }; }; } template <class T> class QLinkedList; template <typename T> struct QMetaTypeId< QLinkedList<T> > { enum { Defined = QMetaTypeId2<T>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.load()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1875) : qt_noop()); const int tNameLen = int(qstrlen(tName)); QByteArray typeName; typeName.reserve(int(sizeof("QLinkedList")) + 1 + tNameLen + 1 + 1); typeName.append("QLinkedList", int(sizeof("QLinkedList")) - 1) .append('<').append(tName, tNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< QLinkedList<T> >( typeName, reinterpret_cast< QLinkedList<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; namespace QtPrivate { template<typename T> struct IsSequentialContainer<QLinkedList<T> > { enum { Value = true }; }; }





 template <typename T> struct QMetaTypeId< std::vector<T> > { enum { Defined = QMetaTypeId2<T>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.load()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1881) : qt_noop()); const int tNameLen = int(qstrlen(tName)); QByteArray typeName; typeName.reserve(int(sizeof("std::vector")) + 1 + tNameLen + 1 + 1); typeName.append("std::vector", int(sizeof("std::vector")) - 1) .append('<').append(tName, tNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< std::vector<T> >( typeName, reinterpret_cast< std::vector<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; namespace QtPrivate { template<typename T> struct IsSequentialContainer<std::vector<T> > { enum { Value = true }; }; }
 template <typename T> struct QMetaTypeId< std::list<T> > { enum { Defined = QMetaTypeId2<T>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.load()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1882) : qt_noop()); const int tNameLen = int(qstrlen(tName)); QByteArray typeName; typeName.reserve(int(sizeof("std::list")) + 1 + tNameLen + 1 + 1); typeName.append("std::list", int(sizeof("std::list")) - 1) .append('<').append(tName, tNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< std::list<T> >( typeName, reinterpret_cast< std::list<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; namespace QtPrivate { template<typename T> struct IsSequentialContainer<std::list<T> > { enum { Value = true }; }; }






 template <class T1, class T2> class QHash; template <class T1, class T2> class QMap; template <class T1, class T2> struct QPair;
#line 1905 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h"
 namespace QtPrivate { template<typename T, typename U> struct IsAssociativeContainer<QHash<T, U> > { enum { Value = true }; }; } template<typename T, typename U> struct QMetaTypeId< QHash<T, U> > { enum { Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); const char *uName = QMetaType::typeName(qMetaTypeId<U>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1905) : qt_noop()); ((!(uName)) ? qt_assert("uName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1905) : qt_noop()); const int tNameLen = int(qstrlen(tName)); const int uNameLen = int(qstrlen(uName)); QByteArray typeName; typeName.reserve(int(sizeof("QHash")) + 1 + tNameLen + 1 + uNameLen + 1 + 1); typeName.append("QHash", int(sizeof("QHash")) - 1) .append('<').append(tName, tNameLen).append(',').append(uName, uNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< QHash<T, U> >( typeName, reinterpret_cast< QHash<T, U> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } };
 namespace QtPrivate { template<typename T, typename U> struct IsAssociativeContainer<QMap<T, U> > { enum { Value = true }; }; } template<typename T, typename U> struct QMetaTypeId< QMap<T, U> > { enum { Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); const char *uName = QMetaType::typeName(qMetaTypeId<U>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1906) : qt_noop()); ((!(uName)) ? qt_assert("uName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1906) : qt_noop()); const int tNameLen = int(qstrlen(tName)); const int uNameLen = int(qstrlen(uName)); QByteArray typeName; typeName.reserve(int(sizeof("QMap")) + 1 + tNameLen + 1 + uNameLen + 1 + 1); typeName.append("QMap", int(sizeof("QMap")) - 1) .append('<').append(tName, tNameLen).append(',').append(uName, uNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< QMap<T, U> >( typeName, reinterpret_cast< QMap<T, U> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } };
 namespace QtPrivate { template<typename T, typename U> struct IsAssociativeContainer<std::map<T, U> > { enum { Value = true }; }; } template<typename T, typename U> struct QMetaTypeId< std::map<T, U> > { enum { Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); const char *uName = QMetaType::typeName(qMetaTypeId<U>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1907) : qt_noop()); ((!(uName)) ? qt_assert("uName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1907) : qt_noop()); const int tNameLen = int(qstrlen(tName)); const int uNameLen = int(qstrlen(uName)); QByteArray typeName; typeName.reserve(int(sizeof("std::map")) + 1 + tNameLen + 1 + uNameLen + 1 + 1); typeName.append("std::map", int(sizeof("std::map")) - 1) .append('<').append(tName, tNameLen).append(',').append(uName, uNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< std::map<T, U> >( typeName, reinterpret_cast< std::map<T, U> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } };

 template<typename T, typename U> struct QMetaTypeId< QPair<T, U> > { enum { Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); const char *uName = QMetaType::typeName(qMetaTypeId<U>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1909) : qt_noop()); ((!(uName)) ? qt_assert("uName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1909) : qt_noop()); const int tNameLen = int(qstrlen(tName)); const int uNameLen = int(qstrlen(uName)); QByteArray typeName; typeName.reserve(int(sizeof("QPair")) + 1 + tNameLen + 1 + uNameLen + 1 + 1); typeName.append("QPair", int(sizeof("QPair")) - 1) .append('<').append(tName, tNameLen).append(',').append(uName, uNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< QPair<T, U> >( typeName, reinterpret_cast< QPair<T, U> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } };
 template<typename T, typename U> struct QMetaTypeId< std::pair<T, U> > { enum { Defined = QMetaTypeId2<T>::Defined && QMetaTypeId2<U>::Defined }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const char *tName = QMetaType::typeName(qMetaTypeId<T>()); const char *uName = QMetaType::typeName(qMetaTypeId<U>()); ((!(tName)) ? qt_assert("tName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1910) : qt_noop()); ((!(uName)) ? qt_assert("uName","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmetatype.h",1910) : qt_noop()); const int tNameLen = int(qstrlen(tName)); const int uNameLen = int(qstrlen(uName)); QByteArray typeName; typeName.reserve(int(sizeof("std::pair")) + 1 + tNameLen + 1 + uNameLen + 1 + 1); typeName.append("std::pair", int(sizeof("std::pair")) - 1) .append('<').append(tName, tNameLen).append(',').append(uName, uNameLen); if (typeName.endsWith('>')) typeName.append(' '); typeName.append('>'); const int newId = qRegisterNormalizedMetaType< std::pair<T, U> >( typeName, reinterpret_cast< std::pair<T, U> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } };





 namespace QtPrivate { template<typename T> struct SharedPointerMetaTypeIdHelper<QSharedPointer<T>, true> { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const char * const cName = T::staticMetaObject.className(); QByteArray typeName; typeName.reserve(int(sizeof("QSharedPointer") + 1 + strlen(cName) + 1)); typeName.append("QSharedPointer", int(sizeof("QSharedPointer")) - 1) .append('<').append(cName).append('>'); const int newId = qRegisterNormalizedMetaType< QSharedPointer<T> >( typeName, reinterpret_cast< QSharedPointer<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; template<typename T> struct MetaTypeSmartPointerHelper<QSharedPointer<T> , typename QEnableIf<IsPointerToTypeDerivedFromQObject<T*>::Value >::Type> { static bool registerConverter(int id) { const int toId = QMetaType::QObjectStar; if (!QMetaType::hasRegisteredConverterFunction(id, toId)) { QtPrivate::QSmartPointerConvertFunctor<QSharedPointer<T> > o; static const QtPrivate::ConverterFunctor<QSharedPointer<T>, QObject*, QSmartPointerConvertFunctor<QSharedPointer<T> > > f(o); return QMetaType::registerConverterFunction(&f, id, toId); } return true; } }; } template <typename T> struct QMetaTypeId< QSharedPointer<T> > : QtPrivate::SharedPointerMetaTypeIdHelper< QSharedPointer<T>, QtPrivate::IsPointerToTypeDerivedFromQObject<T*>::Value> { }; namespace QtPrivate { template<typename T> struct SharedPointerMetaTypeIdHelper<QWeakPointer<T>, true> { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const char * const cName = T::staticMetaObject.className(); QByteArray typeName; typeName.reserve(int(sizeof("QWeakPointer") + 1 + strlen(cName) + 1)); typeName.append("QWeakPointer", int(sizeof("QWeakPointer")) - 1) .append('<').append(cName).append('>'); const int newId = qRegisterNormalizedMetaType< QWeakPointer<T> >( typeName, reinterpret_cast< QWeakPointer<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; template<typename T> struct MetaTypeSmartPointerHelper<QWeakPointer<T> , typename QEnableIf<IsPointerToTypeDerivedFromQObject<T*>::Value >::Type> { static bool registerConverter(int id) { const int toId = QMetaType::QObjectStar; if (!QMetaType::hasRegisteredConverterFunction(id, toId)) { QtPrivate::QSmartPointerConvertFunctor<QWeakPointer<T> > o; static const QtPrivate::ConverterFunctor<QWeakPointer<T>, QObject*, QSmartPointerConvertFunctor<QWeakPointer<T> > > f(o); return QMetaType::registerConverterFunction(&f, id, toId); } return true; } }; } template <typename T> struct QMetaTypeId< QWeakPointer<T> > : QtPrivate::SharedPointerMetaTypeIdHelper< QWeakPointer<T>, QtPrivate::IsPointerToTypeDerivedFromQObject<T*>::Value> { }; namespace QtPrivate { template<typename T> struct SharedPointerMetaTypeIdHelper<QPointer<T>, true> { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const char * const cName = T::staticMetaObject.className(); QByteArray typeName; typeName.reserve(int(sizeof("QPointer") + 1 + strlen(cName) + 1)); typeName.append("QPointer", int(sizeof("QPointer")) - 1) .append('<').append(cName).append('>'); const int newId = qRegisterNormalizedMetaType< QPointer<T> >( typeName, reinterpret_cast< QPointer<T> *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } }; template<typename T> struct MetaTypeSmartPointerHelper<QPointer<T> , typename QEnableIf<IsPointerToTypeDerivedFromQObject<T*>::Value >::Type> { static bool registerConverter(int id) { const int toId = QMetaType::QObjectStar; if (!QMetaType::hasRegisteredConverterFunction(id, toId)) { QtPrivate::QSmartPointerConvertFunctor<QPointer<T> > o; static const QtPrivate::ConverterFunctor<QPointer<T>, QObject*, QSmartPointerConvertFunctor<QPointer<T> > > f(o); return QMetaType::registerConverterFunction(&f, id, toId); } return true; } }; } template <typename T> struct QMetaTypeId< QPointer<T> > : QtPrivate::SharedPointerMetaTypeIdHelper< QPointer<T>, QtPrivate::IsPointerToTypeDerivedFromQObject<T*>::Value> { };





inline QMetaType::QMetaType(const ExtensionFlag extensionFlags, const QMetaTypeInterface *info,
                            Creator creator,
                            Deleter deleter,
                            SaveOperator saveOp,
                            LoadOperator loadOp,
                            Constructor constructor,
                            Destructor destructor,
                            uint size,
                            uint theTypeFlags,
                            int typeId,
                            const QMetaObject *_metaObject)
    : m_creator(creator)
    , m_deleter(deleter)
    , m_saveOp(saveOp)
    , m_loadOp(loadOp)
    , m_constructor(constructor)
    , m_destructor(destructor)
    , m_extension(0)
    , m_size(size)
    , m_typeFlags(theTypeFlags)
    , m_extensionFlags(extensionFlags)
    , m_typeId(typeId)
    , m_metaObject(_metaObject)
{
    if ((isExtended(CtorEx) || typeId == QMetaType::Void))
        ctor(info);
}

inline QMetaType::~QMetaType()
{
    if ((isExtended(DtorEx)))
        dtor();
}

inline bool QMetaType::isValid() const
{
    return m_typeId != UnknownType;
}

inline bool QMetaType::isRegistered() const
{
    return isValid();
}

inline void *QMetaType::create(const void *copy) const
{
    if ((isExtended(CreateEx)))
        return createExtended(copy);
    return m_creator(copy);
}

inline void QMetaType::destroy(void *data) const
{
    if ((isExtended(DestroyEx)))
        return destroyExtended(data);
    m_deleter(data);
}

inline void *QMetaType::construct(void *where, const void *copy) const
{
    if ((isExtended(ConstructEx)))
        return constructExtended(where, copy);
    return m_constructor(where, copy);
}

inline void QMetaType::destruct(void *data) const
{
    if ((isExtended(DestructEx)))
        return destructExtended(data);
    if ((!data))
        return;
    m_destructor(data);
}

inline int QMetaType::sizeOf() const
{
    if ((isExtended(SizeEx)))
        return sizeExtended();
    return m_size;
}

inline QMetaType::TypeFlags QMetaType::flags() const
{
    if ((isExtended(FlagsEx)))
        return flagsExtended();
    return QMetaType::TypeFlags(m_typeFlags);
}

inline const QMetaObject *QMetaType::metaObject() const
{
    if ((isExtended(MetaObjectEx)))
        return metaObjectExtended();
    return m_metaObject;
}




 template<> struct QMetaTypeId2<void> { enum { Defined = 1, IsBuiltIn = true, MetaType = 43 }; static inline int qt_metatype_id() { return 43; } }; template<> struct QMetaTypeId2<bool> { enum { Defined = 1, IsBuiltIn = true, MetaType = 1 }; static inline int qt_metatype_id() { return 1; } }; template<> struct QMetaTypeId2<int> { enum { Defined = 1, IsBuiltIn = true, MetaType = 2 }; static inline int qt_metatype_id() { return 2; } }; template<> struct QMetaTypeId2<uint> { enum { Defined = 1, IsBuiltIn = true, MetaType = 3 }; static inline int qt_metatype_id() { return 3; } }; template<> struct QMetaTypeId2<qlonglong> { enum { Defined = 1, IsBuiltIn = true, MetaType = 4 }; static inline int qt_metatype_id() { return 4; } }; template<> struct QMetaTypeId2<qulonglong> { enum { Defined = 1, IsBuiltIn = true, MetaType = 5 }; static inline int qt_metatype_id() { return 5; } }; template<> struct QMetaTypeId2<double> { enum { Defined = 1, IsBuiltIn = true, MetaType = 6 }; static inline int qt_metatype_id() { return 6; } }; template<> struct QMetaTypeId2<long> { enum { Defined = 1, IsBuiltIn = true, MetaType = 32 }; static inline int qt_metatype_id() { return 32; } }; template<> struct QMetaTypeId2<short> { enum { Defined = 1, IsBuiltIn = true, MetaType = 33 }; static inline int qt_metatype_id() { return 33; } }; template<> struct QMetaTypeId2<char> { enum { Defined = 1, IsBuiltIn = true, MetaType = 34 }; static inline int qt_metatype_id() { return 34; } }; template<> struct QMetaTypeId2<ulong> { enum { Defined = 1, IsBuiltIn = true, MetaType = 35 }; static inline int qt_metatype_id() { return 35; } }; template<> struct QMetaTypeId2<ushort> { enum { Defined = 1, IsBuiltIn = true, MetaType = 36 }; static inline int qt_metatype_id() { return 36; } }; template<> struct QMetaTypeId2<uchar> { enum { Defined = 1, IsBuiltIn = true, MetaType = 37 }; static inline int qt_metatype_id() { return 37; } }; template<> struct QMetaTypeId2<float> { enum { Defined = 1, IsBuiltIn = true, MetaType = 38 }; static inline int qt_metatype_id() { return 38; } }; template<> struct QMetaTypeId2<signed char> { enum { Defined = 1, IsBuiltIn = true, MetaType = 40 }; static inline int qt_metatype_id() { return 40; } }; template<> struct QMetaTypeId2<void*> { enum { Defined = 1, IsBuiltIn = true, MetaType = 31 }; static inline int qt_metatype_id() { return 31; } }; template<> struct QMetaTypeId2<QChar> { enum { Defined = 1, IsBuiltIn = true, MetaType = 7 }; static inline int qt_metatype_id() { return 7; } }; template<> struct QMetaTypeId2<QString> { enum { Defined = 1, IsBuiltIn = true, MetaType = 10 }; static inline int qt_metatype_id() { return 10; } }; template<> struct QMetaTypeId2<QStringList> { enum { Defined = 1, IsBuiltIn = true, MetaType = 11 }; static inline int qt_metatype_id() { return 11; } }; template<> struct QMetaTypeId2<QByteArray> { enum { Defined = 1, IsBuiltIn = true, MetaType = 12 }; static inline int qt_metatype_id() { return 12; } }; template<> struct QMetaTypeId2<QBitArray> { enum { Defined = 1, IsBuiltIn = true, MetaType = 13 }; static inline int qt_metatype_id() { return 13; } }; template<> struct QMetaTypeId2<QDate> { enum { Defined = 1, IsBuiltIn = true, MetaType = 14 }; static inline int qt_metatype_id() { return 14; } }; template<> struct QMetaTypeId2<QTime> { enum { Defined = 1, IsBuiltIn = true, MetaType = 15 }; static inline int qt_metatype_id() { return 15; } }; template<> struct QMetaTypeId2<QDateTime> { enum { Defined = 1, IsBuiltIn = true, MetaType = 16 }; static inline int qt_metatype_id() { return 16; } }; template<> struct QMetaTypeId2<QUrl> { enum { Defined = 1, IsBuiltIn = true, MetaType = 17 }; static inline int qt_metatype_id() { return 17; } }; template<> struct QMetaTypeId2<QLocale> { enum { Defined = 1, IsBuiltIn = true, MetaType = 18 }; static inline int qt_metatype_id() { return 18; } }; template<> struct QMetaTypeId2<QRect> { enum { Defined = 1, IsBuiltIn = true, MetaType = 19 }; static inline int qt_metatype_id() { return 19; } }; template<> struct QMetaTypeId2<QRectF> { enum { Defined = 1, IsBuiltIn = true, MetaType = 20 }; static inline int qt_metatype_id() { return 20; } }; template<> struct QMetaTypeId2<QSize> { enum { Defined = 1, IsBuiltIn = true, MetaType = 21 }; static inline int qt_metatype_id() { return 21; } }; template<> struct QMetaTypeId2<QSizeF> { enum { Defined = 1, IsBuiltIn = true, MetaType = 22 }; static inline int qt_metatype_id() { return 22; } }; template<> struct QMetaTypeId2<QLine> { enum { Defined = 1, IsBuiltIn = true, MetaType = 23 }; static inline int qt_metatype_id() { return 23; } }; template<> struct QMetaTypeId2<QLineF> { enum { Defined = 1, IsBuiltIn = true, MetaType = 24 }; static inline int qt_metatype_id() { return 24; } }; template<> struct QMetaTypeId2<QPoint> { enum { Defined = 1, IsBuiltIn = true, MetaType = 25 }; static inline int qt_metatype_id() { return 25; } }; template<> struct QMetaTypeId2<QPointF> { enum { Defined = 1, IsBuiltIn = true, MetaType = 26 }; static inline int qt_metatype_id() { return 26; } }; template<> struct QMetaTypeId2<QRegExp> { enum { Defined = 1, IsBuiltIn = true, MetaType = 27 }; static inline int qt_metatype_id() { return 27; } }; template<> struct QMetaTypeId2<QEasingCurve> { enum { Defined = 1, IsBuiltIn = true, MetaType = 29 }; static inline int qt_metatype_id() { return 29; } }; template<> struct QMetaTypeId2<QUuid> { enum { Defined = 1, IsBuiltIn = true, MetaType = 30 }; static inline int qt_metatype_id() { return 30; } }; template<> struct QMetaTypeId2<QVariant> { enum { Defined = 1, IsBuiltIn = true, MetaType = 41 }; static inline int qt_metatype_id() { return 41; } }; template<> struct QMetaTypeId2<QModelIndex> { enum { Defined = 1, IsBuiltIn = true, MetaType = 42 }; static inline int qt_metatype_id() { return 42; } }; template<> struct QMetaTypeId2<QRegularExpression> { enum { Defined = 1, IsBuiltIn = true, MetaType = 44 }; static inline int qt_metatype_id() { return 44; } }; template<> struct QMetaTypeId2<QJsonValue> { enum { Defined = 1, IsBuiltIn = true, MetaType = 45 }; static inline int qt_metatype_id() { return 45; } }; template<> struct QMetaTypeId2<QJsonObject> { enum { Defined = 1, IsBuiltIn = true, MetaType = 46 }; static inline int qt_metatype_id() { return 46; } }; template<> struct QMetaTypeId2<QJsonArray> { enum { Defined = 1, IsBuiltIn = true, MetaType = 47 }; static inline int qt_metatype_id() { return 47; } }; template<> struct QMetaTypeId2<QJsonDocument> { enum { Defined = 1, IsBuiltIn = true, MetaType = 48 }; static inline int qt_metatype_id() { return 48; } }; template<> struct QMetaTypeId2<QObject*> { enum { Defined = 1, IsBuiltIn = true, MetaType = 39 }; static inline int qt_metatype_id() { return 39; } }; template<> struct QMetaTypeId2<QVariantMap> { enum { Defined = 1, IsBuiltIn = true, MetaType = 8 }; static inline int qt_metatype_id() { return 8; } }; template<> struct QMetaTypeId2<QVariantList> { enum { Defined = 1, IsBuiltIn = true, MetaType = 9 }; static inline int qt_metatype_id() { return 9; } }; template<> struct QMetaTypeId2<QVariantHash> { enum { Defined = 1, IsBuiltIn = true, MetaType = 28 }; static inline int qt_metatype_id() { return 28; } }; template<> struct QMetaTypeId2<QFont> { enum { Defined = 1, IsBuiltIn = true, MetaType = 64 }; static inline int qt_metatype_id() { return 64; } }; template<> struct QMetaTypeId2<QPixmap> { enum { Defined = 1, IsBuiltIn = true, MetaType = 65 }; static inline int qt_metatype_id() { return 65; } }; template<> struct QMetaTypeId2<QBrush> { enum { Defined = 1, IsBuiltIn = true, MetaType = 66 }; static inline int qt_metatype_id() { return 66; } }; template<> struct QMetaTypeId2<QColor> { enum { Defined = 1, IsBuiltIn = true, MetaType = 67 }; static inline int qt_metatype_id() { return 67; } }; template<> struct QMetaTypeId2<QPalette> { enum { Defined = 1, IsBuiltIn = true, MetaType = 68 }; static inline int qt_metatype_id() { return 68; } }; template<> struct QMetaTypeId2<QIcon> { enum { Defined = 1, IsBuiltIn = true, MetaType = 69 }; static inline int qt_metatype_id() { return 69; } }; template<> struct QMetaTypeId2<QImage> { enum { Defined = 1, IsBuiltIn = true, MetaType = 70 }; static inline int qt_metatype_id() { return 70; } }; template<> struct QMetaTypeId2<QPolygon> { enum { Defined = 1, IsBuiltIn = true, MetaType = 71 }; static inline int qt_metatype_id() { return 71; } }; template<> struct QMetaTypeId2<QRegion> { enum { Defined = 1, IsBuiltIn = true, MetaType = 72 }; static inline int qt_metatype_id() { return 72; } }; template<> struct QMetaTypeId2<QBitmap> { enum { Defined = 1, IsBuiltIn = true, MetaType = 73 }; static inline int qt_metatype_id() { return 73; } }; template<> struct QMetaTypeId2<QCursor> { enum { Defined = 1, IsBuiltIn = true, MetaType = 74 }; static inline int qt_metatype_id() { return 74; } }; template<> struct QMetaTypeId2<QKeySequence> { enum { Defined = 1, IsBuiltIn = true, MetaType = 75 }; static inline int qt_metatype_id() { return 75; } }; template<> struct QMetaTypeId2<QPen> { enum { Defined = 1, IsBuiltIn = true, MetaType = 76 }; static inline int qt_metatype_id() { return 76; } }; template<> struct QMetaTypeId2<QTextLength> { enum { Defined = 1, IsBuiltIn = true, MetaType = 77 }; static inline int qt_metatype_id() { return 77; } }; template<> struct QMetaTypeId2<QTextFormat> { enum { Defined = 1, IsBuiltIn = true, MetaType = 78 }; static inline int qt_metatype_id() { return 78; } }; template<> struct QMetaTypeId2<QMatrix> { enum { Defined = 1, IsBuiltIn = true, MetaType = 79 }; static inline int qt_metatype_id() { return 79; } }; template<> struct QMetaTypeId2<QTransform> { enum { Defined = 1, IsBuiltIn = true, MetaType = 80 }; static inline int qt_metatype_id() { return 80; } }; template<> struct QMetaTypeId2<QMatrix4x4> { enum { Defined = 1, IsBuiltIn = true, MetaType = 81 }; static inline int qt_metatype_id() { return 81; } }; template<> struct QMetaTypeId2<QVector2D> { enum { Defined = 1, IsBuiltIn = true, MetaType = 82 }; static inline int qt_metatype_id() { return 82; } }; template<> struct QMetaTypeId2<QVector3D> { enum { Defined = 1, IsBuiltIn = true, MetaType = 83 }; static inline int qt_metatype_id() { return 83; } }; template<> struct QMetaTypeId2<QVector4D> { enum { Defined = 1, IsBuiltIn = true, MetaType = 84 }; static inline int qt_metatype_id() { return 84; } }; template<> struct QMetaTypeId2<QQuaternion> { enum { Defined = 1, IsBuiltIn = true, MetaType = 85 }; static inline int qt_metatype_id() { return 85; } }; template<> struct QMetaTypeId2<QPolygonF> { enum { Defined = 1, IsBuiltIn = true, MetaType = 86 }; static inline int qt_metatype_id() { return 86; } }; template<> struct QMetaTypeId2<QSizePolicy> { enum { Defined = 1, IsBuiltIn = true, MetaType = 121 }; static inline int qt_metatype_id() { return 121; } };

 template <> struct QMetaTypeId< QtMetaTypePrivate::QSequentialIterableImpl > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const int newId = qRegisterMetaType< QtMetaTypePrivate::QSequentialIterableImpl >("QtMetaTypePrivate::QSequentialIterableImpl", reinterpret_cast< QtMetaTypePrivate::QSequentialIterableImpl *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } };
 template <> struct QMetaTypeId< QtMetaTypePrivate::QAssociativeIterableImpl > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const int newId = qRegisterMetaType< QtMetaTypePrivate::QAssociativeIterableImpl >("QtMetaTypePrivate::QAssociativeIterableImpl", reinterpret_cast< QtMetaTypePrivate::QAssociativeIterableImpl *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } };
 template <> struct QMetaTypeId< QtMetaTypePrivate::QPairVariantInterfaceImpl > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const int newId = qRegisterMetaType< QtMetaTypePrivate::QPairVariantInterfaceImpl >("QtMetaTypePrivate::QPairVariantInterfaceImpl", reinterpret_cast< QtMetaTypePrivate::QPairVariantInterfaceImpl *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } };



template <typename T>
inline bool QtPrivate::IsMetaTypePair<T, true>::registerConverter(int id)
{
    const int toId = qMetaTypeId<QtMetaTypePrivate::QPairVariantInterfaceImpl>();
    if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
        QtMetaTypePrivate::QPairVariantInterfaceConvertFunctor<T> o;
        static const QtPrivate::ConverterFunctor<T,
                                    QtMetaTypePrivate::QPairVariantInterfaceImpl,
                                    QtMetaTypePrivate::QPairVariantInterfaceConvertFunctor<T> > f(o);
        return QMetaType::registerConverterFunction(&f, id, toId);
    }
    return true;
}

namespace QtPrivate {
    template<typename T>
    struct ValueTypeIsMetaType<T, true>
    {
        static bool registerConverter(int id)
        {
            const int toId = qMetaTypeId<QtMetaTypePrivate::QSequentialIterableImpl>();
            if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
                QtMetaTypePrivate::QSequentialIterableConvertFunctor<T> o;
                static const QtPrivate::ConverterFunctor<T,
                        QtMetaTypePrivate::QSequentialIterableImpl,
                QtMetaTypePrivate::QSequentialIterableConvertFunctor<T> > f(o);
                return QMetaType::registerConverterFunction(&f, id, toId);
            }
            return true;
        }
    };

    template<typename T>
    struct AssociativeValueTypeIsMetaType<T, true>
    {
        static bool registerConverter(int id)
        {
            const int toId = qMetaTypeId<QtMetaTypePrivate::QAssociativeIterableImpl>();
            if (!QMetaType::hasRegisteredConverterFunction(id, toId)) {
                QtMetaTypePrivate::QAssociativeIterableConvertFunctor<T> o;
                static const QtPrivate::ConverterFunctor<T,
                                            QtMetaTypePrivate::QAssociativeIterableImpl,
                                            QtMetaTypePrivate::QAssociativeIterableConvertFunctor<T> > f(o);
                return QMetaType::registerConverterFunction(&f, id, toId);
            }
            return true;
        }
    };
}
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject_impl.h"
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject_impl.h"
namespace QtPrivate {
#line 95 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject_impl.h"
    template <typename ArgList> struct TypesAreDeclaredMetaType { enum { Value = false }; };
    template <> struct TypesAreDeclaredMetaType<List<>> { enum { Value = true }; };
    template <typename Arg, typename... Tail> struct TypesAreDeclaredMetaType<List<Arg, Tail...> >
    { enum { Value = QMetaTypeId2<Arg>::Defined && TypesAreDeclaredMetaType<List<Tail...>>::Value }; };

    template <typename ArgList, bool Declared = TypesAreDeclaredMetaType<ArgList>::Value > struct ConnectionTypes
    { static const int *types() { return 0; } };
    template <> struct ConnectionTypes<List<>, true>
    { static const int *types() { return 0; } };
    template <typename... Args> struct ConnectionTypes<List<Args...>, true>
    { static const int *types() { static const int t[sizeof...(Args) + 1] = { (QtPrivate::QMetaTypeIdHelper<Args>::qt_metatype_id())..., 0 }; return t; } };



    class QSlotObjectBase {
        QAtomicInt m_ref;



        typedef void (*ImplFn)(int which, QSlotObjectBase* this_, QObject *receiver, void **args, bool *ret);
        const ImplFn m_impl;
    protected:
        enum Operation {
            Destroy,
            Call,
            Compare,

            NumOperations
        };
    public:
        explicit QSlotObjectBase(ImplFn fn) : m_ref(1), m_impl(fn) {}

        inline int ref() throw() { return m_ref.ref(); }
        inline void destroyIfLastRef() throw()
        { if (!m_ref.deref()) m_impl(Destroy, this, 0, 0, 0); }

        inline bool compare(void **a) { bool ret; m_impl(Compare, this, 0, a, &ret); return ret; }
        inline void call(QObject *r, void **a) { m_impl(Call, this, r, a, 0); }
    protected:
        ~QSlotObjectBase() {}
    private:
        QSlotObjectBase(const QSlotObjectBase &) = delete; QSlotObjectBase &operator=(const QSlotObjectBase &) = delete;
    };


    template<typename Func, typename Args, typename R> class QSlotObject : public QSlotObjectBase
    {
        typedef QtPrivate::FunctionPointer<Func> FuncType;
        Func function;
        static void impl(int which, QSlotObjectBase *this_, QObject *r, void **a, bool *ret)
        {
            switch (which) {
            case Destroy:
                delete static_cast<QSlotObject*>(this_);
                break;
            case Call:
                FuncType::template call<Args, R>(static_cast<QSlotObject*>(this_)->function, static_cast<typename FuncType::Object *>(r), a);
                break;
            case Compare:
                *ret = *reinterpret_cast<Func *>(a) == static_cast<QSlotObject*>(this_)->function;
                break;
            case NumOperations: ;
            }
        }
    public:
        explicit QSlotObject(Func f) : QSlotObjectBase(&impl), function(f) {}
    };


    template<typename Func, typename Args, typename R> class QStaticSlotObject : public QSlotObjectBase
    {
        typedef QtPrivate::FunctionPointer<Func> FuncType;
        Func function;
        static void impl(int which, QSlotObjectBase *this_, QObject *r, void **a, bool *ret)
        {
            switch (which) {
            case Destroy:
                delete static_cast<QStaticSlotObject*>(this_);
                break;
            case Call:
                FuncType::template call<Args, R>(static_cast<QStaticSlotObject*>(this_)->function, r, a);
                break;
            case Compare:
                *ret = false;
                break;
            case NumOperations: ;
            }
        }
    public:
        explicit QStaticSlotObject(Func f) : QSlotObjectBase(&impl), function(f) {}
    };



    template<typename Func, int N, typename Args, typename R> class QFunctorSlotObject : public QSlotObjectBase
    {
        typedef QtPrivate::Functor<Func, N> FuncType;
        Func function;
        static void impl(int which, QSlotObjectBase *this_, QObject *r, void **a, bool *ret)
        {
            switch (which) {
            case Destroy:
                delete static_cast<QFunctorSlotObject*>(this_);
                break;
            case Call:
                FuncType::template call<Args, R>(static_cast<QFunctorSlotObject*>(this_)->function, r, a);
                break;
            case Compare:
                *ret = false;
                break;
            case NumOperations: ;
            }
        }
    public:
        explicit QFunctorSlotObject(const Func &f) : QSlotObjectBase(&impl), function(f) {}
    };
}
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"





class QEvent;
class QTimerEvent;
class QChildEvent;
struct QMetaObject;
class QVariant;
class QObjectPrivate;
class QObject;
class QThread;
class QWidget;

class QRegExp;


class QRegularExpression;


class QObjectUserData;

struct QDynamicMetaObjectData;

typedef QList<QObject*> QObjectList;

__declspec(dllimport) void qt_qFindChildren_helper(const QObject *parent, const QString &name,
                                           const QMetaObject &mo, QList<void *> *list, Qt::FindChildOptions options);
__declspec(dllimport) void qt_qFindChildren_helper(const QObject *parent, const QRegExp &re,
                                           const QMetaObject &mo, QList<void *> *list, Qt::FindChildOptions options);
__declspec(dllimport) void qt_qFindChildren_helper(const QObject *parent, const QRegularExpression &re,
                                           const QMetaObject &mo, QList<void *> *list, Qt::FindChildOptions options);
__declspec(dllimport) QObject *qt_qFindChild_helper(const QObject *parent, const QString &name, const QMetaObject &mo, Qt::FindChildOptions options);

class __declspec(dllimport) QObjectData {
public:
    virtual ~QObjectData() = 0;
    QObject *q_ptr;
    QObject *parent;
    QObjectList children;

    uint isWidget : 1;
    uint blockSig : 1;
    uint wasDeleted : 1;
    uint isDeletingChildren : 1;
    uint sendChildEvents : 1;
    uint receiveChildEvents : 1;
    uint isWindow : 1;
    uint unused : 25;
    int postedEvents;
    QDynamicMetaObjectData *metaObject;
    QMetaObject *dynamicMetaObject() const;
};


class __declspec(dllimport) QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

    inline QObjectPrivate* d_func() { return reinterpret_cast<QObjectPrivate *>(qGetPtrHelper(d_ptr)); } inline const QObjectPrivate* d_func() const { return reinterpret_cast<const QObjectPrivate *>(qGetPtrHelper(d_ptr)); } friend class QObjectPrivate;

public:
                explicit QObject(QObject *parent=0);
    virtual ~QObject();

    virtual bool event(QEvent *);
    virtual bool eventFilter(QObject *, QEvent *);
#line 142 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"
    QString objectName() const;
    void setObjectName(const QString &name);

    inline bool isWidgetType() const { return d_ptr->isWidget; }
    inline bool isWindowType() const { return d_ptr->isWindow; }

    inline bool signalsBlocked() const { return d_ptr->blockSig; }
    bool blockSignals(bool b);

    QThread *thread() const;
    void moveToThread(QThread *thread);

    int startTimer(int interval, Qt::TimerType timerType = Qt::CoarseTimer);
    void killTimer(int id);

    template<typename T>
    inline T findChild(const QString &aName = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
    { return static_cast<T>(qt_qFindChild_helper(this, aName, reinterpret_cast<T>(0)->staticMetaObject, options)); }

    template<typename T>
    inline QList<T> findChildren(const QString &aName = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
    {
        QList<T> list;
        qt_qFindChildren_helper(this, aName, reinterpret_cast<T>(0)->staticMetaObject,
                                reinterpret_cast<QList<void *> *>(&list), options);
        return list;
    }


    template<typename T>
    inline QList<T> findChildren(const QRegExp &re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
    {
        QList<T> list;
        qt_qFindChildren_helper(this, re, reinterpret_cast<T>(0)->staticMetaObject,
                                reinterpret_cast<QList<void *> *>(&list), options);
        return list;
    }



    template<typename T>
    inline QList<T> findChildren(const QRegularExpression &re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
    {
        QList<T> list;
        qt_qFindChildren_helper(this, re, reinterpret_cast<T>(0)->staticMetaObject,
                                reinterpret_cast<QList<void *> *>(&list), options);
        return list;
    }


    inline const QObjectList &children() const { return d_ptr->children; }

    void setParent(QObject *);
    void installEventFilter(QObject *);
    void removeEventFilter(QObject *);

    static QMetaObject::Connection connect(const QObject *sender, const char *signal,
                        const QObject *receiver, const char *member, Qt::ConnectionType = Qt::AutoConnection);

    static QMetaObject::Connection connect(const QObject *sender, const QMetaMethod &signal,
                        const QObject *receiver, const QMetaMethod &method,
                        Qt::ConnectionType type = Qt::AutoConnection);

    inline QMetaObject::Connection connect(const QObject *sender, const char *signal,
                        const char *member, Qt::ConnectionType type = Qt::AutoConnection) const;







    template <typename Func1, typename Func2>
    static inline QMetaObject::Connection connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal,
                                     const typename QtPrivate::FunctionPointer<Func2>::Object *receiver, Func2 slot,
                                     Qt::ConnectionType type = Qt::AutoConnection)
    {
        typedef QtPrivate::FunctionPointer<Func1> SignalType;
        typedef QtPrivate::FunctionPointer<Func2> SlotType;

        static_assert(bool(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value), "No Q_OBJECT in the class with the signal");



        static_assert(bool(int(SignalType::ArgumentCount) >= int(SlotType::ArgumentCount)), "The slot requires more arguments than the signal provides.");

        static_assert(bool((QtPrivate::CheckCompatibleArguments<typename SignalType::Arguments, typename SlotType::Arguments>::value)), "Signal and slot arguments are not compatible.");

        static_assert(bool((QtPrivate::AreArgumentsCompatible<typename SlotType::ReturnType, typename SignalType::ReturnType>::value)), "Return type of the slot is not compatible with the return type of the signal.");


        const int *types = 0;
        if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
            types = QtPrivate::ConnectionTypes<typename SignalType::Arguments>::types();

        return connectImpl(sender, reinterpret_cast<void **>(&signal),
                           receiver, reinterpret_cast<void **>(&slot),
                           new QtPrivate::QSlotObject<Func2, typename QtPrivate::List_Left<typename SignalType::Arguments, SlotType::ArgumentCount>::Value,
                                           typename SignalType::ReturnType>(slot),
                            type, types, &SignalType::Object::staticMetaObject);
    }


    template <typename Func1, typename Func2>
    static inline typename QtPrivate::QEnableIf<int(QtPrivate::FunctionPointer<Func2>::ArgumentCount) >= 0, QMetaObject::Connection>::Type
            connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal, Func2 slot)
    {
        return connect(sender, signal, sender, slot, Qt::DirectConnection);
    }


    template <typename Func1, typename Func2>
    static inline typename QtPrivate::QEnableIf<int(QtPrivate::FunctionPointer<Func2>::ArgumentCount) >= 0 &&
                                                !QtPrivate::FunctionPointer<Func2>::IsPointerToMemberFunction, QMetaObject::Connection>::Type
            connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal, const QObject *context, Func2 slot,
                    Qt::ConnectionType type = Qt::AutoConnection)
    {
        typedef QtPrivate::FunctionPointer<Func1> SignalType;
        typedef QtPrivate::FunctionPointer<Func2> SlotType;

        static_assert(bool(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value), "No Q_OBJECT in the class with the signal");



        static_assert(bool(int(SignalType::ArgumentCount) >= int(SlotType::ArgumentCount)), "The slot requires more arguments than the signal provides.");

        static_assert(bool((QtPrivate::CheckCompatibleArguments<typename SignalType::Arguments, typename SlotType::Arguments>::value)), "Signal and slot arguments are not compatible.");

        static_assert(bool((QtPrivate::AreArgumentsCompatible<typename SlotType::ReturnType, typename SignalType::ReturnType>::value)), "Return type of the slot is not compatible with the return type of the signal.");


        const int *types = 0;
        if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
            types = QtPrivate::ConnectionTypes<typename SignalType::Arguments>::types();

        return connectImpl(sender, reinterpret_cast<void **>(&signal), context, 0,
                           new QtPrivate::QStaticSlotObject<Func2,
                                                 typename QtPrivate::List_Left<typename SignalType::Arguments, SlotType::ArgumentCount>::Value,
                                                 typename SignalType::ReturnType>(slot),
                           type, types, &SignalType::Object::staticMetaObject);
    }


    template <typename Func1, typename Func2>
    static inline typename QtPrivate::QEnableIf<QtPrivate::FunctionPointer<Func2>::ArgumentCount == -1, QMetaObject::Connection>::Type
            connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal, Func2 slot)
    {
        return connect(sender, signal, sender, slot, Qt::DirectConnection);
    }


    template <typename Func1, typename Func2>
    static inline typename QtPrivate::QEnableIf<QtPrivate::FunctionPointer<Func2>::ArgumentCount == -1, QMetaObject::Connection>::Type
            connect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal, const QObject *context, Func2 slot,
                    Qt::ConnectionType type = Qt::AutoConnection)
    {

        typedef QtPrivate::FunctionPointer<Func1> SignalType;
        const int FunctorArgumentCount = QtPrivate::ComputeFunctorArgumentCount<Func2 , typename SignalType::Arguments>::Value;

        static_assert(bool((FunctorArgumentCount >= 0)), "Signal and slot arguments are not compatible.");

        const int SlotArgumentCount = (FunctorArgumentCount >= 0) ? FunctorArgumentCount : 0;
        typedef typename QtPrivate::FunctorReturnType<Func2, typename QtPrivate::List_Left<typename SignalType::Arguments, SlotArgumentCount>::Value>::Value SlotReturnType;
#line 337 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"
        static_assert(bool((QtPrivate::AreArgumentsCompatible<SlotReturnType, typename SignalType::ReturnType>::value)), "Return type of the slot is not compatible with the return type of the signal.");


        static_assert(bool(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value), "No Q_OBJECT in the class with the signal");


        const int *types = 0;
        if (type == Qt::QueuedConnection || type == Qt::BlockingQueuedConnection)
            types = QtPrivate::ConnectionTypes<typename SignalType::Arguments>::types();

        return connectImpl(sender, reinterpret_cast<void **>(&signal), context, 0,
                           new QtPrivate::QFunctorSlotObject<Func2, SlotArgumentCount,
                                typename QtPrivate::List_Left<typename SignalType::Arguments, SlotArgumentCount>::Value,
                                typename SignalType::ReturnType>(slot),
                           type, types, &SignalType::Object::staticMetaObject);
    }


    static bool disconnect(const QObject *sender, const char *signal,
                           const QObject *receiver, const char *member);
    static bool disconnect(const QObject *sender, const QMetaMethod &signal,
                           const QObject *receiver, const QMetaMethod &member);
    inline bool disconnect(const char *signal = 0,
                           const QObject *receiver = 0, const char *member = 0) const
        { return disconnect(this, signal, receiver, member); }
    inline bool disconnect(const QObject *receiver, const char *member = 0) const
        { return disconnect(this, 0, receiver, member); }
    static bool disconnect(const QMetaObject::Connection &);




    template <typename Func1, typename Func2>
    static inline bool disconnect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal,
                                  const typename QtPrivate::FunctionPointer<Func2>::Object *receiver, Func2 slot)
    {
        typedef QtPrivate::FunctionPointer<Func1> SignalType;
        typedef QtPrivate::FunctionPointer<Func2> SlotType;

        static_assert(bool(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value), "No Q_OBJECT in the class with the signal");



        static_assert(bool((QtPrivate::CheckCompatibleArguments<typename SignalType::Arguments, typename SlotType::Arguments>::value)), "Signal and slot arguments are not compatible.");


        return disconnectImpl(sender, reinterpret_cast<void **>(&signal), receiver, reinterpret_cast<void **>(&slot),
                              &SignalType::Object::staticMetaObject);
    }
    template <typename Func1>
    static inline bool disconnect(const typename QtPrivate::FunctionPointer<Func1>::Object *sender, Func1 signal,
                                  const QObject *receiver, void **zero)
    {



        ((!(!zero)) ? qt_assert("!zero","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h",393) : qt_noop());
        typedef QtPrivate::FunctionPointer<Func1> SignalType;
        return disconnectImpl(sender, reinterpret_cast<void **>(&signal), receiver, zero,
                              &SignalType::Object::staticMetaObject);
    }



    void dumpObjectTree();
    void dumpObjectInfo();


    bool setProperty(const char *name, const QVariant &value);
    QVariant property(const char *name) const;
    QList<QByteArray> dynamicPropertyNames() const;



    static uint registerUserData();
    void setUserData(uint id, QObjectUserData* data);
    QObjectUserData* userData(uint id) const;


public:
    void destroyed(QObject * = 0);
    void objectNameChanged(const QString &objectName

    , QPrivateSignal

    );

public:
    inline QObject *parent() const { return d_ptr->parent; }

    inline bool inherits(const char *classname) const
        { return const_cast<QObject *>(this)->qt_metacast(classname) != 0; }

public :
    void deleteLater();

protected:
    QObject *sender() const;
    int senderSignalIndex() const;
    int receivers(const char* signal) const;
    bool isSignalConnected(const QMetaMethod &signal) const;

    virtual void timerEvent(QTimerEvent *);
    virtual void childEvent(QChildEvent *);
    virtual void customEvent(QEvent *);

    virtual void connectNotify(const QMetaMethod &signal);
    virtual void disconnectNotify(const QMetaMethod &signal);

protected:
    QObject(QObjectPrivate &dd, QObject *parent = 0);

protected:
    QScopedPointer<QObjectData> d_ptr;

    static const QMetaObject staticQtMetaObject;

    friend struct QMetaObject;
    friend struct QMetaObjectPrivate;
    friend class QMetaCallEvent;
    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QCoreApplication;
    friend class QCoreApplicationPrivate;
    friend class QWidget;
    friend class QThreadData;

private:
    QObject(const QObject &) = delete; QObject &operator=(const QObject &) = delete;


private:
    static QMetaObject::Connection connectImpl(const QObject *sender, void **signal,
                                               const QObject *receiver, void **slotPtr,
                                               QtPrivate::QSlotObjectBase *slot, Qt::ConnectionType type,
                                               const int *types, const QMetaObject *senderMetaObject);

    static bool disconnectImpl(const QObject *sender, void **signal, const QObject *receiver, void **slot,
                               const QMetaObject *senderMetaObject);

};

inline QMetaObject::Connection QObject::connect(const QObject *asender, const char *asignal,
                                            const char *amember, Qt::ConnectionType atype) const
{ return connect(asender, asignal, this, amember, atype); }


class __declspec(dllimport) QObjectUserData {
public:
    virtual ~QObjectUserData();
};
#line 516 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"
template <class T>
inline T qobject_cast(QObject *object)
{
    typedef typename QtPrivate::remove_cv<typename QtPrivate::remove_pointer<T>::type>::type ObjType;
    static_assert(bool(QtPrivate::HasQ_OBJECT_Macro<ObjType>::Value), "qobject_cast requires the type to have a Q_OBJECT macro");

    return static_cast<T>(reinterpret_cast<T>(object)->staticMetaObject.cast(object));
}

template <class T>
inline T qobject_cast(const QObject *object)
{
    typedef typename QtPrivate::remove_cv<typename QtPrivate::remove_pointer<T>::type>::type ObjType;
    static_assert(bool(QtPrivate::HasQ_OBJECT_Macro<ObjType>::Value), "qobject_cast requires the type to have a Q_OBJECT macro");

    return static_cast<T>(reinterpret_cast<T>(object)->staticMetaObject.cast(object));
}


template <class T> inline const char * qobject_interface_iid()
{ return 0; }
#line 549 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qobject.h"
__declspec(dllimport) QDebug operator<<(QDebug, const QObject *);


class QSignalBlocker
{
public:
    inline explicit QSignalBlocker(QObject *o);
    inline explicit QSignalBlocker(QObject &o);
    inline ~QSignalBlocker();


    inline QSignalBlocker(QSignalBlocker &&other);
    inline QSignalBlocker &operator=(QSignalBlocker &&other);


    inline void reblock();
    inline void unblock();
private:
    QSignalBlocker(const QSignalBlocker &) = delete; QSignalBlocker &operator=(const QSignalBlocker &) = delete;
    QObject * m_o;
    bool m_blocked;
    bool m_inhibited;
};

QSignalBlocker::QSignalBlocker(QObject *o)
    : m_o(o),
      m_blocked(o && o->blockSignals(true)),
      m_inhibited(false)
{}

QSignalBlocker::QSignalBlocker(QObject &o)
    : m_o(&o),
      m_blocked(o.blockSignals(true)),
      m_inhibited(false)
{}


QSignalBlocker::QSignalBlocker(QSignalBlocker &&other)
    : m_o(other.m_o),
      m_blocked(other.m_blocked),
      m_inhibited(other.m_inhibited)
{
    other.m_o = 0;
}

QSignalBlocker &QSignalBlocker::operator=(QSignalBlocker &&other)
{
    if (this != &other) {


        if (m_o != other.m_o || (!m_inhibited && other.m_inhibited))
            unblock();
        m_o = other.m_o;
        m_blocked = other.m_blocked;
        m_inhibited = other.m_inhibited;

        other.m_o = 0;
    }
    return *this;
}


QSignalBlocker::~QSignalBlocker()
{
    if (m_o && !m_inhibited)
        m_o->blockSignals(m_blocked);
}

void QSignalBlocker::reblock()
{
    if (m_o) m_o->blockSignals(true);
    m_inhibited = false;
}

void QSignalBlocker::unblock()
{
    if (m_o) m_o->blockSignals(m_blocked);
    m_inhibited = true;
}

namespace QtPrivate {
    inline QObject & deref_for_methodcall(QObject &o) { return o; }
    inline QObject & deref_for_methodcall(QObject *o) { return *o; }
}
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcoreapplication.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcoreevent.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcoreevent.h"
class QEventPrivate;
class __declspec(dllimport) QEvent
{
    public: static const QMetaObject staticMetaObject; private:


public:
    enum Type {






        None = 0,
        Timer = 1,
        MouseButtonPress = 2,
        MouseButtonRelease = 3,
        MouseButtonDblClick = 4,
        MouseMove = 5,
        KeyPress = 6,
        KeyRelease = 7,
        FocusIn = 8,
        FocusOut = 9,
        FocusAboutToChange = 23,
        Enter = 10,
        Leave = 11,
        Paint = 12,
        Move = 13,
        Resize = 14,
        Create = 15,
        Destroy = 16,
        Show = 17,
        Hide = 18,
        Close = 19,
        Quit = 20,
        ParentChange = 21,
        ParentAboutToChange = 131,
        ThreadChange = 22,
        WindowActivate = 24,
        WindowDeactivate = 25,
        ShowToParent = 26,
        HideToParent = 27,
        Wheel = 31,
        WindowTitleChange = 33,
        WindowIconChange = 34,
        ApplicationWindowIconChange = 35,
        ApplicationFontChange = 36,
        ApplicationLayoutDirectionChange = 37,
        ApplicationPaletteChange = 38,
        PaletteChange = 39,
        Clipboard = 40,
        Speech = 42,
        MetaCall = 43,
        SockAct = 50,
        WinEventAct = 132,
        DeferredDelete = 52,
        DragEnter = 60,
        DragMove = 61,
        DragLeave = 62,
        Drop = 63,
        DragResponse = 64,
        ChildAdded = 68,
        ChildPolished = 69,
        ChildRemoved = 71,
        ShowWindowRequest = 73,
        PolishRequest = 74,
        Polish = 75,
        LayoutRequest = 76,
        UpdateRequest = 77,
        UpdateLater = 78,

        EmbeddingControl = 79,
        ActivateControl = 80,
        DeactivateControl = 81,
        ContextMenu = 82,
        InputMethod = 83,
        TabletMove = 87,
        LocaleChange = 88,
        LanguageChange = 89,
        LayoutDirectionChange = 90,
        Style = 91,
        TabletPress = 92,
        TabletRelease = 93,
        OkRequest = 94,
        HelpRequest = 95,

        IconDrag = 96,

        FontChange = 97,
        EnabledChange = 98,
        ActivationChange = 99,
        StyleChange = 100,
        IconTextChange = 101,
        ModifiedChange = 102,
        MouseTrackingChange = 109,

        WindowBlocked = 103,
        WindowUnblocked = 104,
        WindowStateChange = 105,

        ToolTip = 110,
        WhatsThis = 111,
        StatusTip = 112,

        ActionChanged = 113,
        ActionAdded = 114,
        ActionRemoved = 115,

        FileOpen = 116,

        Shortcut = 117,
        ShortcutOverride = 51,

        WhatsThisClicked = 118,

        ToolBarChange = 120,

        ApplicationActivate = 121,
        ApplicationActivated = ApplicationActivate,
        ApplicationDeactivate = 122,
        ApplicationDeactivated = ApplicationDeactivate,

        QueryWhatsThis = 123,
        EnterWhatsThisMode = 124,
        LeaveWhatsThisMode = 125,

        ZOrderChange = 126,

        HoverEnter = 127,
        HoverLeave = 128,
        HoverMove = 129,







        AcceptDropsChange = 152,

        ZeroTimerEvent = 154,

        GraphicsSceneMouseMove = 155,
        GraphicsSceneMousePress = 156,
        GraphicsSceneMouseRelease = 157,
        GraphicsSceneMouseDoubleClick = 158,
        GraphicsSceneContextMenu = 159,
        GraphicsSceneHoverEnter = 160,
        GraphicsSceneHoverMove = 161,
        GraphicsSceneHoverLeave = 162,
        GraphicsSceneHelp = 163,
        GraphicsSceneDragEnter = 164,
        GraphicsSceneDragMove = 165,
        GraphicsSceneDragLeave = 166,
        GraphicsSceneDrop = 167,
        GraphicsSceneWheel = 168,

        KeyboardLayoutChange = 169,

        DynamicPropertyChange = 170,

        TabletEnterProximity = 171,
        TabletLeaveProximity = 172,

        NonClientAreaMouseMove = 173,
        NonClientAreaMouseButtonPress = 174,
        NonClientAreaMouseButtonRelease = 175,
        NonClientAreaMouseButtonDblClick = 176,

        MacSizeChange = 177,

        ContentsRectChange = 178,

        MacGLWindowChange = 179,

        FutureCallOut = 180,

        GraphicsSceneResize = 181,
        GraphicsSceneMove = 182,

        CursorChange = 183,
        ToolTipChange = 184,

        NetworkReplyUpdated = 185,

        GrabMouse = 186,
        UngrabMouse = 187,
        GrabKeyboard = 188,
        UngrabKeyboard = 189,
        MacGLClearDrawable = 191,

        StateMachineSignal = 192,
        StateMachineWrapped = 193,

        TouchBegin = 194,
        TouchUpdate = 195,
        TouchEnd = 196,


        NativeGesture = 197,

        RequestSoftwareInputPanel = 199,
        CloseSoftwareInputPanel = 200,

        WinIdChange = 203,

        Gesture = 198,
        GestureOverride = 202,

        ScrollPrepare = 204,
        Scroll = 205,

        Expose = 206,

        InputMethodQuery = 207,
        OrientationChange = 208,

        TouchCancel = 209,

        ThemeChange = 210,

        SockClose = 211,

        PlatformPanel = 212,

        StyleAnimationUpdate = 213,
        ApplicationStateChange = 214,

        WindowChangeInternal = 215,




        User = 1000,
        MaxUser = 65535
    };

    explicit QEvent(Type type);
    QEvent(const QEvent &other);
    virtual ~QEvent();
    QEvent &operator=(const QEvent &other);
    inline Type type() const { return static_cast<Type>(t); }
    inline bool spontaneous() const { return spont; }

    inline void setAccepted(bool accepted) { m_accept = accepted; }
    inline bool isAccepted() const { return m_accept; }

    inline void accept() { m_accept = true; }
    inline void ignore() { m_accept = false; }

    static int registerEventType(int hint = -1);

protected:
    QEventPrivate *d;
    ushort t;

private:
    ushort posted : 1;
    ushort spont : 1;
    ushort m_accept : 1;
    ushort reserved : 13;

    friend class QCoreApplication;
    friend class QCoreApplicationPrivate;
    friend class QThreadData;
    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QShortcutMap;
    friend class QETWidget;
    friend class QGraphicsView;
    friend class QGraphicsViewPrivate;
    friend class QGraphicsScene;
    friend class QGraphicsScenePrivate;
    friend class QWidgetWindow;

    friend class QGestureManager;

};

class __declspec(dllimport) QTimerEvent : public QEvent
{
public:
    explicit QTimerEvent( int timerId );
    ~QTimerEvent();
    int timerId() const { return id; }
protected:
    int id;
};

class QObject;

class __declspec(dllimport) QChildEvent : public QEvent
{
public:
    QChildEvent( Type type, QObject *child );
    ~QChildEvent();
    QObject *child() const { return c; }
    bool added() const { return type() == ChildAdded; }
    bool polished() const { return type() == ChildPolished; }
    bool removed() const { return type() == ChildRemoved; }
protected:
    QObject *c;
};

class __declspec(dllimport) QDynamicPropertyChangeEvent : public QEvent
{
public:
    explicit QDynamicPropertyChangeEvent(const QByteArray &name);
    ~QDynamicPropertyChangeEvent();

    inline QByteArray propertyName() const { return n; }

private:
    QByteArray n;
};

class __declspec(dllimport) QDeferredDeleteEvent : public QEvent
{
public:
    explicit QDeferredDeleteEvent();
    ~QDeferredDeleteEvent();
    int loopLevel() const { return level; }
private:
    int level;
    friend class QCoreApplication;
};
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcoreapplication.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qeventloop.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qeventloop.h"
class QEventLoopPrivate;

class __declspec(dllimport) QEventLoop : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QEventLoopPrivate* d_func() { return reinterpret_cast<QEventLoopPrivate *>(qGetPtrHelper(d_ptr)); } inline const QEventLoopPrivate* d_func() const { return reinterpret_cast<const QEventLoopPrivate *>(qGetPtrHelper(d_ptr)); } friend class QEventLoopPrivate;

public:
    explicit QEventLoop(QObject *parent = 0);
    ~QEventLoop();

    enum ProcessEventsFlag {
        AllEvents = 0x00,
        ExcludeUserInputEvents = 0x01,
        ExcludeSocketNotifiers = 0x02,
        WaitForMoreEvents = 0x04,
        X11ExcludeTimers = 0x08,
        EventLoopExec = 0x20,
        DialogExec = 0x40
    };
    typedef QFlags<ProcessEventsFlag> ProcessEventsFlags;

    bool processEvents(ProcessEventsFlags flags = AllEvents);
    void processEvents(ProcessEventsFlags flags, int maximumTime);

    int exec(ProcessEventsFlags flags = AllEvents);
    void exit(int returnCode = 0);
    bool isRunning() const;

    void wakeUp();

    bool event(QEvent *event);

public :
    void quit();
};

 inline QFlags<QEventLoop::ProcessEventsFlags::enum_type> operator|(QEventLoop::ProcessEventsFlags::enum_type f1, QEventLoop::ProcessEventsFlags::enum_type f2) { return QFlags<QEventLoop::ProcessEventsFlags::enum_type>(f1) | f2; } inline QFlags<QEventLoop::ProcessEventsFlags::enum_type> operator|(QEventLoop::ProcessEventsFlags::enum_type f1, QFlags<QEventLoop::ProcessEventsFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QEventLoop::ProcessEventsFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


class QEventLoopLockerPrivate;

class __declspec(dllimport) QEventLoopLocker
{
public:
    QEventLoopLocker();
    explicit QEventLoopLocker(QEventLoop *loop);
    explicit QEventLoopLocker(QThread *thread);
    ~QEventLoopLocker();

private:
    QEventLoopLocker(const QEventLoopLocker &) = delete; QEventLoopLocker &operator=(const QEventLoopLocker &) = delete;
    QEventLoopLockerPrivate *d_ptr;
};
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcoreapplication.h"







typedef struct tagMSG MSG;






class QCoreApplicationPrivate;
class QTextCodec;
class QTranslator;
class QPostEventList;
class QStringList;
class QAbstractEventDispatcher;
class QAbstractNativeEventFilter;



class __declspec(dllimport) QCoreApplication

    : public QObject

{

    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};







    inline QCoreApplicationPrivate* d_func() { return reinterpret_cast<QCoreApplicationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QCoreApplicationPrivate* d_func() const { return reinterpret_cast<const QCoreApplicationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QCoreApplicationPrivate;
public:
    enum { ApplicationFlags = 0x050302
    };

    QCoreApplication(int &argc, char **argv

                     , int = ApplicationFlags

            );

    ~QCoreApplication();

    static QStringList arguments();

    static void setAttribute(Qt::ApplicationAttribute attribute, bool on = true);
    static bool testAttribute(Qt::ApplicationAttribute attribute);

    static void setOrganizationDomain(const QString &orgDomain);
    static QString organizationDomain();
    static void setOrganizationName(const QString &orgName);
    static QString organizationName();
    static void setApplicationName(const QString &application);
    static QString applicationName();
    static void setApplicationVersion(const QString &version);
    static QString applicationVersion();

    static void setSetuidAllowed(bool allow);
    static bool isSetuidAllowed();

    static QCoreApplication *instance() { return self; }


    static int exec();
    static void processEvents(QEventLoop::ProcessEventsFlags flags = QEventLoop::AllEvents);
    static void processEvents(QEventLoop::ProcessEventsFlags flags, int maxtime);
    static void exit(int retcode=0);

    static bool sendEvent(QObject *receiver, QEvent *event);
    static void postEvent(QObject *receiver, QEvent *event, int priority = Qt::NormalEventPriority);
    static void sendPostedEvents(QObject *receiver = 0, int event_type = 0);
    static void removePostedEvents(QObject *receiver, int eventType = 0);

                  static bool hasPendingEvents();

    static QAbstractEventDispatcher *eventDispatcher();
    static void setEventDispatcher(QAbstractEventDispatcher *eventDispatcher);

    virtual bool notify(QObject *, QEvent *);

    static bool startingUp();
    static bool closingDown();


    static QString applicationDirPath();
    static QString applicationFilePath();
    static qint64 applicationPid();


    static void setLibraryPaths(const QStringList &);
    static QStringList libraryPaths();
    static void addLibraryPath(const QString &);
    static void removeLibraryPath(const QString &);



    static bool installTranslator(QTranslator * messageFile);
    static bool removeTranslator(QTranslator * messageFile);


    static QString translate(const char * context,
                             const char * key,
                             const char * disambiguation = 0,
                             int n = -1);
#line 170 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcoreapplication.h"
    static void flush();

    void installNativeEventFilter(QAbstractNativeEventFilter *filterObj);
    void removeNativeEventFilter(QAbstractNativeEventFilter *filterObj);

    static bool isQuitLockEnabled();
    static void setQuitLockEnabled(bool enabled);

public :
    static void quit();

public:
    void aboutToQuit(

    QPrivateSignal

    );

    void organizationNameChanged();
    void organizationDomainChanged();
    void applicationNameChanged();
    void applicationVersionChanged();

protected:
    bool event(QEvent *);

    virtual bool compressEvent(QEvent *, QObject *receiver, QPostEventList *);


protected:
    QCoreApplication(QCoreApplicationPrivate &p);





private:

    static bool sendSpontaneousEvent(QObject *receiver, QEvent *event);
    bool notifyInternal(QObject *receiver, QEvent *event);


    void init();

    static QCoreApplication *self;

    QCoreApplication(const QCoreApplication &) = delete; QCoreApplication &operator=(const QCoreApplication &) = delete;

    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QGuiApplication;
    friend class QGuiApplicationPrivate;
    friend class QETWidget;
    friend class QWidget;
    friend class QWidgetWindow;
    friend class QWidgetPrivate;

    friend class QEventDispatcherUNIXPrivate;
    friend class QCocoaEventDispatcherPrivate;
    friend bool qt_sendSpontaneousEvent(QObject*, QEvent*);

    friend __declspec(dllimport) QString qAppName();
    friend class QClassFactory;
};


inline bool QCoreApplication::sendEvent(QObject *receiver, QEvent *event)
{ if (event) event->spont = false; return self ? self->notifyInternal(receiver, event) : false; }

inline bool QCoreApplication::sendSpontaneousEvent(QObject *receiver, QEvent *event)
{ if (event) event->spont = true; return self ? self->notifyInternal(receiver, event) : false; }
#line 258 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcoreapplication.h"
typedef void (*QtStartUpFunction)();
typedef void (*QtCleanUpFunction)();

__declspec(dllimport) void qAddPreRoutine(QtStartUpFunction);
__declspec(dllimport) void qAddPostRoutine(QtCleanUpFunction);
__declspec(dllimport) void qRemovePostRoutine(QtCleanUpFunction);
__declspec(dllimport) QString qAppName();
#line 274 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcoreapplication.h"
__declspec(dllimport) QString decodeMSG(const MSG &);
__declspec(dllimport) QDebug operator<<(QDebug, const MSG &);
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QCoreApplication"
#line 6 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QWidget"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qwindowdefs.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qwindowdefs.h"
class QPaintDevice;
class QWidget;
class QWindow;
class QDialog;
class QColor;
class QPalette;
class QCursor;
class QPoint;
class QSize;
class QRect;
class QPolygon;
class QPainter;
class QRegion;
class QFont;
class QFontMetrics;
class QFontInfo;
class QPen;
class QBrush;
class QMatrix;
class QPixmap;
class QBitmap;
class QMovie;
class QImage;
class QPicture;
class QTimer;
class QTime;
class QClipboard;
class QString;
class QByteArray;
class QApplication;

template<typename T> class QList;
typedef QList<QWidget *> QWidgetList;
typedef QList<QWindow *> QWindowList;








#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qwindowdefs_win.h"
#line 75 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qwindowdefs_win.h"
struct HINSTANCE__; typedef struct HINSTANCE__ *HINSTANCE;


struct HDC__; typedef struct HDC__ *HDC;


struct HWND__; typedef struct HWND__ *HWND;


struct HFONT__; typedef struct HFONT__ *HFONT;


struct HPEN__; typedef struct HPEN__ *HPEN;


struct HBRUSH__; typedef struct HBRUSH__ *HBRUSH;


struct HBITMAP__; typedef struct HBITMAP__ *HBITMAP;


struct HICON__; typedef struct HICON__ *HICON;


typedef HICON HCURSOR;


struct HPALETTE__; typedef struct HPALETTE__ *HPALETTE;


struct HRGN__; typedef struct HRGN__ *HRGN;


struct HMONITOR__; typedef struct HMONITOR__ *HMONITOR;


typedef long HRESULT;


typedef struct tagMSG MSG;



__declspec(dllimport) HINSTANCE qWinAppInst();
__declspec(dllimport) HINSTANCE qWinAppPrevInst();
__declspec(dllimport) int qWinAppCmdShow();
__declspec(dllimport) HDC qt_win_display_dc();
#line 95 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qwindowdefs.h"






typedef ::quintptr WId;





template<class K, class V> class QHash;
typedef QHash<WId, QWidget *> QWidgetMapper;

template<class V> class QSet;
typedef QSet<QWidget *> QWidgetSet;
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmargins.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmargins.h"
class QMargins
{
public:
                     QMargins();
                     QMargins(int left, int top, int right, int bottom);

                     bool isNull() const;

                     int left() const;
                     int top() const;
                     int right() const;
                     int bottom() const;

    void setLeft(int left);
    void setTop(int top);
    void setRight(int right);
    void setBottom(int bottom);

    QMargins &operator+=(const QMargins &margins);
    QMargins &operator-=(const QMargins &margins);
    QMargins &operator+=(int);
    QMargins &operator-=(int);
    QMargins &operator*=(int);
    QMargins &operator/=(int);
    QMargins &operator*=(qreal);
    QMargins &operator/=(qreal);

private:
    int m_left;
    int m_top;
    int m_right;
    int m_bottom;

    friend inline bool operator==(const QMargins &, const QMargins &);
    friend inline bool operator!=(const QMargins &, const QMargins &);
};

template<> class QTypeInfo<QMargins > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMargins)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QMargins >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QMargins) }; static inline const char *name() { return "QMargins"; } };





__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QMargins &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QMargins &);






                 inline QMargins::QMargins() : m_left(0), m_top(0), m_right(0), m_bottom(0) {}

                 inline QMargins::QMargins(int aleft, int atop, int aright, int abottom)
    : m_left(aleft), m_top(atop), m_right(aright), m_bottom(abottom) {}

                 inline bool QMargins::isNull() const
{ return m_left==0 && m_top==0 && m_right==0 && m_bottom==0; }

                 inline int QMargins::left() const
{ return m_left; }

                 inline int QMargins::top() const
{ return m_top; }

                 inline int QMargins::right() const
{ return m_right; }

                 inline int QMargins::bottom() const
{ return m_bottom; }


inline void QMargins::setLeft(int aleft)
{ m_left = aleft; }

inline void QMargins::setTop(int atop)
{ m_top = atop; }

inline void QMargins::setRight(int aright)
{ m_right = aright; }

inline void QMargins::setBottom(int abottom)
{ m_bottom = abottom; }

                 inline bool operator==(const QMargins &m1, const QMargins &m2)
{
    return
            m1.m_left == m2.m_left &&
            m1.m_top == m2.m_top &&
            m1.m_right == m2.m_right &&
            m1.m_bottom == m2.m_bottom;
}

                 inline bool operator!=(const QMargins &m1, const QMargins &m2)
{
    return
            m1.m_left != m2.m_left ||
            m1.m_top != m2.m_top ||
            m1.m_right != m2.m_right ||
            m1.m_bottom != m2.m_bottom;
}

                 inline QMargins operator+(const QMargins &m1, const QMargins &m2)
{
    return QMargins(m1.left() + m2.left(), m1.top() + m2.top(),
                    m1.right() + m2.right(), m1.bottom() + m2.bottom());
}

                 inline QMargins operator-(const QMargins &m1, const QMargins &m2)
{
    return QMargins(m1.left() - m2.left(), m1.top() - m2.top(),
                    m1.right() - m2.right(), m1.bottom() - m2.bottom());
}

                 inline QMargins operator+(const QMargins &lhs, int rhs)
{
    return QMargins(lhs.left() + rhs, lhs.top() + rhs,
                    lhs.right() + rhs, lhs.bottom() + rhs);
}

                 inline QMargins operator+(int lhs, const QMargins &rhs)
{
    return QMargins(rhs.left() + lhs, rhs.top() + lhs,
                    rhs.right() + lhs, rhs.bottom() + lhs);
}

                 inline QMargins operator-(const QMargins &lhs, int rhs)
{
    return QMargins(lhs.left() - rhs, lhs.top() - rhs,
                    lhs.right() - rhs, lhs.bottom() - rhs);
}

                 inline QMargins operator*(const QMargins &margins, int factor)
{
    return QMargins(margins.left() * factor, margins.top() * factor,
                    margins.right() * factor, margins.bottom() * factor);
}

                 inline QMargins operator*(int factor, const QMargins &margins)
{
    return QMargins(margins.left() * factor, margins.top() * factor,
                    margins.right() * factor, margins.bottom() * factor);
}

                 inline QMargins operator*(const QMargins &margins, qreal factor)
{
    return QMargins(qRound(margins.left() * factor), qRound(margins.top() * factor),
                    qRound(margins.right() * factor), qRound(margins.bottom() * factor));
}

                 inline QMargins operator*(qreal factor, const QMargins &margins)
{
    return QMargins(qRound(margins.left() * factor), qRound(margins.top() * factor),
                    qRound(margins.right() * factor), qRound(margins.bottom() * factor));
}

                 inline QMargins operator/(const QMargins &margins, int divisor)
{
    return QMargins(margins.left() / divisor, margins.top() / divisor,
                    margins.right() / divisor, margins.bottom() / divisor);
}

                 inline QMargins operator/(const QMargins &margins, qreal divisor)
{
    return QMargins(qRound(margins.left() / divisor), qRound(margins.top() / divisor),
                    qRound(margins.right() / divisor), qRound(margins.bottom() / divisor));
}

inline QMargins &QMargins::operator+=(const QMargins &margins)
{
    return *this = *this + margins;
}

inline QMargins &QMargins::operator-=(const QMargins &margins)
{
    return *this = *this - margins;
}

inline QMargins &QMargins::operator+=(int margin)
{
    m_left += margin;
    m_top += margin;
    m_right += margin;
    m_bottom += margin;
    return *this;
}

inline QMargins &QMargins::operator-=(int margin)
{
    m_left -= margin;
    m_top -= margin;
    m_right -= margin;
    m_bottom -= margin;
    return *this;
}

inline QMargins &QMargins::operator*=(int factor)
{
    return *this = *this * factor;
}

inline QMargins &QMargins::operator/=(int divisor)
{
    return *this = *this / divisor;
}

inline QMargins &QMargins::operator*=(qreal factor)
{
    return *this = *this * factor;
}

inline QMargins &QMargins::operator/=(qreal divisor)
{
    return *this = *this / divisor;
}

                 inline QMargins operator+(const QMargins &margins)
{
    return margins;
}

                 inline QMargins operator-(const QMargins &margins)
{
    return QMargins(-margins.left(), -margins.top(), -margins.right(), -margins.bottom());
}


__declspec(dllimport) QDebug operator<<(QDebug, const QMargins &);






class QMarginsF
{
public:
                     QMarginsF();
                     QMarginsF(qreal left, qreal top, qreal right, qreal bottom);
                     QMarginsF(const QMargins &margins);

                     bool isNull() const;

                     qreal left() const;
                     qreal top() const;
                     qreal right() const;
                     qreal bottom() const;

    void setLeft(qreal left);
    void setTop(qreal top);
    void setRight(qreal right);
    void setBottom(qreal bottom);

    QMarginsF &operator+=(const QMarginsF &margins);
    QMarginsF &operator-=(const QMarginsF &margins);
    QMarginsF &operator+=(qreal addend);
    QMarginsF &operator-=(qreal subtrahend);
    QMarginsF &operator*=(qreal factor);
    QMarginsF &operator/=(qreal divisor);

                     inline QMargins toMargins() const;

private:
    qreal m_left;
    qreal m_top;
    qreal m_right;
    qreal m_bottom;
};

template<> class QTypeInfo<QMarginsF > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMarginsF)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QMarginsF >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QMarginsF) }; static inline const char *name() { return "QMarginsF"; } };






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QMarginsF &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QMarginsF &);






                 inline QMarginsF::QMarginsF() : m_left(0), m_top(0), m_right(0), m_bottom(0) {}

                 inline QMarginsF::QMarginsF(qreal aleft, qreal atop, qreal aright, qreal abottom)
    : m_left(aleft), m_top(atop), m_right(aright), m_bottom(abottom) {}

                 inline QMarginsF::QMarginsF(const QMargins &margins)
    : m_left(margins.left()), m_top(margins.top()), m_right(margins.right()), m_bottom(margins.bottom()) {}

                 inline bool QMarginsF::isNull() const
{ return qFuzzyIsNull(m_left) && qFuzzyIsNull(m_top) && qFuzzyIsNull(m_right) && qFuzzyIsNull(m_bottom); }

                 inline qreal QMarginsF::left() const
{ return m_left; }

                 inline qreal QMarginsF::top() const
{ return m_top; }

                 inline qreal QMarginsF::right() const
{ return m_right; }

                 inline qreal QMarginsF::bottom() const
{ return m_bottom; }


inline void QMarginsF::setLeft(qreal aleft)
{ m_left = aleft; }

inline void QMarginsF::setTop(qreal atop)
{ m_top = atop; }

inline void QMarginsF::setRight(qreal aright)
{ m_right = aright; }

inline void QMarginsF::setBottom(qreal abottom)
{ m_bottom = abottom; }

                 inline bool operator==(const QMarginsF &lhs, const QMarginsF &rhs)
{
    return qFuzzyCompare(lhs.left(), rhs.left())
           && qFuzzyCompare(lhs.top(), rhs.top())
           && qFuzzyCompare(lhs.right(), rhs.right())
           && qFuzzyCompare(lhs.bottom(), rhs.bottom());
}

                 inline bool operator!=(const QMarginsF &lhs, const QMarginsF &rhs)
{
    return !operator==(lhs, rhs);
}

                 inline QMarginsF operator+(const QMarginsF &lhs, const QMarginsF &rhs)
{
    return QMarginsF(lhs.left() + rhs.left(), lhs.top() + rhs.top(),
                     lhs.right() + rhs.right(), lhs.bottom() + rhs.bottom());
}

                 inline QMarginsF operator-(const QMarginsF &lhs, const QMarginsF &rhs)
{
    return QMarginsF(lhs.left() - rhs.left(), lhs.top() - rhs.top(),
                     lhs.right() - rhs.right(), lhs.bottom() - rhs.bottom());
}

                 inline QMarginsF operator+(const QMarginsF &lhs, qreal rhs)
{
    return QMarginsF(lhs.left() + rhs, lhs.top() + rhs,
                     lhs.right() + rhs, lhs.bottom() + rhs);
}

                 inline QMarginsF operator+(qreal lhs, const QMarginsF &rhs)
{
    return QMarginsF(rhs.left() + lhs, rhs.top() + lhs,
                     rhs.right() + lhs, rhs.bottom() + lhs);
}

                 inline QMarginsF operator-(const QMarginsF &lhs, qreal rhs)
{
    return QMarginsF(lhs.left() - rhs, lhs.top() - rhs,
                     lhs.right() - rhs, lhs.bottom() - rhs);
}

                 inline QMarginsF operator*(const QMarginsF &lhs, qreal rhs)
{
    return QMarginsF(lhs.left() * rhs, lhs.top() * rhs,
                     lhs.right() * rhs, lhs.bottom() * rhs);
}

                 inline QMarginsF operator*(qreal lhs, const QMarginsF &rhs)
{
    return QMarginsF(rhs.left() * lhs, rhs.top() * lhs,
                     rhs.right() * lhs, rhs.bottom() * lhs);
}

                 inline QMarginsF operator/(const QMarginsF &lhs, qreal divisor)
{
    return QMarginsF(lhs.left() / divisor, lhs.top() / divisor,
                     lhs.right() / divisor, lhs.bottom() / divisor);
}

inline QMarginsF &QMarginsF::operator+=(const QMarginsF &margins)
{
    return *this = *this + margins;
}

inline QMarginsF &QMarginsF::operator-=(const QMarginsF &margins)
{
    return *this = *this - margins;
}

inline QMarginsF &QMarginsF::operator+=(qreal addend)
{
    m_left += addend;
    m_top += addend;
    m_right += addend;
    m_bottom += addend;
    return *this;
}

inline QMarginsF &QMarginsF::operator-=(qreal subtrahend)
{
    m_left -= subtrahend;
    m_top -= subtrahend;
    m_right -= subtrahend;
    m_bottom -= subtrahend;
    return *this;
}

inline QMarginsF &QMarginsF::operator*=(qreal factor)
{
    return *this = *this * factor;
}

inline QMarginsF &QMarginsF::operator/=(qreal divisor)
{
    return *this = *this / divisor;
}

                 inline QMarginsF operator+(const QMarginsF &margins)
{
    return margins;
}

                 inline QMarginsF operator-(const QMarginsF &margins)
{
    return QMarginsF(-margins.left(), -margins.top(), -margins.right(), -margins.bottom());
}

                 inline QMargins QMarginsF::toMargins() const
{
    return QMargins(qRound(m_left), qRound(m_top), qRound(m_right), qRound(m_bottom));
}


__declspec(dllimport) QDebug operator<<(QDebug, const QMarginsF &);
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpaintdevice.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpaintdevice.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qrect.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qrect.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsize.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsize.h"
class __declspec(dllimport) QSize
{
public:
                     QSize();
                     QSize(int w, int h);

                     inline bool isNull() const;
                     inline bool isEmpty() const;
                     inline bool isValid() const;

                     inline int width() const;
                     inline int height() const;
    inline void setWidth(int w);
    inline void setHeight(int h);
    void transpose();
                     inline QSize transposed() const;

    inline void scale(int w, int h, Qt::AspectRatioMode mode);
    inline void scale(const QSize &s, Qt::AspectRatioMode mode);
    QSize scaled(int w, int h, Qt::AspectRatioMode mode) const;
    QSize scaled(const QSize &s, Qt::AspectRatioMode mode) const;

                     inline QSize expandedTo(const QSize &) const;
                     inline QSize boundedTo(const QSize &) const;

    inline int &rwidth();
    inline int &rheight();

    inline QSize &operator+=(const QSize &);
    inline QSize &operator-=(const QSize &);
    inline QSize &operator*=(qreal c);
    inline QSize &operator/=(qreal c);

    friend inline bool operator==(const QSize &, const QSize &);
    friend inline bool operator!=(const QSize &, const QSize &);
    friend inline const QSize operator+(const QSize &, const QSize &);
    friend inline const QSize operator-(const QSize &, const QSize &);
    friend inline const QSize operator*(const QSize &, qreal);
    friend inline const QSize operator*(qreal, const QSize &);
    friend inline const QSize operator/(const QSize &, qreal);

private:
    int wd;
    int ht;
};
template<> class QTypeInfo<QSize > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QSize)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QSize >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QSize) }; static inline const char *name() { return "QSize"; } };






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QSize &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QSize &);







                 inline QSize::QSize() : wd(-1), ht(-1) {}

                 inline QSize::QSize(int w, int h) : wd(w), ht(h) {}

                 inline bool QSize::isNull() const
{ return wd==0 && ht==0; }

                 inline bool QSize::isEmpty() const
{ return wd<1 || ht<1; }

                 inline bool QSize::isValid() const
{ return wd>=0 && ht>=0; }

                 inline int QSize::width() const
{ return wd; }

                 inline int QSize::height() const
{ return ht; }

inline void QSize::setWidth(int w)
{ wd = w; }

inline void QSize::setHeight(int h)
{ ht = h; }

                 inline QSize QSize::transposed() const
{ return QSize(ht, wd); }

inline void QSize::scale(int w, int h, Qt::AspectRatioMode mode)
{ scale(QSize(w, h), mode); }

inline void QSize::scale(const QSize &s, Qt::AspectRatioMode mode)
{ *this = scaled(s, mode); }

inline QSize QSize::scaled(int w, int h, Qt::AspectRatioMode mode) const
{ return scaled(QSize(w, h), mode); }

inline int &QSize::rwidth()
{ return wd; }

inline int &QSize::rheight()
{ return ht; }

inline QSize &QSize::operator+=(const QSize &s)
{ wd+=s.wd; ht+=s.ht; return *this; }

inline QSize &QSize::operator-=(const QSize &s)
{ wd-=s.wd; ht-=s.ht; return *this; }

inline QSize &QSize::operator*=(qreal c)
{ wd = qRound(wd*c); ht = qRound(ht*c); return *this; }

                 inline bool operator==(const QSize &s1, const QSize &s2)
{ return s1.wd == s2.wd && s1.ht == s2.ht; }

                 inline bool operator!=(const QSize &s1, const QSize &s2)
{ return s1.wd != s2.wd || s1.ht != s2.ht; }

                 inline const QSize operator+(const QSize & s1, const QSize & s2)
{ return QSize(s1.wd+s2.wd, s1.ht+s2.ht); }

                 inline const QSize operator-(const QSize &s1, const QSize &s2)
{ return QSize(s1.wd-s2.wd, s1.ht-s2.ht); }

                 inline const QSize operator*(const QSize &s, qreal c)
{ return QSize(qRound(s.wd*c), qRound(s.ht*c)); }

                 inline const QSize operator*(qreal c, const QSize &s)
{ return QSize(qRound(s.wd*c), qRound(s.ht*c)); }

inline QSize &QSize::operator/=(qreal c)
{
    ((!(!qFuzzyIsNull(c))) ? qt_assert("!qFuzzyIsNull(c)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsize.h",183) : qt_noop());
    wd = qRound(wd/c); ht = qRound(ht/c);
    return *this;
}

inline const QSize operator/(const QSize &s, qreal c)
{
    ((!(!qFuzzyIsNull(c))) ? qt_assert("!qFuzzyIsNull(c)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsize.h",190) : qt_noop());
    return QSize(qRound(s.wd/c), qRound(s.ht/c));
}

                 inline QSize QSize::expandedTo(const QSize & otherSize) const
{
    return QSize(qMax(wd,otherSize.wd), qMax(ht,otherSize.ht));
}

                 inline QSize QSize::boundedTo(const QSize & otherSize) const
{
    return QSize(qMin(wd,otherSize.wd), qMin(ht,otherSize.ht));
}


__declspec(dllimport) QDebug operator<<(QDebug, const QSize &);



class __declspec(dllimport) QSizeF
{
public:
                     QSizeF();
                     QSizeF(const QSize &sz);
                     QSizeF(qreal w, qreal h);

    inline bool isNull() const;
                     inline bool isEmpty() const;
                     inline bool isValid() const;

                     inline qreal width() const;
                     inline qreal height() const;
    inline void setWidth(qreal w);
    inline void setHeight(qreal h);
    void transpose();
                     inline QSizeF transposed() const;

    inline void scale(qreal w, qreal h, Qt::AspectRatioMode mode);
    inline void scale(const QSizeF &s, Qt::AspectRatioMode mode);
    QSizeF scaled(qreal w, qreal h, Qt::AspectRatioMode mode) const;
    QSizeF scaled(const QSizeF &s, Qt::AspectRatioMode mode) const;

                     inline QSizeF expandedTo(const QSizeF &) const;
                     inline QSizeF boundedTo(const QSizeF &) const;

    inline qreal &rwidth();
    inline qreal &rheight();

    inline QSizeF &operator+=(const QSizeF &);
    inline QSizeF &operator-=(const QSizeF &);
    inline QSizeF &operator*=(qreal c);
    inline QSizeF &operator/=(qreal c);

    friend inline bool operator==(const QSizeF &, const QSizeF &);
    friend inline bool operator!=(const QSizeF &, const QSizeF &);
    friend inline const QSizeF operator+(const QSizeF &, const QSizeF &);
    friend inline const QSizeF operator-(const QSizeF &, const QSizeF &);
    friend inline const QSizeF operator*(const QSizeF &, qreal);
    friend inline const QSizeF operator*(qreal, const QSizeF &);
    friend inline const QSizeF operator/(const QSizeF &, qreal);

                     inline QSize toSize() const;

private:
    qreal wd;
    qreal ht;
};
template<> class QTypeInfo<QSizeF > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QSizeF)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QSizeF >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QSizeF) }; static inline const char *name() { return "QSizeF"; } };







__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QSizeF &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QSizeF &);







                 inline QSizeF::QSizeF() : wd(-1.), ht(-1.) {}

                 inline QSizeF::QSizeF(const QSize &sz) : wd(sz.width()), ht(sz.height()) {}

                 inline QSizeF::QSizeF(qreal w, qreal h) : wd(w), ht(h) {}

inline bool QSizeF::isNull() const
{ return qIsNull(wd) && qIsNull(ht); }

                 inline bool QSizeF::isEmpty() const
{ return wd <= 0. || ht <= 0.; }

                 inline bool QSizeF::isValid() const
{ return wd >= 0. && ht >= 0.; }

                 inline qreal QSizeF::width() const
{ return wd; }

                 inline qreal QSizeF::height() const
{ return ht; }

inline void QSizeF::setWidth(qreal w)
{ wd = w; }

inline void QSizeF::setHeight(qreal h)
{ ht = h; }

                 inline QSizeF QSizeF::transposed() const
{ return QSizeF(ht, wd); }

inline void QSizeF::scale(qreal w, qreal h, Qt::AspectRatioMode mode)
{ scale(QSizeF(w, h), mode); }

inline void QSizeF::scale(const QSizeF &s, Qt::AspectRatioMode mode)
{ *this = scaled(s, mode); }

inline QSizeF QSizeF::scaled(qreal w, qreal h, Qt::AspectRatioMode mode) const
{ return scaled(QSizeF(w, h), mode); }

inline qreal &QSizeF::rwidth()
{ return wd; }

inline qreal &QSizeF::rheight()
{ return ht; }

inline QSizeF &QSizeF::operator+=(const QSizeF &s)
{ wd += s.wd; ht += s.ht; return *this; }

inline QSizeF &QSizeF::operator-=(const QSizeF &s)
{ wd -= s.wd; ht -= s.ht; return *this; }

inline QSizeF &QSizeF::operator*=(qreal c)
{ wd *= c; ht *= c; return *this; }

                 inline bool operator==(const QSizeF &s1, const QSizeF &s2)
{ return qFuzzyCompare(s1.wd, s2.wd) && qFuzzyCompare(s1.ht, s2.ht); }

                 inline bool operator!=(const QSizeF &s1, const QSizeF &s2)
{ return !qFuzzyCompare(s1.wd, s2.wd) || !qFuzzyCompare(s1.ht, s2.ht); }

                 inline const QSizeF operator+(const QSizeF & s1, const QSizeF & s2)
{ return QSizeF(s1.wd+s2.wd, s1.ht+s2.ht); }

                 inline const QSizeF operator-(const QSizeF &s1, const QSizeF &s2)
{ return QSizeF(s1.wd-s2.wd, s1.ht-s2.ht); }

                 inline const QSizeF operator*(const QSizeF &s, qreal c)
{ return QSizeF(s.wd*c, s.ht*c); }

                 inline const QSizeF operator*(qreal c, const QSizeF &s)
{ return QSizeF(s.wd*c, s.ht*c); }

inline QSizeF &QSizeF::operator/=(qreal c)
{
    ((!(!qFuzzyIsNull(c))) ? qt_assert("!qFuzzyIsNull(c)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsize.h",348) : qt_noop());
    wd = wd/c; ht = ht/c;
    return *this;
}

inline const QSizeF operator/(const QSizeF &s, qreal c)
{
    ((!(!qFuzzyIsNull(c))) ? qt_assert("!qFuzzyIsNull(c)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsize.h",355) : qt_noop());
    return QSizeF(s.wd/c, s.ht/c);
}

                 inline QSizeF QSizeF::expandedTo(const QSizeF & otherSize) const
{
    return QSizeF(qMax(wd,otherSize.wd), qMax(ht,otherSize.ht));
}

                 inline QSizeF QSizeF::boundedTo(const QSizeF & otherSize) const
{
    return QSizeF(qMin(wd,otherSize.wd), qMin(ht,otherSize.ht));
}

                 inline QSize QSizeF::toSize() const
{
    return QSize(qRound(wd), qRound(ht));
}


__declspec(dllimport) QDebug operator<<(QDebug, const QSizeF &);
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qrect.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qpoint.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qpoint.h"
class __declspec(dllimport) QPoint
{
public:
                     QPoint();
                     QPoint(int xpos, int ypos);

                     inline bool isNull() const;

                     inline int x() const;
                     inline int y() const;
    inline void setX(int x);
    inline void setY(int y);

                     inline int manhattanLength() const;

    inline int &rx();
    inline int &ry();

    inline QPoint &operator+=(const QPoint &p);
    inline QPoint &operator-=(const QPoint &p);

    inline QPoint &operator*=(float factor);
    inline QPoint &operator*=(double factor);
    inline QPoint &operator*=(int factor);

    inline QPoint &operator/=(qreal divisor);

                     static inline int dotProduct(const QPoint &p1, const QPoint &p2)
    { return p1.xp * p2.xp + p1.yp * p2.yp; }

    friend inline bool operator==(const QPoint &, const QPoint &);
    friend inline bool operator!=(const QPoint &, const QPoint &);
    friend inline const QPoint operator+(const QPoint &, const QPoint &);
    friend inline const QPoint operator-(const QPoint &, const QPoint &);
    friend inline const QPoint operator*(const QPoint &, float);
    friend inline const QPoint operator*(float, const QPoint &);
    friend inline const QPoint operator*(const QPoint &, double);
    friend inline const QPoint operator*(double, const QPoint &);
    friend inline const QPoint operator*(const QPoint &, int);
    friend inline const QPoint operator*(int, const QPoint &);
    friend inline const QPoint operator+(const QPoint &);
    friend inline const QPoint operator-(const QPoint &);
    friend inline const QPoint operator/(const QPoint &, qreal);

private:
    friend class QTransform;
    int xp;
    int yp;
};

template<> class QTypeInfo<QPoint > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPoint)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QPoint >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QPoint) }; static inline const char *name() { return "QPoint"; } };





__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPoint &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPoint &);






                 inline QPoint::QPoint() : xp(0), yp(0) {}

                 inline QPoint::QPoint(int xpos, int ypos) : xp(xpos), yp(ypos) {}

                 inline bool QPoint::isNull() const
{ return xp == 0 && yp == 0; }

                 inline int QPoint::x() const
{ return xp; }

                 inline int QPoint::y() const
{ return yp; }

inline void QPoint::setX(int xpos)
{ xp = xpos; }

inline void QPoint::setY(int ypos)
{ yp = ypos; }

inline int QPoint::manhattanLength() const
{ return qAbs(x())+qAbs(y()); }

inline int &QPoint::rx()
{ return xp; }

inline int &QPoint::ry()
{ return yp; }

inline QPoint &QPoint::operator+=(const QPoint &p)
{ xp+=p.xp; yp+=p.yp; return *this; }

inline QPoint &QPoint::operator-=(const QPoint &p)
{ xp-=p.xp; yp-=p.yp; return *this; }

inline QPoint &QPoint::operator*=(float factor)
{ xp = qRound(xp*factor); yp = qRound(yp*factor); return *this; }

inline QPoint &QPoint::operator*=(double factor)
{ xp = qRound(xp*factor); yp = qRound(yp*factor); return *this; }

inline QPoint &QPoint::operator*=(int factor)
{ xp = xp*factor; yp = yp*factor; return *this; }

                 inline bool operator==(const QPoint &p1, const QPoint &p2)
{ return p1.xp == p2.xp && p1.yp == p2.yp; }

                 inline bool operator!=(const QPoint &p1, const QPoint &p2)
{ return p1.xp != p2.xp || p1.yp != p2.yp; }

                 inline const QPoint operator+(const QPoint &p1, const QPoint &p2)
{ return QPoint(p1.xp+p2.xp, p1.yp+p2.yp); }

                 inline const QPoint operator-(const QPoint &p1, const QPoint &p2)
{ return QPoint(p1.xp-p2.xp, p1.yp-p2.yp); }

                 inline const QPoint operator*(const QPoint &p, float factor)
{ return QPoint(qRound(p.xp*factor), qRound(p.yp*factor)); }

                 inline const QPoint operator*(const QPoint &p, double factor)
{ return QPoint(qRound(p.xp*factor), qRound(p.yp*factor)); }

                 inline const QPoint operator*(const QPoint &p, int factor)
{ return QPoint(p.xp*factor, p.yp*factor); }

                 inline const QPoint operator*(float factor, const QPoint &p)
{ return QPoint(qRound(p.xp*factor), qRound(p.yp*factor)); }

                 inline const QPoint operator*(double factor, const QPoint &p)
{ return QPoint(qRound(p.xp*factor), qRound(p.yp*factor)); }

                 inline const QPoint operator*(int factor, const QPoint &p)
{ return QPoint(p.xp*factor, p.yp*factor); }

                 inline const QPoint operator+(const QPoint &p)
{ return p; }

                 inline const QPoint operator-(const QPoint &p)
{ return QPoint(-p.xp, -p.yp); }

inline QPoint &QPoint::operator/=(qreal c)
{
    xp = qRound(xp/c);
    yp = qRound(yp/c);
    return *this;
}

                 inline const QPoint operator/(const QPoint &p, qreal c)
{
    return QPoint(qRound(p.xp/c), qRound(p.yp/c));
}


__declspec(dllimport) QDebug operator<<(QDebug, const QPoint &);






class __declspec(dllimport) QPointF
{
public:
                     QPointF();
                     QPointF(const QPoint &p);
                     QPointF(qreal xpos, qreal ypos);

                     inline qreal manhattanLength() const;

    inline bool isNull() const;

                     inline qreal x() const;
                     inline qreal y() const;
    inline void setX(qreal x);
    inline void setY(qreal y);

    inline qreal &rx();
    inline qreal &ry();

    inline QPointF &operator+=(const QPointF &p);
    inline QPointF &operator-=(const QPointF &p);
    inline QPointF &operator*=(qreal c);
    inline QPointF &operator/=(qreal c);

                     static inline qreal dotProduct(const QPointF &p1, const QPointF &p2)
    { return p1.xp * p2.xp + p1.yp * p2.yp; }

    friend inline bool operator==(const QPointF &, const QPointF &);
    friend inline bool operator!=(const QPointF &, const QPointF &);
    friend inline const QPointF operator+(const QPointF &, const QPointF &);
    friend inline const QPointF operator-(const QPointF &, const QPointF &);
    friend inline const QPointF operator*(qreal, const QPointF &);
    friend inline const QPointF operator*(const QPointF &, qreal);
    friend inline const QPointF operator+(const QPointF &);
    friend inline const QPointF operator-(const QPointF &);
    friend inline const QPointF operator/(const QPointF &, qreal);

                     QPoint toPoint() const;

private:
    friend class QMatrix;
    friend class QTransform;

    qreal xp;
    qreal yp;
};

template<> class QTypeInfo<QPointF > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPointF)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QPointF >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QPointF) }; static inline const char *name() { return "QPointF"; } };





__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPointF &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPointF &);






                 inline QPointF::QPointF() : xp(0), yp(0) { }

                 inline QPointF::QPointF(qreal xpos, qreal ypos) : xp(xpos), yp(ypos) { }

                 inline QPointF::QPointF(const QPoint &p) : xp(p.x()), yp(p.y()) { }

                 inline qreal QPointF::manhattanLength() const
{
    return qAbs(x())+qAbs(y());
}

inline bool QPointF::isNull() const
{
    return qIsNull(xp) && qIsNull(yp);
}

                 inline qreal QPointF::x() const
{
    return xp;
}

                 inline qreal QPointF::y() const
{
    return yp;
}

inline void QPointF::setX(qreal xpos)
{
    xp = xpos;
}

inline void QPointF::setY(qreal ypos)
{
    yp = ypos;
}

inline qreal &QPointF::rx()
{
    return xp;
}

inline qreal &QPointF::ry()
{
    return yp;
}

inline QPointF &QPointF::operator+=(const QPointF &p)
{
    xp+=p.xp;
    yp+=p.yp;
    return *this;
}

inline QPointF &QPointF::operator-=(const QPointF &p)
{
    xp-=p.xp; yp-=p.yp; return *this;
}

inline QPointF &QPointF::operator*=(qreal c)
{
    xp*=c; yp*=c; return *this;
}

                 inline bool operator==(const QPointF &p1, const QPointF &p2)
{
    return qFuzzyIsNull(p1.xp - p2.xp) && qFuzzyIsNull(p1.yp - p2.yp);
}

                 inline bool operator!=(const QPointF &p1, const QPointF &p2)
{
    return !qFuzzyIsNull(p1.xp - p2.xp) || !qFuzzyIsNull(p1.yp - p2.yp);
}

                 inline const QPointF operator+(const QPointF &p1, const QPointF &p2)
{
    return QPointF(p1.xp+p2.xp, p1.yp+p2.yp);
}

                 inline const QPointF operator-(const QPointF &p1, const QPointF &p2)
{
    return QPointF(p1.xp-p2.xp, p1.yp-p2.yp);
}

                 inline const QPointF operator*(const QPointF &p, qreal c)
{
    return QPointF(p.xp*c, p.yp*c);
}

                 inline const QPointF operator*(qreal c, const QPointF &p)
{
    return QPointF(p.xp*c, p.yp*c);
}

                 inline const QPointF operator+(const QPointF &p)
{
    return p;
}

                 inline const QPointF operator-(const QPointF &p)
{
    return QPointF(-p.xp, -p.yp);
}

inline QPointF &QPointF::operator/=(qreal divisor)
{
    xp/=divisor;
    yp/=divisor;
    return *this;
}

                 inline const QPointF operator/(const QPointF &p, qreal divisor)
{
    return QPointF(p.xp/divisor, p.yp/divisor);
}

                 inline QPoint QPointF::toPoint() const
{
    return QPoint(qRound(xp), qRound(yp));
}


__declspec(dllimport) QDebug operator<<(QDebug d, const QPointF &p);
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qrect.h"








class __declspec(dllimport) QRect
{
public:
                     QRect() : x1(0), y1(0), x2(-1), y2(-1) {}
                     QRect(const QPoint &topleft, const QPoint &bottomright);
                     QRect(const QPoint &topleft, const QSize &size);
                     QRect(int left, int top, int width, int height);

                     inline bool isNull() const;
                     inline bool isEmpty() const;
                     inline bool isValid() const;

                     inline int left() const;
                     inline int top() const;
                     inline int right() const;
                     inline int bottom() const;
    QRect normalized() const;

                     inline int x() const;
                     inline int y() const;
    inline void setLeft(int pos);
    inline void setTop(int pos);
    inline void setRight(int pos);
    inline void setBottom(int pos);
    inline void setX(int x);
    inline void setY(int y);

    inline void setTopLeft(const QPoint &p);
    inline void setBottomRight(const QPoint &p);
    inline void setTopRight(const QPoint &p);
    inline void setBottomLeft(const QPoint &p);

                     inline QPoint topLeft() const;
                     inline QPoint bottomRight() const;
                     inline QPoint topRight() const;
                     inline QPoint bottomLeft() const;
                     inline QPoint center() const;

    inline void moveLeft(int pos);
    inline void moveTop(int pos);
    inline void moveRight(int pos);
    inline void moveBottom(int pos);
    inline void moveTopLeft(const QPoint &p);
    inline void moveBottomRight(const QPoint &p);
    inline void moveTopRight(const QPoint &p);
    inline void moveBottomLeft(const QPoint &p);
    inline void moveCenter(const QPoint &p);

    inline void translate(int dx, int dy);
    inline void translate(const QPoint &p);
                     inline QRect translated(int dx, int dy) const;
                     inline QRect translated(const QPoint &p) const;

    inline void moveTo(int x, int t);
    inline void moveTo(const QPoint &p);

    inline void setRect(int x, int y, int w, int h);
    inline void getRect(int *x, int *y, int *w, int *h) const;

    inline void setCoords(int x1, int y1, int x2, int y2);
    inline void getCoords(int *x1, int *y1, int *x2, int *y2) const;

    inline void adjust(int x1, int y1, int x2, int y2);
                     inline QRect adjusted(int x1, int y1, int x2, int y2) const;

                     inline QSize size() const;
                     inline int width() const;
                     inline int height() const;
    inline void setWidth(int w);
    inline void setHeight(int h);
    inline void setSize(const QSize &s);

    QRect operator|(const QRect &r) const;
    QRect operator&(const QRect &r) const;
    inline QRect& operator|=(const QRect &r);
    inline QRect& operator&=(const QRect &r);

    bool contains(const QRect &r, bool proper = false) const;
    bool contains(const QPoint &p, bool proper=false) const;
    inline bool contains(int x, int y) const;
    inline bool contains(int x, int y, bool proper) const;
    inline QRect united(const QRect &other) const;
    inline QRect intersected(const QRect &other) const;
    bool intersects(const QRect &r) const;

                     inline QRect marginsAdded(const QMargins &margins) const;
                     inline QRect marginsRemoved(const QMargins &margins) const;
    inline QRect &operator+=(const QMargins &margins);
    inline QRect &operator-=(const QMargins &margins);






    friend inline bool operator==(const QRect &, const QRect &);
    friend inline bool operator!=(const QRect &, const QRect &);

private:
    int x1;
    int y1;
    int x2;
    int y2;
};
template<> class QTypeInfo<QRect > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRect)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QRect >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QRect) }; static inline const char *name() { return "QRect"; } };

                 inline bool operator==(const QRect &, const QRect &);
                 inline bool operator!=(const QRect &, const QRect &);






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QRect &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QRect &);






                 inline QRect::QRect(int aleft, int atop, int awidth, int aheight)
    : x1(aleft), y1(atop), x2(aleft + awidth - 1), y2(atop + aheight - 1) {}

                 inline QRect::QRect(const QPoint &atopLeft, const QPoint &abottomRight)
    : x1(atopLeft.x()), y1(atopLeft.y()), x2(abottomRight.x()), y2(abottomRight.y()) {}

                 inline QRect::QRect(const QPoint &atopLeft, const QSize &asize)
    : x1(atopLeft.x()), y1(atopLeft.y()), x2(atopLeft.x()+asize.width() - 1), y2(atopLeft.y()+asize.height() - 1) {}

                 inline bool QRect::isNull() const
{ return x2 == x1 - 1 && y2 == y1 - 1; }

                 inline bool QRect::isEmpty() const
{ return x1 > x2 || y1 > y2; }

                 inline bool QRect::isValid() const
{ return x1 <= x2 && y1 <= y2; }

                 inline int QRect::left() const
{ return x1; }

                 inline int QRect::top() const
{ return y1; }

                 inline int QRect::right() const
{ return x2; }

                 inline int QRect::bottom() const
{ return y2; }

                 inline int QRect::x() const
{ return x1; }

                 inline int QRect::y() const
{ return y1; }

inline void QRect::setLeft(int pos)
{ x1 = pos; }

inline void QRect::setTop(int pos)
{ y1 = pos; }

inline void QRect::setRight(int pos)
{ x2 = pos; }

inline void QRect::setBottom(int pos)
{ y2 = pos; }

inline void QRect::setTopLeft(const QPoint &p)
{ x1 = p.x(); y1 = p.y(); }

inline void QRect::setBottomRight(const QPoint &p)
{ x2 = p.x(); y2 = p.y(); }

inline void QRect::setTopRight(const QPoint &p)
{ x2 = p.x(); y1 = p.y(); }

inline void QRect::setBottomLeft(const QPoint &p)
{ x1 = p.x(); y2 = p.y(); }

inline void QRect::setX(int ax)
{ x1 = ax; }

inline void QRect::setY(int ay)
{ y1 = ay; }

                 inline QPoint QRect::topLeft() const
{ return QPoint(x1, y1); }

                 inline QPoint QRect::bottomRight() const
{ return QPoint(x2, y2); }

                 inline QPoint QRect::topRight() const
{ return QPoint(x2, y1); }

                 inline QPoint QRect::bottomLeft() const
{ return QPoint(x1, y2); }

                 inline QPoint QRect::center() const
{ return QPoint((x1+x2)/2, (y1+y2)/2); }

                 inline int QRect::width() const
{ return x2 - x1 + 1; }

                 inline int QRect::height() const
{ return y2 - y1 + 1; }

                 inline QSize QRect::size() const
{ return QSize(width(), height()); }

inline void QRect::translate(int dx, int dy)
{
    x1 += dx;
    y1 += dy;
    x2 += dx;
    y2 += dy;
}

inline void QRect::translate(const QPoint &p)
{
    x1 += p.x();
    y1 += p.y();
    x2 += p.x();
    y2 += p.y();
}

                 inline QRect QRect::translated(int dx, int dy) const
{ return QRect(QPoint(x1 + dx, y1 + dy), QPoint(x2 + dx, y2 + dy)); }

                 inline QRect QRect::translated(const QPoint &p) const
{ return QRect(QPoint(x1 + p.x(), y1 + p.y()), QPoint(x2 + p.x(), y2 + p.y())); }

inline void QRect::moveTo(int ax, int ay)
{
    x2 += ax - x1;
    y2 += ay - y1;
    x1 = ax;
    y1 = ay;
}

inline void QRect::moveTo(const QPoint &p)
{
    x2 += p.x() - x1;
    y2 += p.y() - y1;
    x1 = p.x();
    y1 = p.y();
}

inline void QRect::moveLeft(int pos)
{ x2 += (pos - x1); x1 = pos; }

inline void QRect::moveTop(int pos)
{ y2 += (pos - y1); y1 = pos; }

inline void QRect::moveRight(int pos)
{
    x1 += (pos - x2);
    x2 = pos;
}

inline void QRect::moveBottom(int pos)
{
    y1 += (pos - y2);
    y2 = pos;
}

inline void QRect::moveTopLeft(const QPoint &p)
{
    moveLeft(p.x());
    moveTop(p.y());
}

inline void QRect::moveBottomRight(const QPoint &p)
{
    moveRight(p.x());
    moveBottom(p.y());
}

inline void QRect::moveTopRight(const QPoint &p)
{
    moveRight(p.x());
    moveTop(p.y());
}

inline void QRect::moveBottomLeft(const QPoint &p)
{
    moveLeft(p.x());
    moveBottom(p.y());
}

inline void QRect::moveCenter(const QPoint &p)
{
    int w = x2 - x1;
    int h = y2 - y1;
    x1 = p.x() - w/2;
    y1 = p.y() - h/2;
    x2 = x1 + w;
    y2 = y1 + h;
}

inline void QRect::getRect(int *ax, int *ay, int *aw, int *ah) const
{
    *ax = x1;
    *ay = y1;
    *aw = x2 - x1 + 1;
    *ah = y2 - y1 + 1;
}

inline void QRect::setRect(int ax, int ay, int aw, int ah)
{
    x1 = ax;
    y1 = ay;
    x2 = (ax + aw - 1);
    y2 = (ay + ah - 1);
}

inline void QRect::getCoords(int *xp1, int *yp1, int *xp2, int *yp2) const
{
    *xp1 = x1;
    *yp1 = y1;
    *xp2 = x2;
    *yp2 = y2;
}

inline void QRect::setCoords(int xp1, int yp1, int xp2, int yp2)
{
    x1 = xp1;
    y1 = yp1;
    x2 = xp2;
    y2 = yp2;
}

                 inline QRect QRect::adjusted(int xp1, int yp1, int xp2, int yp2) const
{ return QRect(QPoint(x1 + xp1, y1 + yp1), QPoint(x2 + xp2, y2 + yp2)); }

inline void QRect::adjust(int dx1, int dy1, int dx2, int dy2)
{
    x1 += dx1;
    y1 += dy1;
    x2 += dx2;
    y2 += dy2;
}

inline void QRect::setWidth(int w)
{ x2 = (x1 + w - 1); }

inline void QRect::setHeight(int h)
{ y2 = (y1 + h - 1); }

inline void QRect::setSize(const QSize &s)
{
    x2 = (s.width() + x1 - 1);
    y2 = (s.height() + y1 - 1);
}

inline bool QRect::contains(int ax, int ay, bool aproper) const
{
    return contains(QPoint(ax, ay), aproper);
}

inline bool QRect::contains(int ax, int ay) const
{
    return contains(QPoint(ax, ay), false);
}

inline QRect& QRect::operator|=(const QRect &r)
{
    *this = *this | r;
    return *this;
}

inline QRect& QRect::operator&=(const QRect &r)
{
    *this = *this & r;
    return *this;
}

inline QRect QRect::intersected(const QRect &other) const
{
    return *this & other;
}

inline QRect QRect::united(const QRect &r) const
{
    return *this | r;
}

                 inline bool operator==(const QRect &r1, const QRect &r2)
{
    return r1.x1==r2.x1 && r1.x2==r2.x2 && r1.y1==r2.y1 && r1.y2==r2.y2;
}

                 inline bool operator!=(const QRect &r1, const QRect &r2)
{
    return r1.x1!=r2.x1 || r1.x2!=r2.x2 || r1.y1!=r2.y1 || r1.y2!=r2.y2;
}

                 inline QRect operator+(const QRect &rectangle, const QMargins &margins)
{
    return QRect(QPoint(rectangle.left() - margins.left(), rectangle.top() - margins.top()),
                 QPoint(rectangle.right() + margins.right(), rectangle.bottom() + margins.bottom()));
}

                 inline QRect operator+(const QMargins &margins, const QRect &rectangle)
{
    return QRect(QPoint(rectangle.left() - margins.left(), rectangle.top() - margins.top()),
                 QPoint(rectangle.right() + margins.right(), rectangle.bottom() + margins.bottom()));
}

                 inline QRect operator-(const QRect &lhs, const QMargins &rhs)
{
    return QRect(QPoint(lhs.left() + rhs.left(), lhs.top() + rhs.top()),
                 QPoint(lhs.right() - rhs.right(), lhs.bottom() - rhs.bottom()));
}

                 inline QRect QRect::marginsAdded(const QMargins &margins) const
{
    return QRect(QPoint(x1 - margins.left(), y1 - margins.top()),
                 QPoint(x2 + margins.right(), y2 + margins.bottom()));
}

                 inline QRect QRect::marginsRemoved(const QMargins &margins) const
{
    return QRect(QPoint(x1 + margins.left(), y1 + margins.top()),
                 QPoint(x2 - margins.right(), y2 - margins.bottom()));
}

inline QRect &QRect::operator+=(const QMargins &margins)
{
    *this = marginsAdded(margins);
    return *this;
}

inline QRect &QRect::operator-=(const QMargins &margins)
{
    *this = marginsRemoved(margins);
    return *this;
}


__declspec(dllimport) QDebug operator<<(QDebug, const QRect &);



class __declspec(dllimport) QRectF
{
public:
                     QRectF() : xp(0.), yp(0.), w(0.), h(0.) {}
                     QRectF(const QPointF &topleft, const QSizeF &size);
                     QRectF(const QPointF &topleft, const QPointF &bottomRight);
                     QRectF(qreal left, qreal top, qreal width, qreal height);
                     QRectF(const QRect &rect);

                     inline bool isNull() const;
                     inline bool isEmpty() const;
                     inline bool isValid() const;
    QRectF normalized() const;

                     inline qreal left() const { return xp; }
                     inline qreal top() const { return yp; }
                     inline qreal right() const { return xp + w; }
                     inline qreal bottom() const { return yp + h; }

                     inline qreal x() const;
                     inline qreal y() const;
    inline void setLeft(qreal pos);
    inline void setTop(qreal pos);
    inline void setRight(qreal pos);
    inline void setBottom(qreal pos);
    inline void setX(qreal pos) { setLeft(pos); }
    inline void setY(qreal pos) { setTop(pos); }

                     inline QPointF topLeft() const { return QPointF(xp, yp); }
                     inline QPointF bottomRight() const { return QPointF(xp+w, yp+h); }
                     inline QPointF topRight() const { return QPointF(xp+w, yp); }
                     inline QPointF bottomLeft() const { return QPointF(xp, yp+h); }
                     inline QPointF center() const;

    inline void setTopLeft(const QPointF &p);
    inline void setBottomRight(const QPointF &p);
    inline void setTopRight(const QPointF &p);
    inline void setBottomLeft(const QPointF &p);

    inline void moveLeft(qreal pos);
    inline void moveTop(qreal pos);
    inline void moveRight(qreal pos);
    inline void moveBottom(qreal pos);
    inline void moveTopLeft(const QPointF &p);
    inline void moveBottomRight(const QPointF &p);
    inline void moveTopRight(const QPointF &p);
    inline void moveBottomLeft(const QPointF &p);
    inline void moveCenter(const QPointF &p);

    inline void translate(qreal dx, qreal dy);
    inline void translate(const QPointF &p);

                     inline QRectF translated(qreal dx, qreal dy) const;
                     inline QRectF translated(const QPointF &p) const;

    inline void moveTo(qreal x, qreal y);
    inline void moveTo(const QPointF &p);

    inline void setRect(qreal x, qreal y, qreal w, qreal h);
    inline void getRect(qreal *x, qreal *y, qreal *w, qreal *h) const;

    inline void setCoords(qreal x1, qreal y1, qreal x2, qreal y2);
    inline void getCoords(qreal *x1, qreal *y1, qreal *x2, qreal *y2) const;

    inline void adjust(qreal x1, qreal y1, qreal x2, qreal y2);
                     inline QRectF adjusted(qreal x1, qreal y1, qreal x2, qreal y2) const;

                     inline QSizeF size() const;
                     inline qreal width() const;
                     inline qreal height() const;
    inline void setWidth(qreal w);
    inline void setHeight(qreal h);
    inline void setSize(const QSizeF &s);

    QRectF operator|(const QRectF &r) const;
    QRectF operator&(const QRectF &r) const;
    inline QRectF& operator|=(const QRectF &r);
    inline QRectF& operator&=(const QRectF &r);

    bool contains(const QRectF &r) const;
    bool contains(const QPointF &p) const;
    inline bool contains(qreal x, qreal y) const;
    inline QRectF united(const QRectF &other) const;
    inline QRectF intersected(const QRectF &other) const;
    bool intersects(const QRectF &r) const;

                     inline QRectF marginsAdded(const QMarginsF &margins) const;
                     inline QRectF marginsRemoved(const QMarginsF &margins) const;
    inline QRectF &operator+=(const QMarginsF &margins);
    inline QRectF &operator-=(const QMarginsF &margins);






    friend inline bool operator==(const QRectF &, const QRectF &);
    friend inline bool operator!=(const QRectF &, const QRectF &);

                     inline QRect toRect() const;
    QRect toAlignedRect() const;

private:
    qreal xp;
    qreal yp;
    qreal w;
    qreal h;
};
template<> class QTypeInfo<QRectF > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRectF)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QRectF >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QRectF) }; static inline const char *name() { return "QRectF"; } };

                 inline bool operator==(const QRectF &, const QRectF &);
                 inline bool operator!=(const QRectF &, const QRectF &);






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QRectF &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QRectF &);






                 inline QRectF::QRectF(qreal aleft, qreal atop, qreal awidth, qreal aheight)
    : xp(aleft), yp(atop), w(awidth), h(aheight)
{
}

                 inline QRectF::QRectF(const QPointF &atopLeft, const QSizeF &asize)
    : xp(atopLeft.x()), yp(atopLeft.y()), w(asize.width()), h(asize.height())
{
}


                 inline QRectF::QRectF(const QPointF &atopLeft, const QPointF &abottomRight)
    : xp(atopLeft.x()), yp(atopLeft.y()), w(abottomRight.x() - atopLeft.x()), h(abottomRight.y() - atopLeft.y())
{
}

                 inline QRectF::QRectF(const QRect &r)
    : xp(r.x()), yp(r.y()), w(r.width()), h(r.height())
{
}

                 inline bool QRectF::isNull() const
{ return w == 0. && h == 0.; }

                 inline bool QRectF::isEmpty() const
{ return w <= 0. || h <= 0.; }

                 inline bool QRectF::isValid() const
{ return w > 0. && h > 0.; }

                 inline qreal QRectF::x() const
{ return xp; }

                 inline qreal QRectF::y() const
{ return yp; }

inline void QRectF::setLeft(qreal pos) { qreal diff = pos - xp; xp += diff; w -= diff; }

inline void QRectF::setRight(qreal pos) { w = pos - xp; }

inline void QRectF::setTop(qreal pos) { qreal diff = pos - yp; yp += diff; h -= diff; }

inline void QRectF::setBottom(qreal pos) { h = pos - yp; }

inline void QRectF::setTopLeft(const QPointF &p) { setLeft(p.x()); setTop(p.y()); }

inline void QRectF::setTopRight(const QPointF &p) { setRight(p.x()); setTop(p.y()); }

inline void QRectF::setBottomLeft(const QPointF &p) { setLeft(p.x()); setBottom(p.y()); }

inline void QRectF::setBottomRight(const QPointF &p) { setRight(p.x()); setBottom(p.y()); }

                 inline QPointF QRectF::center() const
{ return QPointF(xp + w/2, yp + h/2); }

inline void QRectF::moveLeft(qreal pos) { xp = pos; }

inline void QRectF::moveTop(qreal pos) { yp = pos; }

inline void QRectF::moveRight(qreal pos) { xp = pos - w; }

inline void QRectF::moveBottom(qreal pos) { yp = pos - h; }

inline void QRectF::moveTopLeft(const QPointF &p) { moveLeft(p.x()); moveTop(p.y()); }

inline void QRectF::moveTopRight(const QPointF &p) { moveRight(p.x()); moveTop(p.y()); }

inline void QRectF::moveBottomLeft(const QPointF &p) { moveLeft(p.x()); moveBottom(p.y()); }

inline void QRectF::moveBottomRight(const QPointF &p) { moveRight(p.x()); moveBottom(p.y()); }

inline void QRectF::moveCenter(const QPointF &p) { xp = p.x() - w/2; yp = p.y() - h/2; }

                 inline qreal QRectF::width() const
{ return w; }

                 inline qreal QRectF::height() const
{ return h; }

                 inline QSizeF QRectF::size() const
{ return QSizeF(w, h); }

inline void QRectF::translate(qreal dx, qreal dy)
{
    xp += dx;
    yp += dy;
}

inline void QRectF::translate(const QPointF &p)
{
    xp += p.x();
    yp += p.y();
}

inline void QRectF::moveTo(qreal ax, qreal ay)
{
    xp = ax;
    yp = ay;
}

inline void QRectF::moveTo(const QPointF &p)
{
    xp = p.x();
    yp = p.y();
}

                 inline QRectF QRectF::translated(qreal dx, qreal dy) const
{ return QRectF(xp + dx, yp + dy, w, h); }

                 inline QRectF QRectF::translated(const QPointF &p) const
{ return QRectF(xp + p.x(), yp + p.y(), w, h); }

inline void QRectF::getRect(qreal *ax, qreal *ay, qreal *aaw, qreal *aah) const
{
    *ax = this->xp;
    *ay = this->yp;
    *aaw = this->w;
    *aah = this->h;
}

inline void QRectF::setRect(qreal ax, qreal ay, qreal aaw, qreal aah)
{
    this->xp = ax;
    this->yp = ay;
    this->w = aaw;
    this->h = aah;
}

inline void QRectF::getCoords(qreal *xp1, qreal *yp1, qreal *xp2, qreal *yp2) const
{
    *xp1 = xp;
    *yp1 = yp;
    *xp2 = xp + w;
    *yp2 = yp + h;
}

inline void QRectF::setCoords(qreal xp1, qreal yp1, qreal xp2, qreal yp2)
{
    xp = xp1;
    yp = yp1;
    w = xp2 - xp1;
    h = yp2 - yp1;
}

inline void QRectF::adjust(qreal xp1, qreal yp1, qreal xp2, qreal yp2)
{ xp += xp1; yp += yp1; w += xp2 - xp1; h += yp2 - yp1; }

                 inline QRectF QRectF::adjusted(qreal xp1, qreal yp1, qreal xp2, qreal yp2) const
{ return QRectF(xp + xp1, yp + yp1, w + xp2 - xp1, h + yp2 - yp1); }

inline void QRectF::setWidth(qreal aw)
{ this->w = aw; }

inline void QRectF::setHeight(qreal ah)
{ this->h = ah; }

inline void QRectF::setSize(const QSizeF &s)
{
    w = s.width();
    h = s.height();
}

inline bool QRectF::contains(qreal ax, qreal ay) const
{
    return contains(QPointF(ax, ay));
}

inline QRectF& QRectF::operator|=(const QRectF &r)
{
    *this = *this | r;
    return *this;
}

inline QRectF& QRectF::operator&=(const QRectF &r)
{
    *this = *this & r;
    return *this;
}

inline QRectF QRectF::intersected(const QRectF &r) const
{
    return *this & r;
}

inline QRectF QRectF::united(const QRectF &r) const
{
    return *this | r;
}

                 inline bool operator==(const QRectF &r1, const QRectF &r2)
{
    return qFuzzyCompare(r1.xp, r2.xp) && qFuzzyCompare(r1.yp, r2.yp)
           && qFuzzyCompare(r1.w, r2.w) && qFuzzyCompare(r1.h, r2.h);
}

                 inline bool operator!=(const QRectF &r1, const QRectF &r2)
{
    return !qFuzzyCompare(r1.xp, r2.xp) || !qFuzzyCompare(r1.yp, r2.yp)
           || !qFuzzyCompare(r1.w, r2.w) || !qFuzzyCompare(r1.h, r2.h);
}

                 inline QRect QRectF::toRect() const
{
    return QRect(qRound(xp), qRound(yp), qRound(w), qRound(h));
}

                 inline QRectF operator+(const QRectF &lhs, const QMarginsF &rhs)
{
    return QRectF(QPointF(lhs.left() - rhs.left(), lhs.top() - rhs.top()),
                  QSizeF(lhs.width() + rhs.left() + rhs.right(), lhs.height() + rhs.top() + rhs.bottom()));
}

                 inline QRectF operator+(const QMarginsF &lhs, const QRectF &rhs)
{
    return QRectF(QPointF(rhs.left() - lhs.left(), rhs.top() - lhs.top()),
                  QSizeF(rhs.width() + lhs.left() + lhs.right(), rhs.height() + lhs.top() + lhs.bottom()));
}

                 inline QRectF operator-(const QRectF &lhs, const QMarginsF &rhs)
{
    return QRectF(QPointF(lhs.left() + rhs.left(), lhs.top() + rhs.top()),
                  QSizeF(lhs.width() - rhs.left() - rhs.right(), lhs.height() - rhs.top() - rhs.bottom()));
}

                 inline QRectF QRectF::marginsAdded(const QMarginsF &margins) const
{
    return QRectF(QPointF(xp - margins.left(), yp - margins.top()),
                  QSizeF(w + margins.left() + margins.right(), h + margins.top() + margins.bottom()));
}

                 inline QRectF QRectF::marginsRemoved(const QMarginsF &margins) const
{
    return QRectF(QPointF(xp + margins.left(), yp + margins.top()),
                  QSizeF(w - margins.left() - margins.right(), h - margins.top() - margins.bottom()));
}

inline QRectF &QRectF::operator+=(const QMarginsF &margins)
{
    *this = marginsAdded(margins);
    return *this;
}

inline QRectF &QRectF::operator-=(const QMarginsF &margins)
{
    *this = marginsRemoved(margins);
    return *this;
}


__declspec(dllimport) QDebug operator<<(QDebug, const QRectF &);
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpaintdevice.h"






class QPaintEngine;
class QPaintDevicePrivate;

class __declspec(dllimport) QPaintDevice
{
public:
    enum PaintDeviceMetric {
        PdmWidth = 1,
        PdmHeight,
        PdmWidthMM,
        PdmHeightMM,
        PdmNumColors,
        PdmDepth,
        PdmDpiX,
        PdmDpiY,
        PdmPhysicalDpiX,
        PdmPhysicalDpiY,
        PdmDevicePixelRatio
    };

    virtual ~QPaintDevice();

    virtual int devType() const;
    bool paintingActive() const;
    virtual QPaintEngine *paintEngine() const = 0;

    int width() const { return metric(PdmWidth); }
    int height() const { return metric(PdmHeight); }
    int widthMM() const { return metric(PdmWidthMM); }
    int heightMM() const { return metric(PdmHeightMM); }
    int logicalDpiX() const { return metric(PdmDpiX); }
    int logicalDpiY() const { return metric(PdmDpiY); }
    int physicalDpiX() const { return metric(PdmPhysicalDpiX); }
    int physicalDpiY() const { return metric(PdmPhysicalDpiY); }
    int devicePixelRatio() const { return metric(PdmDevicePixelRatio); }
    int colorCount() const { return metric(PdmNumColors); }
    int depth() const { return metric(PdmDepth); }

protected:
    QPaintDevice();
    virtual int metric(PaintDeviceMetric metric) const;
    virtual void initPainter(QPainter *painter) const;
    virtual QPaintDevice *redirected(QPoint *offset) const;
    virtual QPainter *sharedPainter() const;

    ushort painters;

private:
    QPaintDevice(const QPaintDevice &) = delete; QPaintDevice &operator=(const QPaintDevice &) = delete;

    QPaintDevicePrivate *reserved;

    friend class QPainter;
    friend class QPainterPrivate;
    friend class QFontEngineMac;
    friend class QX11PaintEngine;
    friend __declspec(dllimport) int qt_paint_device_metric(const QPaintDevice *device, PaintDeviceMetric metric);
};





inline int QPaintDevice::devType() const
{ return QInternal::UnknownDevice; }

inline bool QPaintDevice::paintingActive() const
{ return painters != 0; }
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpalette.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpalette.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qcolor.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qcolor.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qrgb.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qrgb.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qprocessordetection.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qrgb.h"





typedef unsigned int QRgb;


const QRgb RGB_MASK = 0x00ffffff;

inline int qRed(QRgb rgb)
{ return ((rgb >> 16) & 0xff); }

inline int qGreen(QRgb rgb)
{ return ((rgb >> 8) & 0xff); }

inline int qBlue(QRgb rgb)
{ return (rgb & 0xff); }

inline int qAlpha(QRgb rgb)
{ return rgb >> 24; }

inline QRgb qRgb(int r, int g, int b)
{ return (0xffu << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

inline QRgb qRgba(int r, int g, int b, int a)
{ return ((a & 0xff) << 24) | ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff); }

inline int qGray(int r, int g, int b)
{ return (r*11+g*16+b*5)/32; }

inline int qGray(QRgb rgb)
{ return qGray(qRed(rgb), qGreen(rgb), qBlue(rgb)); }

inline bool qIsGray(QRgb rgb)
{ return qRed(rgb) == qGreen(rgb) && qRed(rgb) == qBlue(rgb); }
#line 94 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qrgb.h"
inline QRgb qPremultiply(QRgb x)
{
    const uint a = qAlpha(x);
    uint t = (x & 0xff00ff) * a;
    t = (t + ((t >> 8) & 0xff00ff) + 0x800080) >> 8;
    t &= 0xff00ff;

    x = ((x >> 8) & 0xff) * a;
    x = (x + ((x >> 8) & 0xff) + 0x80);
    x &= 0xff00;
    x |= t | (a << 24);
    return x;
}


__declspec(dllimport) extern const uint qt_inv_premul_factor[];

inline QRgb qUnpremultiply(QRgb p)
{
    const uint alpha = qAlpha(p);

    if (alpha == 255)
        return p;
    if (alpha == 0)
        return 0;

    const uint invAlpha = qt_inv_premul_factor[alpha];

    return qRgba((qRed(p)*invAlpha + 0x8000)>>16, (qGreen(p)*invAlpha + 0x8000)>>16, (qBlue(p)*invAlpha + 0x8000)>>16, alpha);
}
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qcolor.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstringlist.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstringlist.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qdatastream.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qdatastream.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qiodevice.h"
#line 61 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qiodevice.h"
class QByteArray;
class QIODevicePrivate;

class __declspec(dllimport) QIODevice

    : public QObject

{

    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

public:
    enum OpenModeFlag {
        NotOpen = 0x0000,
        ReadOnly = 0x0001,
        WriteOnly = 0x0002,
        ReadWrite = ReadOnly | WriteOnly,
        Append = 0x0004,
        Truncate = 0x0008,
        Text = 0x0010,
        Unbuffered = 0x0020
    };
    typedef QFlags<OpenModeFlag> OpenMode;

    QIODevice();

    explicit QIODevice(QObject *parent);

    virtual ~QIODevice();

    OpenMode openMode() const;

    void setTextModeEnabled(bool enabled);
    bool isTextModeEnabled() const;

    bool isOpen() const;
    bool isReadable() const;
    bool isWritable() const;
    virtual bool isSequential() const;

    virtual bool open(OpenMode mode);
    virtual void close();



    virtual qint64 pos() const;
    virtual qint64 size() const;
    virtual bool seek(qint64 pos);
    virtual bool atEnd() const;
    virtual bool reset();

    virtual qint64 bytesAvailable() const;
    virtual qint64 bytesToWrite() const;

    qint64 read(char *data, qint64 maxlen);
    QByteArray read(qint64 maxlen);
    QByteArray readAll();
    qint64 readLine(char *data, qint64 maxlen);
    QByteArray readLine(qint64 maxlen = 0);
    virtual bool canReadLine() const;

    qint64 write(const char *data, qint64 len);
    qint64 write(const char *data);
    inline qint64 write(const QByteArray &data)
    { return write(data.constData(), data.size()); }

    qint64 peek(char *data, qint64 maxlen);
    QByteArray peek(qint64 maxlen);

    virtual bool waitForReadyRead(int msecs);
    virtual bool waitForBytesWritten(int msecs);

    void ungetChar(char c);
    bool putChar(char c);
    bool getChar(char *c);

    QString errorString() const;


public:
    void readyRead();
    void bytesWritten(qint64 bytes);
    void aboutToClose();
    void readChannelFinished();


protected:



    QIODevice(QIODevicePrivate &dd, QObject *parent = 0);

    virtual qint64 readData(char *data, qint64 maxlen) = 0;
    virtual qint64 readLineData(char *data, qint64 maxlen);
    virtual qint64 writeData(const char *data, qint64 len) = 0;

    void setOpenMode(OpenMode openMode);

    void setErrorString(const QString &errorString);





private:
    inline QIODevicePrivate* d_func() { return reinterpret_cast<QIODevicePrivate *>(qGetPtrHelper(d_ptr)); } inline const QIODevicePrivate* d_func() const { return reinterpret_cast<const QIODevicePrivate *>(qGetPtrHelper(d_ptr)); } friend class QIODevicePrivate;
    QIODevice(const QIODevice &) = delete; QIODevice &operator=(const QIODevice &) = delete;
};

 inline QFlags<QIODevice::OpenMode::enum_type> operator|(QIODevice::OpenMode::enum_type f1, QIODevice::OpenMode::enum_type f2) { return QFlags<QIODevice::OpenMode::enum_type>(f1) | f2; } inline QFlags<QIODevice::OpenMode::enum_type> operator|(QIODevice::OpenMode::enum_type f1, QFlags<QIODevice::OpenMode::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QIODevice::OpenMode::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


class QDebug;
__declspec(dllimport) QDebug operator<<(QDebug debug, QIODevice::OpenMode modes);
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qdatastream.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qpair.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qpair.h"
template <class T1, class T2>
struct QPair
{
    typedef T1 first_type;
    typedef T2 second_type;

    QPair() : first(), second() {}
    QPair(const T1 &t1, const T2 &t2) : first(t1), second(t2) {}


    template <typename TT1, typename TT2>
    QPair(const QPair<TT1, TT2> &p) : first(p.first), second(p.second) {}
    template <typename TT1, typename TT2>
    QPair &operator=(const QPair<TT1, TT2> &p)
    { first = p.first; second = p.second; return *this; }

    template <typename TT1, typename TT2>
    QPair(QPair<TT1, TT2> &&p) : first(std::move(p.first)), second(std::move(p.second)) {}
    template <typename TT1, typename TT2>
    QPair &operator=(QPair<TT1, TT2> &&p)
    { first = std::move(p.first); second = std::move(p.second); return *this; }


    T1 first;
    T2 second;
};



template<class T1, class T2>
class QTypeInfo<QPair<T1, T2> > : public QTypeInfoMerger<QPair<T1, T2>, T1, T2> {};

template <class T1, class T2>
inline bool operator==(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{ return p1.first == p2.first && p1.second == p2.second; }

template <class T1, class T2>
inline bool operator!=(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{ return !(p1 == p2); }

template <class T1, class T2>
inline bool operator<(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
    return p1.first < p2.first || (!(p2.first < p1.first) && p1.second < p2.second);
}

template <class T1, class T2>
inline bool operator>(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
    return p2 < p1;
}

template <class T1, class T2>
inline bool operator<=(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
    return !(p2 < p1);
}

template <class T1, class T2>
inline bool operator>=(const QPair<T1, T2> &p1, const QPair<T1, T2> &p2)
{
    return !(p1 < p2);
}

template <class T1, class T2>
inline QPair<T1, T2> qMakePair(const T1 &x, const T2 &y)
{
    return QPair<T1, T2>(x, y);
}
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qdatastream.h"
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qdatastream.h"
class QByteArray;
class QIODevice;

template <typename T> class QList;
template <typename T> class QLinkedList;
template <typename T> class QVector;
template <typename T> class QSet;
template <class Key, class T> class QHash;
template <class Key, class T> class QMap;


class QDataStreamPrivate;
class __declspec(dllimport) QDataStream
{
public:
    enum Version {
        Qt_1_0 = 1,
        Qt_2_0 = 2,
        Qt_2_1 = 3,
        Qt_3_0 = 4,
        Qt_3_1 = 5,
        Qt_3_3 = 6,
        Qt_4_0 = 7,
        Qt_4_1 = Qt_4_0,
        Qt_4_2 = 8,
        Qt_4_3 = 9,
        Qt_4_4 = 10,
        Qt_4_5 = 11,
        Qt_4_6 = 12,
        Qt_4_7 = Qt_4_6,
        Qt_4_8 = Qt_4_7,
        Qt_4_9 = Qt_4_8,
        Qt_5_0 = 13,
        Qt_5_1 = 14,
        Qt_5_2 = 15,
        Qt_5_3 = Qt_5_2



    };

    enum ByteOrder {
        BigEndian = QSysInfo::BigEndian,
        LittleEndian = QSysInfo::LittleEndian
    };

    enum Status {
        Ok,
        ReadPastEnd,
        ReadCorruptData,
        WriteFailed
    };

    enum FloatingPointPrecision {
        SinglePrecision,
        DoublePrecision
    };

    QDataStream();
    explicit QDataStream(QIODevice *);
    QDataStream(QByteArray *, QIODevice::OpenMode flags);
    QDataStream(const QByteArray &);
    ~QDataStream();

    QIODevice *device() const;
    void setDevice(QIODevice *);
    void unsetDevice();

    bool atEnd() const;

    Status status() const;
    void setStatus(Status status);
    void resetStatus();

    FloatingPointPrecision floatingPointPrecision() const;
    void setFloatingPointPrecision(FloatingPointPrecision precision);

    ByteOrder byteOrder() const;
    void setByteOrder(ByteOrder);

    int version() const;
    void setVersion(int);

    QDataStream &operator>>(qint8 &i);
    QDataStream &operator>>(quint8 &i);
    QDataStream &operator>>(qint16 &i);
    QDataStream &operator>>(quint16 &i);
    QDataStream &operator>>(qint32 &i);
    QDataStream &operator>>(quint32 &i);
    QDataStream &operator>>(qint64 &i);
    QDataStream &operator>>(quint64 &i);

    QDataStream &operator>>(bool &i);
    QDataStream &operator>>(float &f);
    QDataStream &operator>>(double &f);
    QDataStream &operator>>(char *&str);

    QDataStream &operator<<(qint8 i);
    QDataStream &operator<<(quint8 i);
    QDataStream &operator<<(qint16 i);
    QDataStream &operator<<(quint16 i);
    QDataStream &operator<<(qint32 i);
    QDataStream &operator<<(quint32 i);
    QDataStream &operator<<(qint64 i);
    QDataStream &operator<<(quint64 i);
    QDataStream &operator<<(bool i);
    QDataStream &operator<<(float f);
    QDataStream &operator<<(double f);
    QDataStream &operator<<(const char *str);

    QDataStream &readBytes(char *&, uint &len);
    int readRawData(char *, int len);

    QDataStream &writeBytes(const char *, uint len);
    int writeRawData(const char *, int len);

    int skipRawData(int len);

private:
    QDataStream(const QDataStream &) = delete; QDataStream &operator=(const QDataStream &) = delete;

    QScopedPointer<QDataStreamPrivate> d;

    QIODevice *dev;
    bool owndev;
    bool noswap;
    ByteOrder byteorder;
    int ver;
    Status q_status;
};






inline QIODevice *QDataStream::device() const
{ return dev; }

inline QDataStream::ByteOrder QDataStream::byteOrder() const
{ return byteorder; }

inline int QDataStream::version() const
{ return ver; }

inline void QDataStream::setVersion(int v)
{ ver = v; }

inline QDataStream &QDataStream::operator>>(quint8 &i)
{ return *this >> reinterpret_cast<qint8&>(i); }

inline QDataStream &QDataStream::operator>>(quint16 &i)
{ return *this >> reinterpret_cast<qint16&>(i); }

inline QDataStream &QDataStream::operator>>(quint32 &i)
{ return *this >> reinterpret_cast<qint32&>(i); }

inline QDataStream &QDataStream::operator>>(quint64 &i)
{ return *this >> reinterpret_cast<qint64&>(i); }

inline QDataStream &QDataStream::operator<<(quint8 i)
{ return *this << qint8(i); }

inline QDataStream &QDataStream::operator<<(quint16 i)
{ return *this << qint16(i); }

inline QDataStream &QDataStream::operator<<(quint32 i)
{ return *this << qint32(i); }

inline QDataStream &QDataStream::operator<<(quint64 i)
{ return *this << qint64(i); }

template <typename T>
QDataStream& operator>>(QDataStream& s, QList<T>& l)
{
    l.clear();
    quint32 c;
    s >> c;
    l.reserve(c);
    for(quint32 i = 0; i < c; ++i)
    {
        T t;
        s >> t;
        l.append(t);
        if (s.atEnd())
            break;
    }
    return s;
}

template <typename T>
QDataStream& operator<<(QDataStream& s, const QList<T>& l)
{
    s << quint32(l.size());
    for (int i = 0; i < l.size(); ++i)
        s << l.at(i);
    return s;
}

template <typename T>
QDataStream& operator>>(QDataStream& s, QLinkedList<T>& l)
{
    l.clear();
    quint32 c;
    s >> c;
    for(quint32 i = 0; i < c; ++i)
    {
        T t;
        s >> t;
        l.append(t);
        if (s.atEnd())
            break;
    }
    return s;
}

template <typename T>
QDataStream& operator<<(QDataStream& s, const QLinkedList<T>& l)
{
    s << quint32(l.size());
    typename QLinkedList<T>::ConstIterator it = l.constBegin();
    for(; it != l.constEnd(); ++it)
        s << *it;
    return s;
}

template<typename T>
QDataStream& operator>>(QDataStream& s, QVector<T>& v)
{
    v.clear();
    quint32 c;
    s >> c;
    v.resize(c);
    for(quint32 i = 0; i < c; ++i) {
        T t;
        s >> t;
        v[i] = t;
    }
    return s;
}

template<typename T>
QDataStream& operator<<(QDataStream& s, const QVector<T>& v)
{
    s << quint32(v.size());
    for (typename QVector<T>::const_iterator it = v.begin(); it != v.end(); ++it)
        s << *it;
    return s;
}

template <typename T>
QDataStream &operator>>(QDataStream &in, QSet<T> &set)
{
    set.clear();
    quint32 c;
    in >> c;
    for (quint32 i = 0; i < c; ++i) {
        T t;
        in >> t;
        set << t;
        if (in.atEnd())
            break;
    }
    return in;
}

template <typename T>
QDataStream& operator<<(QDataStream &out, const QSet<T> &set)
{
    out << quint32(set.size());
    typename QSet<T>::const_iterator i = set.constBegin();
    while (i != set.constEnd()) {
        out << *i;
        ++i;
    }
    return out;
}

template <class Key, class T>
inline QDataStream &operator>>(QDataStream &in, QHash<Key, T> &hash)
{
    QDataStream::Status oldStatus = in.status();
    in.resetStatus();
    hash.clear();

    quint32 n;
    in >> n;

    for (quint32 i = 0; i < n; ++i) {
        if (in.status() != QDataStream::Ok)
            break;

        Key k;
        T t;
        in >> k >> t;
        hash.insertMulti(k, t);
    }

    if (in.status() != QDataStream::Ok)
        hash.clear();
    if (oldStatus != QDataStream::Ok)
        in.setStatus(oldStatus);
    return in;
}

template <class Key, class T>
inline QDataStream &operator<<(QDataStream &out, const QHash<Key, T>& hash)
{
    out << quint32(hash.size());
    typename QHash<Key, T>::ConstIterator it = hash.end();
    typename QHash<Key, T>::ConstIterator begin = hash.begin();
    while (it != begin) {
        --it;
        out << it.key() << it.value();
    }
    return out;
}




template <class aKey, class aT>
inline QDataStream &operator>>(QDataStream &in, QMap<aKey, aT> &map)

{
    QDataStream::Status oldStatus = in.status();
    in.resetStatus();
    map.clear();

    quint32 n;
    in >> n;

    map.detach();
    for (quint32 i = 0; i < n; ++i) {
        if (in.status() != QDataStream::Ok)
            break;

        aKey key;
        aT value;
        in >> key >> value;
        map.insertMulti(key, value);
    }
    if (in.status() != QDataStream::Ok)
        map.clear();
    if (oldStatus != QDataStream::Ok)
        in.setStatus(oldStatus);
    return in;
}

template <class Key, class T>
inline QDataStream &operator<<(QDataStream &out, const QMap<Key, T> &map)
{
    out << quint32(map.size());
    typename QMap<Key, T>::ConstIterator it = map.end();
    typename QMap<Key, T>::ConstIterator begin = map.begin();
    while (it != begin) {
        --it;
        out << it.key() << it.value();
    }
    return out;
}


template <class T1, class T2>
inline QDataStream& operator>>(QDataStream& s, QPair<T1, T2>& p)
{
    s >> p.first >> p.second;
    return s;
}

template <class T1, class T2>
inline QDataStream& operator<<(QDataStream& s, const QPair<T1, T2>& p)
{
    s << p.first << p.second;
    return s;
}
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstringlist.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qregexp.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qregexp.h"
struct QRegExpPrivate;
class QStringList;

class __declspec(dllimport) QRegExp
{
public:
    enum PatternSyntax {
        RegExp,
        Wildcard,
        FixedString,
        RegExp2,
        WildcardUnix,
        W3CXmlSchema11 };
    enum CaretMode { CaretAtZero, CaretAtOffset, CaretWontMatch };

    QRegExp();
    explicit QRegExp(const QString &pattern, Qt::CaseSensitivity cs = Qt::CaseSensitive,
                     PatternSyntax syntax = RegExp);
    QRegExp(const QRegExp &rx);
    ~QRegExp();
    QRegExp &operator=(const QRegExp &rx);

    inline QRegExp &operator=(QRegExp &&other)
    { qSwap(priv,other.priv); return *this; }

    inline void swap(QRegExp &other) { qSwap(priv, other.priv); }

    bool operator==(const QRegExp &rx) const;
    inline bool operator!=(const QRegExp &rx) const { return !operator==(rx); }

    bool isEmpty() const;
    bool isValid() const;
    QString pattern() const;
    void setPattern(const QString &pattern);
    Qt::CaseSensitivity caseSensitivity() const;
    void setCaseSensitivity(Qt::CaseSensitivity cs);
    PatternSyntax patternSyntax() const;
    void setPatternSyntax(PatternSyntax syntax);

    bool isMinimal() const;
    void setMinimal(bool minimal);

    bool exactMatch(const QString &str) const;

    int indexIn(const QString &str, int offset = 0, CaretMode caretMode = CaretAtZero) const;
    int lastIndexIn(const QString &str, int offset = -1, CaretMode caretMode = CaretAtZero) const;
    int matchedLength() const;

    int captureCount() const;
    QStringList capturedTexts() const;
    QStringList capturedTexts();
    QString cap(int nth = 0) const;
    QString cap(int nth = 0);
    int pos(int nth = 0) const;
    int pos(int nth = 0);
    QString errorString() const;
    QString errorString();


    static QString escape(const QString &str);

private:
    QRegExpPrivate *priv;
};

template<> class QTypeInfo<QRegExp > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRegExp)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QRegExp >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QRegExp) }; static inline const char *name() { return "QRegExp"; } };


__declspec(dllimport) QDataStream &operator<<(QDataStream &out, const QRegExp &regExp);
__declspec(dllimport) QDataStream &operator>>(QDataStream &in, QRegExp &regExp);



__declspec(dllimport) QDebug operator<<(QDebug, const QRegExp &);
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstringlist.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstringmatcher.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstringmatcher.h"
class QStringMatcherPrivate;

class __declspec(dllimport) QStringMatcher
{
public:
    QStringMatcher();
    explicit QStringMatcher(const QString &pattern,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QStringMatcher(const QChar *uc, int len,
                   Qt::CaseSensitivity cs = Qt::CaseSensitive);
    QStringMatcher(const QStringMatcher &other);
    ~QStringMatcher();

    QStringMatcher &operator=(const QStringMatcher &other);

    void setPattern(const QString &pattern);
    void setCaseSensitivity(Qt::CaseSensitivity cs);

    int indexIn(const QString &str, int from = 0) const;
    int indexIn(const QChar *str, int length, int from = 0) const;
    QString pattern() const;
    inline Qt::CaseSensitivity caseSensitivity() const { return q_cs; }

private:
    QStringMatcherPrivate *d_ptr;
    QString q_pattern;
    Qt::CaseSensitivity q_cs;





    struct Data {
        uchar q_skiptable[256];
        const QChar *uc;
        int len;
    };
    union {
        uint q_data[256];
        Data p;
    };



};
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qstringlist.h"





class QRegExp;
class QRegularExpression;

typedef QListIterator<QString> QStringListIterator;
typedef QMutableListIterator<QString> QMutableStringListIterator;

class QStringList : public QList<QString>
{
public:
    inline QStringList() { }
    inline explicit QStringList(const QString &i) { append(i); }
    inline QStringList(const QStringList &l) : QList<QString>(l) { }
    inline QStringList(const QList<QString> &l) : QList<QString>(l) { }




    inline void sort(Qt::CaseSensitivity cs = Qt::CaseSensitive);
    inline int removeDuplicates();

    inline QString join(const QString &sep) const;
    inline QString join(QChar sep) const;

    inline QStringList filter(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;
    inline bool contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const;

    inline QStringList &replaceInStrings(const QString &before, const QString &after, Qt::CaseSensitivity cs = Qt::CaseSensitive);

    inline QStringList operator+(const QStringList &other) const
    { QStringList n = *this; n += other; return n; }
    inline QStringList &operator<<(const QString &str)
    { append(str); return *this; }
    inline QStringList &operator<<(const QStringList &l)
    { *this += l; return *this; }


    inline QStringList filter(const QRegExp &rx) const;
    inline QStringList &replaceInStrings(const QRegExp &rx, const QString &after);
    inline int indexOf(const QRegExp &rx, int from = 0) const;
    inline int lastIndexOf(const QRegExp &rx, int from = -1) const;
    inline int indexOf(QRegExp &rx, int from = 0) const;
    inline int lastIndexOf(QRegExp &rx, int from = -1) const;




    inline QStringList filter(const QRegularExpression &re) const;
    inline QStringList &replaceInStrings(const QRegularExpression &re, const QString &after);
    inline int indexOf(const QRegularExpression &re, int from = 0) const;
    inline int lastIndexOf(const QRegularExpression &re, int from = -1) const;




    using QList<QString>::indexOf;
    using QList<QString>::lastIndexOf;






};

template<> class QTypeInfo<QStringList > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QStringList)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QStringList >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QStringList) }; static inline const char *name() { return "QStringList"; } };

namespace QtPrivate {
    void __declspec(dllimport) QStringList_sort(QStringList *that, Qt::CaseSensitivity cs);
    int __declspec(dllimport) QStringList_removeDuplicates(QStringList *that);
    QString __declspec(dllimport) QStringList_join(const QStringList *that, const QChar *sep, int seplen);
    QStringList __declspec(dllimport) QStringList_filter(const QStringList *that, const QString &str,
                                               Qt::CaseSensitivity cs);

    bool __declspec(dllimport) QStringList_contains(const QStringList *that, const QString &str, Qt::CaseSensitivity cs);
    void __declspec(dllimport) QStringList_replaceInStrings(QStringList *that, const QString &before, const QString &after,
                                      Qt::CaseSensitivity cs);


    void __declspec(dllimport) QStringList_replaceInStrings(QStringList *that, const QRegExp &rx, const QString &after);
    QStringList __declspec(dllimport) QStringList_filter(const QStringList *that, const QRegExp &re);
    int __declspec(dllimport) QStringList_indexOf(const QStringList *that, const QRegExp &rx, int from);
    int __declspec(dllimport) QStringList_lastIndexOf(const QStringList *that, const QRegExp &rx, int from);
    int __declspec(dllimport) QStringList_indexOf(const QStringList *that, QRegExp &rx, int from);
    int __declspec(dllimport) QStringList_lastIndexOf(const QStringList *that, QRegExp &rx, int from);




    void __declspec(dllimport) QStringList_replaceInStrings(QStringList *that, const QRegularExpression &rx, const QString &after);
    QStringList __declspec(dllimport) QStringList_filter(const QStringList *that, const QRegularExpression &re);
    int __declspec(dllimport) QStringList_indexOf(const QStringList *that, const QRegularExpression &re, int from);
    int __declspec(dllimport) QStringList_lastIndexOf(const QStringList *that, const QRegularExpression &re, int from);


}

inline void QStringList::sort(Qt::CaseSensitivity cs)
{
    QtPrivate::QStringList_sort(this, cs);
}

inline int QStringList::removeDuplicates()
{
    return QtPrivate::QStringList_removeDuplicates(this);
}

inline QString QStringList::join(const QString &sep) const
{
    return QtPrivate::QStringList_join(this, sep.constData(), sep.length());
}

inline QString QStringList::join(QChar sep) const
{
    return QtPrivate::QStringList_join(this, &sep, 1);
}

inline QStringList QStringList::filter(const QString &str, Qt::CaseSensitivity cs) const
{
    return QtPrivate::QStringList_filter(this, str, cs);
}

inline bool QStringList::contains(const QString &str, Qt::CaseSensitivity cs) const
{
    return QtPrivate::QStringList_contains(this, str, cs);
}

inline QStringList &QStringList::replaceInStrings(const QString &before, const QString &after, Qt::CaseSensitivity cs)
{
    QtPrivate::QStringList_replaceInStrings(this, before, after, cs);
    return *this;
}


inline QStringList &QStringList::replaceInStrings(const QRegExp &rx, const QString &after)
{
    QtPrivate::QStringList_replaceInStrings(this, rx, after);
    return *this;
}

inline QStringList QStringList::filter(const QRegExp &rx) const
{
    return QtPrivate::QStringList_filter(this, rx);
}

inline int QStringList::indexOf(const QRegExp &rx, int from) const
{
    return QtPrivate::QStringList_indexOf(this, rx, from);
}

inline int QStringList::lastIndexOf(const QRegExp &rx, int from) const
{
    return QtPrivate::QStringList_lastIndexOf(this, rx, from);
}

inline int QStringList::indexOf(QRegExp &rx, int from) const
{
    return QtPrivate::QStringList_indexOf(this, rx, from);
}

inline int QStringList::lastIndexOf(QRegExp &rx, int from) const
{
    return QtPrivate::QStringList_lastIndexOf(this, rx, from);
}




inline QStringList &QStringList::replaceInStrings(const QRegularExpression &rx, const QString &after)
{
    QtPrivate::QStringList_replaceInStrings(this, rx, after);
    return *this;
}

inline QStringList QStringList::filter(const QRegularExpression &rx) const
{
    return QtPrivate::QStringList_filter(this, rx);
}

inline int QStringList::indexOf(const QRegularExpression &rx, int from) const
{
    return QtPrivate::QStringList_indexOf(this, rx, from);
}

inline int QStringList::lastIndexOf(const QRegularExpression &rx, int from) const
{
    return QtPrivate::QStringList_lastIndexOf(this, rx, from);
}




inline QDataStream &operator>>(QDataStream &in, QStringList &list)
{
    return operator>>(in, static_cast<QList<QString> &>(list));
}
inline QDataStream &operator<<(QDataStream &out, const QStringList &list)
{
    return operator<<(out, static_cast<const QList<QString> &>(list));
}
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qcolor.h"





class QColor;
class QColormap;
class QVariant;


__declspec(dllimport) QDebug operator<<(QDebug, const QColor &);


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QColor &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QColor &);


class __declspec(dllimport) QColor
{
public:
    enum Spec { Invalid, Rgb, Hsv, Cmyk, Hsl };
    enum NameFormat { HexRgb, HexArgb };

    QColor();
    QColor(Qt::GlobalColor color);
    QColor(int r, int g, int b, int a = 255);
    QColor(QRgb rgb);
    QColor(const QString& name);
    QColor(const char *name);
    QColor(const QColor &color);
    QColor(Spec spec);

    bool isValid() const;


    QString name() const;
    QString name(NameFormat format) const;
    void setNamedColor(const QString& name);

    static QStringList colorNames();

    inline Spec spec() const
    { return cspec; }

    int alpha() const;
    void setAlpha(int alpha);

    qreal alphaF() const;
    void setAlphaF(qreal alpha);

    int red() const;
    int green() const;
    int blue() const;
    void setRed(int red);
    void setGreen(int green);
    void setBlue(int blue);

    qreal redF() const;
    qreal greenF() const;
    qreal blueF() const;
    void setRedF(qreal red);
    void setGreenF(qreal green);
    void setBlueF(qreal blue);

    void getRgb(int *r, int *g, int *b, int *a = 0) const;
    void setRgb(int r, int g, int b, int a = 255);

    void getRgbF(qreal *r, qreal *g, qreal *b, qreal *a = 0) const;
    void setRgbF(qreal r, qreal g, qreal b, qreal a = 1.0);

    QRgb rgba() const;
    void setRgba(QRgb rgba);

    QRgb rgb() const;
    void setRgb(QRgb rgb);

    int hue() const;
    int saturation() const;
    int hsvHue() const;
    int hsvSaturation() const;
    int value() const;

    qreal hueF() const;
    qreal saturationF() const;
    qreal hsvHueF() const;
    qreal hsvSaturationF() const;
    qreal valueF() const;

    void getHsv(int *h, int *s, int *v, int *a = 0) const;
    void setHsv(int h, int s, int v, int a = 255);

    void getHsvF(qreal *h, qreal *s, qreal *v, qreal *a = 0) const;
    void setHsvF(qreal h, qreal s, qreal v, qreal a = 1.0);

    int cyan() const;
    int magenta() const;
    int yellow() const;
    int black() const;

    qreal cyanF() const;
    qreal magentaF() const;
    qreal yellowF() const;
    qreal blackF() const;

    void getCmyk(int *c, int *m, int *y, int *k, int *a = 0);
    void setCmyk(int c, int m, int y, int k, int a = 255);

    void getCmykF(qreal *c, qreal *m, qreal *y, qreal *k, qreal *a = 0);
    void setCmykF(qreal c, qreal m, qreal y, qreal k, qreal a = 1.0);

    int hslHue() const;
    int hslSaturation() const;
    int lightness() const;

    qreal hslHueF() const;
    qreal hslSaturationF() const;
    qreal lightnessF() const;

    void getHsl(int *h, int *s, int *l, int *a = 0) const;
    void setHsl(int h, int s, int l, int a = 255);

    void getHslF(qreal *h, qreal *s, qreal *l, qreal *a = 0) const;
    void setHslF(qreal h, qreal s, qreal l, qreal a = 1.0);

    QColor toRgb() const;
    QColor toHsv() const;
    QColor toCmyk() const;
    QColor toHsl() const;

    QColor convertTo(Spec colorSpec) const;

    static QColor fromRgb(QRgb rgb);
    static QColor fromRgba(QRgb rgba);

    static QColor fromRgb(int r, int g, int b, int a = 255);
    static QColor fromRgbF(qreal r, qreal g, qreal b, qreal a = 1.0);

    static QColor fromHsv(int h, int s, int v, int a = 255);
    static QColor fromHsvF(qreal h, qreal s, qreal v, qreal a = 1.0);

    static QColor fromCmyk(int c, int m, int y, int k, int a = 255);
    static QColor fromCmykF(qreal c, qreal m, qreal y, qreal k, qreal a = 1.0);

    static QColor fromHsl(int h, int s, int l, int a = 255);
    static QColor fromHslF(qreal h, qreal s, qreal l, qreal a = 1.0);

    QColor light(int f = 150) const;
    QColor lighter(int f = 150) const;
    QColor dark(int f = 200) const;
    QColor darker(int f = 200) const;

    QColor &operator=(const QColor &);
    QColor &operator=(Qt::GlobalColor color);

    bool operator==(const QColor &c) const;
    bool operator!=(const QColor &c) const;

    operator QVariant() const;

    static bool isValidColor(const QString &name);

private:

    void invalidate();
    bool setColorFromString(const QString &name);

    Spec cspec;
    union {
        struct {
            ushort alpha;
            ushort red;
            ushort green;
            ushort blue;
            ushort pad;
        } argb;
        struct {
            ushort alpha;
            ushort hue;
            ushort saturation;
            ushort value;
            ushort pad;
        } ahsv;
        struct {
            ushort alpha;
            ushort cyan;
            ushort magenta;
            ushort yellow;
            ushort black;
        } acmyk;
        struct {
            ushort alpha;
            ushort hue;
            ushort saturation;
            ushort lightness;
            ushort pad;
        } ahsl;
        ushort array[5];
    } ct;

    friend class QColormap;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QColor &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QColor &);

};

inline QColor::QColor()
{ invalidate(); }

inline QColor::QColor(int r, int g, int b, int a)
{ setRgb(r, g, b, a); }

inline QColor::QColor(const char *aname)
{ setNamedColor(QLatin1String(aname)); }

inline QColor::QColor(const QString& aname)
{ setNamedColor(aname); }

inline QColor::QColor(const QColor &acolor)
    : cspec(acolor.cspec)
{ ct.argb = acolor.ct.argb; }

inline bool QColor::isValid() const
{ return cspec != Invalid; }

inline QColor QColor::lighter(int f) const
{ return light(f); }

inline QColor QColor::darker(int f) const
{ return dark(f); }
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpalette.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qbrush.h"
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qbrush.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h"
#line 63 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h"
class QRegion;

template <typename T>
class QVector
{
    typedef QTypedArrayData<T> Data;
    Data *d;

public:
    inline QVector() : d(Data::sharedNull()) { }
    explicit QVector(int size);
    QVector(int size, const T &t);
    inline QVector(const QVector<T> &v);
    inline ~QVector() { if (!d->ref.deref()) freeData(d); }
    QVector<T> &operator=(const QVector<T> &v);

    inline QVector(QVector<T> &&other) : d(other.d) { other.d = Data::sharedNull(); }
    inline QVector<T> operator=(QVector<T> &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QVector<T> &other) { qSwap(d, other.d); }



    bool operator==(const QVector<T> &v) const;
    inline bool operator!=(const QVector<T> &v) const { return !(*this == v); }

    inline int size() const { return d->size; }

    inline bool isEmpty() const { return d->size == 0; }

    void resize(int size);

    inline int capacity() const { return int(d->alloc); }
    void reserve(int size);
    inline void squeeze()
    {
        reallocData(d->size, d->size);
        if (d->capacityReserved) {


            d->capacityReserved = 0;
        }
    }

    inline void detach();
    inline bool isDetached() const { return !d->ref.isShared(); }

    inline void setSharable(bool sharable)
    {
        if (sharable == d->ref.isSharable())
            return;
        if (!sharable)
            detach();

        if (d == Data::unsharableEmpty()) {
            if (sharable)
                d = Data::sharedNull();
        } else {
            d->ref.setSharable(sharable);
        }
        ((!(d->ref.isSharable() == sharable)) ? qt_assert("d->ref.isSharable() == sharable","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",124) : qt_noop());
    }


    inline bool isSharedWith(const QVector<T> &other) const { return d == other.d; }

    inline T *data() { detach(); return d->begin(); }
    inline const T *data() const { return d->begin(); }
    inline const T *constData() const { return d->begin(); }
    void clear();

    const T &at(int i) const;
    T &operator[](int i);
    const T &operator[](int i) const;
    void append(const T &t);
    void prepend(const T &t);
    void insert(int i, const T &t);
    void insert(int i, int n, const T &t);
    void replace(int i, const T &t);
    void remove(int i);
    void remove(int i, int n);
    inline void removeFirst() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",145) : qt_noop()); erase(d->begin()); }
    inline void removeLast();
    inline T takeFirst() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",147) : qt_noop()); T r = first(); removeFirst(); return r; }
    inline T takeLast() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",148) : qt_noop()); T r = last(); removeLast(); return r; }

    QVector<T> &fill(const T &t, int size = -1);

    int indexOf(const T &t, int from = 0) const;
    int lastIndexOf(const T &t, int from = -1) const;
    bool contains(const T &t) const;
    int count(const T &t) const;


    void removeAt(int i) { remove(i); }
    int length() const { return size(); }
    T takeAt(int i) { T t = at(i); remove(i); return t; }


    typedef typename Data::iterator iterator;
    typedef typename Data::const_iterator const_iterator;

    inline iterator begin() { detach(); return d->begin(); }
    inline const_iterator begin() const { return d->constBegin(); }
    inline const_iterator cbegin() const { return d->constBegin(); }
    inline const_iterator constBegin() const { return d->constBegin(); }
    inline iterator end() { detach(); return d->end(); }
    inline const_iterator end() const { return d->constEnd(); }
    inline const_iterator cend() const { return d->constEnd(); }
    inline const_iterator constEnd() const { return d->constEnd(); }
#line 184 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h"
    iterator insert(iterator before, int n, const T &x);
    inline iterator insert(iterator before, const T &x) { return insert(before, 1, x); }
    iterator erase(iterator begin, iterator end);
    inline iterator erase(iterator pos) { return erase(pos, pos+1); }


    inline int count() const { return d->size; }
    inline T& first() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",191) : qt_noop()); return *begin(); }
    inline const T &first() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",192) : qt_noop()); return *begin(); }
    inline T& last() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",193) : qt_noop()); return *(end()-1); }
    inline const T &last() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",194) : qt_noop()); return *(end()-1); }
    inline bool startsWith(const T &t) const { return !isEmpty() && first() == t; }
    inline bool endsWith(const T &t) const { return !isEmpty() && last() == t; }
    QVector<T> mid(int pos, int len = -1) const;

    T value(int i) const;
    T value(int i, const T &defaultValue) const;


    typedef T value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef qptrdiff difference_type;
    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    typedef int size_type;
    inline void push_back(const T &t) { append(t); }
    inline void push_front(const T &t) { prepend(t); }
    void pop_back() { removeLast(); }
    void pop_front() { removeFirst(); }
    inline bool empty() const
    { return d->size == 0; }
    inline T& front() { return first(); }
    inline const_reference front() const { return first(); }
    inline reference back() { return last(); }
    inline const_reference back() const { return last(); }


    QVector<T> &operator+=(const QVector<T> &l);
    inline QVector<T> operator+(const QVector<T> &l) const
    { QVector n = *this; n += l; return n; }
    inline QVector<T> &operator+=(const T &t)
    { append(t); return *this; }
    inline QVector<T> &operator<< (const T &t)
    { append(t); return *this; }
    inline QVector<T> &operator<<(const QVector<T> &l)
    { *this += l; return *this; }

    QList<T> toList() const;

    static QVector<T> fromList(const QList<T> &list);

    static inline QVector<T> fromStdVector(const std::vector<T> &vector)
    { QVector<T> tmp; tmp.reserve(int(vector.size())); std::copy(vector.begin(), vector.end(), std::back_inserter(tmp)); return tmp; }
    inline std::vector<T> toStdVector() const
    { std::vector<T> tmp; tmp.reserve(size()); std::copy(constBegin(), constEnd(), std::back_inserter(tmp)); return tmp; }
private:
    friend class QRegion;

    void reallocData(const int size, const int alloc, QArrayData::AllocationOptions options = QArrayData::Default);
    void reallocData(const int sz) { reallocData(sz, d->alloc); }
    void freeData(Data *d);
    void defaultConstruct(T *from, T *to);
    void copyConstruct(const T *srcFrom, const T *srcTo, T *dstFrom);
    void destruct(T *from, T *to);
    bool isValidIterator(const iterator &i) const
    {
        return (i <= d->end()) && (d->begin() <= i);
    }
    class AlignmentDummy { Data header; T array[1]; };
};




#pragma warning(push)
#pragma warning(disable: 4345)


template <typename T>
void QVector<T>::defaultConstruct(T *from, T *to)
{
    if (QTypeInfo<T>::isComplex) {
        while (from != to) {
            new (from++) T();
        }
    } else {
        ::memset(static_cast<void *>(from), 0, (to - from) * sizeof(T));
    }
}


#pragma warning(pop)


template <typename T>
void QVector<T>::copyConstruct(const T *srcFrom, const T *srcTo, T *dstFrom)
{
    if (QTypeInfo<T>::isComplex) {
        while (srcFrom != srcTo)
            new (dstFrom++) T(*srcFrom++);
    } else {
        ::memcpy(static_cast<void *>(dstFrom), static_cast<const void *>(srcFrom), (srcTo - srcFrom) * sizeof(T));
    }
}


#pragma warning(push)
#pragma warning(disable: 4127)


template <typename T>
void QVector<T>::destruct(T *from, T *to)
{
    if (QTypeInfo<T>::isComplex) {
        while (from != to) {
            from++->~T();
        }
    }
}


#pragma warning(pop)


template <typename T>
inline QVector<T>::QVector(const QVector<T> &v)
{
    if (v.d->ref.ref()) {
        d = v.d;
    } else {
        if (v.d->capacityReserved) {
            d = Data::allocate(v.d->alloc);
            d->capacityReserved = true;
        } else {
            d = Data::allocate(v.d->size);
        }
        if (d->alloc) {
            copyConstruct(v.d->begin(), v.d->end(), d->begin());
            d->size = v.d->size;
        }
    }
}

template <typename T>
void QVector<T>::detach()
{
    if (!isDetached()) {

        if (!d->alloc)
            d = Data::unsharableEmpty();
        else

            reallocData(d->size, int(d->alloc));
    }
    ((!(isDetached())) ? qt_assert("isDetached()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",341) : qt_noop());
}

template <typename T>
void QVector<T>::reserve(int asize)
{
    if (asize > int(d->alloc))
        reallocData(d->size, asize);
    if (isDetached())
        d->capacityReserved = 1;
    ((!(capacity() >= asize)) ? qt_assert("capacity() >= asize","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",351) : qt_noop());
}

template <typename T>
void QVector<T>::resize(int asize)
{
    int newAlloc;
    const int oldAlloc = int(d->alloc);
    QArrayData::AllocationOptions opt;

    if (asize > oldAlloc) {
        newAlloc = asize;
        opt = QArrayData::Grow;
    } else if (!d->capacityReserved && asize < d->size && asize < (oldAlloc >> 1)) {
        newAlloc = asize;
        opt = QArrayData::Grow;
    } else {
        newAlloc = oldAlloc;
    }
    reallocData(asize, newAlloc, opt);
}
template <typename T>
inline void QVector<T>::clear()
{ *this = QVector<T>(); }
template <typename T>
inline const T &QVector<T>::at(int i) const
{ ((!(i >= 0 && i < d->size)) ? qt_assert_x("QVector<T>::at", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",377) : qt_noop());
  return d->begin()[i]; }
template <typename T>
inline const T &QVector<T>::operator[](int i) const
{ ((!(i >= 0 && i < d->size)) ? qt_assert_x("QVector<T>::operator[]", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",381) : qt_noop());
  return d->begin()[i]; }
template <typename T>
inline T &QVector<T>::operator[](int i)
{ ((!(i >= 0 && i < d->size)) ? qt_assert_x("QVector<T>::operator[]", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",385) : qt_noop());
  return data()[i]; }
template <typename T>
inline void QVector<T>::insert(int i, const T &t)
{ ((!(i >= 0 && i <= d->size)) ? qt_assert_x("QVector<T>::insert", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",389) : qt_noop());
  insert(begin() + i, 1, t); }
template <typename T>
inline void QVector<T>::insert(int i, int n, const T &t)
{ ((!(i >= 0 && i <= d->size)) ? qt_assert_x("QVector<T>::insert", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",393) : qt_noop());
  insert(begin() + i, n, t); }
template <typename T>
inline void QVector<T>::remove(int i, int n)
{ ((!(i >= 0 && n >= 0 && i + n <= d->size)) ? qt_assert_x("QVector<T>::remove", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",397) : qt_noop());
  erase(d->begin() + i, d->begin() + i + n); }
template <typename T>
inline void QVector<T>::remove(int i)
{ ((!(i >= 0 && i < d->size)) ? qt_assert_x("QVector<T>::remove", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",401) : qt_noop());
  erase(d->begin() + i, d->begin() + i + 1); }
template <typename T>
inline void QVector<T>::prepend(const T &t)
{ insert(begin(), 1, t); }

template <typename T>
inline void QVector<T>::replace(int i, const T &t)
{
    ((!(i >= 0 && i < d->size)) ? qt_assert_x("QVector<T>::replace", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",410) : qt_noop());
    const T copy(t);
    data()[i] = copy;
}

template <typename T>
QVector<T> &QVector<T>::operator=(const QVector<T> &v)
{
    if (v.d != d) {
        QVector<T> tmp(v);
        tmp.swap(*this);
    }
    return *this;
}

template <typename T>
QVector<T>::QVector(int asize)
{
    ((!(asize >= 0)) ? qt_assert_x("QVector::QVector", "Size must be greater than or equal to 0.","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",428) : qt_noop());
    if ((asize > 0)) {
        d = Data::allocate(asize);
        d->size = asize;
        defaultConstruct(d->begin(), d->end());
    } else {
        d = Data::sharedNull();
    }
}

template <typename T>
QVector<T>::QVector(int asize, const T &t)
{
    ((!(asize >= 0)) ? qt_assert_x("QVector::QVector", "Size must be greater than or equal to 0.","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",441) : qt_noop());
    if (asize > 0) {
        d = Data::allocate(asize);
        d->size = asize;
        T* i = d->end();
        while (i != d->begin())
            new (--i) T(t);
    } else {
        d = Data::sharedNull();
    }
}
#line 469 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h"
template <typename T>
void QVector<T>::freeData(Data *x)
{
    destruct(x->begin(), x->end());
    Data::deallocate(x);
}

template <typename T>
void QVector<T>::reallocData(const int asize, const int aalloc, QArrayData::AllocationOptions options)
{
    ((!(asize >= 0 && asize <= aalloc)) ? qt_assert("asize >= 0 && asize <= aalloc","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",479) : qt_noop());
    Data *x = d;

    const bool isShared = d->ref.isShared();

    if (aalloc != 0) {
        if (aalloc != int(d->alloc) || isShared) {
            try {

                x = Data::allocate(aalloc, options);
                do { if (!(x)) qBadAlloc(); } while (0);


                ((!(x->ref.isSharable() || options.testFlag(QArrayData::Unsharable))) ? qt_assert("x->ref.isSharable() || options.testFlag(QArrayData::Unsharable)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",492) : qt_noop());

                ((!(!x->ref.isStatic())) ? qt_assert("!x->ref.isStatic()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",494) : qt_noop());
                x->size = asize;

                T *srcBegin = d->begin();
                T *srcEnd = asize > d->size ? d->end() : d->begin() + asize;
                T *dst = x->begin();

                if (QTypeInfo<T>::isStatic || (isShared && QTypeInfo<T>::isComplex)) {

                    while (srcBegin != srcEnd) {
                        new (dst++) T(*srcBegin++);
                    }
                } else {
                    ::memcpy(static_cast<void *>(dst), static_cast<void *>(srcBegin), (srcEnd - srcBegin) * sizeof(T));
                    dst += srcEnd - srcBegin;


                    if (asize < d->size)
                        destruct(d->begin() + asize, d->end());
                }

                if (asize > d->size) {

                    try {
                        defaultConstruct(dst, x->end());
                    } catch (...) {

                        destruct(x->begin(), dst);
                        throw;
                    }
                }
            } catch (...) {
                Data::deallocate(x);
                throw;
            }
            x->capacityReserved = d->capacityReserved;
        } else {
            ((!(int(d->alloc) == aalloc)) ? qt_assert("int(d->alloc) == aalloc","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",531) : qt_noop());
            ((!(isDetached())) ? qt_assert("isDetached()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",532) : qt_noop());
            ((!(x == d)) ? qt_assert("x == d","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",533) : qt_noop());
            if (asize <= d->size) {
                destruct(x->begin() + asize, x->end());
            } else {
                defaultConstruct(x->end(), x->begin() + asize);
            }
            x->size = asize;
        }
    } else {
        x = Data::sharedNull();
    }
    if (d != x) {
        if (!d->ref.deref()) {
            if (QTypeInfo<T>::isStatic || !aalloc || (isShared && QTypeInfo<T>::isComplex)) {


                freeData(d);
            } else {
                Data::deallocate(d);
            }
        }
        d = x;
    }

    ((!(d->data())) ? qt_assert("d->data()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",557) : qt_noop());
    ((!(uint(d->size) <= d->alloc)) ? qt_assert("uint(d->size) <= d->alloc","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",558) : qt_noop());

    ((!(d != Data::unsharableEmpty())) ? qt_assert("d != Data::unsharableEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",560) : qt_noop());

    ((!(aalloc ? d != Data::sharedNull() : d == Data::sharedNull())) ? qt_assert("aalloc ? d != Data::sharedNull() : d == Data::sharedNull()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",562) : qt_noop());
    ((!(d->alloc >= uint(aalloc))) ? qt_assert("d->alloc >= uint(aalloc)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",563) : qt_noop());
    ((!(d->size == asize)) ? qt_assert("d->size == asize","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",564) : qt_noop());
}

template<typename T>
inline T QVector<T>::value(int i) const
{
    if (uint(i) >= uint(d->size)) {
        return T();
    }
    return d->begin()[i];
}
template<typename T>
inline T QVector<T>::value(int i, const T &defaultValue) const
{
    return uint(i) >= uint(d->size) ? defaultValue : d->begin()[i];
}

template <typename T>
void QVector<T>::append(const T &t)
{
    const T copy(t);
    const bool isTooSmall = uint(d->size + 1) > d->alloc;
    if (!isDetached() || isTooSmall) {
        QArrayData::AllocationOptions opt(isTooSmall ? QArrayData::Grow : QArrayData::Default);
        reallocData(d->size, isTooSmall ? d->size + 1 : d->alloc, opt);
    }
    if (QTypeInfo<T>::isComplex)
        new (d->end()) T(copy);
    else
        *d->end() = copy;
    ++d->size;
}

template <typename T>
void QVector<T>::removeLast()
{
    ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",600) : qt_noop());
    ((!(d->alloc)) ? qt_assert("d->alloc","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",601) : qt_noop());

    if (!d->ref.isShared()) {
        --d->size;
        if (QTypeInfo<T>::isComplex)
            (d->data() + d->size)->~T();
    } else {
        reallocData(d->size - 1);
    }
}

template <typename T>
typename QVector<T>::iterator QVector<T>::insert(iterator before, size_type n, const T &t)
{
    ((!(isValidIterator(before))) ? qt_assert_x("QVector::insert", "The specified iterator argument 'before' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",615) : qt_noop());

    int offset = std::distance(d->begin(), before);
    if (n != 0) {
        const T copy(t);
        if (!isDetached() || d->size + n > int(d->alloc))
            reallocData(d->size, d->size + n, QArrayData::Grow);
        if (QTypeInfo<T>::isStatic) {
            T *b = d->end();
            T *i = d->end() + n;
            while (i != b)
                new (--i) T;
            i = d->end();
            T *j = i + n;
            b = d->begin() + offset;
            while (i != b)
                *--j = *--i;
            i = b+n;
            while (i != b)
                *--i = copy;
        } else {
            T *b = d->begin() + offset;
            T *i = b + n;
            memmove(i, b, (d->size - offset) * sizeof(T));
            while (i != b)
                new (--i) T(copy);
        }
        d->size += n;
    }
    return d->begin() + offset;
}

template <typename T>
typename QVector<T>::iterator QVector<T>::erase(iterator abegin, iterator aend)
{
    ((!(isValidIterator(abegin))) ? qt_assert_x("QVector::erase", "The specified iterator argument 'abegin' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",650) : qt_noop());
    ((!(isValidIterator(aend))) ? qt_assert_x("QVector::erase", "The specified iterator argument 'aend' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",651) : qt_noop());

    const int itemsToErase = aend - abegin;

    if (!itemsToErase)
        return abegin;

    ((!(abegin >= d->begin())) ? qt_assert("abegin >= d->begin()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",658) : qt_noop());
    ((!(aend <= d->end())) ? qt_assert("aend <= d->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",659) : qt_noop());
    ((!(abegin <= aend)) ? qt_assert("abegin <= aend","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",660) : qt_noop());

    const int itemsUntouched = abegin - d->begin();




    if (d->alloc) {
        detach();
        abegin = d->begin() + itemsUntouched;
        aend = abegin + itemsToErase;
        if (QTypeInfo<T>::isStatic) {
            iterator moveBegin = abegin + itemsToErase;
            iterator moveEnd = d->end();
            while (moveBegin != moveEnd) {
                if (QTypeInfo<T>::isComplex)
                    static_cast<T *>(abegin)->~T();
                new (abegin++) T(*moveBegin++);
            }
            if (abegin < d->end()) {

                destruct(abegin, d->end());
            }
        } else {
            destruct(abegin, aend);
            memmove(abegin, aend, (d->size - itemsToErase - itemsUntouched) * sizeof(T));
        }
        d->size -= itemsToErase;
    }
    return d->begin() + itemsUntouched;
}

template <typename T>
bool QVector<T>::operator==(const QVector<T> &v) const
{
    if (d->size != v.d->size)
        return false;
    if (d == v.d)
        return true;
    T* b = d->begin();
    T* i = b + d->size;
    T* j = v.d->end();
    while (i != b)
        if (!(*--i == *--j))
            return false;
    return true;
}

template <typename T>
QVector<T> &QVector<T>::fill(const T &from, int asize)
{
    const T copy(from);
    resize(asize < 0 ? d->size : asize);
    if (d->size) {
        T *i = d->end();
        T *b = d->begin();
        while (i != b)
            *--i = copy;
    }
    return *this;
}

template <typename T>
QVector<T> &QVector<T>::operator+=(const QVector &l)
{
    uint newSize = d->size + l.d->size;
    const bool isTooSmall = newSize > d->alloc;
    if (!isDetached() || isTooSmall) {
        QArrayData::AllocationOptions opt(isTooSmall ? QArrayData::Grow : QArrayData::Default);
        reallocData(d->size, isTooSmall ? newSize : d->alloc, opt);
    }

    if (d->alloc) {
        T *w = d->begin() + newSize;
        T *i = l.d->end();
        T *b = l.d->begin();
        while (i != b) {
            if (QTypeInfo<T>::isComplex)
                new (--w) T(*--i);
            else
                *--w = *--i;
        }
        d->size = newSize;
    }
    return *this;
}

template <typename T>
int QVector<T>::indexOf(const T &t, int from) const
{
    if (from < 0)
        from = qMax(from + d->size, 0);
    if (from < d->size) {
        T* n = d->begin() + from - 1;
        T* e = d->end();
        while (++n != e)
            if (*n == t)
                return n - d->begin();
    }
    return -1;
}

template <typename T>
int QVector<T>::lastIndexOf(const T &t, int from) const
{
    if (from < 0)
        from += d->size;
    else if (from >= d->size)
        from = d->size-1;
    if (from >= 0) {
        T* b = d->begin();
        T* n = d->begin() + from + 1;
        while (n != b) {
            if (*--n == t)
                return n - b;
        }
    }
    return -1;
}

template <typename T>
bool QVector<T>::contains(const T &t) const
{
    T* b = d->begin();
    T* i = d->end();
    while (i != b)
        if (*--i == t)
            return true;
    return false;
}

template <typename T>
int QVector<T>::count(const T &t) const
{
    int c = 0;
    T* b = d->begin();
    T* i = d->end();
    while (i != b)
        if (*--i == t)
            ++c;
    return c;
}

template <typename T>
inline QVector<T> QVector<T>::mid(int pos, int len) const
{
    if (len < 0)
        len = size() - pos;
    if (pos == 0 && len == size())
        return *this;
    if (pos + len > size())
        len = size() - pos;
    QVector<T> copy;
    copy.reserve(len);
    for (int i = pos; i < pos + len; ++i)
        copy += at(i);
    return copy;
}

template <typename T>
inline QList<T> QVector<T>::toList() const
{
    QList<T> result;
    result.reserve(size());
    for (int i = 0; i < size(); ++i)
        result.append(at(i));
    return result;
}

template <typename T>
inline QVector<T> QList<T>::toVector() const
{
    QVector<T> result(size());
    for (int i = 0; i < size(); ++i)
        result[i] = at(i);
    return result;
}

template <typename T>
QVector<T> QVector<T>::fromList(const QList<T> &list)
{
    return list.toVector();
}

template <typename T>
QList<T> QList<T>::fromVector(const QVector<T> &vector)
{
    return vector.toList();
}

template <class T> class QVectorIterator { typedef typename QVector<T>::const_iterator const_iterator; QVector<T> c; const_iterator i; public: inline QVectorIterator(const QVector<T> &container) : c(container), i(c.constBegin()) {} inline QVectorIterator &operator=(const QVector<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };
template <class T> class QMutableVectorIterator { typedef typename QVector<T>::iterator iterator; typedef typename QVector<T>::const_iterator const_iterator; QVector<T> *c; iterator i, n; inline bool item_exists() const { return const_iterator(n) != c->constEnd(); } public: inline QMutableVectorIterator(QVector<T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableVectorIterator() { c->setSharable(true); } inline QMutableVectorIterator &operator=(QVector<T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = i; } inline bool hasNext() const { return c->constEnd() != const_iterator(i); } inline T &next() { n = i++; return *n; } inline T &peekNext() const { return *i; } inline bool hasPrevious() const { return c->constBegin() != const_iterator(i); } inline T &previous() { n = --i; return *n; } inline T &peekPrevious() const { iterator p = i; return *--p; } inline void remove() { if (c->constEnd() != const_iterator(n)) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) const { if (c->constEnd() != const_iterator(n)) *n = t; } inline T &value() { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",851) : qt_noop()); return *n; } inline const T &value() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h",851) : qt_noop()); return *n; } inline void insert(const T &t) { n = i = c->insert(i, t); ++i; } inline bool findNext(const T &t) { while (c->constEnd() != const_iterator(n = i)) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (c->constBegin() != const_iterator(i)) if (*(n = --i) == t) return true; n = c->end(); return false; } };
#line 870 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvector.h"
extern template class __declspec(dllimport) QVector<QPointF>;
extern template class __declspec(dllimport) QVector<QPoint>;
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qbrush.h"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qmatrix.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qmatrix.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpolygon.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpolygon.h"
class QMatrix;
class QTransform;
class QRect;
class QVariant;

class __declspec(dllimport) QPolygon : public QVector<QPoint>
{
public:
    inline QPolygon() {}
    inline ~QPolygon() {}
    inline explicit QPolygon(int size);
    inline QPolygon(const QPolygon &a) : QVector<QPoint>(a) {}
    inline QPolygon(const QVector<QPoint> &v) : QVector<QPoint>(v) {}
    QPolygon(const QRect &r, bool closed=false);
    QPolygon(int nPoints, const int *points);
    inline void swap(QPolygon &other) { QVector<QPoint>::swap(other); }

    operator QVariant() const;

    void translate(int dx, int dy);
    void translate(const QPoint &offset);

    QPolygon translated(int dx, int dy) const;
    inline QPolygon translated(const QPoint &offset) const;

    QRect boundingRect() const;

    void point(int i, int *x, int *y) const;
    QPoint point(int i) const;
    void setPoint(int index, int x, int y);
    void setPoint(int index, const QPoint &p);
    void setPoints(int nPoints, const int *points);
    void setPoints(int nPoints, int firstx, int firsty, ...);
    void putPoints(int index, int nPoints, const int *points);
    void putPoints(int index, int nPoints, int firstx, int firsty, ...);
    void putPoints(int index, int nPoints, const QPolygon & from, int fromIndex=0);

    bool containsPoint(const QPoint &pt, Qt::FillRule fillRule) const;

    QPolygon united(const QPolygon &r) const;
    QPolygon intersected(const QPolygon &r) const;
    QPolygon subtracted(const QPolygon &r) const;
};

inline QPolygon::QPolygon(int asize) : QVector<QPoint>(asize) {}


__declspec(dllimport) QDebug operator<<(QDebug, const QPolygon &);






__declspec(dllimport) QDataStream &operator<<(QDataStream &stream, const QPolygon &polygon);
__declspec(dllimport) QDataStream &operator>>(QDataStream &stream, QPolygon &polygon);






inline void QPolygon::setPoint(int index, const QPoint &pt)
{ (*this)[index] = pt; }

inline void QPolygon::setPoint(int index, int x, int y)
{ (*this)[index] = QPoint(x, y); }

inline QPoint QPolygon::point(int index) const
{ return at(index); }

inline void QPolygon::translate(const QPoint &offset)
{ translate(offset.x(), offset.y()); }

inline QPolygon QPolygon::translated(const QPoint &offset) const
{ return translated(offset.x(), offset.y()); }

class QRectF;

class __declspec(dllimport) QPolygonF : public QVector<QPointF>
{
public:
    inline QPolygonF() {}
    inline ~QPolygonF() {}
    inline explicit QPolygonF(int size);
    inline QPolygonF(const QPolygonF &a) : QVector<QPointF>(a) {}
    inline QPolygonF(const QVector<QPointF> &v) : QVector<QPointF>(v) {}
    QPolygonF(const QRectF &r);
                 QPolygonF(const QPolygon &a);
    inline void swap(QPolygonF &other) { QVector<QPointF>::swap(other); }

    operator QVariant() const;

    inline void translate(qreal dx, qreal dy);
    void translate(const QPointF &offset);

    inline QPolygonF translated(qreal dx, qreal dy) const;
    QPolygonF translated(const QPointF &offset) const;

    QPolygon toPolygon() const;

    bool isClosed() const { return !isEmpty() && first() == last(); }

    QRectF boundingRect() const;

    bool containsPoint(const QPointF &pt, Qt::FillRule fillRule) const;

    QPolygonF united(const QPolygonF &r) const;
    QPolygonF intersected(const QPolygonF &r) const;
    QPolygonF subtracted(const QPolygonF &r) const;
};

inline QPolygonF::QPolygonF(int asize) : QVector<QPointF>(asize) {}


__declspec(dllimport) QDebug operator<<(QDebug, const QPolygonF &);






__declspec(dllimport) QDataStream &operator<<(QDataStream &stream, const QPolygonF &array);
__declspec(dllimport) QDataStream &operator>>(QDataStream &stream, QPolygonF &array);


inline void QPolygonF::translate(qreal dx, qreal dy)
{ translate(QPointF(dx, dy)); }

inline QPolygonF QPolygonF::translated(qreal dx, qreal dy) const
{ return translated(QPointF(dx, dy)); }
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qmatrix.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qregion.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qregion.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qregion.h"
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qregion.h"
template <class T> class QVector;
class QVariant;

struct QRegionPrivate;

class QBitmap;

class __declspec(dllimport) QRegion
{
public:
    enum RegionType { Rectangle, Ellipse };

    QRegion();
    QRegion(int x, int y, int w, int h, RegionType t = Rectangle);
    QRegion(const QRect &r, RegionType t = Rectangle);
    QRegion(const QPolygon &pa, Qt::FillRule fillRule = Qt::OddEvenFill);
    QRegion(const QRegion &region);
    QRegion(const QBitmap &bitmap);
    ~QRegion();
    QRegion &operator=(const QRegion &);

    inline QRegion &operator=(QRegion &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QRegion &other) { qSwap(d, other.d); }
    bool isEmpty() const;
    bool isNull() const;

    bool contains(const QPoint &p) const;
    bool contains(const QRect &r) const;

    void translate(int dx, int dy);
    inline void translate(const QPoint &p) { translate(p.x(), p.y()); }
    QRegion translated(int dx, int dy) const;
    inline QRegion translated(const QPoint &p) const { return translated(p.x(), p.y()); }

    QRegion united(const QRegion &r) const;
    QRegion united(const QRect &r) const;
    QRegion intersected(const QRegion &r) const;
    QRegion intersected(const QRect &r) const;
    QRegion subtracted(const QRegion &r) const;
    QRegion xored(const QRegion &r) const;
#line 108 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qregion.h"
    bool intersects(const QRegion &r) const;
    bool intersects(const QRect &r) const;

    QRect boundingRect() const;
    QVector<QRect> rects() const;
    void setRects(const QRect *rect, int num);
    int rectCount() const;

    const QRegion operator|(const QRegion &r) const;
    const QRegion operator+(const QRegion &r) const;
    const QRegion operator+(const QRect &r) const;
    const QRegion operator&(const QRegion &r) const;
    const QRegion operator&(const QRect &r) const;
    const QRegion operator-(const QRegion &r) const;
    const QRegion operator^(const QRegion &r) const;
    QRegion& operator|=(const QRegion &r);
    QRegion& operator+=(const QRegion &r);
    QRegion& operator+=(const QRect &r);
    QRegion& operator&=(const QRegion &r);
    QRegion& operator&=(const QRect &r);
    QRegion& operator-=(const QRegion &r);
    QRegion& operator^=(const QRegion &r);

    bool operator==(const QRegion &r) const;
    inline bool operator!=(const QRegion &r) const { return !(operator==(r)); }
    operator QVariant() const;


    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QRegion &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QRegion &);

private:
    QRegion copy() const;
    void detach();
__declspec(dllimport)
    friend bool qt_region_strictContains(const QRegion &region,
                                         const QRect &rect);
    friend struct QRegionPrivate;


    void exec(const QByteArray &ba, int ver = 0, QDataStream::ByteOrder byteOrder = QDataStream::BigEndian);

    struct QRegionData {
        QBasicAtomicInt ref;
        QRegionPrivate *qt_rgn;
    };
    struct QRegionData *d;
    static struct QRegionData shared_empty;
    static void cleanUp(QRegionData *x);
};






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QRegion &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QRegion &);



__declspec(dllimport) QDebug operator<<(QDebug, const QRegion &);
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qmatrix.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qline.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qline.h"
class __declspec(dllimport) QLine
{
public:
                     inline QLine();
                     inline QLine(const QPoint &pt1, const QPoint &pt2);
                     inline QLine(int x1, int y1, int x2, int y2);

                     inline bool isNull() const;

                     inline QPoint p1() const;
                     inline QPoint p2() const;

                     inline int x1() const;
                     inline int y1() const;

                     inline int x2() const;
                     inline int y2() const;

                     inline int dx() const;
                     inline int dy() const;

    inline void translate(const QPoint &p);
    inline void translate(int dx, int dy);

                     inline QLine translated(const QPoint &p) const;
                     inline QLine translated(int dx, int dy) const;

    inline void setP1(const QPoint &p1);
    inline void setP2(const QPoint &p2);
    inline void setPoints(const QPoint &p1, const QPoint &p2);
    inline void setLine(int x1, int y1, int x2, int y2);

                     inline bool operator==(const QLine &d) const;
                     inline bool operator!=(const QLine &d) const { return !(*this == d); }

private:
    QPoint pt1, pt2;
};
template<> class QTypeInfo<QLine > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QLine)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QLine >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QLine) }; static inline const char *name() { return "QLine"; } };





                 inline QLine::QLine() { }

                 inline QLine::QLine(const QPoint &pt1_, const QPoint &pt2_) : pt1(pt1_), pt2(pt2_) { }

                 inline QLine::QLine(int x1pos, int y1pos, int x2pos, int y2pos) : pt1(QPoint(x1pos, y1pos)), pt2(QPoint(x2pos, y2pos)) { }

                 inline bool QLine::isNull() const
{
    return pt1 == pt2;
}

                 inline int QLine::x1() const
{
    return pt1.x();
}

                 inline int QLine::y1() const
{
    return pt1.y();
}

                 inline int QLine::x2() const
{
    return pt2.x();
}

                 inline int QLine::y2() const
{
    return pt2.y();
}

                 inline QPoint QLine::p1() const
{
    return pt1;
}

                 inline QPoint QLine::p2() const
{
    return pt2;
}

                 inline int QLine::dx() const
{
    return pt2.x() - pt1.x();
}

                 inline int QLine::dy() const
{
    return pt2.y() - pt1.y();
}

inline void QLine::translate(const QPoint &point)
{
    pt1 += point;
    pt2 += point;
}

inline void QLine::translate(int adx, int ady)
{
    this->translate(QPoint(adx, ady));
}

                 inline QLine QLine::translated(const QPoint &p) const
{
    return QLine(pt1 + p, pt2 + p);
}

                 inline QLine QLine::translated(int adx, int ady) const
{
    return translated(QPoint(adx, ady));
}

inline void QLine::setP1(const QPoint &aP1)
{
    pt1 = aP1;
}

inline void QLine::setP2(const QPoint &aP2)
{
    pt2 = aP2;
}

inline void QLine::setPoints(const QPoint &aP1, const QPoint &aP2)
{
    pt1 = aP1;
    pt2 = aP2;
}

inline void QLine::setLine(int aX1, int aY1, int aX2, int aY2)
{
    pt1 = QPoint(aX1, aY1);
    pt2 = QPoint(aX2, aY2);
}

                 inline bool QLine::operator==(const QLine &d) const
{
    return pt1 == d.pt1 && pt2 == d.pt2;
}


__declspec(dllimport) QDebug operator<<(QDebug d, const QLine &p);



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QLine &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QLine &);





class __declspec(dllimport) QLineF {
public:

    enum IntersectType { NoIntersection, BoundedIntersection, UnboundedIntersection };

                     inline QLineF();
                     inline QLineF(const QPointF &pt1, const QPointF &pt2);
                     inline QLineF(qreal x1, qreal y1, qreal x2, qreal y2);
                     inline QLineF(const QLine &line) : pt1(line.p1()), pt2(line.p2()) { }

    static QLineF fromPolar(qreal length, qreal angle);

                     bool isNull() const;

                     inline QPointF p1() const;
                     inline QPointF p2() const;

                     inline qreal x1() const;
                     inline qreal y1() const;

                     inline qreal x2() const;
                     inline qreal y2() const;

                     inline qreal dx() const;
                     inline qreal dy() const;

    qreal length() const;
    void setLength(qreal len);

    qreal angle() const;
    void setAngle(qreal angle);

    qreal angleTo(const QLineF &l) const;

    QLineF unitVector() const;
                     inline QLineF normalVector() const;


    IntersectType intersect(const QLineF &l, QPointF *intersectionPoint) const;

    qreal angle(const QLineF &l) const;

                     inline QPointF pointAt(qreal t) const;
    inline void translate(const QPointF &p);
    inline void translate(qreal dx, qreal dy);

                     inline QLineF translated(const QPointF &p) const;
                     inline QLineF translated(qreal dx, qreal dy) const;

    inline void setP1(const QPointF &p1);
    inline void setP2(const QPointF &p2);
    inline void setPoints(const QPointF &p1, const QPointF &p2);
    inline void setLine(qreal x1, qreal y1, qreal x2, qreal y2);

                     inline bool operator==(const QLineF &d) const;
                     inline bool operator!=(const QLineF &d) const { return !(*this == d); }

                     QLine toLine() const;

private:
    QPointF pt1, pt2;
};
template<> class QTypeInfo<QLineF > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QLineF)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QLineF >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QLineF) }; static inline const char *name() { return "QLineF"; } };





                 inline QLineF::QLineF()
{
}

                 inline QLineF::QLineF(const QPointF &apt1, const QPointF &apt2)
    : pt1(apt1), pt2(apt2)
{
}

                 inline QLineF::QLineF(qreal x1pos, qreal y1pos, qreal x2pos, qreal y2pos)
    : pt1(x1pos, y1pos), pt2(x2pos, y2pos)
{
}

                 inline qreal QLineF::x1() const
{
    return pt1.x();
}

                 inline qreal QLineF::y1() const
{
    return pt1.y();
}

                 inline qreal QLineF::x2() const
{
    return pt2.x();
}

                 inline qreal QLineF::y2() const
{
    return pt2.y();
}

                 inline bool QLineF::isNull() const
{
    return qFuzzyCompare(pt1.x(), pt2.x()) && qFuzzyCompare(pt1.y(), pt2.y());
}

                 inline QPointF QLineF::p1() const
{
    return pt1;
}

                 inline QPointF QLineF::p2() const
{
    return pt2;
}

                 inline qreal QLineF::dx() const
{
    return pt2.x() - pt1.x();
}

                 inline qreal QLineF::dy() const
{
    return pt2.y() - pt1.y();
}

                 inline QLineF QLineF::normalVector() const
{
    return QLineF(p1(), p1() + QPointF(dy(), -dx()));
}

inline void QLineF::translate(const QPointF &point)
{
    pt1 += point;
    pt2 += point;
}

inline void QLineF::translate(qreal adx, qreal ady)
{
    this->translate(QPointF(adx, ady));
}

                 inline QLineF QLineF::translated(const QPointF &p) const
{
    return QLineF(pt1 + p, pt2 + p);
}

                 inline QLineF QLineF::translated(qreal adx, qreal ady) const
{
    return translated(QPointF(adx, ady));
}

inline void QLineF::setLength(qreal len)
{
    if (isNull())
        return;
    QLineF v = unitVector();
    pt2 = QPointF(pt1.x() + v.dx() * len, pt1.y() + v.dy() * len);
}

                 inline QPointF QLineF::pointAt(qreal t) const
{
    return QPointF(pt1.x() + (pt2.x() - pt1.x()) * t, pt1.y() + (pt2.y() - pt1.y()) * t);
}

                 inline QLine QLineF::toLine() const
{
    return QLine(pt1.toPoint(), pt2.toPoint());
}


inline void QLineF::setP1(const QPointF &aP1)
{
    pt1 = aP1;
}

inline void QLineF::setP2(const QPointF &aP2)
{
    pt2 = aP2;
}

inline void QLineF::setPoints(const QPointF &aP1, const QPointF &aP2)
{
    pt1 = aP1;
    pt2 = aP2;
}

inline void QLineF::setLine(qreal aX1, qreal aY1, qreal aX2, qreal aY2)
{
    pt1 = QPointF(aX1, aY1);
    pt2 = QPointF(aX2, aY2);
}


                 inline bool QLineF::operator==(const QLineF &d) const
{
    return pt1 == d.pt1 && pt2 == d.pt2;
}




__declspec(dllimport) QDebug operator<<(QDebug d, const QLineF &p);



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QLineF &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QLineF &);
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qmatrix.h"







class QPainterPath;
class QVariant;

class __declspec(dllimport) QMatrix
{
public:
    inline explicit QMatrix(Qt::Initialization) {}
    QMatrix();
    QMatrix(qreal m11, qreal m12, qreal m21, qreal m22,
            qreal dx, qreal dy);
    QMatrix(const QMatrix &matrix);

    void setMatrix(qreal m11, qreal m12, qreal m21, qreal m22,
                   qreal dx, qreal dy);

    qreal m11() const { return _m11; }
    qreal m12() const { return _m12; }
    qreal m21() const { return _m21; }
    qreal m22() const { return _m22; }
    qreal dx() const { return _dx; }
    qreal dy() const { return _dy; }

    void map(int x, int y, int *tx, int *ty) const;
    void map(qreal x, qreal y, qreal *tx, qreal *ty) const;
    QRect mapRect(const QRect &) const;
    QRectF mapRect(const QRectF &) const;

    QPoint map(const QPoint &p) const;
    QPointF map(const QPointF&p) const;
    QLine map(const QLine &l) const;
    QLineF map(const QLineF &l) const;
    QPolygonF map(const QPolygonF &a) const;
    QPolygon map(const QPolygon &a) const;
    QRegion map(const QRegion &r) const;
    QPainterPath map(const QPainterPath &p) const;
    QPolygon mapToPolygon(const QRect &r) const;

    void reset();
    inline bool isIdentity() const;

    QMatrix &translate(qreal dx, qreal dy);
    QMatrix &scale(qreal sx, qreal sy);
    QMatrix &shear(qreal sh, qreal sv);
    QMatrix &rotate(qreal a);

    bool isInvertible() const { return !qFuzzyIsNull(_m11*_m22 - _m12*_m21); }
    qreal determinant() const { return _m11*_m22 - _m12*_m21; }

    QMatrix inverted(bool *invertible = 0) const;

    bool operator==(const QMatrix &) const;
    bool operator!=(const QMatrix &) const;

    QMatrix &operator*=(const QMatrix &);
    QMatrix operator*(const QMatrix &o) const;

    QMatrix &operator=(const QMatrix &);

    operator QVariant() const;

private:
    inline QMatrix(bool)
            : _m11(1.)
            , _m12(0.)
            , _m21(0.)
            , _m22(1.)
            , _dx(0.)
            , _dy(0.) {}
    inline QMatrix(qreal am11, qreal am12, qreal am21, qreal am22, qreal adx, qreal ady, bool)
            : _m11(am11)
            , _m12(am12)
            , _m21(am21)
            , _m22(am22)
            , _dx(adx)
            , _dy(ady) {}
    friend class QTransform;
    qreal _m11, _m12;
    qreal _m21, _m22;
    qreal _dx, _dy;
};
template<> class QTypeInfo<QMatrix > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMatrix)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QMatrix >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QMatrix) }; static inline const char *name() { return "QMatrix"; } };


inline QPoint operator*(const QPoint &p, const QMatrix &m)
{ return m.map(p); }
inline QPointF operator*(const QPointF &p, const QMatrix &m)
{ return m.map(p); }
inline QLineF operator*(const QLineF &l, const QMatrix &m)
{ return m.map(l); }
inline QLine operator*(const QLine &l, const QMatrix &m)
{ return m.map(l); }
inline QPolygon operator *(const QPolygon &a, const QMatrix &m)
{ return m.map(a); }
inline QPolygonF operator *(const QPolygonF &a, const QMatrix &m)
{ return m.map(a); }
inline QRegion operator *(const QRegion &r, const QMatrix &m)
{ return m.map(r); }
__declspec(dllimport) QPainterPath operator *(const QPainterPath &p, const QMatrix &m);

inline bool QMatrix::isIdentity() const
{
    return qFuzzyIsNull(_m11 - 1) && qFuzzyIsNull(_m22 - 1) && qFuzzyIsNull(_m12)
           && qFuzzyIsNull(_m21) && qFuzzyIsNull(_dx) && qFuzzyIsNull(_dy);
}

inline bool qFuzzyCompare(const QMatrix& m1, const QMatrix& m2)
{
    return qFuzzyCompare(m1.m11(), m2.m11())
        && qFuzzyCompare(m1.m12(), m2.m12())
        && qFuzzyCompare(m1.m21(), m2.m21())
        && qFuzzyCompare(m1.m22(), m2.m22())
        && qFuzzyCompare(m1.dx(), m2.dx())
        && qFuzzyCompare(m1.dy(), m2.dy());
}







__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QMatrix &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QMatrix &);



__declspec(dllimport) QDebug operator<<(QDebug, const QMatrix &);
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qbrush.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtransform.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtransform.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpainterpath.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpainterpath.h"
class QFont;
class QPainterPathPrivate;
struct QPainterPathPrivateDeleter;
class QPainterPathData;
class QPainterPathStrokerPrivate;
class QPen;
class QPolygonF;
class QRegion;
class QVectorPath;

class __declspec(dllimport) QPainterPath
{
public:
    enum ElementType {
        MoveToElement,
        LineToElement,
        CurveToElement,
        CurveToDataElement
    };

    class Element {
    public:
        qreal x;
        qreal y;
        ElementType type;

        bool isMoveTo() const { return type == MoveToElement; }
        bool isLineTo() const { return type == LineToElement; }
        bool isCurveTo() const { return type == CurveToElement; }

        operator QPointF () const { return QPointF(x, y); }

        bool operator==(const Element &e) const { return qFuzzyCompare(x, e.x)
            && qFuzzyCompare(y, e.y) && type == e.type; }
        inline bool operator!=(const Element &e) const { return !operator==(e); }
    };

    QPainterPath();
    explicit QPainterPath(const QPointF &startPoint);
    QPainterPath(const QPainterPath &other);
    QPainterPath &operator=(const QPainterPath &other);

    inline QPainterPath &operator=(QPainterPath &&other)
    { qSwap(d_ptr, other.d_ptr); return *this; }

    ~QPainterPath();
    inline void swap(QPainterPath &other) { d_ptr.swap(other.d_ptr); }

    void closeSubpath();

    void moveTo(const QPointF &p);
    inline void moveTo(qreal x, qreal y);

    void lineTo(const QPointF &p);
    inline void lineTo(qreal x, qreal y);

    void arcMoveTo(const QRectF &rect, qreal angle);
    inline void arcMoveTo(qreal x, qreal y, qreal w, qreal h, qreal angle);

    void arcTo(const QRectF &rect, qreal startAngle, qreal arcLength);
    inline void arcTo(qreal x, qreal y, qreal w, qreal h, qreal startAngle, qreal arcLength);

    void cubicTo(const QPointF &ctrlPt1, const QPointF &ctrlPt2, const QPointF &endPt);
    inline void cubicTo(qreal ctrlPt1x, qreal ctrlPt1y, qreal ctrlPt2x, qreal ctrlPt2y,
                        qreal endPtx, qreal endPty);
    void quadTo(const QPointF &ctrlPt, const QPointF &endPt);
    inline void quadTo(qreal ctrlPtx, qreal ctrlPty, qreal endPtx, qreal endPty);

    QPointF currentPosition() const;

    void addRect(const QRectF &rect);
    inline void addRect(qreal x, qreal y, qreal w, qreal h);
    void addEllipse(const QRectF &rect);
    inline void addEllipse(qreal x, qreal y, qreal w, qreal h);
    inline void addEllipse(const QPointF &center, qreal rx, qreal ry);
    void addPolygon(const QPolygonF &polygon);
    void addText(const QPointF &point, const QFont &f, const QString &text);
    inline void addText(qreal x, qreal y, const QFont &f, const QString &text);
    void addPath(const QPainterPath &path);
    void addRegion(const QRegion &region);

    void addRoundedRect(const QRectF &rect, qreal xRadius, qreal yRadius,
                        Qt::SizeMode mode = Qt::AbsoluteSize);
    inline void addRoundedRect(qreal x, qreal y, qreal w, qreal h,
                               qreal xRadius, qreal yRadius,
                               Qt::SizeMode mode = Qt::AbsoluteSize);

    void addRoundRect(const QRectF &rect, int xRnd, int yRnd);
    inline void addRoundRect(qreal x, qreal y, qreal w, qreal h,
                             int xRnd, int yRnd);
    inline void addRoundRect(const QRectF &rect, int roundness);
    inline void addRoundRect(qreal x, qreal y, qreal w, qreal h,
                             int roundness);

    void connectPath(const QPainterPath &path);

    bool contains(const QPointF &pt) const;
    bool contains(const QRectF &rect) const;
    bool intersects(const QRectF &rect) const;

    void translate(qreal dx, qreal dy);
    inline void translate(const QPointF &offset);

    QPainterPath translated(qreal dx, qreal dy) const;
    inline QPainterPath translated(const QPointF &offset) const;

    QRectF boundingRect() const;
    QRectF controlPointRect() const;

    Qt::FillRule fillRule() const;
    void setFillRule(Qt::FillRule fillRule);

    bool isEmpty() const;

    QPainterPath toReversed() const;
    QList<QPolygonF> toSubpathPolygons(const QMatrix &matrix = QMatrix()) const;
    QList<QPolygonF> toFillPolygons(const QMatrix &matrix = QMatrix()) const;
    QPolygonF toFillPolygon(const QMatrix &matrix = QMatrix()) const;
    QList<QPolygonF> toSubpathPolygons(const QTransform &matrix) const;
    QList<QPolygonF> toFillPolygons(const QTransform &matrix) const;
    QPolygonF toFillPolygon(const QTransform &matrix) const;

    int elementCount() const;
    QPainterPath::Element elementAt(int i) const;
    void setElementPositionAt(int i, qreal x, qreal y);

    qreal length() const;
    qreal percentAtLength(qreal t) const;
    QPointF pointAtPercent(qreal t) const;
    qreal angleAtPercent(qreal t) const;
    qreal slopeAtPercent(qreal t) const;

    bool intersects(const QPainterPath &p) const;
    bool contains(const QPainterPath &p) const;
    QPainterPath united(const QPainterPath &r) const;
    QPainterPath intersected(const QPainterPath &r) const;
    QPainterPath subtracted(const QPainterPath &r) const;
    QPainterPath subtractedInverted(const QPainterPath &r) const;

    QPainterPath simplified() const;

    bool operator==(const QPainterPath &other) const;
    bool operator!=(const QPainterPath &other) const;

    QPainterPath operator&(const QPainterPath &other) const;
    QPainterPath operator|(const QPainterPath &other) const;
    QPainterPath operator+(const QPainterPath &other) const;
    QPainterPath operator-(const QPainterPath &other) const;
    QPainterPath &operator&=(const QPainterPath &other);
    QPainterPath &operator|=(const QPainterPath &other);
    QPainterPath &operator+=(const QPainterPath &other);
    QPainterPath &operator-=(const QPainterPath &other);

private:
    QScopedPointer<QPainterPathPrivate, QPainterPathPrivateDeleter> d_ptr;

    inline void ensureData() { if (!d_ptr) ensureData_helper(); }
    void ensureData_helper();
    void detach();
    void detach_helper();
    void setDirty(bool);
    void computeBoundingRect() const;
    void computeControlPointRect() const;

    QPainterPathData *d_func() const { return reinterpret_cast<QPainterPathData *>(d_ptr.data()); }

    friend class QPainterPathData;
    friend class QPainterPathStroker;
    friend class QPainterPathStrokerPrivate;
    friend class QMatrix;
    friend class QTransform;
    friend class QVectorPath;
    friend __declspec(dllimport) const QVectorPath &qtVectorPathForPath(const QPainterPath &);


    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPainterPath &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QPainterPath &);

};

template<> class QTypeInfo<QPainterPath::Element > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPainterPath::Element)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QPainterPath::Element >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QPainterPath::Element) }; static inline const char *name() { return "QPainterPath::Element"; } };


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPainterPath &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPainterPath &);


class __declspec(dllimport) QPainterPathStroker
{
    inline QPainterPathStrokerPrivate* d_func() { return reinterpret_cast<QPainterPathStrokerPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPainterPathStrokerPrivate* d_func() const { return reinterpret_cast<const QPainterPathStrokerPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPainterPathStrokerPrivate;
public:
    QPainterPathStroker();
    explicit QPainterPathStroker(const QPen &pen);
    ~QPainterPathStroker();

    void setWidth(qreal width);
    qreal width() const;

    void setCapStyle(Qt::PenCapStyle style);
    Qt::PenCapStyle capStyle() const;

    void setJoinStyle(Qt::PenJoinStyle style);
    Qt::PenJoinStyle joinStyle() const;

    void setMiterLimit(qreal length);
    qreal miterLimit() const;

    void setCurveThreshold(qreal threshold);
    qreal curveThreshold() const;

    void setDashPattern(Qt::PenStyle);
    void setDashPattern(const QVector<qreal> &dashPattern);
    QVector<qreal> dashPattern() const;

    void setDashOffset(qreal offset);
    qreal dashOffset() const;

    QPainterPath createStroke(const QPainterPath &path) const;

private:
    QPainterPathStroker(const QPainterPathStroker &) = delete; QPainterPathStroker &operator=(const QPainterPathStroker &) = delete;

    friend class QX11PaintEngine;

    QScopedPointer<QPainterPathStrokerPrivate> d_ptr;
};

inline void QPainterPath::moveTo(qreal x, qreal y)
{
    moveTo(QPointF(x, y));
}

inline void QPainterPath::lineTo(qreal x, qreal y)
{
    lineTo(QPointF(x, y));
}

inline void QPainterPath::arcTo(qreal x, qreal y, qreal w, qreal h, qreal startAngle, qreal arcLength)
{
    arcTo(QRectF(x, y, w, h), startAngle, arcLength);
}

inline void QPainterPath::arcMoveTo(qreal x, qreal y, qreal w, qreal h, qreal angle)
{
    arcMoveTo(QRectF(x, y, w, h), angle);
}

inline void QPainterPath::cubicTo(qreal ctrlPt1x, qreal ctrlPt1y, qreal ctrlPt2x, qreal ctrlPt2y,
                                   qreal endPtx, qreal endPty)
{
    cubicTo(QPointF(ctrlPt1x, ctrlPt1y), QPointF(ctrlPt2x, ctrlPt2y),
            QPointF(endPtx, endPty));
}

inline void QPainterPath::quadTo(qreal ctrlPtx, qreal ctrlPty, qreal endPtx, qreal endPty)
{
    quadTo(QPointF(ctrlPtx, ctrlPty), QPointF(endPtx, endPty));
}

inline void QPainterPath::addEllipse(qreal x, qreal y, qreal w, qreal h)
{
    addEllipse(QRectF(x, y, w, h));
}

inline void QPainterPath::addEllipse(const QPointF &center, qreal rx, qreal ry)
{
    addEllipse(QRectF(center.x() - rx, center.y() - ry, 2 * rx, 2 * ry));
}

inline void QPainterPath::addRect(qreal x, qreal y, qreal w, qreal h)
{
    addRect(QRectF(x, y, w, h));
}

inline void QPainterPath::addRoundedRect(qreal x, qreal y, qreal w, qreal h,
                                         qreal xRadius, qreal yRadius,
                                         Qt::SizeMode mode)
{
    addRoundedRect(QRectF(x, y, w, h), xRadius, yRadius, mode);
}

inline void QPainterPath::addRoundRect(qreal x, qreal y, qreal w, qreal h,
                                       int xRnd, int yRnd)
{
    addRoundRect(QRectF(x, y, w, h), xRnd, yRnd);
}

inline void QPainterPath::addRoundRect(const QRectF &rect,
                                       int roundness)
{
    int xRnd = roundness;
    int yRnd = roundness;
    if (rect.width() > rect.height())
        xRnd = int(roundness * rect.height()/rect.width());
    else
        yRnd = int(roundness * rect.width()/rect.height());
    addRoundRect(rect, xRnd, yRnd);
}

inline void QPainterPath::addRoundRect(qreal x, qreal y, qreal w, qreal h,
                                       int roundness)
{
    addRoundRect(QRectF(x, y, w, h), roundness);
}

inline void QPainterPath::addText(qreal x, qreal y, const QFont &f, const QString &text)
{
    addText(QPointF(x, y), f, text);
}

inline void QPainterPath::translate(const QPointF &offset)
{ translate(offset.x(), offset.y()); }

inline QPainterPath QPainterPath::translated(const QPointF &offset) const
{ return translated(offset.x(), offset.y()); }



__declspec(dllimport) QDebug operator<<(QDebug, const QPainterPath &);
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtransform.h"
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtransform.h"
class QVariant;

class __declspec(dllimport) QTransform
{
public:
    enum TransformationType {
        TxNone = 0x00,
        TxTranslate = 0x01,
        TxScale = 0x02,
        TxRotate = 0x04,
        TxShear = 0x08,
        TxProject = 0x10
    };

    inline explicit QTransform(Qt::Initialization) : affine(Qt::Uninitialized) {}
    QTransform();
    QTransform(qreal h11, qreal h12, qreal h13,
               qreal h21, qreal h22, qreal h23,
               qreal h31, qreal h32, qreal h33 = 1.0);
    QTransform(qreal h11, qreal h12, qreal h21,
               qreal h22, qreal dx, qreal dy);
    explicit QTransform(const QMatrix &mtx);

    bool isAffine() const;
    bool isIdentity() const;
    bool isInvertible() const;
    bool isScaling() const;
    bool isRotating() const;
    bool isTranslating() const;

    TransformationType type() const;

    inline qreal determinant() const;
    qreal det() const;

    qreal m11() const;
    qreal m12() const;
    qreal m13() const;
    qreal m21() const;
    qreal m22() const;
    qreal m23() const;
    qreal m31() const;
    qreal m32() const;
    qreal m33() const;
    qreal dx() const;
    qreal dy() const;

    void setMatrix(qreal m11, qreal m12, qreal m13,
                   qreal m21, qreal m22, qreal m23,
                   qreal m31, qreal m32, qreal m33);

    QTransform inverted(bool *invertible = 0) const;
    QTransform adjoint() const;
    QTransform transposed() const;

    QTransform &translate(qreal dx, qreal dy);
    QTransform &scale(qreal sx, qreal sy);
    QTransform &shear(qreal sh, qreal sv);
    QTransform &rotate(qreal a, Qt::Axis axis = Qt::ZAxis);
    QTransform &rotateRadians(qreal a, Qt::Axis axis = Qt::ZAxis);

    static bool squareToQuad(const QPolygonF &square, QTransform &result);
    static bool quadToSquare(const QPolygonF &quad, QTransform &result);
    static bool quadToQuad(const QPolygonF &one,
                           const QPolygonF &two,
                           QTransform &result);

    bool operator==(const QTransform &) const;
    bool operator!=(const QTransform &) const;

    QTransform &operator*=(const QTransform &);
    QTransform operator*(const QTransform &o) const;

    QTransform &operator=(const QTransform &);

    operator QVariant() const;

    void reset();
    QPoint map(const QPoint &p) const;
    QPointF map(const QPointF &p) const;
    QLine map(const QLine &l) const;
    QLineF map(const QLineF &l) const;
    QPolygonF map(const QPolygonF &a) const;
    QPolygon map(const QPolygon &a) const;
    QRegion map(const QRegion &r) const;
    QPainterPath map(const QPainterPath &p) const;
    QPolygon mapToPolygon(const QRect &r) const;
    QRect mapRect(const QRect &) const;
    QRectF mapRect(const QRectF &) const;
    void map(int x, int y, int *tx, int *ty) const;
    void map(qreal x, qreal y, qreal *tx, qreal *ty) const;

    const QMatrix &toAffine() const;

    QTransform &operator*=(qreal div);
    QTransform &operator/=(qreal div);
    QTransform &operator+=(qreal div);
    QTransform &operator-=(qreal div);

    static QTransform fromTranslate(qreal dx, qreal dy);
    static QTransform fromScale(qreal dx, qreal dy);

private:
    inline QTransform(qreal h11, qreal h12, qreal h13,
                      qreal h21, qreal h22, qreal h23,
                      qreal h31, qreal h32, qreal h33, bool)
        : affine(h11, h12, h21, h22, h31, h32, true)
        , m_13(h13), m_23(h23), m_33(h33)
        , m_type(TxNone)
        , m_dirty(TxProject) {}
    inline QTransform(bool)
        : affine(true)
        , m_13(0), m_23(0), m_33(1)
        , m_type(TxNone)
        , m_dirty(TxNone) {}
    inline TransformationType inline_type() const;
    QMatrix affine;
    qreal m_13;
    qreal m_23;
    qreal m_33;

    mutable uint m_type : 5;
    mutable uint m_dirty : 5;

    class Private;
    Private *d;
};
template<> class QTypeInfo<QTransform > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTransform)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTransform >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTransform) }; static inline const char *name() { return "QTransform"; } };


inline QTransform::TransformationType QTransform::inline_type() const
{
    if (m_dirty == TxNone)
        return static_cast<TransformationType>(m_type);
    return type();
}

inline bool QTransform::isAffine() const
{
    return inline_type() < TxProject;
}
inline bool QTransform::isIdentity() const
{
    return inline_type() == TxNone;
}

inline bool QTransform::isInvertible() const
{
    return !qFuzzyIsNull(determinant());
}

inline bool QTransform::isScaling() const
{
    return type() >= TxScale;
}
inline bool QTransform::isRotating() const
{
    return inline_type() >= TxRotate;
}

inline bool QTransform::isTranslating() const
{
    return inline_type() >= TxTranslate;
}

inline qreal QTransform::determinant() const
{
    return affine._m11*(m_33*affine._m22-affine._dy*m_23) -
        affine._m21*(m_33*affine._m12-affine._dy*m_13)+affine._dx*(m_23*affine._m12-affine._m22*m_13);
}
inline qreal QTransform::det() const
{
    return determinant();
}
inline qreal QTransform::m11() const
{
    return affine._m11;
}
inline qreal QTransform::m12() const
{
    return affine._m12;
}
inline qreal QTransform::m13() const
{
    return m_13;
}
inline qreal QTransform::m21() const
{
    return affine._m21;
}
inline qreal QTransform::m22() const
{
    return affine._m22;
}
inline qreal QTransform::m23() const
{
    return m_23;
}
inline qreal QTransform::m31() const
{
    return affine._dx;
}
inline qreal QTransform::m32() const
{
    return affine._dy;
}
inline qreal QTransform::m33() const
{
    return m_33;
}
inline qreal QTransform::dx() const
{
    return affine._dx;
}
inline qreal QTransform::dy() const
{
    return affine._dy;
}

inline QTransform &QTransform::operator*=(qreal num)
{
    if (num == 1.)
        return *this;
    affine._m11 *= num;
    affine._m12 *= num;
    m_13 *= num;
    affine._m21 *= num;
    affine._m22 *= num;
    m_23 *= num;
    affine._dx *= num;
    affine._dy *= num;
    m_33 *= num;
    if (m_dirty < TxScale)
        m_dirty = TxScale;
    return *this;
}
inline QTransform &QTransform::operator/=(qreal div)
{
    if (div == 0)
        return *this;
    div = 1/div;
    return operator*=(div);
}
inline QTransform &QTransform::operator+=(qreal num)
{
    if (num == 0)
        return *this;
    affine._m11 += num;
    affine._m12 += num;
    m_13 += num;
    affine._m21 += num;
    affine._m22 += num;
    m_23 += num;
    affine._dx += num;
    affine._dy += num;
    m_33 += num;
    m_dirty = TxProject;
    return *this;
}
inline QTransform &QTransform::operator-=(qreal num)
{
    if (num == 0)
        return *this;
    affine._m11 -= num;
    affine._m12 -= num;
    m_13 -= num;
    affine._m21 -= num;
    affine._m22 -= num;
    m_23 -= num;
    affine._dx -= num;
    affine._dy -= num;
    m_33 -= num;
    m_dirty = TxProject;
    return *this;
}

inline bool qFuzzyCompare(const QTransform& t1, const QTransform& t2)
{
    return qFuzzyCompare(t1.m11(), t2.m11())
        && qFuzzyCompare(t1.m12(), t2.m12())
        && qFuzzyCompare(t1.m13(), t2.m13())
        && qFuzzyCompare(t1.m21(), t2.m21())
        && qFuzzyCompare(t1.m22(), t2.m22())
        && qFuzzyCompare(t1.m23(), t2.m23())
        && qFuzzyCompare(t1.m31(), t2.m31())
        && qFuzzyCompare(t1.m32(), t2.m32())
        && qFuzzyCompare(t1.m33(), t2.m33());
}




__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTransform &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QTransform &);



__declspec(dllimport) QDebug operator<<(QDebug, const QTransform &);




inline QPoint operator*(const QPoint &p, const QTransform &m)
{ return m.map(p); }
inline QPointF operator*(const QPointF &p, const QTransform &m)
{ return m.map(p); }
inline QLineF operator*(const QLineF &l, const QTransform &m)
{ return m.map(l); }
inline QLine operator*(const QLine &l, const QTransform &m)
{ return m.map(l); }
inline QPolygon operator *(const QPolygon &a, const QTransform &m)
{ return m.map(a); }
inline QPolygonF operator *(const QPolygonF &a, const QTransform &m)
{ return m.map(a); }
inline QRegion operator *(const QRegion &r, const QTransform &m)
{ return m.map(r); }
inline QPainterPath operator *(const QPainterPath &p, const QTransform &m)
{ return m.map(p); }

inline QTransform operator *(const QTransform &a, qreal n)
{ QTransform t(a); t *= n; return t; }
inline QTransform operator /(const QTransform &a, qreal n)
{ QTransform t(a); t /= n; return t; }
inline QTransform operator +(const QTransform &a, qreal n)
{ QTransform t(a); t += n; return t; }
inline QTransform operator -(const QTransform &a, qreal n)
{ QTransform t(a); t -= n; return t; }
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qbrush.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qimage.h"
#line 59 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qimage.h"
class QIODevice;
class QStringList;
class QMatrix;
class QTransform;
class QVariant;
template <class T> class QList;
template <class T> class QVector;

struct QImageData;
class QImageDataMisc;
#line 90 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qimage.h"
typedef void (*QImageCleanupFunction)(void*);

class __declspec(dllimport) QImage : public QPaintDevice
{
public:
    enum InvertMode { InvertRgb, InvertRgba };
    enum Format {
        Format_Invalid,
        Format_Mono,
        Format_MonoLSB,
        Format_Indexed8,
        Format_RGB32,
        Format_ARGB32,
        Format_ARGB32_Premultiplied,
        Format_RGB16,
        Format_ARGB8565_Premultiplied,
        Format_RGB666,
        Format_ARGB6666_Premultiplied,
        Format_RGB555,
        Format_ARGB8555_Premultiplied,
        Format_RGB888,
        Format_RGB444,
        Format_ARGB4444_Premultiplied,
        Format_RGBX8888,
        Format_RGBA8888,
        Format_RGBA8888_Premultiplied,
#line 127 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qimage.h"
        NImageFormats

    };

    QImage();
    QImage(const QSize &size, Format format);
    QImage(int width, int height, Format format);
    QImage(uchar *data, int width, int height, Format format, QImageCleanupFunction cleanupFunction = 0, void *cleanupInfo = 0);
    QImage(const uchar *data, int width, int height, Format format, QImageCleanupFunction cleanupFunction = 0, void *cleanupInfo = 0);
    QImage(uchar *data, int width, int height, int bytesPerLine, Format format, QImageCleanupFunction cleanupFunction = 0, void *cleanupInfo = 0);
    QImage(const uchar *data, int width, int height, int bytesPerLine, Format format, QImageCleanupFunction cleanupFunction = 0, void *cleanupInfo = 0);


    explicit QImage(const char * const xpm[]);

    explicit QImage(const QString &fileName, const char *format = 0);

    QImage(const QImage &);

    inline QImage(QImage &&other)
        : QPaintDevice(), d(0)
    { qSwap(d, other.d); }

    ~QImage();

    QImage &operator=(const QImage &);

    inline QImage &operator=(QImage &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QImage &other) { qSwap(d, other.d); }

    bool isNull() const;

    int devType() const;

    bool operator==(const QImage &) const;
    bool operator!=(const QImage &) const;
    operator QVariant() const;
    void detach();
    bool isDetached() const;

    QImage copy(const QRect &rect = QRect()) const;
    inline QImage copy(int x, int y, int w, int h) const
        { return copy(QRect(x, y, w, h)); }

    Format format() const;
#line 186 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qimage.h"
    QImage convertToFormat(Format f, Qt::ImageConversionFlags flags = Qt::AutoColor) const ;

    QImage convertToFormat(Format f, const QVector<QRgb> &colorTable, Qt::ImageConversionFlags flags = Qt::AutoColor) const ;

    int width() const;
    int height() const;
    QSize size() const;
    QRect rect() const;

    int depth() const;
    int colorCount() const;
    int bitPlaneCount() const;

    QRgb color(int i) const;
    void setColor(int i, QRgb c);
    void setColorCount(int);

    bool allGray() const;
    bool isGrayscale() const;

    uchar *bits();
    const uchar *bits() const;
    const uchar *constBits() const;

    int byteCount() const;

    uchar *scanLine(int);
    const uchar *scanLine(int) const;
    const uchar *constScanLine(int) const;
    int bytesPerLine() const;

    bool valid(int x, int y) const;
    bool valid(const QPoint &pt) const;

    int pixelIndex(int x, int y) const;
    int pixelIndex(const QPoint &pt) const;

    QRgb pixel(int x, int y) const;
    QRgb pixel(const QPoint &pt) const;

    void setPixel(int x, int y, uint index_or_rgb);
    void setPixel(const QPoint &pt, uint index_or_rgb);

    QVector<QRgb> colorTable() const;
    void setColorTable(const QVector<QRgb> colors);

    qreal devicePixelRatio() const;
    void setDevicePixelRatio(qreal scaleFactor);

    void fill(uint pixel);
    void fill(const QColor &color);
    void fill(Qt::GlobalColor color);


    bool hasAlphaChannel() const;
    void setAlphaChannel(const QImage &alphaChannel);
    QImage alphaChannel() const;
    QImage createAlphaMask(Qt::ImageConversionFlags flags = Qt::AutoColor) const;

    QImage createHeuristicMask(bool clipTight = true) const;

    QImage createMaskFromColor(QRgb color, Qt::MaskMode mode = Qt::MaskInColor) const;

    inline QImage scaled(int w, int h, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
                        Qt::TransformationMode mode = Qt::FastTransformation) const
        { return scaled(QSize(w, h), aspectMode, mode); }
    QImage scaled(const QSize &s, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
                 Qt::TransformationMode mode = Qt::FastTransformation) const;
    QImage scaledToWidth(int w, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QImage scaledToHeight(int h, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QImage transformed(const QMatrix &matrix, Qt::TransformationMode mode = Qt::FastTransformation) const;
    static QMatrix trueMatrix(const QMatrix &, int w, int h);
    QImage transformed(const QTransform &matrix, Qt::TransformationMode mode = Qt::FastTransformation) const;
    static QTransform trueMatrix(const QTransform &, int w, int h);
#line 270 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qimage.h"
    QImage mirrored(bool horizontally = false, bool vertically = true) const;
    QImage rgbSwapped() const;

    void invertPixels(InvertMode = InvertRgb);


    bool load(QIODevice *device, const char* format);
    bool load(const QString &fileName, const char* format=0);
    bool loadFromData(const uchar *buf, int len, const char *format = 0);
    inline bool loadFromData(const QByteArray &data, const char* aformat=0)
        { return loadFromData(reinterpret_cast<const uchar *>(data.constData()), data.size(), aformat); }

    bool save(const QString &fileName, const char* format=0, int quality=-1) const;
    bool save(QIODevice *device, const char* format=0, int quality=-1) const;

    static QImage fromData(const uchar *data, int size, const char *format = 0);
    inline static QImage fromData(const QByteArray &data, const char *format = 0)
        { return fromData(reinterpret_cast<const uchar *>(data.constData()), data.size(), format); }




    qint64 cacheKey() const;

    QPaintEngine *paintEngine() const;


    int dotsPerMeterX() const;
    int dotsPerMeterY() const;
    void setDotsPerMeterX(int);
    void setDotsPerMeterY(int);
    QPoint offset() const;
    void setOffset(const QPoint&);

    QStringList textKeys() const;
    QString text(const QString &key = QString()) const;
    void setText(const QString &key, const QString &value);
#line 322 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qimage.h"
protected:
    virtual int metric(PaintDeviceMetric metric) const;
    QImage mirrored_helper(bool horizontal, bool vertical) const;
    QImage rgbSwapped_helper() const;
    void mirrored_inplace(bool horizontal, bool vertical);
    void rgbSwapped_inplace();
    QImage convertToFormat_helper(Format format, Qt::ImageConversionFlags flags) const;
    bool convertToFormat_inplace(Format format, Qt::ImageConversionFlags flags);

private:
    friend class QWSOnScreenSurface;
    QImageData *d;

    friend class QRasterPlatformPixmap;
    friend class QBlittablePlatformPixmap;
    friend class QPixmapCacheEntry;

public:
    typedef QImageData * DataPtr;
    inline DataPtr &data_ptr() { return d; }
};

template<> class QTypeInfo<QImage > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QImage)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QImage >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QImage) }; static inline const char *name() { return "QImage"; } }; template <> inline void qSwap<QImage>(QImage &value1, QImage &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QImage >(::QImage &value1, ::QImage &value2) { value1.swap(value2); } }



inline bool QImage::valid(const QPoint &pt) const { return valid(pt.x(), pt.y()); }
inline int QImage::pixelIndex(const QPoint &pt) const { return pixelIndex(pt.x(), pt.y());}
inline QRgb QImage::pixel(const QPoint &pt) const { return pixel(pt.x(), pt.y()); }
inline void QImage::setPixel(const QPoint &pt, uint index_or_rgb) { setPixel(pt.x(), pt.y(), index_or_rgb); }
#line 458 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qimage.h"
__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QImage &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QImage &);



__declspec(dllimport) QDebug operator<<(QDebug, const QImage &);
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qbrush.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpixmap.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpixmap.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qshareddata.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qshareddata.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qshareddata.h"





template <class T> class QSharedDataPointer;

class __declspec(dllimport) QSharedData
{
public:
    mutable QAtomicInt ref;

    inline QSharedData() : ref(0) { }
    inline QSharedData(const QSharedData &) : ref(0) { }

private:

    QSharedData &operator=(const QSharedData &);
};

template <class T> class QSharedDataPointer
{
public:
    typedef T Type;
    typedef T *pointer;

    inline void detach() { if (d && d->ref.load() != 1) detach_helper(); }
    inline T &operator*() { detach(); return *d; }
    inline const T &operator*() const { return *d; }
    inline T *operator->() { detach(); return d; }
    inline const T *operator->() const { return d; }
    inline operator T *() { detach(); return d; }
    inline operator const T *() const { return d; }
    inline T *data() { detach(); return d; }
    inline const T *data() const { return d; }
    inline const T *constData() const { return d; }

    inline bool operator==(const QSharedDataPointer<T> &other) const { return d == other.d; }
    inline bool operator!=(const QSharedDataPointer<T> &other) const { return d != other.d; }

    inline QSharedDataPointer() { d = 0; }
    inline ~QSharedDataPointer() { if (d && !d->ref.deref()) delete d; }

    explicit QSharedDataPointer(T *data);
    inline QSharedDataPointer(const QSharedDataPointer<T> &o) : d(o.d) { if (d) d->ref.ref(); }
    inline QSharedDataPointer<T> & operator=(const QSharedDataPointer<T> &o) {
        if (o.d != d) {
            if (o.d)
                o.d->ref.ref();
            T *old = d;
            d = o.d;
            if (old && !old->ref.deref())
                delete old;
        }
        return *this;
    }
    inline QSharedDataPointer &operator=(T *o) {
        if (o != d) {
            if (o)
                o->ref.ref();
            T *old = d;
            d = o;
            if (old && !old->ref.deref())
                delete old;
        }
        return *this;
    }

    QSharedDataPointer(QSharedDataPointer &&o) : d(o.d) { o.d = 0; }
    inline QSharedDataPointer<T> &operator=(QSharedDataPointer<T> &&other)
    { qSwap(d, other.d); return *this; }


    inline bool operator!() const { return !d; }

    inline void swap(QSharedDataPointer &other)
    { qSwap(d, other.d); }

protected:
    T *clone();

private:
    void detach_helper();

    T *d;
};

template <class T> class QExplicitlySharedDataPointer
{
public:
    typedef T Type;
    typedef T *pointer;

    inline T &operator*() const { return *d; }
    inline T *operator->() { return d; }
    inline T *operator->() const { return d; }
    inline T *data() const { return d; }
    inline const T *constData() const { return d; }

    inline void detach() { if (d && d->ref.load() != 1) detach_helper(); }

    inline void reset()
    {
        if(d && !d->ref.deref())
            delete d;

        d = 0;
    }

    inline operator bool () const { return d != 0; }

    inline bool operator==(const QExplicitlySharedDataPointer<T> &other) const { return d == other.d; }
    inline bool operator!=(const QExplicitlySharedDataPointer<T> &other) const { return d != other.d; }
    inline bool operator==(const T *ptr) const { return d == ptr; }
    inline bool operator!=(const T *ptr) const { return d != ptr; }

    inline QExplicitlySharedDataPointer() { d = 0; }
    inline ~QExplicitlySharedDataPointer() { if (d && !d->ref.deref()) delete d; }

    explicit QExplicitlySharedDataPointer(T *data);
    inline QExplicitlySharedDataPointer(const QExplicitlySharedDataPointer<T> &o) : d(o.d) { if (d) d->ref.ref(); }

    template<class X>
    inline QExplicitlySharedDataPointer(const QExplicitlySharedDataPointer<X> &o) : d(static_cast<T *>(o.data()))
    {
        if(d)
            d->ref.ref();
    }

    inline QExplicitlySharedDataPointer<T> & operator=(const QExplicitlySharedDataPointer<T> &o) {
        if (o.d != d) {
            if (o.d)
                o.d->ref.ref();
            T *old = d;
            d = o.d;
            if (old && !old->ref.deref())
                delete old;
        }
        return *this;
    }
    inline QExplicitlySharedDataPointer &operator=(T *o) {
        if (o != d) {
            if (o)
                o->ref.ref();
            T *old = d;
            d = o;
            if (old && !old->ref.deref())
                delete old;
        }
        return *this;
    }

    inline QExplicitlySharedDataPointer(QExplicitlySharedDataPointer &&o) : d(o.d) { o.d = 0; }
    inline QExplicitlySharedDataPointer<T> &operator=(QExplicitlySharedDataPointer<T> &&other)
    { qSwap(d, other.d); return *this; }


    inline bool operator!() const { return !d; }

    inline void swap(QExplicitlySharedDataPointer &other)
    { qSwap(d, other.d); }

protected:
    T *clone();

private:
    void detach_helper();

    T *d;
};

template <class T>
inline QSharedDataPointer<T>::QSharedDataPointer(T *adata) : d(adata)
{ if (d) d->ref.ref(); }

template <class T>
inline T *QSharedDataPointer<T>::clone()
{
    return new T(*d);
}

template <class T>
inline void QSharedDataPointer<T>::detach_helper()
{
    T *x = clone();
    x->ref.ref();
    if (!d->ref.deref())
        delete d;
    d = x;
}

template <class T>
inline T *QExplicitlySharedDataPointer<T>::clone()
{
    return new T(*d);
}

template <class T>
inline void QExplicitlySharedDataPointer<T>::detach_helper()
{
    T *x = clone();
    x->ref.ref();
    if (!d->ref.deref())
        delete d;
    d = x;
}

template <class T>
inline QExplicitlySharedDataPointer<T>::QExplicitlySharedDataPointer(T *adata) : d(adata)
{ if (d) d->ref.ref(); }

template <class T>
inline void qSwap(QSharedDataPointer<T> &p1, QSharedDataPointer<T> &p2)
{ p1.swap(p2); }

template <class T>
inline void qSwap(QExplicitlySharedDataPointer<T> &p1, QExplicitlySharedDataPointer<T> &p2)
{ p1.swap(p2); }


namespace std {
    template <class T>
    inline void swap(::QSharedDataPointer<T> &p1, ::QSharedDataPointer<T> &p2)
    { p1.swap(p2); }

    template <class T>
    inline void swap(::QExplicitlySharedDataPointer<T> &p1, ::QExplicitlySharedDataPointer<T> &p2)
    { p1.swap(p2); }
}


template<typename T> class QTypeInfo<QSharedDataPointer<T> > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QSharedDataPointer<T>)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QSharedDataPointer<T> >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QSharedDataPointer<T>) }; static inline const char *name() { return "QSharedDataPointer<T>"; } };
template<typename T> class QTypeInfo<QExplicitlySharedDataPointer<T> > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QExplicitlySharedDataPointer<T>)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QExplicitlySharedDataPointer<T> >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QExplicitlySharedDataPointer<T>) }; static inline const char *name() { return "QExplicitlySharedDataPointer<T>"; } };
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer.h"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h"
#line 64 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 64 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h"
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h"
#pragma warning(push)
#pragma warning(disable: 4311)
#pragma warning(disable: 4127)




class QBitArray;
class QByteArray;
class QString;
class QStringRef;
class QLatin1String;

inline uint qHash(char key, uint seed = 0) throw() { return uint(key) ^ seed; }
inline uint qHash(uchar key, uint seed = 0) throw() { return uint(key) ^ seed; }
inline uint qHash(signed char key, uint seed = 0) throw() { return uint(key) ^ seed; }
inline uint qHash(ushort key, uint seed = 0) throw() { return uint(key) ^ seed; }
inline uint qHash(short key, uint seed = 0) throw() { return uint(key) ^ seed; }
inline uint qHash(uint key, uint seed = 0) throw() { return key ^ seed; }
inline uint qHash(int key, uint seed = 0) throw() { return uint(key) ^ seed; }
inline uint qHash(ulong key, uint seed = 0) throw()
{
    if (sizeof(ulong) > sizeof(uint)) {
        return uint(((key >> (8 * sizeof(uint) - 1)) ^ key) & (~0U)) ^ seed;
    } else {
        return uint(key & (~0U)) ^ seed;
    }
}
inline uint qHash(long key, uint seed = 0) throw() { return qHash(ulong(key), seed); }
inline uint qHash(quint64 key, uint seed = 0) throw()
{
    if (sizeof(quint64) > sizeof(uint)) {
        return uint(((key >> (8 * sizeof(uint) - 1)) ^ key) & (~0U)) ^ seed;
    } else {
        return uint(key & (~0U)) ^ seed;
    }
}
inline uint qHash(qint64 key, uint seed = 0) throw() { return qHash(quint64(key), seed); }
__declspec(dllimport) uint qHash(float key, uint seed = 0) throw();
__declspec(dllimport) uint qHash(double key, uint seed = 0) throw();

__declspec(dllimport) uint qHash(long double key, uint seed = 0) throw();

inline uint qHash(QChar key, uint seed = 0) throw() { return qHash(key.unicode(), seed); }
__declspec(dllimport) uint qHash(const QByteArray &key, uint seed = 0) throw();
__declspec(dllimport) uint qHash(const QString &key, uint seed = 0) throw();
__declspec(dllimport) uint qHash(const QStringRef &key, uint seed = 0) throw();
__declspec(dllimport) uint qHash(const QBitArray &key, uint seed = 0) throw();
__declspec(dllimport) uint qHash(QLatin1String key, uint seed = 0) throw();
__declspec(dllimport) uint qt_hash(const QString &key) throw();
__declspec(dllimport) uint qt_hash(const QStringRef &key) throw();

template <class T> inline uint qHash(const T *key, uint seed = 0) throw()
{
    return qHash(reinterpret_cast<quintptr>(key), seed);
}
template<typename T> inline uint qHash(const T &t, uint seed)

{ return (qHash(t) ^ seed); }

template <typename T1, typename T2> inline uint qHash(const QPair<T1, T2> &key, uint seed = 0)

{
    uint h1 = qHash(key.first, seed);
    uint h2 = qHash(key.second, seed);
    return ((h1 << 16) | (h1 >> 16)) ^ h2 ^ seed;
}

struct __declspec(dllimport) QHashData
{
    struct Node {
        Node *next;
        uint h;
    };

    Node *fakeNext;
    Node **buckets;
    QtPrivate::RefCount ref;
    int size;
    int nodeSize;
    short userNumBits;
    short numBits;
    int numBuckets;
    uint seed;
    uint sharable : 1;
    uint strictAlignment : 1;
    uint reserved : 30;

    void *allocateNode(int nodeAlign);
    void freeNode(void *node);
    QHashData *detach_helper(void (*node_duplicate)(Node *, void *), void (*node_delete)(Node *),
                             int nodeSize, int nodeAlign);
    bool willGrow();
    void hasShrunk();
    void rehash(int hint);
    void free_helper(void (*node_delete)(Node *));
    Node *firstNode();




    static Node *nextNode(Node *node);
    static Node *previousNode(Node *node);

    static const QHashData shared_null;
};

inline bool QHashData::willGrow()
{
    if (size >= numBuckets) {
        rehash(numBits + 1);
        return true;
    } else {
        return false;
    }
}

inline void QHashData::hasShrunk()
{
    if (size <= (numBuckets >> 3) && numBits > userNumBits) {
        try {
            rehash(qMax(int(numBits) - 2, int(userNumBits)));
        } catch (const std::bad_alloc &) {

        }
    }
}

inline QHashData::Node *QHashData::firstNode()
{
    Node *e = reinterpret_cast<Node *>(this);
    Node **bucket = buckets;
    int n = numBuckets;
    while (n--) {
        if (*bucket != e)
            return *bucket;
        ++bucket;
    }
    return e;
}

struct QHashDummyValue
{
};

inline bool operator==(const QHashDummyValue & , const QHashDummyValue & )
{
    return true;
}

template<> class QTypeInfo<QHashDummyValue > { public: enum { isComplex = (((Q_MOVABLE_TYPE | Q_DUMMY_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE | Q_DUMMY_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QHashDummyValue)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QHashDummyValue >::value, isDummy = (((Q_MOVABLE_TYPE | Q_DUMMY_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QHashDummyValue) }; static inline const char *name() { return "QHashDummyValue"; } };

template <class Key, class T>
struct QHashNode
{
    QHashNode *next;
    const uint h;
    const Key key;
    T value;

    inline QHashNode(const Key &key0, const T &value0, uint hash, QHashNode *n)
        : next(n), h(hash), key(key0), value(value0) {}
    inline bool same_key(uint h0, const Key &key0) const { return h0 == h && key0 == key; }

private:
    QHashNode(const QHashNode &) = delete; QHashNode &operator=(const QHashNode &) = delete;
};

template <class Key, class T>
struct QHashDummyNode
{
    QHashNode<Key, T> *next;
    const uint h;
    const Key key;

    inline QHashDummyNode(const Key &key0, uint hash, QHashNode<Key, T> *n) : next(n), h(hash), key(key0) {}

private:
    QHashDummyNode(const QHashDummyNode &) = delete; QHashDummyNode &operator=(const QHashDummyNode &) = delete;
};
#line 280 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h"
template <class Key, class T>
class QHash
{
    typedef QHashDummyNode<Key, T> DummyNode;
    typedef QHashNode<Key, T> Node;

    union {
        QHashData *d;
        QHashNode<Key, T> *e;
    };

    static inline Node *concrete(QHashData::Node *node) {
        return reinterpret_cast<Node *>(node);
    }

    static inline int alignOfNode() { return qMax<int>(sizeof(void*), __alignof(Node)); }
    static inline int alignOfDummyNode() { return qMax<int>(sizeof(void*), __alignof(DummyNode)); }

public:
    inline QHash() : d(const_cast<QHashData *>(&QHashData::shared_null)) { }
#line 309 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h"
    inline QHash(const QHash<Key, T> &other) : d(other.d) { d->ref.ref(); if (!d->sharable) detach(); }
    inline ~QHash() { if (!d->ref.deref()) freeData(d); }

    QHash<Key, T> &operator=(const QHash<Key, T> &other);

    inline QHash(QHash<Key, T> &&other) : d(other.d) { other.d = const_cast<QHashData *>(&QHashData::shared_null); }
    inline QHash<Key, T> &operator=(QHash<Key, T> &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QHash<Key, T> &other) { qSwap(d, other.d); }

    bool operator==(const QHash<Key, T> &other) const;
    inline bool operator!=(const QHash<Key, T> &other) const { return !(*this == other); }

    inline int size() const { return d->size; }

    inline bool isEmpty() const { return d->size == 0; }

    inline int capacity() const { return d->numBuckets; }
    void reserve(int size);
    inline void squeeze() { reserve(1); }

    inline void detach() { if (d->ref.isShared()) detach_helper(); }
    inline bool isDetached() const { return !d->ref.isShared(); }

    inline void setSharable(bool sharable) { if (!sharable) detach(); if (d != &QHashData::shared_null) d->sharable = sharable; }

    inline bool isSharedWith(const QHash<Key, T> &other) const { return d == other.d; }

    void clear();

    int remove(const Key &key);
    T take(const Key &key);

    bool contains(const Key &key) const;
    const Key key(const T &value) const;
    const Key key(const T &value, const Key &defaultKey) const;
    const T value(const Key &key) const;
    const T value(const Key &key, const T &defaultValue) const;
    T &operator[](const Key &key);
    const T operator[](const Key &key) const;

    QList<Key> uniqueKeys() const;
    QList<Key> keys() const;
    QList<Key> keys(const T &value) const;
    QList<T> values() const;
    QList<T> values(const Key &key) const;
    int count(const Key &key) const;

    class const_iterator;

    class iterator
    {
        friend class const_iterator;
        friend class QHash<Key, T>;
        QHashData::Node *i;

    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;

        inline iterator() : i(0) { }
        explicit inline iterator(void *node) : i(reinterpret_cast<QHashData::Node *>(node)) { }

        inline const Key &key() const { return concrete(i)->key; }
        inline T &value() const { return concrete(i)->value; }
        inline T &operator*() const { return concrete(i)->value; }
        inline T *operator->() const { return &concrete(i)->value; }
        inline bool operator==(const iterator &o) const { return i == o.i; }
        inline bool operator!=(const iterator &o) const { return i != o.i; }

        inline iterator &operator++() {
            i = QHashData::nextNode(i);
            return *this;
        }
        inline iterator operator++(int) {
            iterator r = *this;
            i = QHashData::nextNode(i);
            return r;
        }
        inline iterator &operator--() {
            i = QHashData::previousNode(i);
            return *this;
        }
        inline iterator operator--(int) {
            iterator r = *this;
            i = QHashData::previousNode(i);
            return r;
        }
        inline iterator operator+(int j) const
        { iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
        inline iterator operator-(int j) const { return operator+(-j); }
        inline iterator &operator+=(int j) { return *this = *this + j; }
        inline iterator &operator-=(int j) { return *this = *this - j; }


    public:
        inline bool operator==(const const_iterator &o) const
            { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const
            { return i != o.i; }

    };
    friend class iterator;

    class const_iterator
    {
        friend class iterator;
        QHashData::Node *i;

    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef const T *pointer;
        typedef const T &reference;

        inline const_iterator() : i(0) { }
        explicit inline const_iterator(void *node)
            : i(reinterpret_cast<QHashData::Node *>(node)) { }



        inline const_iterator(const iterator &o)

        { i = o.i; }

        inline const Key &key() const { return concrete(i)->key; }
        inline const T &value() const { return concrete(i)->value; }
        inline const T &operator*() const { return concrete(i)->value; }
        inline const T *operator->() const { return &concrete(i)->value; }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }

        inline const_iterator &operator++() {
            i = QHashData::nextNode(i);
            return *this;
        }
        inline const_iterator operator++(int) {
            const_iterator r = *this;
            i = QHashData::nextNode(i);
            return r;
        }
        inline const_iterator &operator--() {
            i = QHashData::previousNode(i);
            return *this;
        }
        inline const_iterator operator--(int) {
            const_iterator r = *this;
            i = QHashData::previousNode(i);
            return r;
        }
        inline const_iterator operator+(int j) const
        { const_iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
        inline const_iterator operator-(int j) const { return operator+(-j); }
        inline const_iterator &operator+=(int j) { return *this = *this + j; }
        inline const_iterator &operator-=(int j) { return *this = *this - j; }







    };
    friend class const_iterator;


    inline iterator begin() { detach(); return iterator(d->firstNode()); }
    inline const_iterator begin() const { return const_iterator(d->firstNode()); }
    inline const_iterator cbegin() const { return const_iterator(d->firstNode()); }
    inline const_iterator constBegin() const { return const_iterator(d->firstNode()); }
    inline iterator end() { detach(); return iterator(e); }
    inline const_iterator end() const { return const_iterator(e); }
    inline const_iterator cend() const { return const_iterator(e); }
    inline const_iterator constEnd() const { return const_iterator(e); }
    iterator erase(iterator it);


    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    inline int count() const { return d->size; }
    iterator find(const Key &key);
    const_iterator find(const Key &key) const;
    const_iterator constFind(const Key &key) const;
    iterator insert(const Key &key, const T &value);
    iterator insertMulti(const Key &key, const T &value);
    QHash<Key, T> &unite(const QHash<Key, T> &other);


    typedef T mapped_type;
    typedef Key key_type;
    typedef qptrdiff difference_type;
    typedef int size_type;

    inline bool empty() const { return isEmpty(); }






private:
    void detach_helper();
    void freeData(QHashData *d);
    Node **findNode(const Key &key, uint *hp = 0) const;
    Node *createNode(uint h, const Key &key, const T &value, Node **nextNode);
    void deleteNode(Node *node);
    static void deleteNode2(QHashData::Node *node);

    static void duplicateNode(QHashData::Node *originalNode, void *newNode);

    bool isValidIterator(const iterator &it) const
    {

        QHashData::Node *node = it.i;
        while (node->next)
            node = node->next;
        return (static_cast<void *>(node) == d);




    }
    friend class QSet<Key>;
};


template <class Key, class T>
inline void QHash<Key, T>::deleteNode(Node *node)
{
    deleteNode2(reinterpret_cast<QHashData::Node*>(node));
    d->freeNode(node);
}

template <class Key, class T>
inline void QHash<Key, T>::deleteNode2(QHashData::Node *node)
{



    concrete(node)->~Node();

}

template <class Key, class T>
inline void QHash<Key, T>::duplicateNode(QHashData::Node *node, void *newNode)
{
    Node *concreteNode = concrete(node);
    if (QTypeInfo<T>::isDummy) {
        (void) new (newNode) DummyNode(concreteNode->key, concreteNode->h, 0);
    } else {
        (void) new (newNode) Node(concreteNode->key, concreteNode->value, concreteNode->h, 0);
    }
}

template <class Key, class T>
inline typename QHash<Key, T>::Node *
QHash<Key, T>::createNode(uint ah, const Key &akey, const T &avalue, Node **anextNode)
{
    Node *node;

    if (QTypeInfo<T>::isDummy) {
        node = reinterpret_cast<Node *>(new (d->allocateNode(alignOfDummyNode())) DummyNode(akey, ah, *anextNode));
    } else {
        node = new (d->allocateNode(alignOfNode())) Node(akey, avalue, ah, *anextNode);
    }

    *anextNode = node;
    ++d->size;
    return node;
}

template <class Key, class T>
inline QHash<Key, T> &QHash<Key, T>::unite(const QHash<Key, T> &other)
{
    QHash<Key, T> copy(other);
    const_iterator it = copy.constEnd();
    while (it != copy.constBegin()) {
        --it;
        insertMulti(it.key(), it.value());
    }
    return *this;
}

template <class Key, class T>
inline void QHash<Key, T>::freeData(QHashData *x)
{
    x->free_helper(deleteNode2);
}

template <class Key, class T>
inline void QHash<Key, T>::clear()
{
    *this = QHash<Key,T>();
}

template <class Key, class T>
inline void QHash<Key, T>::detach_helper()
{
    QHashData *x = d->detach_helper(duplicateNode, deleteNode2,
        QTypeInfo<T>::isDummy ? sizeof(DummyNode) : sizeof(Node),
        QTypeInfo<T>::isDummy ? alignOfDummyNode() : alignOfNode());
    if (!d->ref.deref())
        freeData(d);
    d = x;
}

template <class Key, class T>
inline QHash<Key, T> &QHash<Key, T>::operator=(const QHash<Key, T> &other)
{
    if (d != other.d) {
        QHashData *o = other.d;
        o->ref.ref();
        if (!d->ref.deref())
            freeData(d);
        d = o;
        if (!d->sharable)
            detach_helper();
    }
    return *this;
}

template <class Key, class T>
inline const T QHash<Key, T>::value(const Key &akey) const
{
    Node *node;
    if (d->size == 0 || (node = *findNode(akey)) == e) {
        return T();
    } else {
        return node->value;
    }
}

template <class Key, class T>
inline const T QHash<Key, T>::value(const Key &akey, const T &adefaultValue) const
{
    Node *node;
    if (d->size == 0 || (node = *findNode(akey)) == e) {
        return adefaultValue;
    } else {
        return node->value;
    }
}

template <class Key, class T>
inline QList<Key> QHash<Key, T>::uniqueKeys() const
{
    QList<Key> res;
    res.reserve(size());
    const_iterator i = begin();
    if (i != end()) {
        for (;;) {
            const Key &aKey = i.key();
            res.append(aKey);
            do {
                if (++i == end())
                    goto break_out_of_outer_loop;
            } while (aKey == i.key());
        }
    }
break_out_of_outer_loop:
    return res;
}

template <class Key, class T>
inline QList<Key> QHash<Key, T>::keys() const
{
    QList<Key> res;
    res.reserve(size());
    const_iterator i = begin();
    while (i != end()) {
        res.append(i.key());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline QList<Key> QHash<Key, T>::keys(const T &avalue) const
{
    QList<Key> res;
    const_iterator i = begin();
    while (i != end()) {
        if (i.value() == avalue)
            res.append(i.key());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline const Key QHash<Key, T>::key(const T &avalue) const
{
    return key(avalue, Key());
}

template <class Key, class T>
inline const Key QHash<Key, T>::key(const T &avalue, const Key &defaultValue) const
{
    const_iterator i = begin();
    while (i != end()) {
        if (i.value() == avalue)
            return i.key();
        ++i;
    }

    return defaultValue;
}

template <class Key, class T>
inline QList<T> QHash<Key, T>::values() const
{
    QList<T> res;
    res.reserve(size());
    const_iterator i = begin();
    while (i != end()) {
        res.append(i.value());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline QList<T> QHash<Key, T>::values(const Key &akey) const
{
    QList<T> res;
    Node *node = *findNode(akey);
    if (node != e) {
        do {
            res.append(node->value);
        } while ((node = node->next) != e && node->key == akey);
    }
    return res;
}

template <class Key, class T>
inline int QHash<Key, T>::count(const Key &akey) const
{
    int cnt = 0;
    Node *node = *findNode(akey);
    if (node != e) {
        do {
            ++cnt;
        } while ((node = node->next) != e && node->key == akey);
    }
    return cnt;
}

template <class Key, class T>
inline const T QHash<Key, T>::operator[](const Key &akey) const
{
    return value(akey);
}

template <class Key, class T>
inline T &QHash<Key, T>::operator[](const Key &akey)
{
    detach();

    uint h;
    Node **node = findNode(akey, &h);
    if (*node == e) {
        if (d->willGrow())
            node = findNode(akey, &h);
        return createNode(h, akey, T(), node)->value;
    }
    return (*node)->value;
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::insert(const Key &akey,
                                                                         const T &avalue)
{
    detach();

    uint h;
    Node **node = findNode(akey, &h);
    if (*node == e) {
        if (d->willGrow())
            node = findNode(akey, &h);
        return iterator(createNode(h, akey, avalue, node));
    }

    if (!QTypeInfo<T>::isDummy)
        (*node)->value = avalue;
    return iterator(*node);
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::insertMulti(const Key &akey,
                                                                              const T &avalue)
{
    detach();
    d->willGrow();

    uint h;
    Node **nextNode = findNode(akey, &h);
    return iterator(createNode(h, akey, avalue, nextNode));
}

template <class Key, class T>
inline int QHash<Key, T>::remove(const Key &akey)
{
    if (isEmpty())
        return 0;
    detach();

    int oldSize = d->size;
    Node **node = findNode(akey);
    if (*node != e) {
        bool deleteNext = true;
        do {
            Node *next = (*node)->next;
            deleteNext = (next != e && next->key == (*node)->key);
            deleteNode(*node);
            *node = next;
            --d->size;
        } while (deleteNext);
        d->hasShrunk();
    }
    return oldSize - d->size;
}

template <class Key, class T>
inline T QHash<Key, T>::take(const Key &akey)
{
    if (isEmpty())
        return T();
    detach();

    Node **node = findNode(akey);
    if (*node != e) {
        T t = (*node)->value;
        Node *next = (*node)->next;
        deleteNode(*node);
        *node = next;
        --d->size;
        d->hasShrunk();
        return t;
    }
    return T();
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::erase(iterator it)
{
    ((!(isValidIterator(it))) ? qt_assert_x("QHash::erase", "The specified iterator argument 'it' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h",859) : qt_noop());

    if (it == iterator(e))
        return it;

    if (d->ref.isShared()) {
        int bucketNum = (it.i->h % d->numBuckets);
        iterator bucketIterator(*(d->buckets + bucketNum));
        int stepsFromBucketStartToIte = 0;
        while (bucketIterator != it) {
            ++stepsFromBucketStartToIte;
            ++bucketIterator;
        }
        detach();
        it = iterator(*(d->buckets + bucketNum));
        while (stepsFromBucketStartToIte > 0) {
            --stepsFromBucketStartToIte;
            ++it;
        }
    }

    iterator ret = it;
    ++ret;

    Node *node = concrete(it.i);
    Node **node_ptr = reinterpret_cast<Node **>(&d->buckets[node->h % d->numBuckets]);
    while (*node_ptr != node)
        node_ptr = &(*node_ptr)->next;
    *node_ptr = node->next;
    deleteNode(node);
    --d->size;
    return ret;
}

template <class Key, class T>
inline void QHash<Key, T>::reserve(int asize)
{
    detach();
    d->rehash(-qMax(asize, 1));
}

template <class Key, class T>
inline typename QHash<Key, T>::const_iterator QHash<Key, T>::find(const Key &akey) const
{
    return const_iterator(*findNode(akey));
}

template <class Key, class T>
inline typename QHash<Key, T>::const_iterator QHash<Key, T>::constFind(const Key &akey) const
{
    return const_iterator(*findNode(akey));
}

template <class Key, class T>
inline typename QHash<Key, T>::iterator QHash<Key, T>::find(const Key &akey)
{
    detach();
    return iterator(*findNode(akey));
}

template <class Key, class T>
inline bool QHash<Key, T>::contains(const Key &akey) const
{
    return *findNode(akey) != e;
}

template <class Key, class T>
inline typename QHash<Key, T>::Node **QHash<Key, T>::findNode(const Key &akey,
                                                                            uint *ahp) const
{
    Node **node;
    uint h = 0;

    if (d->numBuckets || ahp) {
        h = qHash(akey, d->seed);
        if (ahp)
            *ahp = h;
    }
    if (d->numBuckets) {
        node = reinterpret_cast<Node **>(&d->buckets[h % d->numBuckets]);
        ((!(*node == e || (*node)->next)) ? qt_assert("*node == e || (*node)->next","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h",939) : qt_noop());
        while (*node != e && !(*node)->same_key(h, akey))
            node = &(*node)->next;
    } else {
        node = const_cast<Node **>(reinterpret_cast<const Node * const *>(&e));
    }
    return node;
}

template <class Key, class T>
inline bool QHash<Key, T>::operator==(const QHash<Key, T> &other) const
{
    if (size() != other.size())
        return false;
    if (d == other.d)
        return true;

    const_iterator it = begin();

    while (it != end()) {
        const Key &akey = it.key();

        const_iterator it2 = other.find(akey);
        do {
            if (it2 == other.end() || !(it2.key() == akey))
                return false;
            if (!QTypeInfo<T>::isDummy && !(it.value() == it2.value()))
                return false;
            ++it;
            ++it2;
        } while (it != end() && it.key() == akey);
    }
    return true;
}

template <class Key, class T>
class QMultiHash : public QHash<Key, T>
{
public:
    QMultiHash() {}
#line 987 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h"
    QMultiHash(const QHash<Key, T> &other) : QHash<Key, T>(other) {}
    inline void swap(QMultiHash<Key, T> &other) { QHash<Key, T>::swap(other); }

    inline typename QHash<Key, T>::iterator replace(const Key &key, const T &value)
    { return QHash<Key, T>::insert(key, value); }

    inline typename QHash<Key, T>::iterator insert(const Key &key, const T &value)
    { return QHash<Key, T>::insertMulti(key, value); }

    inline QMultiHash &operator+=(const QMultiHash &other)
    { this->unite(other); return *this; }
    inline QMultiHash operator+(const QMultiHash &other) const
    { QMultiHash result = *this; result += other; return result; }



    using QHash<Key, T>::contains;
    using QHash<Key, T>::remove;
    using QHash<Key, T>::count;
    using QHash<Key, T>::find;
    using QHash<Key, T>::constFind;
#line 1025 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h"
    bool contains(const Key &key, const T &value) const;

    int remove(const Key &key, const T &value);

    int count(const Key &key, const T &value) const;

    typename QHash<Key, T>::iterator find(const Key &key, const T &value) {
        typename QHash<Key, T>::iterator i(find(key));
        typename QHash<Key, T>::iterator end(this->end());
        while (i != end && i.key() == key) {
            if (i.value() == value)
                return i;
            ++i;
        }
        return end;
    }
    typename QHash<Key, T>::const_iterator find(const Key &key, const T &value) const {
        typename QHash<Key, T>::const_iterator i(constFind(key));
        typename QHash<Key, T>::const_iterator end(QHash<Key, T>::constEnd());
        while (i != end && i.key() == key) {
            if (i.value() == value)
                return i;
            ++i;
        }
        return end;
    }
    typename QHash<Key, T>::const_iterator constFind(const Key &key, const T &value) const
        { return find(key, value); }
private:
    T &operator[](const Key &key);
    const T operator[](const Key &key) const;
};

template <class Key, class T>
inline bool QMultiHash<Key, T>::contains(const Key &key, const T &value) const
{
    return constFind(key, value) != QHash<Key, T>::constEnd();
}

template <class Key, class T>
inline int QMultiHash<Key, T>::remove(const Key &key, const T &value)
{
    int n = 0;
    typename QHash<Key, T>::iterator i(find(key));
    typename QHash<Key, T>::iterator end(QHash<Key, T>::end());
    while (i != end && i.key() == key) {
        if (i.value() == value) {
            i = this->erase(i);
            ++n;
        } else {
            ++i;
        }
    }
    return n;
}

template <class Key, class T>
inline int QMultiHash<Key, T>::count(const Key &key, const T &value) const
{
    int n = 0;
    typename QHash<Key, T>::const_iterator i(constFind(key));
    typename QHash<Key, T>::const_iterator end(QHash<Key, T>::constEnd());
    while (i != end && i.key() == key) {
        if (i.value() == value)
            ++n;
        ++i;
    }
    return n;
}

template <class Key, class T> class QHashIterator { typedef typename QHash<Key,T>::const_iterator const_iterator; typedef const_iterator Item; QHash<Key,T> c; const_iterator i, n; inline bool item_exists() const { return n != c.constEnd(); } public: inline QHashIterator(const QHash<Key,T> &container) : c(container), i(c.constBegin()), n(c.constEnd()) {} inline QHashIterator &operator=(const QHash<Key,T> &container) { c = container; i = c.constBegin(); n = c.constEnd(); return *this; } inline void toFront() { i = c.constBegin(); n = c.constEnd(); } inline void toBack() { i = c.constEnd(); n = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { const_iterator p = i; return --p; } inline const T &value() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h",1095) : qt_noop()); return *n; } inline const Key &key() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h",1095) : qt_noop()); return n.key(); } inline bool findNext(const T &t) { while ((n = i) != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(n = --i) == t) return true; n = c.constEnd(); return false; } };
template <class Key, class T> class QMutableHashIterator { typedef typename QHash<Key,T>::iterator iterator; typedef typename QHash<Key,T>::const_iterator const_iterator; typedef iterator Item; QHash<Key,T> *c; iterator i, n; inline bool item_exists() const { return const_iterator(n) != c->constEnd(); } public: inline QMutableHashIterator(QHash<Key,T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableHashIterator() { c->setSharable(true); } inline QMutableHashIterator &operator=(QHash<Key,T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = c->end(); } inline bool hasNext() const { return const_iterator(i) != c->constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return const_iterator(i) != c->constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { iterator p = i; return --p; } inline void remove() { if (const_iterator(n) != c->constEnd()) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) { if (const_iterator(n) != c->constEnd()) *n = t; } inline T &value() { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h",1096) : qt_noop()); return *n; } inline const T &value() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h",1096) : qt_noop()); return *n; } inline const Key &key() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qhash.h",1096) : qt_noop()); return n.key(); } inline bool findNext(const T &t) { while (const_iterator(n = i) != c->constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (const_iterator(i) != c->constBegin()) if (*(n = --i) == t) return true; n = c->end(); return false; } };




#pragma warning(pop)
#line 66 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h"
#line 84 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h"
template<typename T> inline void qt_sharedpointer_cast_check(T *) { }







template <class T> class QWeakPointer;
template <class T> class QSharedPointer;

class QVariant;

template <class X, class T>
QSharedPointer<X> qSharedPointerCast(const QSharedPointer<T> &ptr);
template <class X, class T>
QSharedPointer<X> qSharedPointerDynamicCast(const QSharedPointer<T> &ptr);
template <class X, class T>
QSharedPointer<X> qSharedPointerConstCast(const QSharedPointer<T> &ptr);


template <class X, class T>
QSharedPointer<X> qSharedPointerObjectCast(const QSharedPointer<T> &ptr);


namespace QtSharedPointer {
    template <class T> class ExternalRefCount;

    template <class X, class Y> QSharedPointer<X> copyAndSetPointer(X * ptr, const QSharedPointer<Y> &src);


    __declspec(dllimport) void internalSafetyCheckAdd(const void *, const volatile void *);
    __declspec(dllimport) void internalSafetyCheckRemove(const void *);

    template <class T, typename Klass, typename RetVal>
    inline void executeDeleter(T *t, RetVal (Klass:: *memberDeleter)())
    { (t->*memberDeleter)(); }
    template <class T, typename Deleter>
    inline void executeDeleter(T *t, Deleter d)
    { d(t); }
    struct NormalDeleter {};


    template <class T> struct RemovePointer;
    template <class T> struct RemovePointer<T *> { typedef T Type; };
    template <class T> struct RemovePointer<QSharedPointer<T> > { typedef T Type; };
    template <class T> struct RemovePointer<QWeakPointer<T> > { typedef T Type; };
#line 142 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h"
    struct ExternalRefCountData
    {
        typedef void (*DestroyerFn)(ExternalRefCountData *);
        QBasicAtomicInt weakref;
        QBasicAtomicInt strongref;
        DestroyerFn destroyer;

        inline ExternalRefCountData(DestroyerFn d)
            : destroyer(d)
        {
            strongref.store(1);
            weakref.store(1);
        }
        inline ExternalRefCountData(Qt::Initialization) { }
        ~ExternalRefCountData() { ((!(!weakref.load())) ? qt_assert("!weakref.load()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h",156) : qt_noop()); ((!(strongref.load() <= 0)) ? qt_assert("strongref.load() <= 0","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h",156) : qt_noop()); }

        void destroy() { destroyer(this); }


        __declspec(dllimport) static ExternalRefCountData *getAndRef(const QObject *);
        __declspec(dllimport) void setQObjectShared(const QObject *, bool enable);
        __declspec(dllimport) void checkQObjectShared(const QObject *);

        inline void checkQObjectShared(...) { }
        inline void setQObjectShared(...) { }

        inline void operator delete(void *ptr) { ::operator delete(ptr); }
        inline void operator delete(void *, void *) { }
    };


    template <class T, typename Deleter>
    struct CustomDeleter
    {
        Deleter deleter;
        T *ptr;

        CustomDeleter(T *p, Deleter d) : deleter(d), ptr(p) {}
        void execute() { executeDeleter(ptr, deleter); }
    };
#line 190 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h"
    template <class T>
    struct CustomDeleter<T, NormalDeleter>
    {
        T *ptr;

        CustomDeleter(T *p, NormalDeleter) : ptr(p) {}
        void execute() { delete ptr; }
    };






    template <class T, typename Deleter>
    struct ExternalRefCountWithCustomDeleter: public ExternalRefCountData
    {
        typedef ExternalRefCountWithCustomDeleter Self;
        typedef ExternalRefCountData BaseClass;
        CustomDeleter<T, Deleter> extra;

        static inline void deleter(ExternalRefCountData *self)
        {
            Self *realself = static_cast<Self *>(self);
            realself->extra.execute();


            realself->extra.~CustomDeleter<T, Deleter>();
        }
        static void safetyCheckDeleter(ExternalRefCountData *self)
        {
            internalSafetyCheckRemove(self);
            deleter(self);
        }

        static inline Self *create(T *ptr, Deleter userDeleter, DestroyerFn actualDeleter)
        {
            Self *d = static_cast<Self *>(::operator new(sizeof(Self)));


            new (&d->extra) CustomDeleter<T, Deleter>(ptr, userDeleter);
            new (d) BaseClass(actualDeleter);

            return d;
        }
    private:

        ExternalRefCountWithCustomDeleter() = delete;
        ~ExternalRefCountWithCustomDeleter() = delete;
        ExternalRefCountWithCustomDeleter(const ExternalRefCountWithCustomDeleter &) = delete; ExternalRefCountWithCustomDeleter &operator=(const ExternalRefCountWithCustomDeleter &) = delete;
    };





    template <class T>
    struct ExternalRefCountWithContiguousData: public ExternalRefCountData
    {
        typedef ExternalRefCountData Parent;
        T data;

        static void deleter(ExternalRefCountData *self)
        {
            ExternalRefCountWithContiguousData *that =
                    static_cast<ExternalRefCountWithContiguousData *>(self);
            that->data.~T();
        }
        static void safetyCheckDeleter(ExternalRefCountData *self)
        {
            internalSafetyCheckRemove(self);
            deleter(self);
        }

        static inline ExternalRefCountData *create(T **ptr, DestroyerFn destroy)
        {
            ExternalRefCountWithContiguousData *d =
                static_cast<ExternalRefCountWithContiguousData *>(::operator new(sizeof(ExternalRefCountWithContiguousData)));



            new (d) Parent(destroy);

            *ptr = &d->data;
            return d;
        }

    private:

        ExternalRefCountWithContiguousData() = delete;
        ~ExternalRefCountWithContiguousData() = delete;
        ExternalRefCountWithContiguousData(const ExternalRefCountWithContiguousData &) = delete; ExternalRefCountWithContiguousData &operator=(const ExternalRefCountWithContiguousData &) = delete;
    };


    __declspec(dllimport) QWeakPointer<QObject> weakPointerFromVariant_internal(const QVariant &variant);
    __declspec(dllimport) QSharedPointer<QObject> sharedPointerFromVariant_internal(const QVariant &variant);

}

template <class T> class QSharedPointer
{
    typedef T *QSharedPointer:: *RestrictedBool;
    typedef QtSharedPointer::ExternalRefCountData Data;
public:
    typedef T Type;
    typedef T element_type;
    typedef T value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;
    typedef qptrdiff difference_type;

    inline T *data() const { return value; }
    inline bool isNull() const { return !data(); }
    inline operator RestrictedBool() const { return isNull() ? 0 : &QSharedPointer::value; }
    inline bool operator !() const { return isNull(); }
    inline T &operator*() const { return *data(); }
    inline T *operator->() const { return data(); }

    QSharedPointer() : value(0), d(0) { }
    ~QSharedPointer() { deref(); }

    inline explicit QSharedPointer(T *ptr) : value(ptr)
    { internalConstruct(ptr, QtSharedPointer::NormalDeleter()); }

    template <typename Deleter>
    inline QSharedPointer(T *ptr, Deleter deleter) : value(ptr)
    { internalConstruct(ptr, deleter); }

    inline QSharedPointer(const QSharedPointer<T> &other) : value(other.value), d(other.d)
    { if (d) ref(); }
    inline QSharedPointer<T> &operator=(const QSharedPointer<T> &other)
    {
        QSharedPointer copy(other);
        swap(copy);
        return *this;
    }

    inline QSharedPointer<T> &operator=(QSharedPointer<T> &&other)
    {
        swap(other);
        return *this;
    }


    template <class X>
    inline QSharedPointer(const QSharedPointer<X> &other) : value(other.value), d(other.d)
    { if (d) ref(); }

    template <class X>
    inline QSharedPointer<T> &operator=(const QSharedPointer<X> &other)
    {
        qt_sharedpointer_cast_check<T>(static_cast<X *>(0));
        internalCopy(other);
        return *this;
    }

    template <class X>
    inline QSharedPointer(const QWeakPointer<X> &other) : value(0), d(0)
    { *this = other; }

    template <class X>
    inline QSharedPointer<T> &operator=(const QWeakPointer<X> &other)
    { internalSet(other.d, other.value); return *this; }

    inline void swap(QSharedPointer &other)
    { QSharedPointer<T>::internalSwap(other); }

    inline void reset() { clear(); }
    inline void reset(T *t)
    { QSharedPointer copy(t); swap(copy); }
    template <typename Deleter>
    inline void reset(T *t, Deleter deleter)
    { QSharedPointer copy(t, deleter); swap(copy); }

    template <class X>
    QSharedPointer<X> staticCast() const
    {
        return qSharedPointerCast<X, T>(*this);
    }

    template <class X>
    QSharedPointer<X> dynamicCast() const
    {
        return qSharedPointerDynamicCast<X, T>(*this);
    }

    template <class X>
    QSharedPointer<X> constCast() const
    {
        return qSharedPointerConstCast<X, T>(*this);
    }


    template <class X>
    QSharedPointer<X> objectCast() const
    {
        return qSharedPointerObjectCast<X, T>(*this);
    }


    inline void clear() { QSharedPointer copy; swap(copy); }

    QWeakPointer<T> toWeakRef() const;


    template <typename... Args>
    static QSharedPointer<T> create(Args && ...arguments)
    {
        typedef QtSharedPointer::ExternalRefCountWithContiguousData<T> Private;



        typename Private::DestroyerFn destroy = &Private::deleter;

        QSharedPointer<T> result(Qt::Uninitialized);
        result.d = Private::create(&result.value, destroy);


        new (result.data()) T(std::forward<Args>(arguments)...);
        result.d->setQObjectShared(result.value, true);



        return result;
    }
#line 440 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h"
private:
    explicit QSharedPointer(Qt::Initialization) {}

    inline void deref()
    { deref(d); }
    static inline void deref(Data *d)
    {
        if (!d) return;
        if (!d->strongref.deref()) {
            d->destroy();
        }
        if (!d->weakref.deref())
            delete d;
    }

    template <typename Deleter>
    inline void internalConstruct(T *ptr, Deleter deleter)
    {
        if (!ptr) {
            d = 0;
            return;
        }

        typedef QtSharedPointer::ExternalRefCountWithCustomDeleter<T, Deleter> Private;



        typename Private::DestroyerFn actualDeleter = &Private::deleter;

        d = Private::create(ptr, deleter, actualDeleter);




        d->setQObjectShared(ptr, true);
    }

    template <class X>
    inline void internalCopy(const QSharedPointer<X> &other)
    {
        Data *o = other.d;
        T *actual = other.value;
        if (o)
            other.ref();
        qSwap(d, o);
        qSwap(this->value, actual);
        deref(o);
    }

    inline void internalSwap(QSharedPointer &other)
    {
        qSwap(d, other.d);
        qSwap(this->value, other.value);
    }


public:





    inline void ref() const { d->weakref.ref(); d->strongref.ref(); }

    inline void internalSet(Data *o, T *actual)
    {
        if (o) {


            int tmp = o->strongref.load();
            while (tmp > 0) {

                if (o->strongref.testAndSetRelaxed(tmp, tmp + 1))
                    break;
                tmp = o->strongref.load();
            }

            if (tmp > 0) {
                o->weakref.ref();
            } else {
                o->checkQObjectShared(actual);
                o = 0;
            }
        }

        qSwap(d, o);
        qSwap(this->value, actual);
        if (!d || d->strongref.load() == 0)
            this->value = 0;


        deref(o);
    }

    Type *value;
    Data *d;
};

template <class T>
class QWeakPointer
{
    typedef T *QWeakPointer:: *RestrictedBool;
    typedef QtSharedPointer::ExternalRefCountData Data;

public:
    typedef T element_type;
    typedef T value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;
    typedef qptrdiff difference_type;

    inline bool isNull() const { return d == 0 || d->strongref.load() == 0 || value == 0; }
    inline operator RestrictedBool() const { return isNull() ? 0 : &QWeakPointer::value; }
    inline bool operator !() const { return isNull(); }
    inline T *data() const { return d == 0 || d->strongref.load() == 0 ? 0 : value; }

    inline QWeakPointer() : d(0), value(0) { }
    inline ~QWeakPointer() { if (d && !d->weakref.deref()) delete d; }
#line 576 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer_impl.h"
    inline QWeakPointer(const QWeakPointer<T> &o) : d(o.d), value(o.value)
    { if (d) d->weakref.ref(); }
    inline QWeakPointer<T> &operator=(const QWeakPointer<T> &o)
    {
        internalSet(o.d, o.value);
        return *this;
    }

    inline QWeakPointer(const QSharedPointer<T> &o) : d(o.d), value(o.data())
    { if (d) d->weakref.ref();}
    inline QWeakPointer<T> &operator=(const QSharedPointer<T> &o)
    {
        internalSet(o.d, o.value);
        return *this;
    }

    template <class X>
    inline QWeakPointer(const QWeakPointer<X> &o) : d(0), value(0)
    { *this = o; }

    template <class X>
    inline QWeakPointer<T> &operator=(const QWeakPointer<X> &o)
    {


        *this = o.toStrongRef();
        return *this;
    }

    template <class X>
    inline bool operator==(const QWeakPointer<X> &o) const
    { return d == o.d && value == static_cast<const T *>(o.value); }

    template <class X>
    inline bool operator!=(const QWeakPointer<X> &o) const
    { return !(*this == o); }

    template <class X>
    inline QWeakPointer(const QSharedPointer<X> &o) : d(0), value(0)
    { *this = o; }

    template <class X>
    inline QWeakPointer<T> &operator=(const QSharedPointer<X> &o)
    {
        qt_sharedpointer_cast_check<T>(static_cast<X *>(0));
        internalSet(o.d, o.data());
        return *this;
    }

    template <class X>
    inline bool operator==(const QSharedPointer<X> &o) const
    { return d == o.d; }

    template <class X>
    inline bool operator!=(const QSharedPointer<X> &o) const
    { return !(*this == o); }

    inline void clear() { *this = QWeakPointer<T>(); }

    inline QSharedPointer<T> toStrongRef() const { return QSharedPointer<T>(*this); }





private:


public:





    template <class X>
    inline QWeakPointer &assign(X *ptr)
    { return *this = QWeakPointer<X>(ptr, true); }


    template <class X>
    inline QWeakPointer(X *ptr, bool) : d(ptr ? Data::getAndRef(ptr) : 0), value(ptr)
    { }


    inline void internalSet(Data *o, T *actual)
    {
        if (d == o) return;
        if (o)
            o->weakref.ref();
        if (d && !d->weakref.deref())
            delete d;
        d = o;
        value = actual;
    }

    Data *d;
    T *value;
};




template <class T, class X>
bool operator==(const QSharedPointer<T> &ptr1, const QSharedPointer<X> &ptr2)
{
    return ptr1.data() == ptr2.data();
}
template <class T, class X>
bool operator!=(const QSharedPointer<T> &ptr1, const QSharedPointer<X> &ptr2)
{
    return ptr1.data() != ptr2.data();
}

template <class T, class X>
bool operator==(const QSharedPointer<T> &ptr1, const X *ptr2)
{
    return ptr1.data() == ptr2;
}
template <class T, class X>
bool operator==(const T *ptr1, const QSharedPointer<X> &ptr2)
{
    return ptr1 == ptr2.data();
}
template <class T, class X>
bool operator!=(const QSharedPointer<T> &ptr1, const X *ptr2)
{
    return !(ptr1 == ptr2);
}
template <class T, class X>
bool operator!=(const T *ptr1, const QSharedPointer<X> &ptr2)
{
    return !(ptr2 == ptr1);
}

template <class T, class X>
bool operator==(const QSharedPointer<T> &ptr1, const QWeakPointer<X> &ptr2)
{
    return ptr2 == ptr1;
}
template <class T, class X>
bool operator!=(const QSharedPointer<T> &ptr1, const QWeakPointer<X> &ptr2)
{
    return ptr2 != ptr1;
}




template <class T, class X>
inline typename QSharedPointer<T>::difference_type operator-(const QSharedPointer<T> &ptr1, const QSharedPointer<X> &ptr2)
{
    return ptr1.data() - ptr2.data();
}
template <class T, class X>
inline typename QSharedPointer<T>::difference_type operator-(const QSharedPointer<T> &ptr1, X *ptr2)
{
    return ptr1.data() - ptr2;
}
template <class T, class X>
inline typename QSharedPointer<X>::difference_type operator-(T *ptr1, const QSharedPointer<X> &ptr2)
{
    return ptr1 - ptr2.data();
}




template <class T, class X>
inline bool operator<(const QSharedPointer<T> &ptr1, const QSharedPointer<X> &ptr2)
{
    return ptr1.data() < ptr2.data();
}
template <class T, class X>
inline bool operator<(const QSharedPointer<T> &ptr1, X *ptr2)
{
    return ptr1.data() < ptr2;
}
template <class T, class X>
inline bool operator<(T *ptr1, const QSharedPointer<X> &ptr2)
{
    return ptr1 < ptr2.data();
}




template <class T>
inline uint qHash(const QSharedPointer<T> &ptr, uint seed = 0)
{
    return ::qHash(ptr.data(), seed);
}


template <class T>
inline QWeakPointer<T> QSharedPointer<T>::toWeakRef() const
{
    return QWeakPointer<T>(*this);
}

template <class T>
inline void qSwap(QSharedPointer<T> &p1, QSharedPointer<T> &p2)
{
    p1.swap(p2);
}


namespace std {
    template <class T>
    inline void swap(::QSharedPointer<T> &p1, ::QSharedPointer<T> &p2)
    { p1.swap(p2); }
}


namespace QtSharedPointer {

    template <class X, class T>
    inline QSharedPointer<X> copyAndSetPointer(X *ptr, const QSharedPointer<T> &src)
    {
        QSharedPointer<X> result;
        result.internalSet(src.d, ptr);
        return result;
    }
}


template <class X, class T>
inline QSharedPointer<X> qSharedPointerCast(const QSharedPointer<T> &src)
{
    X *ptr = static_cast<X *>(src.data());
    return QtSharedPointer::copyAndSetPointer(ptr, src);
}
template <class X, class T>
inline QSharedPointer<X> qSharedPointerCast(const QWeakPointer<T> &src)
{
    return qSharedPointerCast<X, T>(src.toStrongRef());
}

template <class X, class T>
inline QSharedPointer<X> qSharedPointerDynamicCast(const QSharedPointer<T> &src)
{
    X *ptr = dynamic_cast<X *>(src.data());
    if (!ptr)
        return QSharedPointer<X>();
    return QtSharedPointer::copyAndSetPointer(ptr, src);
}
template <class X, class T>
inline QSharedPointer<X> qSharedPointerDynamicCast(const QWeakPointer<T> &src)
{
    return qSharedPointerDynamicCast<X, T>(src.toStrongRef());
}

template <class X, class T>
inline QSharedPointer<X> qSharedPointerConstCast(const QSharedPointer<T> &src)
{
    X *ptr = const_cast<X *>(src.data());
    return QtSharedPointer::copyAndSetPointer(ptr, src);
}
template <class X, class T>
inline QSharedPointer<X> qSharedPointerConstCast(const QWeakPointer<T> &src)
{
    return qSharedPointerConstCast<X, T>(src.toStrongRef());
}

template <class X, class T>
inline
QWeakPointer<X> qWeakPointerCast(const QSharedPointer<T> &src)
{
    return qSharedPointerCast<X, T>(src).toWeakRef();
}


template <class X, class T>
inline QSharedPointer<X> qSharedPointerObjectCast(const QSharedPointer<T> &src)
{
    X *ptr = qobject_cast<X *>(src.data());
    return QtSharedPointer::copyAndSetPointer(ptr, src);
}
template <class X, class T>
inline QSharedPointer<X> qSharedPointerObjectCast(const QWeakPointer<T> &src)
{
    return qSharedPointerObjectCast<X>(src.toStrongRef());
}

template <class X, class T>
inline QSharedPointer<typename QtSharedPointer::RemovePointer<X>::Type>
qobject_cast(const QSharedPointer<T> &src)
{
    return qSharedPointerObjectCast<typename QtSharedPointer::RemovePointer<X>::Type, T>(src);
}
template <class X, class T>
inline QSharedPointer<typename QtSharedPointer::RemovePointer<X>::Type>
qobject_cast(const QWeakPointer<T> &src)
{
    return qSharedPointerObjectCast<typename QtSharedPointer::RemovePointer<X>::Type, T>(src);
}

template<typename T>
QWeakPointer<typename QtPrivate::QEnableIf<QtPrivate::IsPointerToTypeDerivedFromQObject<T*>::Value, T>::Type>
qWeakPointerFromVariant(const QVariant &variant)
{
    return QWeakPointer<T>(qobject_cast<T*>(QtSharedPointer::weakPointerFromVariant_internal(variant).data()));
}
template<typename T>
QSharedPointer<typename QtPrivate::QEnableIf<QtPrivate::IsPointerToTypeDerivedFromQObject<T*>::Value, T>::Type>
qSharedPointerFromVariant(const QVariant &variant)
{
    return qSharedPointerObjectCast<T>(QtSharedPointer::sharedPointerFromVariant_internal(variant));
}



template<typename T> class QTypeInfo<QWeakPointer<T> > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QWeakPointer<T>)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QWeakPointer<T> >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QWeakPointer<T>) }; static inline const char *name() { return "QWeakPointer<T>"; } };
template<typename T> class QTypeInfo<QSharedPointer<T> > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QSharedPointer<T>)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QSharedPointer<T> >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QSharedPointer<T>) }; static inline const char *name() { return "QSharedPointer<T>"; } };
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsharedpointer.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpixmap.h"







class QImageWriter;
class QImageReader;
class QColor;
class QVariant;
class QPlatformPixmap;

class __declspec(dllimport) QPixmap : public QPaintDevice
{
public:
    QPixmap();
    explicit QPixmap(QPlatformPixmap *data);
    QPixmap(int w, int h);
    explicit QPixmap(const QSize &);
    QPixmap(const QString& fileName, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);

    explicit QPixmap(const char * const xpm[]);

    QPixmap(const QPixmap &);
    ~QPixmap();

    QPixmap &operator=(const QPixmap &);

    inline QPixmap &operator=(QPixmap &&other)
    { qSwap(data, other.data); return *this; }

    inline void swap(QPixmap &other) { qSwap(data, other.data); }

    operator QVariant() const;

    bool isNull() const;
    int devType() const;

    int width() const;
    int height() const;
    QSize size() const;
    QRect rect() const;
    int depth() const;

    static int defaultDepth();

    void fill(const QColor &fillColor = Qt::white);
    void fill(const QPaintDevice *device, const QPoint &ofs);
    inline void fill(const QPaintDevice *device, int xofs, int yofs) { fill(device, QPoint(xofs, yofs)); }

    QBitmap mask() const;
    void setMask(const QBitmap &);

    qreal devicePixelRatio() const;
    void setDevicePixelRatio(qreal scaleFactor);

    bool hasAlpha() const;
    bool hasAlphaChannel() const;


    QBitmap createHeuristicMask(bool clipTight = true) const;

    QBitmap createMaskFromColor(const QColor &maskColor, Qt::MaskMode mode = Qt::MaskInColor) const;

    static QPixmap grabWindow(WId, int x=0, int y=0, int w=-1, int h=-1);
    static QPixmap grabWidget(QObject *widget, const QRect &rect);
    static inline QPixmap grabWidget(QObject *widget, int x=0, int y=0, int w=-1, int h=-1)
    { return grabWidget(widget, QRect(x, y, w, h)); }

    inline QPixmap scaled(int w, int h, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
                          Qt::TransformationMode mode = Qt::FastTransformation) const
        { return scaled(QSize(w, h), aspectMode, mode); }
    QPixmap scaled(const QSize &s, Qt::AspectRatioMode aspectMode = Qt::IgnoreAspectRatio,
                   Qt::TransformationMode mode = Qt::FastTransformation) const;
    QPixmap scaledToWidth(int w, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QPixmap scaledToHeight(int h, Qt::TransformationMode mode = Qt::FastTransformation) const;
    QPixmap transformed(const QMatrix &, Qt::TransformationMode mode = Qt::FastTransformation) const;
    static QMatrix trueMatrix(const QMatrix &m, int w, int h);
    QPixmap transformed(const QTransform &, Qt::TransformationMode mode = Qt::FastTransformation) const;
    static QTransform trueMatrix(const QTransform &m, int w, int h);

    QImage toImage() const;
    static QPixmap fromImage(const QImage &image, Qt::ImageConversionFlags flags = Qt::AutoColor);
    static QPixmap fromImageReader(QImageReader *imageReader, Qt::ImageConversionFlags flags = Qt::AutoColor);

    static QPixmap fromImage(QImage &&image, Qt::ImageConversionFlags flags = Qt::AutoColor)
    {
        return fromImageInPlace(image, flags);
    }


    bool load(const QString& fileName, const char *format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
    bool loadFromData(const uchar *buf, uint len, const char* format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
    inline bool loadFromData(const QByteArray &data, const char* format = 0, Qt::ImageConversionFlags flags = Qt::AutoColor);
    bool save(const QString& fileName, const char* format = 0, int quality = -1) const;
    bool save(QIODevice* device, const char* format = 0, int quality = -1) const;

    bool convertFromImage(const QImage &img, Qt::ImageConversionFlags flags = Qt::AutoColor);

    inline QPixmap copy(int x, int y, int width, int height) const;
    QPixmap copy(const QRect &rect = QRect()) const;

    inline void scroll(int dx, int dy, int x, int y, int width, int height, QRegion *exposed = 0);
    void scroll(int dx, int dy, const QRect &rect, QRegion *exposed = 0);




    qint64 cacheKey() const;

    bool isDetached() const;
    void detach();

    bool isQBitmap() const;

    QPaintEngine *paintEngine() const;

    inline bool operator!() const { return isNull(); }






protected:
    int metric(PaintDeviceMetric) const;
    static QPixmap fromImageInPlace(QImage &image, Qt::ImageConversionFlags flags = Qt::AutoColor);

private:
    QExplicitlySharedDataPointer<QPlatformPixmap> data;

    bool doImageIO(QImageWriter *io, int quality) const;

    QPixmap(const QSize &s, int type);
    void doInit(int, int, int);

    friend class QPlatformPixmap;
    friend class QBitmap;
    friend class QPaintDevice;
    friend class QPainter;
    friend class QOpenGLWidget;
    friend class QWidgetPrivate;
    friend class QRasterBuffer;

    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QPixmap &);


public:
    QPlatformPixmap* handle() const;

public:
    typedef QExplicitlySharedDataPointer<QPlatformPixmap> DataPtr;
    inline DataPtr &data_ptr() { return data; }
};

template<> class QTypeInfo<QPixmap > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPixmap)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QPixmap >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QPixmap) }; static inline const char *name() { return "QPixmap"; } }; template <> inline void qSwap<QPixmap>(QPixmap &value1, QPixmap &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QPixmap >(::QPixmap &value1, ::QPixmap &value2) { value1.swap(value2); } }

inline QPixmap QPixmap::copy(int ax, int ay, int awidth, int aheight) const
{
    return copy(QRect(ax, ay, awidth, aheight));
}

inline void QPixmap::scroll(int dx, int dy, int ax, int ay, int awidth, int aheight, QRegion *exposed)
{
    scroll(dx, dy, QRect(ax, ay, awidth, aheight), exposed);
}

inline bool QPixmap::loadFromData(const QByteArray &buf, const char *format,
                                  Qt::ImageConversionFlags flags)
{
    return loadFromData(reinterpret_cast<const uchar *>(buf.constData()), buf.size(), format, flags);
}
#line 243 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpixmap.h"
__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPixmap &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPixmap &);



__declspec(dllimport) QDebug operator<<(QDebug, const QPixmap &);
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qbrush.h"





struct QBrushData;
class QPixmap;
class QGradient;
class QVariant;
struct QBrushDataPointerDeleter;

class __declspec(dllimport) QBrush
{
public:
    QBrush();
    QBrush(Qt::BrushStyle bs);
    QBrush(const QColor &color, Qt::BrushStyle bs=Qt::SolidPattern);
    QBrush(Qt::GlobalColor color, Qt::BrushStyle bs=Qt::SolidPattern);

    QBrush(const QColor &color, const QPixmap &pixmap);
    QBrush(Qt::GlobalColor color, const QPixmap &pixmap);
    QBrush(const QPixmap &pixmap);
    QBrush(const QImage &image);

    QBrush(const QBrush &brush);

    QBrush(const QGradient &gradient);

    ~QBrush();
    QBrush &operator=(const QBrush &brush);

    inline QBrush &operator=(QBrush &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QBrush &other) { qSwap(d, other.d); }

    operator QVariant() const;

    inline Qt::BrushStyle style() const;
    void setStyle(Qt::BrushStyle);

    inline const QMatrix &matrix() const;
    void setMatrix(const QMatrix &mat);

    inline QTransform transform() const;
    void setTransform(const QTransform &);

    QPixmap texture() const;
    void setTexture(const QPixmap &pixmap);

    QImage textureImage() const;
    void setTextureImage(const QImage &image);

    inline const QColor &color() const;
    void setColor(const QColor &color);
    inline void setColor(Qt::GlobalColor color);

    const QGradient *gradient() const;

    bool isOpaque() const;

    bool operator==(const QBrush &b) const;
    inline bool operator!=(const QBrush &b) const { return !(operator==(b)); }

private:
    friend class QRasterPaintEngine;
    friend class QRasterPaintEnginePrivate;
    friend struct QSpanData;
    friend class QPainter;
    friend bool __declspec(dllimport) qHasPixmapTexture(const QBrush& brush);
    void detach(Qt::BrushStyle newStyle);
    void init(const QColor &color, Qt::BrushStyle bs);
    QScopedPointer<QBrushData, QBrushDataPointerDeleter> d;
    void cleanUp(QBrushData *x);

public:
    inline bool isDetached() const;
    typedef QScopedPointer<QBrushData, QBrushDataPointerDeleter> DataPtr;
    inline DataPtr &data_ptr() { return d; }
};

inline void QBrush::setColor(Qt::GlobalColor acolor)
{ setColor(QColor(acolor)); }

template<> class QTypeInfo<QBrush > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QBrush)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QBrush >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QBrush) }; static inline const char *name() { return "QBrush"; } }; template <> inline void qSwap<QBrush>(QBrush &value1, QBrush &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QBrush >(::QBrush &value1, ::QBrush &value2) { value1.swap(value2); } }






__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QBrush &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QBrush &);



__declspec(dllimport) QDebug operator<<(QDebug, const QBrush &);


struct QBrushData
{
    QAtomicInt ref;
    Qt::BrushStyle style;
    QColor color;
    QTransform transform;
};

inline Qt::BrushStyle QBrush::style() const { return d->style; }
inline const QColor &QBrush::color() const { return d->color; }
inline const QMatrix &QBrush::matrix() const { return d->transform.toAffine(); }
inline QTransform QBrush::transform() const { return d->transform; }
inline bool QBrush::isDetached() const { return d->ref.load() == 1; }





class QGradientPrivate;

typedef QPair<qreal, QColor> QGradientStop;
typedef QVector<QGradientStop> QGradientStops;

class __declspec(dllimport) QGradient
{
    public: static const QMetaObject staticMetaObject; private:

public:
    enum Type {
        LinearGradient,
        RadialGradient,
        ConicalGradient,
        NoGradient
    };

    enum Spread {
        PadSpread,
        ReflectSpread,
        RepeatSpread
    };

    enum CoordinateMode {
        LogicalMode,
        StretchToDeviceMode,
        ObjectBoundingMode
    };

    enum InterpolationMode {
        ColorInterpolation,
        ComponentInterpolation
    };

    QGradient();

    Type type() const { return m_type; }

    inline void setSpread(Spread spread);
    Spread spread() const { return m_spread; }

    void setColorAt(qreal pos, const QColor &color);

    void setStops(const QGradientStops &stops);
    QGradientStops stops() const;

    CoordinateMode coordinateMode() const;
    void setCoordinateMode(CoordinateMode mode);

    InterpolationMode interpolationMode() const;
    void setInterpolationMode(InterpolationMode mode);

    bool operator==(const QGradient &gradient) const;
    inline bool operator!=(const QGradient &other) const
    { return !operator==(other); }

private:
    friend class QLinearGradient;
    friend class QRadialGradient;
    friend class QConicalGradient;
    friend class QBrush;

    Type m_type;
    Spread m_spread;
    QGradientStops m_stops;
    union {
        struct {
            qreal x1, y1, x2, y2;
        } linear;
        struct {
            qreal cx, cy, fx, fy, cradius;
        } radial;
        struct {
            qreal cx, cy, angle;
        } conical;
    } m_data;
    void *dummy;
};

inline void QGradient::setSpread(Spread aspread)
{ m_spread = aspread; }

class __declspec(dllimport) QLinearGradient : public QGradient
{
public:
    QLinearGradient();
    QLinearGradient(const QPointF &start, const QPointF &finalStop);
    QLinearGradient(qreal xStart, qreal yStart, qreal xFinalStop, qreal yFinalStop);

    QPointF start() const;
    void setStart(const QPointF &start);
    inline void setStart(qreal x, qreal y) { setStart(QPointF(x, y)); }

    QPointF finalStop() const;
    void setFinalStop(const QPointF &stop);
    inline void setFinalStop(qreal x, qreal y) { setFinalStop(QPointF(x, y)); }
};


class __declspec(dllimport) QRadialGradient : public QGradient
{
public:
    QRadialGradient();
    QRadialGradient(const QPointF &center, qreal radius, const QPointF &focalPoint);
    QRadialGradient(qreal cx, qreal cy, qreal radius, qreal fx, qreal fy);

    QRadialGradient(const QPointF &center, qreal radius);
    QRadialGradient(qreal cx, qreal cy, qreal radius);

    QRadialGradient(const QPointF &center, qreal centerRadius, const QPointF &focalPoint, qreal focalRadius);
    QRadialGradient(qreal cx, qreal cy, qreal centerRadius, qreal fx, qreal fy, qreal focalRadius);

    QPointF center() const;
    void setCenter(const QPointF &center);
    inline void setCenter(qreal x, qreal y) { setCenter(QPointF(x, y)); }

    QPointF focalPoint() const;
    void setFocalPoint(const QPointF &focalPoint);
    inline void setFocalPoint(qreal x, qreal y) { setFocalPoint(QPointF(x, y)); }

    qreal radius() const;
    void setRadius(qreal radius);

    qreal centerRadius() const;
    void setCenterRadius(qreal radius);

    qreal focalRadius() const;
    void setFocalRadius(qreal radius);
};


class __declspec(dllimport) QConicalGradient : public QGradient
{
public:
    QConicalGradient();
    QConicalGradient(const QPointF &center, qreal startAngle);
    QConicalGradient(qreal cx, qreal cy, qreal startAngle);

    QPointF center() const;
    void setCenter(const QPointF &center);
    inline void setCenter(qreal x, qreal y) { setCenter(QPointF(x, y)); }

    qreal angle() const;
    void setAngle(qreal angle);
};
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpalette.h"





class QPalettePrivate;
class QVariant;

class __declspec(dllimport) QPalette
{
    public: static const QMetaObject staticMetaObject; private:

public:
    QPalette();
    QPalette(const QColor &button);
    QPalette(Qt::GlobalColor button);
    QPalette(const QColor &button, const QColor &window);
    QPalette(const QBrush &windowText, const QBrush &button, const QBrush &light,
             const QBrush &dark, const QBrush &mid, const QBrush &text,
             const QBrush &bright_text, const QBrush &base, const QBrush &window);
    QPalette(const QColor &windowText, const QColor &window, const QColor &light,
             const QColor &dark, const QColor &mid, const QColor &text, const QColor &base);
    QPalette(const QPalette &palette);
    ~QPalette();
    QPalette &operator=(const QPalette &palette);

    inline QPalette &operator=(QPalette &&other)
    {
        for_faster_swapping_dont_use = other.for_faster_swapping_dont_use;
        qSwap(d, other.d); return *this;
    }


    void swap(QPalette &other) {
        qSwap(d, other.d);
        qSwap(for_faster_swapping_dont_use, other.for_faster_swapping_dont_use);
    }

    operator QVariant() const;


    enum ColorGroup { Active, Disabled, Inactive, NColorGroups, Current, All, Normal = Active };
    enum ColorRole { WindowText, Button, Light, Midlight, Dark, Mid,
                     Text, BrightText, ButtonText, Base, Window, Shadow,
                     Highlight, HighlightedText,
                     Link, LinkVisited,
                     AlternateBase,
                     NoRole,
                     ToolTipBase, ToolTipText,
                     NColorRoles = ToolTipText + 1,
                     Foreground = WindowText, Background = Window
                   };

    inline ColorGroup currentColorGroup() const { return static_cast<ColorGroup>(data.current_group); }
    inline void setCurrentColorGroup(ColorGroup cg) { data.current_group = cg; }

    inline const QColor &color(ColorGroup cg, ColorRole cr) const
    { return brush(cg, cr).color(); }
    const QBrush &brush(ColorGroup cg, ColorRole cr) const;
    inline void setColor(ColorGroup cg, ColorRole cr, const QColor &color);
    inline void setColor(ColorRole cr, const QColor &color);
    inline void setBrush(ColorRole cr, const QBrush &brush);
    bool isBrushSet(ColorGroup cg, ColorRole cr) const;
    void setBrush(ColorGroup cg, ColorRole cr, const QBrush &brush);
    void setColorGroup(ColorGroup cr, const QBrush &windowText, const QBrush &button,
                       const QBrush &light, const QBrush &dark, const QBrush &mid,
                       const QBrush &text, const QBrush &bright_text, const QBrush &base,
                       const QBrush &window);
    bool isEqual(ColorGroup cr1, ColorGroup cr2) const;

    inline const QColor &color(ColorRole cr) const { return color(Current, cr); }
    inline const QBrush &brush(ColorRole cr) const { return brush(Current, cr); }
    inline const QBrush &foreground() const { return brush(WindowText); }
    inline const QBrush &windowText() const { return brush(WindowText); }
    inline const QBrush &button() const { return brush(Button); }
    inline const QBrush &light() const { return brush(Light); }
    inline const QBrush &dark() const { return brush(Dark); }
    inline const QBrush &mid() const { return brush(Mid); }
    inline const QBrush &text() const { return brush(Text); }
    inline const QBrush &base() const { return brush(Base); }
    inline const QBrush &alternateBase() const { return brush(AlternateBase); }
    inline const QBrush &toolTipBase() const { return brush(ToolTipBase); }
    inline const QBrush &toolTipText() const { return brush(ToolTipText); }
    inline const QBrush &background() const { return brush(Window); }
    inline const QBrush &window() const { return brush(Window); }
    inline const QBrush &midlight() const { return brush(Midlight); }
    inline const QBrush &brightText() const { return brush(BrightText); }
    inline const QBrush &buttonText() const { return brush(ButtonText); }
    inline const QBrush &shadow() const { return brush(Shadow); }
    inline const QBrush &highlight() const { return brush(Highlight); }
    inline const QBrush &highlightedText() const { return brush(HighlightedText); }
    inline const QBrush &link() const { return brush(Link); }
    inline const QBrush &linkVisited() const { return brush(LinkVisited); }

    bool operator==(const QPalette &p) const;
    inline bool operator!=(const QPalette &p) const { return !(operator==(p)); }
    bool isCopyOf(const QPalette &p) const;




    qint64 cacheKey() const;

    QPalette resolve(const QPalette &) const;
    inline uint resolve() const { return data.resolve_mask; }
    inline void resolve(uint mask) { data.resolve_mask = mask; }

private:
    void setColorGroup(ColorGroup cr, const QBrush &windowText, const QBrush &button,
                       const QBrush &light, const QBrush &dark, const QBrush &mid,
                       const QBrush &text, const QBrush &bright_text,
                       const QBrush &base, const QBrush &alternate_base,
                       const QBrush &window, const QBrush &midlight,
                       const QBrush &button_text, const QBrush &shadow,
                       const QBrush &highlight, const QBrush &highlighted_text,
                       const QBrush &link, const QBrush &link_visited);
    void setColorGroup(ColorGroup cr, const QBrush &windowText, const QBrush &button,
                       const QBrush &light, const QBrush &dark, const QBrush &mid,
                       const QBrush &text, const QBrush &bright_text,
                       const QBrush &base, const QBrush &alternate_base,
                       const QBrush &window, const QBrush &midlight,
                       const QBrush &button_text, const QBrush &shadow,
                       const QBrush &highlight, const QBrush &highlighted_text,
                       const QBrush &link, const QBrush &link_visited,
                       const QBrush &toolTipBase, const QBrush &toolTipText);
    void init();
    void detach();

    QPalettePrivate *d;
    struct Data {
        uint current_group : 4;
        uint resolve_mask : 28;
    };
    union {
        Data data;
        quint32 for_faster_swapping_dont_use;
    };
    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &s, const QPalette &p);
};

template<> class QTypeInfo<QPalette > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPalette)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QPalette >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QPalette) }; static inline const char *name() { return "QPalette"; } }; template <> inline void qSwap<QPalette>(QPalette &value1, QPalette &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QPalette >(::QPalette &value1, ::QPalette &value2) { value1.swap(value2); } }

inline void QPalette::setColor(ColorGroup acg, ColorRole acr,
                               const QColor &acolor)
{ setBrush(acg, acr, QBrush(acolor)); }
inline void QPalette::setColor(ColorRole acr, const QColor &acolor)
{ setColor(All, acr, acolor); }
inline void QPalette::setBrush(ColorRole acr, const QBrush &abrush)
{ setBrush(All, acr, abrush); }





__declspec(dllimport) QDataStream &operator<<(QDataStream &ds, const QPalette &p);
__declspec(dllimport) QDataStream &operator>>(QDataStream &ds, QPalette &p);



__declspec(dllimport) QDebug operator<<(QDebug, const QPalette &);
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qfont.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qfont.h"
class QFontPrivate;
class QStringList;
class QVariant;

class __declspec(dllimport) QFont
{
    public: static const QMetaObject staticMetaObject; private:

public:
    enum StyleHint {
        Helvetica, SansSerif = Helvetica,
        Times, Serif = Times,
        Courier, TypeWriter = Courier,
        OldEnglish, Decorative = OldEnglish,
        System,
        AnyStyle,
        Cursive,
        Monospace,
        Fantasy
    };

    enum StyleStrategy {
        PreferDefault = 0x0001,
        PreferBitmap = 0x0002,
        PreferDevice = 0x0004,
        PreferOutline = 0x0008,
        ForceOutline = 0x0010,
        PreferMatch = 0x0020,
        PreferQuality = 0x0040,
        PreferAntialias = 0x0080,
        NoAntialias = 0x0100,
        OpenGLCompatible = 0x0200,
        ForceIntegerMetrics = 0x0400,
        NoFontMerging = 0x8000
    };

    enum HintingPreference {
        PreferDefaultHinting = 0,
        PreferNoHinting = 1,
        PreferVerticalHinting = 2,
        PreferFullHinting = 3
    };

    enum Weight {
        Light = 25,
        Normal = 50,
        DemiBold = 63,
        Bold = 75,
        Black = 87
    };

    enum Style {
        StyleNormal,
        StyleItalic,
        StyleOblique
    };

    enum Stretch {
        UltraCondensed = 50,
        ExtraCondensed = 62,
        Condensed = 75,
        SemiCondensed = 87,
        Unstretched = 100,
        SemiExpanded = 112,
        Expanded = 125,
        ExtraExpanded = 150,
        UltraExpanded = 200
    };

    enum Capitalization {
        MixedCase,
        AllUppercase,
        AllLowercase,
        SmallCaps,
        Capitalize
    };

    enum SpacingType {
        PercentageSpacing,
        AbsoluteSpacing
    };

    enum ResolveProperties {
        FamilyResolved = 0x0001,
        SizeResolved = 0x0002,
        StyleHintResolved = 0x0004,
        StyleStrategyResolved = 0x0008,
        WeightResolved = 0x0010,
        StyleResolved = 0x0020,
        UnderlineResolved = 0x0040,
        OverlineResolved = 0x0080,
        StrikeOutResolved = 0x0100,
        FixedPitchResolved = 0x0200,
        StretchResolved = 0x0400,
        KerningResolved = 0x0800,
        CapitalizationResolved = 0x1000,
        LetterSpacingResolved = 0x2000,
        WordSpacingResolved = 0x4000,
        HintingPreferenceResolved = 0x8000,
        StyleNameResolved = 0x10000,
        AllPropertiesResolved = 0x1ffff
    };

    QFont();
    QFont(const QString &family, int pointSize = -1, int weight = -1, bool italic = false);
    QFont(const QFont &, QPaintDevice *pd);
    QFont(const QFont &);
    ~QFont();

    void swap(QFont &other)
    { qSwap(d, other.d); qSwap(resolve_mask, other.resolve_mask); }

    QString family() const;
    void setFamily(const QString &);

    QString styleName() const;
    void setStyleName(const QString &);

    int pointSize() const;
    void setPointSize(int);
    qreal pointSizeF() const;
    void setPointSizeF(qreal);

    int pixelSize() const;
    void setPixelSize(int);

    int weight() const;
    void setWeight(int);

    inline bool bold() const;
    inline void setBold(bool);

    void setStyle(Style style);
    Style style() const;

    inline bool italic() const;
    inline void setItalic(bool b);

    bool underline() const;
    void setUnderline(bool);

    bool overline() const;
    void setOverline(bool);

    bool strikeOut() const;
    void setStrikeOut(bool);

    bool fixedPitch() const;
    void setFixedPitch(bool);

    bool kerning() const;
    void setKerning(bool);

    StyleHint styleHint() const;
    StyleStrategy styleStrategy() const;
    void setStyleHint(StyleHint, StyleStrategy = PreferDefault);
    void setStyleStrategy(StyleStrategy s);

    int stretch() const;
    void setStretch(int);

    qreal letterSpacing() const;
    SpacingType letterSpacingType() const;
    void setLetterSpacing(SpacingType type, qreal spacing);

    qreal wordSpacing() const;
    void setWordSpacing(qreal spacing);

    void setCapitalization(Capitalization);
    Capitalization capitalization() const;

    void setHintingPreference(HintingPreference hintingPreference);
    HintingPreference hintingPreference() const;


    bool rawMode() const;
    void setRawMode(bool);


    bool exactMatch() const;

    QFont &operator=(const QFont &);
    bool operator==(const QFont &) const;
    bool operator!=(const QFont &) const;
    bool operator<(const QFont &) const;
    operator QVariant() const;
    bool isCopyOf(const QFont &) const;

    inline QFont &operator=(QFont &&other)
    { qSwap(d, other.d); qSwap(resolve_mask, other.resolve_mask); return *this; }




                  void setRawName(const QString &);
                  QString rawName() const;


    QString key() const;

    QString toString() const;
    bool fromString(const QString &);

    static QString substitute(const QString &);
    static QStringList substitutes(const QString &);
    static QStringList substitutions();
    static void insertSubstitution(const QString&, const QString &);
    static void insertSubstitutions(const QString&, const QStringList &);
    static void removeSubstitutions(const QString &);



    static void initialize();
    static void cleanup();
    static void cacheStatistics();

    QString defaultFamily() const;
    QString lastResortFamily() const;
    QString lastResortFont() const;

    QFont resolve(const QFont &) const;
    inline uint resolve() const { return resolve_mask; }
    inline void resolve(uint mask) { resolve_mask = mask; }

private:
    explicit QFont(QFontPrivate *);

    void detach();


    friend class QFontPrivate;
    friend class QFontDialogPrivate;
    friend class QFontMetrics;
    friend class QFontMetricsF;
    friend class QFontInfo;
    friend class QPainter;
    friend class QPainterPrivate;
    friend class QApplication;
    friend class QWidget;
    friend class QWidgetPrivate;
    friend class QTextLayout;
    friend class QTextEngine;
    friend class QStackTextEngine;
    friend class QTextLine;
    friend struct QScriptLine;
    friend class QOpenGLContext;
    friend class QWin32PaintEngine;
    friend class QAlphaPaintEngine;
    friend class QPainterPath;
    friend class QTextItemInt;
    friend class QPicturePaintEngine;
    friend class QPainterReplayer;
    friend class QPaintBufferEngine;
    friend class QCommandLinkButtonPrivate;
    friend class QFontEngine;


    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QFont &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QFont &);


    QExplicitlySharedDataPointer<QFontPrivate> d;
    uint resolve_mask;
};

template<> class QTypeInfo<QFont > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QFont)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QFont >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QFont) }; static inline const char *name() { return "QFont"; } }; template <> inline void qSwap<QFont>(QFont &value1, QFont &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QFont >(::QFont &value1, ::QFont &value2) { value1.swap(value2); } }

__declspec(dllimport) uint qHash(const QFont &font, uint seed = 0) throw();

inline bool QFont::bold() const
{ return weight() > Normal; }


inline void QFont::setBold(bool enable)
{ setWeight(enable ? Bold : Normal); }

inline bool QFont::italic() const
{
    return (style() != StyleNormal);
}

inline void QFont::setItalic(bool b) {
    setStyle(b ? StyleItalic : StyleNormal);
}







__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QFont &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QFont &);



__declspec(dllimport) QDebug operator<<(QDebug, const QFont &);
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qfontmetrics.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qfontmetrics.h"
class QTextCodec;
class QRect;


class __declspec(dllimport) QFontMetrics
{
public:
    explicit QFontMetrics(const QFont &);
    QFontMetrics(const QFont &, QPaintDevice *pd);
    QFontMetrics(const QFontMetrics &);
    ~QFontMetrics();

    QFontMetrics &operator=(const QFontMetrics &);

    inline QFontMetrics &operator=(QFontMetrics &&other)
    { qSwap(d, other.d); return *this; }


    void swap(QFontMetrics &other) { qSwap(d, other.d); }

    int ascent() const;
    int descent() const;
    int height() const;
    int leading() const;
    int lineSpacing() const;
    int minLeftBearing() const;
    int minRightBearing() const;
    int maxWidth() const;

    int xHeight() const;
    int averageCharWidth() const;

    bool inFont(QChar) const;
    bool inFontUcs4(uint ucs4) const;

    int leftBearing(QChar) const;
    int rightBearing(QChar) const;
    int width(const QString &, int len = -1) const;
    int width(const QString &, int len, int flags) const;

    int width(QChar) const;
    int charWidth(const QString &str, int pos) const;

    QRect boundingRect(QChar) const;

    QRect boundingRect(const QString &text) const;
    QRect boundingRect(const QRect &r, int flags, const QString &text, int tabstops=0, int *tabarray=0) const;
    inline QRect boundingRect(int x, int y, int w, int h, int flags, const QString &text,
                              int tabstops=0, int *tabarray=0) const
        { return boundingRect(QRect(x, y, w, h), flags, text, tabstops, tabarray); }
    QSize size(int flags, const QString& str, int tabstops=0, int *tabarray=0) const;

    QRect tightBoundingRect(const QString &text) const;

    QString elidedText(const QString &text, Qt::TextElideMode mode, int width, int flags = 0) const;

    int underlinePos() const;
    int overlinePos() const;
    int strikeOutPos() const;
    int lineWidth() const;

    bool operator==(const QFontMetrics &other) const;
    inline bool operator !=(const QFontMetrics &other) const { return !operator==(other); }

private:
    friend class QFontMetricsF;
    friend class QStackTextEngine;

    QExplicitlySharedDataPointer<QFontPrivate> d;
};

template<> class QTypeInfo<QFontMetrics > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QFontMetrics)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QFontMetrics >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QFontMetrics) }; static inline const char *name() { return "QFontMetrics"; } }; template <> inline void qSwap<QFontMetrics>(QFontMetrics &value1, QFontMetrics &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QFontMetrics >(::QFontMetrics &value1, ::QFontMetrics &value2) { value1.swap(value2); } }

class __declspec(dllimport) QFontMetricsF
{
public:
    explicit QFontMetricsF(const QFont &);
    QFontMetricsF(const QFont &, QPaintDevice *pd);
    QFontMetricsF(const QFontMetrics &);
    QFontMetricsF(const QFontMetricsF &);
    ~QFontMetricsF();

    QFontMetricsF &operator=(const QFontMetricsF &);
    QFontMetricsF &operator=(const QFontMetrics &);

    inline QFontMetricsF &operator=(QFontMetricsF &&other)
    { qSwap(d, other.d); return *this; }


    void swap(QFontMetricsF &other) { qSwap(d, other.d); }

    qreal ascent() const;
    qreal descent() const;
    qreal height() const;
    qreal leading() const;
    qreal lineSpacing() const;
    qreal minLeftBearing() const;
    qreal minRightBearing() const;
    qreal maxWidth() const;

    qreal xHeight() const;
    qreal averageCharWidth() const;

    bool inFont(QChar) const;
    bool inFontUcs4(uint ucs4) const;

    qreal leftBearing(QChar) const;
    qreal rightBearing(QChar) const;
    qreal width(const QString &string) const;

    qreal width(QChar) const;

    QRectF boundingRect(const QString &string) const;
    QRectF boundingRect(QChar) const;
    QRectF boundingRect(const QRectF &r, int flags, const QString& string, int tabstops=0, int *tabarray=0) const;
    QSizeF size(int flags, const QString& str, int tabstops=0, int *tabarray=0) const;

    QRectF tightBoundingRect(const QString &text) const;

    QString elidedText(const QString &text, Qt::TextElideMode mode, qreal width, int flags = 0) const;

    qreal underlinePos() const;
    qreal overlinePos() const;
    qreal strikeOutPos() const;
    qreal lineWidth() const;

    bool operator==(const QFontMetricsF &other) const;
    inline bool operator !=(const QFontMetricsF &other) const { return !operator==(other); }

private:
    QExplicitlySharedDataPointer<QFontPrivate> d;
};

template<> class QTypeInfo<QFontMetricsF > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QFontMetricsF)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QFontMetricsF >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QFontMetricsF) }; static inline const char *name() { return "QFontMetricsF"; } }; template <> inline void qSwap<QFontMetricsF>(QFontMetricsF &value1, QFontMetricsF &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QFontMetricsF >(::QFontMetricsF &value1, ::QFontMetricsF &value2) { value1.swap(value2); } }
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qfontinfo.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qfontinfo.h"
class __declspec(dllimport) QFontInfo
{
public:
    QFontInfo(const QFont &);
    QFontInfo(const QFontInfo &);
    ~QFontInfo();

    QFontInfo &operator=(const QFontInfo &);

    void swap(QFontInfo &other) { qSwap(d, other.d); }

    QString family() const;
    QString styleName() const;
    int pixelSize() const;
    int pointSize() const;
    qreal pointSizeF() const;
    bool italic() const;
    QFont::Style style() const;
    int weight() const;
    inline bool bold() const { return weight() > QFont::Normal; }
    bool underline() const;
    bool overline() const;
    bool strikeOut() const;
    bool fixedPitch() const;
    QFont::StyleHint styleHint() const;
    bool rawMode() const;

    bool exactMatch() const;

private:
    QExplicitlySharedDataPointer<QFontPrivate> d;
};

template<> class QTypeInfo<QFontInfo > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QFontInfo)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QFontInfo >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QFontInfo) }; static inline const char *name() { return "QFontInfo"; } }; template <> inline void qSwap<QFontInfo>(QFontInfo &value1, QFontInfo &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QFontInfo >(::QFontInfo &value1, ::QFontInfo &value2) { value1.swap(value2); } }
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qsizepolicy.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qsizepolicy.h"
class QVariant;

class __declspec(dllimport) QSizePolicy
{
    public: static const QMetaObject staticMetaObject; private:


public:
    enum PolicyFlag {
        GrowFlag = 1,
        ExpandFlag = 2,
        ShrinkFlag = 4,
        IgnoreFlag = 8
    };

    enum Policy {
        Fixed = 0,
        Minimum = GrowFlag,
        Maximum = ShrinkFlag,
        Preferred = GrowFlag | ShrinkFlag,
        MinimumExpanding = GrowFlag | ExpandFlag,
        Expanding = GrowFlag | ShrinkFlag | ExpandFlag,
        Ignored = ShrinkFlag | GrowFlag | IgnoreFlag
    };

    enum ControlType {
        DefaultType = 0x00000001,
        ButtonBox = 0x00000002,
        CheckBox = 0x00000004,
        ComboBox = 0x00000008,
        Frame = 0x00000010,
        GroupBox = 0x00000020,
        Label = 0x00000040,
        Line = 0x00000080,
        LineEdit = 0x00000100,
        PushButton = 0x00000200,
        RadioButton = 0x00000400,
        Slider = 0x00000800,
        SpinBox = 0x00001000,
        TabWidget = 0x00002000,
        ToolButton = 0x00004000
    };
    typedef QFlags<ControlType> ControlTypes;

    QSizePolicy() : data(0) { }


    QSizePolicy(Policy horizontal, Policy vertical, ControlType type = DefaultType)
        : data(0) {
        bits.horPolicy = horizontal;
        bits.verPolicy = vertical;
        setControlType(type);
    }
    Policy horizontalPolicy() const { return static_cast<Policy>(bits.horPolicy); }
    Policy verticalPolicy() const { return static_cast<Policy>(bits.verPolicy); }
    ControlType controlType() const;

    void setHorizontalPolicy(Policy d) { bits.horPolicy = d; }
    void setVerticalPolicy(Policy d) { bits.verPolicy = d; }
    void setControlType(ControlType type);

    Qt::Orientations expandingDirections() const {
        Qt::Orientations result;
        if (verticalPolicy() & ExpandFlag)
            result |= Qt::Vertical;
        if (horizontalPolicy() & ExpandFlag)
            result |= Qt::Horizontal;
        return result;
    }

    void setHeightForWidth(bool b) { bits.hfw = b; }
    bool hasHeightForWidth() const { return bits.hfw; }
    void setWidthForHeight(bool b) { bits.wfh = b; }
    bool hasWidthForHeight() const { return bits.wfh; }

    bool operator==(const QSizePolicy& s) const { return data == s.data; }
    bool operator!=(const QSizePolicy& s) const { return data != s.data; }
    operator QVariant() const;

    int horizontalStretch() const { return static_cast<int>(bits.horStretch); }
    int verticalStretch() const { return static_cast<int>(bits.verStretch); }
    void setHorizontalStretch(int stretchFactor) { bits.horStretch = static_cast<quint32>(qBound(0, stretchFactor, 255)); }
    void setVerticalStretch(int stretchFactor) { bits.verStretch = static_cast<quint32>(qBound(0, stretchFactor, 255)); }

    bool retainSizeWhenHidden() const { return bits.retainSizeWhenHidden; }
    void setRetainSizeWhenHidden(bool retainSize) { bits.retainSizeWhenHidden = retainSize; }

    void transpose();


private:

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QSizePolicy &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QSizePolicy &);

    QSizePolicy(int i) : data(i) { }

    struct Bits {
        quint32 horStretch : 8;
        quint32 verStretch : 8;
        quint32 horPolicy : 4;
        quint32 verPolicy : 4;
        quint32 ctype : 5;
        quint32 hfw : 1;
        quint32 wfh : 1;
        quint32 retainSizeWhenHidden : 1;
    };
    union {
        Bits bits;
        quint32 data;
    };
};

 inline QFlags<QSizePolicy::ControlTypes::enum_type> operator|(QSizePolicy::ControlTypes::enum_type f1, QSizePolicy::ControlTypes::enum_type f2) { return QFlags<QSizePolicy::ControlTypes::enum_type>(f1) | f2; } inline QFlags<QSizePolicy::ControlTypes::enum_type> operator|(QSizePolicy::ControlTypes::enum_type f1, QFlags<QSizePolicy::ControlTypes::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QSizePolicy::ControlTypes::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QSizePolicy &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QSizePolicy &);



__declspec(dllimport) QDebug operator<<(QDebug dbg, const QSizePolicy &);


inline void QSizePolicy::transpose() {
    Policy hData = horizontalPolicy();
    Policy vData = verticalPolicy();
    int hStretch = horizontalStretch();
    int vStretch = verticalStretch();
    setHorizontalPolicy(vData);
    setVerticalPolicy(hData);
    setHorizontalStretch(vStretch);
    setVerticalStretch(hStretch);
}
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qcursor.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qcursor.h"
class QVariant;
class QScreen;
#line 75 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qcursor.h"
class QCursorData;
class QBitmap;
class QPixmap;


class __declspec(dllimport) QCursor
{
public:
    QCursor();
    QCursor(Qt::CursorShape shape);
    QCursor(const QBitmap &bitmap, const QBitmap &mask, int hotX=-1, int hotY=-1);
    QCursor(const QPixmap &pixmap, int hotX=-1, int hotY=-1);
    QCursor(const QCursor &cursor);
    ~QCursor();
    QCursor &operator=(const QCursor &cursor);

    inline QCursor &operator=(QCursor &&other)
    { qSwap(d, other.d); return *this; }

    operator QVariant() const;

    Qt::CursorShape shape() const;
    void setShape(Qt::CursorShape newShape);

    const QBitmap *bitmap() const;
    const QBitmap *mask() const;
    QPixmap pixmap() const;
    QPoint hotSpot() const;

    static QPoint pos();
    static QPoint pos(const QScreen *screen);
    static void setPos(int x, int y);
    static void setPos(QScreen *screen, int x, int y);
    inline static void setPos(const QPoint &p) { setPos(p.x(), p.y()); }
    inline static void setPos(QScreen *screen, const QPoint &p) { setPos(screen, p.x(), p.y()); }

private:
    QCursorData *d;
};





__declspec(dllimport) QDataStream &operator<<(QDataStream &outS, const QCursor &cursor);
__declspec(dllimport) QDataStream &operator>>(QDataStream &inS, QCursor &cursor);



__declspec(dllimport) QDebug operator<<(QDebug, const QCursor &);
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qkeysequence.h"
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qkeysequence.h"
class QKeySequence;
__declspec(dllimport) QDataStream &operator<<(QDataStream &in, const QKeySequence &ks);
__declspec(dllimport) QDataStream &operator>>(QDataStream &out, QKeySequence &ks);






class QVariant;
class QKeySequencePrivate;

class __declspec(dllimport) QKeySequence
{
    public: static const QMetaObject staticMetaObject; private:


public:
    enum StandardKey {
        UnknownKey,
        HelpContents,
        WhatsThis,
        Open,
        Close,
        Save,
        New,
        Delete,
        Cut,
        Copy,
        Paste,
        Undo,
        Redo,
        Back,
        Forward,
        Refresh,
        ZoomIn,
        ZoomOut,
        Print,
        AddTab,
        NextChild,
        PreviousChild,
        Find,
        FindNext,
        FindPrevious,
        Replace,
        SelectAll,
        Bold,
        Italic,
        Underline,
        MoveToNextChar,
        MoveToPreviousChar,
        MoveToNextWord,
        MoveToPreviousWord,
        MoveToNextLine,
        MoveToPreviousLine,
        MoveToNextPage,
        MoveToPreviousPage,
        MoveToStartOfLine,
        MoveToEndOfLine,
        MoveToStartOfBlock,
        MoveToEndOfBlock,
        MoveToStartOfDocument,
        MoveToEndOfDocument,
        SelectNextChar,
        SelectPreviousChar,
        SelectNextWord,
        SelectPreviousWord,
        SelectNextLine,
        SelectPreviousLine,
        SelectNextPage,
        SelectPreviousPage,
        SelectStartOfLine,
        SelectEndOfLine,
        SelectStartOfBlock,
        SelectEndOfBlock,
        SelectStartOfDocument,
        SelectEndOfDocument,
        DeleteStartOfWord,
        DeleteEndOfWord,
        DeleteEndOfLine,
        InsertParagraphSeparator,
        InsertLineSeparator,
        SaveAs,
        Preferences,
        Quit,
        FullScreen,
        Deselect,
        DeleteCompleteLine
     };

    enum SequenceFormat {
        NativeText,
        PortableText
    };

    QKeySequence();
    QKeySequence(const QString &key, SequenceFormat format = NativeText);
    QKeySequence(int k1, int k2 = 0, int k3 = 0, int k4 = 0);
    QKeySequence(const QKeySequence &ks);
    QKeySequence(StandardKey key);
    ~QKeySequence();

    int count() const;
    bool isEmpty() const;

    enum SequenceMatch {
        NoMatch,
        PartialMatch,
        ExactMatch
    };

    QString toString(SequenceFormat format = PortableText) const;
    static QKeySequence fromString(const QString &str, SequenceFormat format = PortableText);

    static QList<QKeySequence> listFromString(const QString &str, SequenceFormat format = PortableText);
    static QString listToString(const QList<QKeySequence> &list, SequenceFormat format = PortableText);

    SequenceMatch matches(const QKeySequence &seq) const;
    static QKeySequence mnemonic(const QString &text);
    static QList<QKeySequence> keyBindings(StandardKey key);





    operator QVariant() const;
    int operator[](uint i) const;
    QKeySequence &operator=(const QKeySequence &other);

    inline QKeySequence &operator=(QKeySequence &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QKeySequence &other) { qSwap(d, other.d); }
    bool operator==(const QKeySequence &other) const;
    inline bool operator!= (const QKeySequence &other) const
    { return !(*this == other); }
    bool operator< (const QKeySequence &ks) const;
    inline bool operator> (const QKeySequence &other) const
    { return other < *this; }
    inline bool operator<= (const QKeySequence &other) const
    { return !(other < *this); }
    inline bool operator>= (const QKeySequence &other) const
    { return !(*this < other); }

    bool isDetached() const;
private:
    static int decodeString(const QString &ks);
    static QString encodeString(int key);
    int assign(const QString &str);
    int assign(const QString &str, SequenceFormat format);
    void setKey(int key, int index);

    QKeySequencePrivate *d;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &in, const QKeySequence &ks);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &in, QKeySequence &ks);
    friend class QShortcutMap;
    friend class QShortcut;

public:
    typedef QKeySequencePrivate * DataPtr;
    inline DataPtr &data_ptr() { return d; }
};

template<> class QTypeInfo<QKeySequence > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QKeySequence)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QKeySequence >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QKeySequence) }; static inline const char *name() { return "QKeySequence"; } }; template <> inline void qSwap<QKeySequence>(QKeySequence &value1, QKeySequence &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QKeySequence >(::QKeySequence &value1, ::QKeySequence &value2) { value1.swap(value2); } }


__declspec(dllimport) QDebug operator<<(QDebug, const QKeySequence &);
#line 57 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"
#line 66 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"
class QLayout;
class QWSRegionManager;
class QStyle;
class QAction;
class QVariant;
class QWindow;
class QActionEvent;
class QMouseEvent;
class QWheelEvent;
class QHoverEvent;
class QKeyEvent;
class QFocusEvent;
class QPaintEvent;
class QMoveEvent;
class QResizeEvent;
class QCloseEvent;
class QContextMenuEvent;
class QInputMethodEvent;
class QTabletEvent;
class QDragEnterEvent;
class QDragMoveEvent;
class QDragLeaveEvent;
class QDropEvent;
class QShowEvent;
class QHideEvent;
class QIcon;
class QBackingStore;
class QPlatformWindow;
class QLocale;
class QGraphicsProxyWidget;
class QGraphicsEffect;
class QRasterWindowSurface;
class QUnifiedToolbarSurface;
class QPixmap;

class QWidgetData
{
public:
    WId winid;
    uint widget_attributes;
    Qt::WindowFlags window_flags;
    uint window_state : 4;
    uint focus_policy : 4;
    uint sizehint_forced :1;
    uint is_closing :1;
    uint in_show : 1;
    uint in_set_window_state : 1;
    mutable uint fstrut_dirty : 1;
    uint context_menu_policy : 3;
    uint window_modality : 2;
    uint in_destructor : 1;
    uint unused : 13;
    QRect crect;
    mutable QPalette pal;
    QFont fnt;
    QRect wrect;
};

class QWidgetPrivate;

class __declspec(dllimport) QWidget : public QObject, public QPaintDevice
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QWidgetPrivate* d_func() { return reinterpret_cast<QWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QWidgetPrivate* d_func() const { return reinterpret_cast<const QWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QWidgetPrivate;
#line 203 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"
public:
    enum RenderFlag {
        DrawWindowBackground = 0x1,
        DrawChildren = 0x2,
        IgnoreMask = 0x4
    };
    typedef QFlags<RenderFlag> RenderFlags;

    explicit QWidget(QWidget* parent = 0, Qt::WindowFlags f = 0);
    ~QWidget();

    int devType() const;

    WId winId() const;
    void createWinId();
    inline WId internalWinId() const { return data->winid; }
    WId effectiveWinId() const;


    QStyle *style() const;
    void setStyle(QStyle *);


    bool isTopLevel() const;
    bool isWindow() const;

    bool isModal() const;
    Qt::WindowModality windowModality() const;
    void setWindowModality(Qt::WindowModality windowModality);

    bool isEnabled() const;
    bool isEnabledTo(const QWidget *) const;
    bool isEnabledToTLW() const;

public :
    void setEnabled(bool);
    void setDisabled(bool);
    void setWindowModified(bool);



public:
    QRect frameGeometry() const;
    const QRect &geometry() const;
    QRect normalGeometry() const;

    int x() const;
    int y() const;
    QPoint pos() const;
    QSize frameSize() const;
    QSize size() const;
    inline int width() const;
    inline int height() const;
    inline QRect rect() const;
    QRect childrenRect() const;
    QRegion childrenRegion() const;

    QSize minimumSize() const;
    QSize maximumSize() const;
    int minimumWidth() const;
    int minimumHeight() const;
    int maximumWidth() const;
    int maximumHeight() const;
    void setMinimumSize(const QSize &);
    void setMinimumSize(int minw, int minh);
    void setMaximumSize(const QSize &);
    void setMaximumSize(int maxw, int maxh);
    void setMinimumWidth(int minw);
    void setMinimumHeight(int minh);
    void setMaximumWidth(int maxw);
    void setMaximumHeight(int maxh);





    QSize sizeIncrement() const;
    void setSizeIncrement(const QSize &);
    void setSizeIncrement(int w, int h);
    QSize baseSize() const;
    void setBaseSize(const QSize &);
    void setBaseSize(int basew, int baseh);

    void setFixedSize(const QSize &);
    void setFixedSize(int w, int h);
    void setFixedWidth(int w);
    void setFixedHeight(int h);



    QPoint mapToGlobal(const QPoint &) const;
    QPoint mapFromGlobal(const QPoint &) const;
    QPoint mapToParent(const QPoint &) const;
    QPoint mapFromParent(const QPoint &) const;
    QPoint mapTo(const QWidget *, const QPoint &) const;
    QPoint mapFrom(const QWidget *, const QPoint &) const;

    QWidget *window() const;
    QWidget *nativeParentWidget() const;
    inline QWidget *topLevelWidget() const { return window(); }


    const QPalette &palette() const;
    void setPalette(const QPalette &);

    void setBackgroundRole(QPalette::ColorRole);
    QPalette::ColorRole backgroundRole() const;

    void setForegroundRole(QPalette::ColorRole);
    QPalette::ColorRole foregroundRole() const;

    const QFont &font() const;
    void setFont(const QFont &);
    QFontMetrics fontMetrics() const;
    QFontInfo fontInfo() const;


    QCursor cursor() const;
    void setCursor(const QCursor &);
    void unsetCursor();


    void setMouseTracking(bool enable);
    bool hasMouseTracking() const;
    bool underMouse() const;

    void setMask(const QBitmap &);
    void setMask(const QRegion &);
    QRegion mask() const;
    void clearMask();

    void render(QPaintDevice *target, const QPoint &targetOffset = QPoint(),
                const QRegion &sourceRegion = QRegion(),
                RenderFlags renderFlags = RenderFlags(DrawWindowBackground | DrawChildren));

    void render(QPainter *painter, const QPoint &targetOffset = QPoint(),
                const QRegion &sourceRegion = QRegion(),
                RenderFlags renderFlags = RenderFlags(DrawWindowBackground | DrawChildren));

                QPixmap grab(const QRect &rectangle = QRect(QPoint(0, 0), QSize(-1, -1)));


    QGraphicsEffect *graphicsEffect() const;
    void setGraphicsEffect(QGraphicsEffect *effect);



    void grabGesture(Qt::GestureType type, Qt::GestureFlags flags = Qt::GestureFlags());
    void ungrabGesture(Qt::GestureType type);


public :
    void setWindowTitle(const QString &);

    void setStyleSheet(const QString& styleSheet);

public:

    QString styleSheet() const;

    QString windowTitle() const;
    void setWindowIcon(const QIcon &icon);
    QIcon windowIcon() const;
    void setWindowIconText(const QString &);
    QString windowIconText() const;
    void setWindowRole(const QString &);
    QString windowRole() const;
    void setWindowFilePath(const QString &filePath);
    QString windowFilePath() const;

    void setWindowOpacity(qreal level);
    qreal windowOpacity() const;

    bool isWindowModified() const;

    void setToolTip(const QString &);
    QString toolTip() const;
    void setToolTipDuration(int msec);
    int toolTipDuration() const;


    void setStatusTip(const QString &);
    QString statusTip() const;


    void setWhatsThis(const QString &);
    QString whatsThis() const;


    QString accessibleName() const;
    void setAccessibleName(const QString &name);
    QString accessibleDescription() const;
    void setAccessibleDescription(const QString &description);


    void setLayoutDirection(Qt::LayoutDirection direction);
    Qt::LayoutDirection layoutDirection() const;
    void unsetLayoutDirection();

    void setLocale(const QLocale &locale);
    QLocale locale() const;
    void unsetLocale();

    inline bool isRightToLeft() const { return layoutDirection() == Qt::RightToLeft; }
    inline bool isLeftToRight() const { return layoutDirection() == Qt::LeftToRight; }

public :
    inline void setFocus() { setFocus(Qt::OtherFocusReason); }

public:
    bool isActiveWindow() const;
    void activateWindow();
    void clearFocus();

    void setFocus(Qt::FocusReason reason);
    Qt::FocusPolicy focusPolicy() const;
    void setFocusPolicy(Qt::FocusPolicy policy);
    bool hasFocus() const;
    static void setTabOrder(QWidget *, QWidget *);
    void setFocusProxy(QWidget *);
    QWidget *focusProxy() const;
    Qt::ContextMenuPolicy contextMenuPolicy() const;
    void setContextMenuPolicy(Qt::ContextMenuPolicy policy);


    void grabMouse();

    void grabMouse(const QCursor &);

    void releaseMouse();
    void grabKeyboard();
    void releaseKeyboard();

    int grabShortcut(const QKeySequence &key, Qt::ShortcutContext context = Qt::WindowShortcut);
    void releaseShortcut(int id);
    void setShortcutEnabled(int id, bool enable = true);
    void setShortcutAutoRepeat(int id, bool enable = true);

    static QWidget *mouseGrabber();
    static QWidget *keyboardGrabber();


    inline bool updatesEnabled() const;
    void setUpdatesEnabled(bool enable);


    QGraphicsProxyWidget *graphicsProxyWidget() const;


public :
    void update();
    void repaint();

public:
    inline void update(int x, int y, int w, int h);
    void update(const QRect&);
    void update(const QRegion&);

    void repaint(int x, int y, int w, int h);
    void repaint(const QRect &);
    void repaint(const QRegion &);

public :


    virtual void setVisible(bool visible);
    void setHidden(bool hidden);
    void show();
    void hide();

    void showMinimized();
    void showMaximized();
    void showFullScreen();
    void showNormal();

    bool close();
    void raise();
    void lower();

public:
    void stackUnder(QWidget*);
    void move(int x, int y);
    void move(const QPoint &);
    void resize(int w, int h);
    void resize(const QSize &);
    inline void setGeometry(int x, int y, int w, int h);
    void setGeometry(const QRect &);
    QByteArray saveGeometry() const;
    bool restoreGeometry(const QByteArray &geometry);
    void adjustSize();
    bool isVisible() const;
    bool isVisibleTo(const QWidget *) const;
    inline bool isHidden() const;

    bool isMinimized() const;
    bool isMaximized() const;
    bool isFullScreen() const;

    Qt::WindowStates windowState() const;
    void setWindowState(Qt::WindowStates state);
    void overrideWindowState(Qt::WindowStates state);

    virtual QSize sizeHint() const;
    virtual QSize minimumSizeHint() const;

    QSizePolicy sizePolicy() const;
    void setSizePolicy(QSizePolicy);
    inline void setSizePolicy(QSizePolicy::Policy horizontal, QSizePolicy::Policy vertical);
    virtual int heightForWidth(int) const;
    virtual bool hasHeightForWidth() const;

    QRegion visibleRegion() const;

    void setContentsMargins(int left, int top, int right, int bottom);
    void setContentsMargins(const QMargins &margins);
    void getContentsMargins(int *left, int *top, int *right, int *bottom) const;
    QMargins contentsMargins() const;

    QRect contentsRect() const;

public:
    QLayout *layout() const;
    void setLayout(QLayout *);
    void updateGeometry();

    void setParent(QWidget *parent);
    void setParent(QWidget *parent, Qt::WindowFlags f);

    void scroll(int dx, int dy);
    void scroll(int dx, int dy, const QRect&);



    QWidget *focusWidget() const;
    QWidget *nextInFocusChain() const;
    QWidget *previousInFocusChain() const;


    bool acceptDrops() const;
    void setAcceptDrops(bool on);



    void addAction(QAction *action);
    void addActions(QList<QAction*> actions);
    void insertAction(QAction *before, QAction *action);
    void insertActions(QAction *before, QList<QAction*> actions);
    void removeAction(QAction *action);
    QList<QAction*> actions() const;


    QWidget *parentWidget() const;

    void setWindowFlags(Qt::WindowFlags type);
    inline Qt::WindowFlags windowFlags() const;
    void overrideWindowFlags(Qt::WindowFlags type);

    inline Qt::WindowType windowType() const;

    static QWidget *find(WId);
    inline QWidget *childAt(int x, int y) const;
    QWidget *childAt(const QPoint &p) const;
#line 576 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qwidget.h"
    void setAttribute(Qt::WidgetAttribute, bool on = true);
    inline bool testAttribute(Qt::WidgetAttribute) const;

    QPaintEngine *paintEngine() const;

    void ensurePolished() const;

    bool isAncestorOf(const QWidget *child) const;






    bool autoFillBackground() const;
    void setAutoFillBackground(bool enabled);

    QBackingStore *backingStore() const;

    QWindow *windowHandle() const;

    static QWidget *createWindowContainer(QWindow *window, QWidget *parent=0, Qt::WindowFlags flags=0);

    friend class QDesktopScreenWidget;

public:
    void windowTitleChanged(const QString &title);
    void windowIconChanged(const QIcon &icon);
    void windowIconTextChanged(const QString &iconText);
    void customContextMenuRequested(const QPoint &pos);

protected:

    bool event(QEvent *);
    virtual void mousePressEvent(QMouseEvent *);
    virtual void mouseReleaseEvent(QMouseEvent *);
    virtual void mouseDoubleClickEvent(QMouseEvent *);
    virtual void mouseMoveEvent(QMouseEvent *);

    virtual void wheelEvent(QWheelEvent *);

    virtual void keyPressEvent(QKeyEvent *);
    virtual void keyReleaseEvent(QKeyEvent *);
    virtual void focusInEvent(QFocusEvent *);
    virtual void focusOutEvent(QFocusEvent *);
    virtual void enterEvent(QEvent *);
    virtual void leaveEvent(QEvent *);
    virtual void paintEvent(QPaintEvent *);
    virtual void moveEvent(QMoveEvent *);
    virtual void resizeEvent(QResizeEvent *);
    virtual void closeEvent(QCloseEvent *);

    virtual void contextMenuEvent(QContextMenuEvent *);


    virtual void tabletEvent(QTabletEvent *);


    virtual void actionEvent(QActionEvent *);



    virtual void dragEnterEvent(QDragEnterEvent *);
    virtual void dragMoveEvent(QDragMoveEvent *);
    virtual void dragLeaveEvent(QDragLeaveEvent *);
    virtual void dropEvent(QDropEvent *);


    virtual void showEvent(QShowEvent *);
    virtual void hideEvent(QHideEvent *);
    virtual bool nativeEvent(const QByteArray &eventType, void *message, long *result);


    virtual void changeEvent(QEvent *);

    int metric(PaintDeviceMetric) const;
    void initPainter(QPainter *painter) const;
    QPaintDevice *redirected(QPoint *offset) const;
    QPainter *sharedPainter() const;

    virtual void inputMethodEvent(QInputMethodEvent *);
public:
    virtual QVariant inputMethodQuery(Qt::InputMethodQuery) const;

    Qt::InputMethodHints inputMethodHints() const;
    void setInputMethodHints(Qt::InputMethodHints hints);

protected :
    void updateMicroFocus();
protected:

    void create(WId = 0, bool initializeWindow = true,
                         bool destroyOldWindow = true);
    void destroy(bool destroyWindow = true,
                 bool destroySubWindows = true);

    virtual bool focusNextPrevChild(bool next);
    inline bool focusNextChild() { return focusNextPrevChild(true); }
    inline bool focusPreviousChild() { return focusNextPrevChild(false); }

protected:
    QWidget(QWidgetPrivate &d, QWidget* parent, Qt::WindowFlags f);
private:
    void setBackingStore(QBackingStore *store);

    bool testAttribute_helper(Qt::WidgetAttribute) const;

    QLayout *takeLayout();

    friend class QBackingStoreDevice;
    friend class QWidgetBackingStore;
    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QGuiApplication;
    friend class QGuiApplicationPrivate;
    friend class QBaseApplication;
    friend class QPainter;
    friend class QPainterPrivate;
    friend class QPixmap;
    friend class QFontMetrics;
    friend class QFontInfo;
    friend class QETWidget;
    friend class QLayout;
    friend class QWidgetItem;
    friend class QWidgetItemV2;
    friend class QGLContext;
    friend class QGLWidget;
    friend class QGLWindowSurface;
    friend class QX11PaintEngine;
    friend class QWin32PaintEngine;
    friend class QShortcutPrivate;
    friend class QWindowSurface;
    friend class QGraphicsProxyWidget;
    friend class QGraphicsProxyWidgetPrivate;
    friend class QStyleSheetStyle;
    friend struct QWidgetExceptionCleaner;
    friend class QWidgetWindow;
    friend class QAccessibleWidget;
    friend class QAccessibleTable;

    friend class QGestureManager;
    friend class QWinNativePanGestureRecognizer;

    friend class QWidgetEffectSourcePrivate;




    friend __declspec(dllimport) QWidgetData *qt_qwidget_data(QWidget *widget);
    friend __declspec(dllimport) QWidgetPrivate *qt_widget_private(QWidget *widget);

private:
    QWidget(const QWidget &) = delete; QWidget &operator=(const QWidget &) = delete;


    QWidgetData *data;
};

 inline QFlags<QWidget::RenderFlags::enum_type> operator|(QWidget::RenderFlags::enum_type f1, QWidget::RenderFlags::enum_type f2) { return QFlags<QWidget::RenderFlags::enum_type>(f1) | f2; } inline QFlags<QWidget::RenderFlags::enum_type> operator|(QWidget::RenderFlags::enum_type f1, QFlags<QWidget::RenderFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QWidget::RenderFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


template <> inline QWidget *qobject_cast<QWidget*>(QObject *o)
{
    if (!o || !o->isWidgetType()) return 0;
    return static_cast<QWidget*>(o);
}
template <> inline const QWidget *qobject_cast<const QWidget*>(const QObject *o)
{
    if (!o || !o->isWidgetType()) return 0;
    return static_cast<const QWidget*>(o);
}


inline QWidget *QWidget::childAt(int ax, int ay) const
{ return childAt(QPoint(ax, ay)); }

inline Qt::WindowType QWidget::windowType() const
{ return static_cast<Qt::WindowType>(int(data->window_flags & Qt::WindowType_Mask)); }
inline Qt::WindowFlags QWidget::windowFlags() const
{ return data->window_flags; }

inline bool QWidget::isTopLevel() const
{ return (windowType() & Qt::Window); }

inline bool QWidget::isWindow() const
{ return (windowType() & Qt::Window); }

inline bool QWidget::isEnabled() const
{ return !testAttribute(Qt::WA_Disabled); }

inline bool QWidget::isModal() const
{ return data->window_modality != Qt::NonModal; }

inline bool QWidget::isEnabledToTLW() const
{ return isEnabled(); }

inline int QWidget::minimumWidth() const
{ return minimumSize().width(); }

inline int QWidget::minimumHeight() const
{ return minimumSize().height(); }

inline int QWidget::maximumWidth() const
{ return maximumSize().width(); }

inline int QWidget::maximumHeight() const
{ return maximumSize().height(); }

inline void QWidget::setMinimumSize(const QSize &s)
{ setMinimumSize(s.width(),s.height()); }

inline void QWidget::setMaximumSize(const QSize &s)
{ setMaximumSize(s.width(),s.height()); }

inline void QWidget::setSizeIncrement(const QSize &s)
{ setSizeIncrement(s.width(),s.height()); }

inline void QWidget::setBaseSize(const QSize &s)
{ setBaseSize(s.width(),s.height()); }

inline const QFont &QWidget::font() const
{ return data->fnt; }

inline QFontMetrics QWidget::fontMetrics() const
{ return QFontMetrics(data->fnt); }

inline QFontInfo QWidget::fontInfo() const
{ return QFontInfo(data->fnt); }

inline void QWidget::setMouseTracking(bool enable)
{ setAttribute(Qt::WA_MouseTracking, enable); }

inline bool QWidget::hasMouseTracking() const
{ return testAttribute(Qt::WA_MouseTracking); }

inline bool QWidget::underMouse() const
{ return testAttribute(Qt::WA_UnderMouse); }

inline bool QWidget::updatesEnabled() const
{ return !testAttribute(Qt::WA_UpdatesDisabled); }

inline void QWidget::update(int ax, int ay, int aw, int ah)
{ update(QRect(ax, ay, aw, ah)); }

inline bool QWidget::isVisible() const
{ return testAttribute(Qt::WA_WState_Visible); }

inline bool QWidget::isHidden() const
{ return testAttribute(Qt::WA_WState_Hidden); }

inline void QWidget::move(int ax, int ay)
{ move(QPoint(ax, ay)); }

inline void QWidget::resize(int w, int h)
{ resize(QSize(w, h)); }

inline void QWidget::setGeometry(int ax, int ay, int aw, int ah)
{ setGeometry(QRect(ax, ay, aw, ah)); }

inline QRect QWidget::rect() const
{ return QRect(0,0,data->crect.width(),data->crect.height()); }

inline const QRect &QWidget::geometry() const
{ return data->crect; }

inline QSize QWidget::size() const
{ return data->crect.size(); }

inline int QWidget::width() const
{ return data->crect.width(); }

inline int QWidget::height() const
{ return data->crect.height(); }

inline QWidget *QWidget::parentWidget() const
{ return static_cast<QWidget *>(QObject::parent()); }

inline void QWidget::setSizePolicy(QSizePolicy::Policy hor, QSizePolicy::Policy ver)
{ setSizePolicy(QSizePolicy(hor, ver)); }

inline bool QWidget::testAttribute(Qt::WidgetAttribute attribute) const
{
    if (attribute < int(8*sizeof(uint)))
        return data->widget_attributes & (1<<attribute);
    return testAttribute_helper(attribute);
}
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QWidget"
#line 7 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QDesktopWidget"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qdesktopwidget.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qdesktopwidget.h"
class QApplication;
class QDesktopWidgetPrivate;

class __declspec(dllimport) QDesktopWidget : public QWidget
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};



public:
    QDesktopWidget();
    ~QDesktopWidget();

    bool isVirtualDesktop() const;

    int numScreens() const;
    int screenCount() const;
    int primaryScreen() const;

    int screenNumber(const QWidget *widget = 0) const;
    int screenNumber(const QPoint &) const;

    QWidget *screen(int screen = -1);

    const QRect screenGeometry(int screen = -1) const;
    const QRect screenGeometry(const QWidget *widget) const;
    const QRect screenGeometry(const QPoint &point) const
    { return screenGeometry(screenNumber(point)); }

    const QRect availableGeometry(int screen = -1) const;
    const QRect availableGeometry(const QWidget *widget) const;
    const QRect availableGeometry(const QPoint &point) const
    { return availableGeometry(screenNumber(point)); }

public:
    void resized(int);
    void workAreaResized(int);
    void screenCountChanged(int);

protected:
    void resizeEvent(QResizeEvent *e);

private:
    QDesktopWidget(const QDesktopWidget &) = delete; QDesktopWidget &operator=(const QDesktopWidget &) = delete;
    inline QDesktopWidgetPrivate* d_func() { return reinterpret_cast<QDesktopWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDesktopWidgetPrivate* d_func() const { return reinterpret_cast<const QDesktopWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDesktopWidgetPrivate;


    friend class QApplication;
    friend class QApplicationPrivate;
};

inline int QDesktopWidget::screenCount() const
{ return numScreens(); }
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QDesktopWidget"
#line 8 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QStackedLayout"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qstackedlayout.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qstackedlayout.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qlayout.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qlayout.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qlayoutitem.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qlayoutitem.h"
static const int QLAYOUTSIZE_MAX = 2147483647/256/16;

class QLayout;
class QLayoutItem;
class QSpacerItem;
class QWidget;
class QSize;

class __declspec(dllimport) QLayoutItem
{
public:
    inline explicit QLayoutItem(Qt::Alignment alignment = 0);
    virtual ~QLayoutItem();
    virtual QSize sizeHint() const = 0;
    virtual QSize minimumSize() const = 0;
    virtual QSize maximumSize() const = 0;
    virtual Qt::Orientations expandingDirections() const = 0;
    virtual void setGeometry(const QRect&) = 0;
    virtual QRect geometry() const = 0;
    virtual bool isEmpty() const = 0;
    virtual bool hasHeightForWidth() const;
    virtual int heightForWidth(int) const;
    virtual int minimumHeightForWidth(int) const;
    virtual void invalidate();

    virtual QWidget *widget();
    virtual QLayout *layout();
    virtual QSpacerItem *spacerItem();

    Qt::Alignment alignment() const { return align; }
    void setAlignment(Qt::Alignment a);
    virtual QSizePolicy::ControlTypes controlTypes() const;

protected:
    Qt::Alignment align;
};

inline QLayoutItem::QLayoutItem(Qt::Alignment aalignment)
    : align(aalignment) { }

class __declspec(dllimport) QSpacerItem : public QLayoutItem
{
public:
    QSpacerItem(int w, int h,
                 QSizePolicy::Policy hData = QSizePolicy::Minimum,
                 QSizePolicy::Policy vData = QSizePolicy::Minimum)
        : width(w), height(h), sizeP(hData, vData) { }
    ~QSpacerItem();

    void changeSize(int w, int h,
                     QSizePolicy::Policy hData = QSizePolicy::Minimum,
                     QSizePolicy::Policy vData = QSizePolicy::Minimum);
    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    Qt::Orientations expandingDirections() const;
    bool isEmpty() const;
    void setGeometry(const QRect&);
    QRect geometry() const;
    QSpacerItem *spacerItem();

private:
    int width;
    int height;
    QSizePolicy sizeP;
    QRect rect;
};

class __declspec(dllimport) QWidgetItem : public QLayoutItem
{
    QWidgetItem(const QWidgetItem &) = delete; QWidgetItem &operator=(const QWidgetItem &) = delete;

public:
    explicit QWidgetItem(QWidget *w) : wid(w) { }
    ~QWidgetItem();

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    Qt::Orientations expandingDirections() const;
    bool isEmpty() const;
    void setGeometry(const QRect&);
    QRect geometry() const;
    virtual QWidget *widget();

    bool hasHeightForWidth() const;
    int heightForWidth(int) const;
    QSizePolicy::ControlTypes controlTypes() const;
protected:
    QWidget *wid;
};

class __declspec(dllimport) QWidgetItemV2 : public QWidgetItem
{
public:
    explicit QWidgetItemV2(QWidget *widget);
    ~QWidgetItemV2();

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    int heightForWidth(int width) const;

private:
    enum { Dirty = -123, HfwCacheMaxSize = 3 };

    inline bool useSizeCache() const;
    void updateCacheIfNecessary() const;
    inline void invalidateSizeCache() {
        q_cachedMinimumSize.setWidth(Dirty);
        q_hfwCacheSize = 0;
    }

    mutable QSize q_cachedMinimumSize;
    mutable QSize q_cachedSizeHint;
    mutable QSize q_cachedMaximumSize;
    mutable QSize q_cachedHfws[HfwCacheMaxSize];
    mutable short q_firstCachedHfw;
    mutable short q_hfwCacheSize;
    void *d;

    friend class QWidgetPrivate;

    QWidgetItemV2(const QWidgetItemV2 &) = delete; QWidgetItemV2 &operator=(const QWidgetItemV2 &) = delete;
};
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qlayout.h"
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qlayout.h"
class QLayout;
class QSize;


class QLayoutPrivate;

class __declspec(dllimport) QLayout : public QObject, public QLayoutItem
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QLayoutPrivate* d_func() { return reinterpret_cast<QLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QLayoutPrivate* d_func() const { return reinterpret_cast<const QLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QLayoutPrivate;





public:
    enum SizeConstraint {
        SetDefaultConstraint,
        SetNoConstraint,
        SetMinimumSize,
        SetFixedSize,
        SetMaximumSize,
        SetMinAndMaxSize
    };

    QLayout(QWidget *parent);
    QLayout();
    ~QLayout();

    int margin() const;
    int spacing() const;

    void setMargin(int);
    void setSpacing(int);

    void setContentsMargins(int left, int top, int right, int bottom);
    void setContentsMargins(const QMargins &margins);
    void getContentsMargins(int *left, int *top, int *right, int *bottom) const;
    QMargins contentsMargins() const;
    QRect contentsRect() const;

    bool setAlignment(QWidget *w, Qt::Alignment alignment);
    bool setAlignment(QLayout *l, Qt::Alignment alignment);



    using QLayoutItem::setAlignment;


    void setSizeConstraint(SizeConstraint);
    SizeConstraint sizeConstraint() const;
    void setMenuBar(QWidget *w);
    QWidget *menuBar() const;

    QWidget *parentWidget() const;

    void invalidate();
    QRect geometry() const;
    bool activate();
    void update();

    void addWidget(QWidget *w);
    virtual void addItem(QLayoutItem *) = 0;

    void removeWidget(QWidget *w);
    void removeItem(QLayoutItem *);

    Qt::Orientations expandingDirections() const;
    QSize minimumSize() const;
    QSize maximumSize() const;
    virtual void setGeometry(const QRect&);
    virtual QLayoutItem *itemAt(int index) const = 0;
    virtual QLayoutItem *takeAt(int index) = 0;
    virtual int indexOf(QWidget *) const;
    virtual int count() const = 0;
    bool isEmpty() const;
    QSizePolicy::ControlTypes controlTypes() const;


    QLayoutItem *replaceWidget(QWidget *from, QWidget *to, Qt::FindChildOptions options = Qt::FindChildrenRecursively);

    int totalHeightForWidth(int w) const;
    QSize totalMinimumSize() const;
    QSize totalMaximumSize() const;
    QSize totalSizeHint() const;
    QLayout *layout();

    void setEnabled(bool);
    bool isEnabled() const;


    static QSize closestAcceptableSize(const QWidget *w, const QSize &s);

protected:
    void widgetEvent(QEvent *);
    void childEvent(QChildEvent *e);
    void addChildLayout(QLayout *l);
    void addChildWidget(QWidget *w);
    bool adoptLayout(QLayout *layout);

    QRect alignmentRect(const QRect&) const;
protected:
    QLayout(QLayoutPrivate &d, QLayout*, QWidget*);

private:
    QLayout(const QLayout &) = delete; QLayout &operator=(const QLayout &) = delete;

    static void activateRecursiveHelper(QLayoutItem *item);

    friend class QApplicationPrivate;
    friend class QWidget;

};





#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qboxlayout.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qboxlayout.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qlayout.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qboxlayout.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qboxlayout.h"
class QBoxLayoutPrivate;

class __declspec(dllimport) QBoxLayout : public QLayout
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QBoxLayoutPrivate* d_func() { return reinterpret_cast<QBoxLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QBoxLayoutPrivate* d_func() const { return reinterpret_cast<const QBoxLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QBoxLayoutPrivate;
public:
    enum Direction { LeftToRight, RightToLeft, TopToBottom, BottomToTop,
                     Down = TopToBottom, Up = BottomToTop };

    explicit QBoxLayout(Direction, QWidget *parent = 0);

    ~QBoxLayout();

    Direction direction() const;
    void setDirection(Direction);

    void addSpacing(int size);
    void addStretch(int stretch = 0);
    void addSpacerItem(QSpacerItem *spacerItem);
    void addWidget(QWidget *, int stretch = 0, Qt::Alignment alignment = 0);
    void addLayout(QLayout *layout, int stretch = 0);
    void addStrut(int);
    void addItem(QLayoutItem *);

    void insertSpacing(int index, int size);
    void insertStretch(int index, int stretch = 0);
    void insertSpacerItem(int index, QSpacerItem *spacerItem);
    void insertWidget(int index, QWidget *widget, int stretch = 0, Qt::Alignment alignment = 0);
    void insertLayout(int index, QLayout *layout, int stretch = 0);
    void insertItem(int index, QLayoutItem *);

    int spacing() const;
    void setSpacing(int spacing);

    bool setStretchFactor(QWidget *w, int stretch);
    bool setStretchFactor(QLayout *l, int stretch);
    void setStretch(int index, int stretch);
    int stretch(int index) const;

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;

    bool hasHeightForWidth() const;
    int heightForWidth(int) const;
    int minimumHeightForWidth(int) const;

    Qt::Orientations expandingDirections() const;
    void invalidate();
    QLayoutItem *itemAt(int) const;
    QLayoutItem *takeAt(int);
    int count() const;
    void setGeometry(const QRect&);

private:
    QBoxLayout(const QBoxLayout &) = delete; QBoxLayout &operator=(const QBoxLayout &) = delete;
};

class __declspec(dllimport) QHBoxLayout : public QBoxLayout
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    QHBoxLayout();
    explicit QHBoxLayout(QWidget *parent);
    ~QHBoxLayout();


private:
    QHBoxLayout(const QHBoxLayout &) = delete; QHBoxLayout &operator=(const QHBoxLayout &) = delete;
};

class __declspec(dllimport) QVBoxLayout : public QBoxLayout
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    QVBoxLayout();
    explicit QVBoxLayout(QWidget *parent);
    ~QVBoxLayout();


private:
    QVBoxLayout(const QVBoxLayout &) = delete; QVBoxLayout &operator=(const QVBoxLayout &) = delete;
};
#line 173 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qlayout.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qgridlayout.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qgridlayout.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qlayout.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qgridlayout.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qgridlayout.h"
class QGridLayoutPrivate;

class __declspec(dllimport) QGridLayout : public QLayout
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QGridLayoutPrivate* d_func() { return reinterpret_cast<QGridLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGridLayoutPrivate* d_func() const { return reinterpret_cast<const QGridLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGridLayoutPrivate;



public:
    explicit QGridLayout(QWidget *parent);
    QGridLayout();

    ~QGridLayout();

    QSize sizeHint() const;
    QSize minimumSize() const;
    QSize maximumSize() const;

    void setHorizontalSpacing(int spacing);
    int horizontalSpacing() const;
    void setVerticalSpacing(int spacing);
    int verticalSpacing() const;
    void setSpacing(int spacing);
    int spacing() const;

    void setRowStretch(int row, int stretch);
    void setColumnStretch(int column, int stretch);
    int rowStretch(int row) const;
    int columnStretch(int column) const;

    void setRowMinimumHeight(int row, int minSize);
    void setColumnMinimumWidth(int column, int minSize);
    int rowMinimumHeight(int row) const;
    int columnMinimumWidth(int column) const;

    int columnCount() const;
    int rowCount() const;

    QRect cellRect(int row, int column) const;

    bool hasHeightForWidth() const;
    int heightForWidth(int) const;
    int minimumHeightForWidth(int) const;

    Qt::Orientations expandingDirections() const;
    void invalidate();

    inline void addWidget(QWidget *w) { QLayout::addWidget(w); }
    void addWidget(QWidget *, int row, int column, Qt::Alignment = 0);
    void addWidget(QWidget *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0);
    void addLayout(QLayout *, int row, int column, Qt::Alignment = 0);
    void addLayout(QLayout *, int row, int column, int rowSpan, int columnSpan, Qt::Alignment = 0);

    void setOriginCorner(Qt::Corner);
    Qt::Corner originCorner() const;

    QLayoutItem *itemAt(int index) const;
    QLayoutItem *itemAtPosition(int row, int column) const;
    QLayoutItem *takeAt(int index);
    int count() const;
    void setGeometry(const QRect&);

    void addItem(QLayoutItem *item, int row, int column, int rowSpan = 1, int columnSpan = 1, Qt::Alignment = 0);

    void setDefaultPositioning(int n, Qt::Orientation orient);
    void getItemPosition(int idx, int *row, int *column, int *rowSpan, int *columnSpan) const;

protected:
    void addItem(QLayoutItem *);

private:
    QGridLayout(const QGridLayout &) = delete; QGridLayout &operator=(const QGridLayout &) = delete;

};
#line 174 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qlayout.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qstackedlayout.h"





class QStackedLayoutPrivate;

class __declspec(dllimport) QStackedLayout : public QLayout
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QStackedLayoutPrivate* d_func() { return reinterpret_cast<QStackedLayoutPrivate *>(qGetPtrHelper(d_ptr)); } inline const QStackedLayoutPrivate* d_func() const { return reinterpret_cast<const QStackedLayoutPrivate *>(qGetPtrHelper(d_ptr)); } friend class QStackedLayoutPrivate;





public:
    enum StackingMode {
        StackOne,
        StackAll
    };

    QStackedLayout();
    explicit QStackedLayout(QWidget *parent);
    explicit QStackedLayout(QLayout *parentLayout);
    ~QStackedLayout();

    int addWidget(QWidget *w);
    int insertWidget(int index, QWidget *w);

    QWidget *currentWidget() const;
    int currentIndex() const;



    using QLayout::widget;

    QWidget *widget(int) const;
    int count() const;

    StackingMode stackingMode() const;
    void setStackingMode(StackingMode stackingMode);


    void addItem(QLayoutItem *item);
    QSize sizeHint() const;
    QSize minimumSize() const;
    QLayoutItem *itemAt(int) const;
    QLayoutItem *takeAt(int);
    void setGeometry(const QRect &rect);
    bool hasHeightForWidth() const;
    int heightForWidth(int width) const;

public:
    void widgetRemoved(int index);
    void currentChanged(int index);

public :
    void setCurrentIndex(int index);
    void setCurrentWidget(QWidget *w);

private:
    QStackedLayout(const QStackedLayout &) = delete; QStackedLayout &operator=(const QStackedLayout &) = delete;
};
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QStackedLayout"
#line 9 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QMainWindow"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qmainwindow.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qmainwindow.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qtabwidget.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qtabwidget.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qicon.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qicon.h"
class QIconPrivate;
class QIconEngine;

class __declspec(dllimport) QIcon
{
public:
    enum Mode { Normal, Disabled, Active, Selected };
    enum State { On, Off };

    QIcon();
    QIcon(const QPixmap &pixmap);
    QIcon(const QIcon &other);

    QIcon(QIcon &&other)
        :d(0) { qSwap(d, other.d); }

    explicit QIcon(const QString &fileName);
    explicit QIcon(QIconEngine *engine);
    ~QIcon();
    QIcon &operator=(const QIcon &other);

    inline QIcon &operator=(QIcon &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QIcon &other) { qSwap(d, other.d); }

    operator QVariant() const;

    QPixmap pixmap(const QSize &size, Mode mode = Normal, State state = Off) const;
    inline QPixmap pixmap(int w, int h, Mode mode = Normal, State state = Off) const
        { return pixmap(QSize(w, h), mode, state); }
    inline QPixmap pixmap(int extent, Mode mode = Normal, State state = Off) const
        { return pixmap(QSize(extent, extent), mode, state); }
    QPixmap pixmap(QWindow *window, const QSize &size, Mode mode = Normal, State state = Off) const;

    QSize actualSize(const QSize &size, Mode mode = Normal, State state = Off) const;
    QSize actualSize(QWindow *window, const QSize &size, Mode mode = Normal, State state = Off) const;

    QString name() const;

    void paint(QPainter *painter, const QRect &rect, Qt::Alignment alignment = Qt::AlignCenter, Mode mode = Normal, State state = Off) const;
    inline void paint(QPainter *painter, int x, int y, int w, int h, Qt::Alignment alignment = Qt::AlignCenter, Mode mode = Normal, State state = Off) const
        { paint(painter, QRect(x, y, w, h), alignment, mode, state); }

    bool isNull() const;
    bool isDetached() const;
    void detach();




    qint64 cacheKey() const;

    void addPixmap(const QPixmap &pixmap, Mode mode = Normal, State state = Off);
    void addFile(const QString &fileName, const QSize &size = QSize(), Mode mode = Normal, State state = Off);

    QList<QSize> availableSizes(Mode mode = Normal, State state = Off) const;

    static QIcon fromTheme(const QString &name, const QIcon &fallback = QIcon());
    static bool hasThemeIcon(const QString &name);

    static QStringList themeSearchPaths();
    static void setThemeSearchPaths(const QStringList &searchpath);

    static QString themeName();
    static void setThemeName(const QString &path);



private:
    QIconPrivate *d;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QIcon &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QIcon &);


public:
    typedef QIconPrivate * DataPtr;
    inline DataPtr &data_ptr() { return d; }
};

template<> class QTypeInfo<QIcon > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QIcon)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QIcon >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QIcon) }; static inline const char *name() { return "QIcon"; } }; template <> inline void qSwap<QIcon>(QIcon &value1, QIcon &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QIcon >(::QIcon &value1, ::QIcon &value2) { value1.swap(value2); } }


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QIcon &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QIcon &);



__declspec(dllimport) QDebug operator<<(QDebug dbg, const QIcon &);
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qtabwidget.h"







class QTabBar;
class QTabWidgetPrivate;
class QStyleOptionTabWidgetFrame;

class __declspec(dllimport) QTabWidget : public QWidget
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 72 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qtabwidget.h"
public:
    explicit QTabWidget(QWidget *parent = 0);
    ~QTabWidget();

    int addTab(QWidget *widget, const QString &);
    int addTab(QWidget *widget, const QIcon& icon, const QString &label);

    int insertTab(int index, QWidget *widget, const QString &);
    int insertTab(int index, QWidget *widget, const QIcon& icon, const QString &label);

    void removeTab(int index);

    bool isTabEnabled(int index) const;
    void setTabEnabled(int index, bool);

    QString tabText(int index) const;
    void setTabText(int index, const QString &);

    QIcon tabIcon(int index) const;
    void setTabIcon(int index, const QIcon & icon);


    void setTabToolTip(int index, const QString & tip);
    QString tabToolTip(int index) const;



    void setTabWhatsThis(int index, const QString &text);
    QString tabWhatsThis(int index) const;


    int currentIndex() const;
    QWidget *currentWidget() const;
    QWidget *widget(int index) const;
    int indexOf(QWidget *widget) const;
    int count() const;

    enum TabPosition { North, South, West, East };
    TabPosition tabPosition() const;
    void setTabPosition(TabPosition);

    bool tabsClosable() const;
    void setTabsClosable(bool closeable);

    bool isMovable() const;
    void setMovable(bool movable);

    enum TabShape { Rounded, Triangular };
    TabShape tabShape() const;
    void setTabShape(TabShape s);

    QSize sizeHint() const;
    QSize minimumSizeHint() const;
    int heightForWidth(int width) const;
    bool hasHeightForWidth() const;

    void setCornerWidget(QWidget * w, Qt::Corner corner = Qt::TopRightCorner);
    QWidget * cornerWidget(Qt::Corner corner = Qt::TopRightCorner) const;

    Qt::TextElideMode elideMode() const;
    void setElideMode(Qt::TextElideMode);

    QSize iconSize() const;
    void setIconSize(const QSize &size);

    bool usesScrollButtons() const;
    void setUsesScrollButtons(bool useButtons);

    bool documentMode() const;
    void setDocumentMode(bool set);

    void clear();

    QTabBar* tabBar() const;

public :
    void setCurrentIndex(int index);
    void setCurrentWidget(QWidget *widget);

public:
    void currentChanged(int index);
    void tabCloseRequested(int index);
    void tabBarClicked(int index);
    void tabBarDoubleClicked(int index);

protected:
    virtual void tabInserted(int index);
    virtual void tabRemoved(int index);

    void showEvent(QShowEvent *);
    void resizeEvent(QResizeEvent *);
    void keyPressEvent(QKeyEvent *);
    void paintEvent(QPaintEvent *);
    void setTabBar(QTabBar *);
    void changeEvent(QEvent *);
    bool event(QEvent *);
    void initStyleOption(QStyleOptionTabWidgetFrame *option) const;


private:
    inline QTabWidgetPrivate* d_func() { return reinterpret_cast<QTabWidgetPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTabWidgetPrivate* d_func() const { return reinterpret_cast<const QTabWidgetPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTabWidgetPrivate;
    QTabWidget(const QTabWidget &) = delete; QTabWidget &operator=(const QTabWidget &) = delete;



    void setUpLayout(bool = false);
};
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qmainwindow.h"







class QDockWidget;
class QMainWindowPrivate;
class QMenuBar;
class QStatusBar;
class QToolBar;
class QMenu;

class __declspec(dllimport) QMainWindow : public QWidget
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 83 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qmainwindow.h"
public:
    enum DockOption {
        AnimatedDocks = 0x01,
        AllowNestedDocks = 0x02,
        AllowTabbedDocks = 0x04,
        ForceTabbedDocks = 0x08,
        VerticalTabs = 0x10
    };
    typedef QFlags<DockOption> DockOptions;

    explicit QMainWindow(QWidget *parent = 0, Qt::WindowFlags flags = 0);
    ~QMainWindow();

    QSize iconSize() const;
    void setIconSize(const QSize &iconSize);

    Qt::ToolButtonStyle toolButtonStyle() const;
    void setToolButtonStyle(Qt::ToolButtonStyle toolButtonStyle);


    bool isAnimated() const;
    bool isDockNestingEnabled() const;



    bool documentMode() const;
    void setDocumentMode(bool enabled);



    QTabWidget::TabShape tabShape() const;
    void setTabShape(QTabWidget::TabShape tabShape);
    QTabWidget::TabPosition tabPosition(Qt::DockWidgetArea area) const;
    void setTabPosition(Qt::DockWidgetAreas areas, QTabWidget::TabPosition tabPosition);


    void setDockOptions(DockOptions options);
    DockOptions dockOptions() const;

    bool isSeparator(const QPoint &pos) const;


    QMenuBar *menuBar() const;
    void setMenuBar(QMenuBar *menubar);

    QWidget *menuWidget() const;
    void setMenuWidget(QWidget *menubar);



    QStatusBar *statusBar() const;
    void setStatusBar(QStatusBar *statusbar);


    QWidget *centralWidget() const;
    void setCentralWidget(QWidget *widget);

    QWidget *takeCentralWidget();


    void setCorner(Qt::Corner corner, Qt::DockWidgetArea area);
    Qt::DockWidgetArea corner(Qt::Corner corner) const;



    void addToolBarBreak(Qt::ToolBarArea area = Qt::TopToolBarArea);
    void insertToolBarBreak(QToolBar *before);

    void addToolBar(Qt::ToolBarArea area, QToolBar *toolbar);
    void addToolBar(QToolBar *toolbar);
    QToolBar *addToolBar(const QString &title);
    void insertToolBar(QToolBar *before, QToolBar *toolbar);
    void removeToolBar(QToolBar *toolbar);
    void removeToolBarBreak(QToolBar *before);

    void setUnifiedTitleAndToolBarOnMac(bool set);
    bool unifiedTitleAndToolBarOnMac() const;

    Qt::ToolBarArea toolBarArea(QToolBar *toolbar) const;
    bool toolBarBreak(QToolBar *toolbar) const;


    void addDockWidget(Qt::DockWidgetArea area, QDockWidget *dockwidget);
    void addDockWidget(Qt::DockWidgetArea area, QDockWidget *dockwidget,
                       Qt::Orientation orientation);
    void splitDockWidget(QDockWidget *after, QDockWidget *dockwidget,
                         Qt::Orientation orientation);
    void tabifyDockWidget(QDockWidget *first, QDockWidget *second);
    QList<QDockWidget*> tabifiedDockWidgets(QDockWidget *dockwidget) const;
    void removeDockWidget(QDockWidget *dockwidget);
    bool restoreDockWidget(QDockWidget *dockwidget);

    Qt::DockWidgetArea dockWidgetArea(QDockWidget *dockwidget) const;


    QByteArray saveState(int version = 0) const;
    bool restoreState(const QByteArray &state, int version = 0);


    virtual QMenu *createPopupMenu();




public :
    void setAnimated(bool enabled);
    void setDockNestingEnabled(bool enabled);


public:
    void iconSizeChanged(const QSize &iconSize);
    void toolButtonStyleChanged(Qt::ToolButtonStyle toolButtonStyle);

protected:

    void contextMenuEvent(QContextMenuEvent *event);

    bool event(QEvent *event);

private:
    inline QMainWindowPrivate* d_func() { return reinterpret_cast<QMainWindowPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMainWindowPrivate* d_func() const { return reinterpret_cast<const QMainWindowPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMainWindowPrivate;
    QMainWindow(const QMainWindow &) = delete; QMainWindow &operator=(const QMainWindow &) = delete;
};

 inline QFlags<QMainWindow::DockOptions::enum_type> operator|(QMainWindow::DockOptions::enum_type f1, QMainWindow::DockOptions::enum_type f2) { return QFlags<QMainWindow::DockOptions::enum_type>(f1) | f2; } inline QFlags<QMainWindow::DockOptions::enum_type> operator|(QMainWindow::DockOptions::enum_type f1, QFlags<QMainWindow::DockOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QMainWindow::DockOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QMainWindow"
#line 10 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QPalette"
#line 11 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QBrush"
#line 12 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QPixmap"
#line 13 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QPainter"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpainter.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpainter.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtextoption.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtextoption.h"
template <typename T> class QList;
struct QTextOptionPrivate;

class __declspec(dllimport) QTextOption
{
public:
    enum TabType {
        LeftTab,
        RightTab,
        CenterTab,
        DelimiterTab
    };

    struct __declspec(dllimport) Tab {
        inline Tab() : position(80), type(QTextOption::LeftTab) { }
        inline Tab(qreal pos, TabType tabType, QChar delim = QChar())
            : position(pos), type(tabType), delimiter(delim) {}

        inline bool operator==(const Tab &other) const {
            return type == other.type
                   && qFuzzyCompare(position, other.position)
                   && delimiter == other.delimiter;
        }

        inline bool operator!=(const Tab &other) const {
            return !operator==(other);
        }

        qreal position;
        TabType type;
        QChar delimiter;
    };

    QTextOption();
                 QTextOption(Qt::Alignment alignment);
    ~QTextOption();

    QTextOption(const QTextOption &o);
    QTextOption &operator=(const QTextOption &o);

    inline void setAlignment(Qt::Alignment alignment);
    inline Qt::Alignment alignment() const { return Qt::Alignment(align); }

    inline void setTextDirection(Qt::LayoutDirection aDirection) { this->direction = aDirection; }
    inline Qt::LayoutDirection textDirection() const { return Qt::LayoutDirection(direction); }

    enum WrapMode {
        NoWrap,
        WordWrap,
        ManualWrap,
        WrapAnywhere,
        WrapAtWordBoundaryOrAnywhere
    };
    inline void setWrapMode(WrapMode wrap) { wordWrap = wrap; }
    inline WrapMode wrapMode() const { return static_cast<WrapMode>(wordWrap); }

    enum Flag {
        ShowTabsAndSpaces = 0x1,
        ShowLineAndParagraphSeparators = 0x2,
        AddSpaceForLineAndParagraphSeparators = 0x4,
        SuppressColors = 0x8,
        IncludeTrailingSpaces = 0x80000000
    };
    typedef QFlags<Flag> Flags;
    inline void setFlags(Flags flags);
    inline Flags flags() const { return Flags(f); }

    inline void setTabStop(qreal tabStop);
    inline qreal tabStop() const { return tab; }

    void setTabArray(const QList<qreal> &tabStops);
    QList<qreal> tabArray() const;

    void setTabs(const QList<Tab> &tabStops);
    QList<Tab> tabs() const;

    void setUseDesignMetrics(bool b) { design = b; }
    bool useDesignMetrics() const { return design; }

private:
    uint align : 8;
    uint wordWrap : 4;
    uint design : 1;
    uint direction : 2;
    uint unused : 17;
    uint unused2;
    uint f;
    qreal tab;
    QTextOptionPrivate *d;
};

 inline QFlags<QTextOption::Flags::enum_type> operator|(QTextOption::Flags::enum_type f1, QTextOption::Flags::enum_type f2) { return QFlags<QTextOption::Flags::enum_type>(f1) | f2; } inline QFlags<QTextOption::Flags::enum_type> operator|(QTextOption::Flags::enum_type f1, QFlags<QTextOption::Flags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextOption::Flags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

inline void QTextOption::setAlignment(Qt::Alignment aalignment)
{ align = aalignment; }

inline void QTextOption::setFlags(Flags aflags)
{ f = aflags; }

inline void QTextOption::setTabStop(qreal atabStop)
{ tab = atabStop; }



 template <> struct QMetaTypeId< QTextOption::Tab > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const int newId = qRegisterMetaType< QTextOption::Tab >("QTextOption::Tab", reinterpret_cast< QTextOption::Tab *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } };
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpainter.h"




#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpen.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qpen.h"
class QVariant;
class QPenPrivate;
class QBrush;
class QPen;


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPen &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPen &);


class __declspec(dllimport) QPen
{
public:
    QPen();
    QPen(Qt::PenStyle);
    QPen(const QColor &color);
    QPen(const QBrush &brush, qreal width, Qt::PenStyle s = Qt::SolidLine,
         Qt::PenCapStyle c = Qt::SquareCap, Qt::PenJoinStyle j = Qt::BevelJoin);
    QPen(const QPen &pen);

    ~QPen();

    QPen &operator=(const QPen &pen);

    inline QPen &operator=(QPen &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QPen &other) { qSwap(d, other.d); }

    Qt::PenStyle style() const;
    void setStyle(Qt::PenStyle);

    QVector<qreal> dashPattern() const;
    void setDashPattern(const QVector<qreal> &pattern);

    qreal dashOffset() const;
    void setDashOffset(qreal doffset);

    qreal miterLimit() const;
    void setMiterLimit(qreal limit);

    qreal widthF() const;
    void setWidthF(qreal width);

    int width() const;
    void setWidth(int width);

    QColor color() const;
    void setColor(const QColor &color);

    QBrush brush() const;
    void setBrush(const QBrush &brush);

    bool isSolid() const;

    Qt::PenCapStyle capStyle() const;
    void setCapStyle(Qt::PenCapStyle pcs);

    Qt::PenJoinStyle joinStyle() const;
    void setJoinStyle(Qt::PenJoinStyle pcs);

    bool isCosmetic() const;
    void setCosmetic(bool cosmetic);

    bool operator==(const QPen &p) const;
    inline bool operator!=(const QPen &p) const { return !(operator==(p)); }
    operator QVariant() const;

    bool isDetached();
private:
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QPen &);
    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPen &);

    void detach();
    class QPenPrivate *d;

public:
    typedef QPenPrivate * DataPtr;
    inline DataPtr &data_ptr() { return d; }
};

template<> class QTypeInfo<QPen > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPen)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QPen >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QPen) }; static inline const char *name() { return "QPen"; } }; template <> inline void qSwap<QPen>(QPen &value1, QPen &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QPen >(::QPen &value1, ::QPen &value2) { value1.swap(value2); } }


__declspec(dllimport) QDebug operator<<(QDebug, const QPen &);
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpainter.h"
#line 66 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpainter.h"
class QBrush;
class QFontInfo;
class QFontMetrics;
class QPaintDevice;
class QPainterPath;
class QPainterPrivate;
class QPen;
class QPolygon;
class QTextItem;
class QTextEngine;
class QMatrix;
class QTransform;
class QStaticText;
class QGlyphRun;

class QPainterPrivateDeleter;

class __declspec(dllimport) QPainter
{
    inline QPainterPrivate* d_func() { return reinterpret_cast<QPainterPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPainterPrivate* d_func() const { return reinterpret_cast<const QPainterPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPainterPrivate;
    public: static const QMetaObject staticMetaObject; private:


public:
    enum RenderHint {
        Antialiasing = 0x01,
        TextAntialiasing = 0x02,
        SmoothPixmapTransform = 0x04,
        HighQualityAntialiasing = 0x08,
        NonCosmeticDefaultPen = 0x10,
        Qt4CompatiblePainting = 0x20
    };

    typedef QFlags<RenderHint> RenderHints;

    class PixmapFragment {
    public:
        qreal x;
        qreal y;
        qreal sourceLeft;
        qreal sourceTop;
        qreal width;
        qreal height;
        qreal scaleX;
        qreal scaleY;
        qreal rotation;
        qreal opacity;
        static PixmapFragment __declspec(dllimport) create(const QPointF &pos, const QRectF &sourceRect,
                                            qreal scaleX = 1, qreal scaleY = 1,
                                            qreal rotation = 0, qreal opacity = 1);
    };

    enum PixmapFragmentHint {
        OpaqueHint = 0x01
    };

    typedef QFlags<PixmapFragmentHint> PixmapFragmentHints;

    QPainter();
    explicit QPainter(QPaintDevice *);
    ~QPainter();

    QPaintDevice *device() const;

    bool begin(QPaintDevice *);
    bool end();
    bool isActive() const;

    void initFrom(const QPaintDevice *device);

    enum CompositionMode {
        CompositionMode_SourceOver,
        CompositionMode_DestinationOver,
        CompositionMode_Clear,
        CompositionMode_Source,
        CompositionMode_Destination,
        CompositionMode_SourceIn,
        CompositionMode_DestinationIn,
        CompositionMode_SourceOut,
        CompositionMode_DestinationOut,
        CompositionMode_SourceAtop,
        CompositionMode_DestinationAtop,
        CompositionMode_Xor,


        CompositionMode_Plus,
        CompositionMode_Multiply,
        CompositionMode_Screen,
        CompositionMode_Overlay,
        CompositionMode_Darken,
        CompositionMode_Lighten,
        CompositionMode_ColorDodge,
        CompositionMode_ColorBurn,
        CompositionMode_HardLight,
        CompositionMode_SoftLight,
        CompositionMode_Difference,
        CompositionMode_Exclusion,


        RasterOp_SourceOrDestination,
        RasterOp_SourceAndDestination,
        RasterOp_SourceXorDestination,
        RasterOp_NotSourceAndNotDestination,
        RasterOp_NotSourceOrNotDestination,
        RasterOp_NotSourceXorDestination,
        RasterOp_NotSource,
        RasterOp_NotSourceAndDestination,
        RasterOp_SourceAndNotDestination,
        RasterOp_NotSourceOrDestination,
        RasterOp_SourceOrNotDestination,
        RasterOp_ClearDestination,
        RasterOp_SetDestination,
        RasterOp_NotDestination
    };
    void setCompositionMode(CompositionMode mode);
    CompositionMode compositionMode() const;

    const QFont &font() const;
    void setFont(const QFont &f);

    QFontMetrics fontMetrics() const;
    QFontInfo fontInfo() const;

    void setPen(const QColor &color);
    void setPen(const QPen &pen);
    void setPen(Qt::PenStyle style);
    const QPen &pen() const;

    void setBrush(const QBrush &brush);
    void setBrush(Qt::BrushStyle style);
    const QBrush &brush() const;


    void setBackgroundMode(Qt::BGMode mode);
    Qt::BGMode backgroundMode() const;

    QPoint brushOrigin() const;
    inline void setBrushOrigin(int x, int y);
    inline void setBrushOrigin(const QPoint &);
    void setBrushOrigin(const QPointF &);

    void setBackground(const QBrush &bg);
    const QBrush &background() const;

    qreal opacity() const;
    void setOpacity(qreal opacity);


    QRegion clipRegion() const;
    QPainterPath clipPath() const;

    void setClipRect(const QRectF &, Qt::ClipOperation op = Qt::ReplaceClip);
    void setClipRect(const QRect &, Qt::ClipOperation op = Qt::ReplaceClip);
    inline void setClipRect(int x, int y, int w, int h, Qt::ClipOperation op = Qt::ReplaceClip);

    void setClipRegion(const QRegion &, Qt::ClipOperation op = Qt::ReplaceClip);

    void setClipPath(const QPainterPath &path, Qt::ClipOperation op = Qt::ReplaceClip);

    void setClipping(bool enable);
    bool hasClipping() const;

    QRectF clipBoundingRect() const;

    void save();
    void restore();


    void setMatrix(const QMatrix &matrix, bool combine = false);
    const QMatrix &matrix() const;
    const QMatrix &deviceMatrix() const;
    void resetMatrix();

    void setTransform(const QTransform &transform, bool combine = false);
    const QTransform &transform() const;
    const QTransform &deviceTransform() const;
    void resetTransform();

    void setWorldMatrix(const QMatrix &matrix, bool combine = false);
    const QMatrix &worldMatrix() const;

    void setWorldTransform(const QTransform &matrix, bool combine = false);
    const QTransform &worldTransform() const;

    QMatrix combinedMatrix() const;
    QTransform combinedTransform() const;

    void setMatrixEnabled(bool enabled);
    bool matrixEnabled() const;

    void setWorldMatrixEnabled(bool enabled);
    bool worldMatrixEnabled() const;

    void scale(qreal sx, qreal sy);
    void shear(qreal sh, qreal sv);
    void rotate(qreal a);

    void translate(const QPointF &offset);
    inline void translate(const QPoint &offset);
    inline void translate(qreal dx, qreal dy);

    QRect window() const;
    void setWindow(const QRect &window);
    inline void setWindow(int x, int y, int w, int h);

    QRect viewport() const;
    void setViewport(const QRect &viewport);
    inline void setViewport(int x, int y, int w, int h);

    void setViewTransformEnabled(bool enable);
    bool viewTransformEnabled() const;


    void strokePath(const QPainterPath &path, const QPen &pen);
    void fillPath(const QPainterPath &path, const QBrush &brush);
    void drawPath(const QPainterPath &path);

    inline void drawPoint(const QPointF &pt);
    inline void drawPoint(const QPoint &p);
    inline void drawPoint(int x, int y);

    void drawPoints(const QPointF *points, int pointCount);
    inline void drawPoints(const QPolygonF &points);
    void drawPoints(const QPoint *points, int pointCount);
    inline void drawPoints(const QPolygon &points);

    inline void drawLine(const QLineF &line);
    inline void drawLine(const QLine &line);
    inline void drawLine(int x1, int y1, int x2, int y2);
    inline void drawLine(const QPoint &p1, const QPoint &p2);
    inline void drawLine(const QPointF &p1, const QPointF &p2);

    void drawLines(const QLineF *lines, int lineCount);
    inline void drawLines(const QVector<QLineF> &lines);
    void drawLines(const QPointF *pointPairs, int lineCount);
    inline void drawLines(const QVector<QPointF> &pointPairs);
    void drawLines(const QLine *lines, int lineCount);
    inline void drawLines(const QVector<QLine> &lines);
    void drawLines(const QPoint *pointPairs, int lineCount);
    inline void drawLines(const QVector<QPoint> &pointPairs);

    inline void drawRect(const QRectF &rect);
    inline void drawRect(int x1, int y1, int w, int h);
    inline void drawRect(const QRect &rect);

    void drawRects(const QRectF *rects, int rectCount);
    inline void drawRects(const QVector<QRectF> &rectangles);
    void drawRects(const QRect *rects, int rectCount);
    inline void drawRects(const QVector<QRect> &rectangles);

    void drawEllipse(const QRectF &r);
    void drawEllipse(const QRect &r);
    inline void drawEllipse(int x, int y, int w, int h);

    inline void drawEllipse(const QPointF &center, qreal rx, qreal ry);
    inline void drawEllipse(const QPoint &center, int rx, int ry);

    void drawPolyline(const QPointF *points, int pointCount);
    inline void drawPolyline(const QPolygonF &polyline);
    void drawPolyline(const QPoint *points, int pointCount);
    inline void drawPolyline(const QPolygon &polygon);

    void drawPolygon(const QPointF *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill);
    inline void drawPolygon(const QPolygonF &polygon, Qt::FillRule fillRule = Qt::OddEvenFill);
    void drawPolygon(const QPoint *points, int pointCount, Qt::FillRule fillRule = Qt::OddEvenFill);
    inline void drawPolygon(const QPolygon &polygon, Qt::FillRule fillRule = Qt::OddEvenFill);

    void drawConvexPolygon(const QPointF *points, int pointCount);
    inline void drawConvexPolygon(const QPolygonF &polygon);
    void drawConvexPolygon(const QPoint *points, int pointCount);
    inline void drawConvexPolygon(const QPolygon &polygon);

    void drawArc(const QRectF &rect, int a, int alen);
    inline void drawArc(const QRect &, int a, int alen);
    inline void drawArc(int x, int y, int w, int h, int a, int alen);

    void drawPie(const QRectF &rect, int a, int alen);
    inline void drawPie(int x, int y, int w, int h, int a, int alen);
    inline void drawPie(const QRect &, int a, int alen);

    void drawChord(const QRectF &rect, int a, int alen);
    inline void drawChord(int x, int y, int w, int h, int a, int alen);
    inline void drawChord(const QRect &, int a, int alen);

    void drawRoundedRect(const QRectF &rect, qreal xRadius, qreal yRadius,
                         Qt::SizeMode mode = Qt::AbsoluteSize);
    inline void drawRoundedRect(int x, int y, int w, int h, qreal xRadius, qreal yRadius,
                                Qt::SizeMode mode = Qt::AbsoluteSize);
    inline void drawRoundedRect(const QRect &rect, qreal xRadius, qreal yRadius,
                                Qt::SizeMode mode = Qt::AbsoluteSize);

    void drawRoundRect(const QRectF &r, int xround = 25, int yround = 25);
    inline void drawRoundRect(int x, int y, int w, int h, int = 25, int = 25);
    inline void drawRoundRect(const QRect &r, int xround = 25, int yround = 25);

    void drawTiledPixmap(const QRectF &rect, const QPixmap &pm, const QPointF &offset = QPointF());
    inline void drawTiledPixmap(int x, int y, int w, int h, const QPixmap &, int sx=0, int sy=0);
    inline void drawTiledPixmap(const QRect &, const QPixmap &, const QPoint & = QPoint());

    void drawPicture(const QPointF &p, const QPicture &picture);
    inline void drawPicture(int x, int y, const QPicture &picture);
    inline void drawPicture(const QPoint &p, const QPicture &picture);


    void drawPixmap(const QRectF &targetRect, const QPixmap &pixmap, const QRectF &sourceRect);
    inline void drawPixmap(const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect);
    inline void drawPixmap(int x, int y, int w, int h, const QPixmap &pm,
                           int sx, int sy, int sw, int sh);
    inline void drawPixmap(int x, int y, const QPixmap &pm,
                           int sx, int sy, int sw, int sh);
    inline void drawPixmap(const QPointF &p, const QPixmap &pm, const QRectF &sr);
    inline void drawPixmap(const QPoint &p, const QPixmap &pm, const QRect &sr);
    void drawPixmap(const QPointF &p, const QPixmap &pm);
    inline void drawPixmap(const QPoint &p, const QPixmap &pm);
    inline void drawPixmap(int x, int y, const QPixmap &pm);
    inline void drawPixmap(const QRect &r, const QPixmap &pm);
    inline void drawPixmap(int x, int y, int w, int h, const QPixmap &pm);

    void drawPixmapFragments(const PixmapFragment *fragments, int fragmentCount,
                             const QPixmap &pixmap, PixmapFragmentHints hints = 0);

    void drawImage(const QRectF &targetRect, const QImage &image, const QRectF &sourceRect,
                   Qt::ImageConversionFlags flags = Qt::AutoColor);
    inline void drawImage(const QRect &targetRect, const QImage &image, const QRect &sourceRect,
                          Qt::ImageConversionFlags flags = Qt::AutoColor);
    inline void drawImage(const QPointF &p, const QImage &image, const QRectF &sr,
                          Qt::ImageConversionFlags flags = Qt::AutoColor);
    inline void drawImage(const QPoint &p, const QImage &image, const QRect &sr,
                          Qt::ImageConversionFlags flags = Qt::AutoColor);
    inline void drawImage(const QRectF &r, const QImage &image);
    inline void drawImage(const QRect &r, const QImage &image);
    void drawImage(const QPointF &p, const QImage &image);
    inline void drawImage(const QPoint &p, const QImage &image);
    inline void drawImage(int x, int y, const QImage &image, int sx = 0, int sy = 0,
                          int sw = -1, int sh = -1, Qt::ImageConversionFlags flags = Qt::AutoColor);

    void setLayoutDirection(Qt::LayoutDirection direction);
    Qt::LayoutDirection layoutDirection() const;


    void drawGlyphRun(const QPointF &position, const QGlyphRun &glyphRun);


    void drawStaticText(const QPointF &topLeftPosition, const QStaticText &staticText);
    inline void drawStaticText(const QPoint &topLeftPosition, const QStaticText &staticText);
    inline void drawStaticText(int left, int top, const QStaticText &staticText);

    void drawText(const QPointF &p, const QString &s);
    inline void drawText(const QPoint &p, const QString &s);
    inline void drawText(int x, int y, const QString &s);

    void drawText(const QPointF &p, const QString &str, int tf, int justificationPadding);

    void drawText(const QRectF &r, int flags, const QString &text, QRectF *br=0);
    void drawText(const QRect &r, int flags, const QString &text, QRect *br=0);
    inline void drawText(int x, int y, int w, int h, int flags, const QString &text, QRect *br=0);

    void drawText(const QRectF &r, const QString &text, const QTextOption &o = QTextOption());

    QRectF boundingRect(const QRectF &rect, int flags, const QString &text);
    QRect boundingRect(const QRect &rect, int flags, const QString &text);
    inline QRect boundingRect(int x, int y, int w, int h, int flags, const QString &text);

    QRectF boundingRect(const QRectF &rect, const QString &text, const QTextOption &o = QTextOption());

    void drawTextItem(const QPointF &p, const QTextItem &ti);
    inline void drawTextItem(int x, int y, const QTextItem &ti);
    inline void drawTextItem(const QPoint &p, const QTextItem &ti);

    void fillRect(const QRectF &, const QBrush &);
    inline void fillRect(int x, int y, int w, int h, const QBrush &);
    void fillRect(const QRect &, const QBrush &);

    void fillRect(const QRectF &, const QColor &color);
    inline void fillRect(int x, int y, int w, int h, const QColor &color);
    void fillRect(const QRect &, const QColor &color);

    inline void fillRect(int x, int y, int w, int h, Qt::GlobalColor c);
    inline void fillRect(const QRect &r, Qt::GlobalColor c);
    inline void fillRect(const QRectF &r, Qt::GlobalColor c);

    inline void fillRect(int x, int y, int w, int h, Qt::BrushStyle style);
    inline void fillRect(const QRect &r, Qt::BrushStyle style);
    inline void fillRect(const QRectF &r, Qt::BrushStyle style);

    void eraseRect(const QRectF &);
    inline void eraseRect(int x, int y, int w, int h);
    inline void eraseRect(const QRect &);

    void setRenderHint(RenderHint hint, bool on = true);
    void setRenderHints(RenderHints hints, bool on = true);
    RenderHints renderHints() const;
    inline bool testRenderHint(RenderHint hint) const { return renderHints() & hint; }

    QPaintEngine *paintEngine() const;

    static void setRedirected(const QPaintDevice *device, QPaintDevice *replacement,
                              const QPoint& offset = QPoint());
    static QPaintDevice *redirected(const QPaintDevice *device, QPoint *offset = 0);
    static void restoreRedirected(const QPaintDevice *device);

    void beginNativePainting();
    void endNativePainting();

private:
    QPainter(const QPainter &) = delete; QPainter &operator=(const QPainter &) = delete;

    QScopedPointer<QPainterPrivate> d_ptr;

    friend class QWidget;
    friend class QFontEngine;
    friend class QFontEngineBox;
    friend class QFontEngineFT;
    friend class QFontEngineMac;
    friend class QFontEngineWin;
    friend class QPaintEngine;
    friend class QPaintEngineExPrivate;
    friend class QOpenGLPaintEngine;
    friend class QWin32PaintEngine;
    friend class QWin32PaintEnginePrivate;
    friend class QRasterPaintEngine;
    friend class QAlphaPaintEngine;
    friend class QPreviewPaintEngine;
    friend class QTextEngine;
};

 inline QFlags<QPainter::RenderHints::enum_type> operator|(QPainter::RenderHints::enum_type f1, QPainter::RenderHints::enum_type f2) { return QFlags<QPainter::RenderHints::enum_type>(f1) | f2; } inline QFlags<QPainter::RenderHints::enum_type> operator|(QPainter::RenderHints::enum_type f1, QFlags<QPainter::RenderHints::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QPainter::RenderHints::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }




inline void QPainter::drawLine(const QLineF &l)
{
    drawLines(&l, 1);
}

inline void QPainter::drawLine(const QLine &line)
{
    drawLines(&line, 1);
}

inline void QPainter::drawLine(int x1, int y1, int x2, int y2)
{
    QLine l(x1, y1, x2, y2);
    drawLines(&l, 1);
}

inline void QPainter::drawLine(const QPoint &p1, const QPoint &p2)
{
    QLine l(p1, p2);
    drawLines(&l, 1);
}

inline void QPainter::drawLine(const QPointF &p1, const QPointF &p2)
{
    drawLine(QLineF(p1, p2));
}

inline void QPainter::drawLines(const QVector<QLineF> &lines)
{
    drawLines(lines.constData(), lines.size());
}

inline void QPainter::drawLines(const QVector<QLine> &lines)
{
    drawLines(lines.constData(), lines.size());
}

inline void QPainter::drawLines(const QVector<QPointF> &pointPairs)
{
    drawLines(pointPairs.constData(), pointPairs.size() / 2);
}

inline void QPainter::drawLines(const QVector<QPoint> &pointPairs)
{
    drawLines(pointPairs.constData(), pointPairs.size() / 2);
}

inline void QPainter::drawPolyline(const QPolygonF &polyline)
{
    drawPolyline(polyline.constData(), polyline.size());
}

inline void QPainter::drawPolyline(const QPolygon &polyline)
{
    drawPolyline(polyline.constData(), polyline.size());
}

inline void QPainter::drawPolygon(const QPolygonF &polygon, Qt::FillRule fillRule)
{
    drawPolygon(polygon.constData(), polygon.size(), fillRule);
}

inline void QPainter::drawPolygon(const QPolygon &polygon, Qt::FillRule fillRule)
{
    drawPolygon(polygon.constData(), polygon.size(), fillRule);
}

inline void QPainter::drawConvexPolygon(const QPolygonF &poly)
{
    drawConvexPolygon(poly.constData(), poly.size());
}

inline void QPainter::drawConvexPolygon(const QPolygon &poly)
{
    drawConvexPolygon(poly.constData(), poly.size());
}

inline void QPainter::drawRect(const QRectF &rect)
{
    drawRects(&rect, 1);
}

inline void QPainter::drawRect(int x, int y, int w, int h)
{
    QRect r(x, y, w, h);
    drawRects(&r, 1);
}

inline void QPainter::drawRect(const QRect &r)
{
    drawRects(&r, 1);
}

inline void QPainter::drawRects(const QVector<QRectF> &rects)
{
    drawRects(rects.constData(), rects.size());
}

inline void QPainter::drawRects(const QVector<QRect> &rects)
{
    drawRects(rects.constData(), rects.size());
}

inline void QPainter::drawPoint(const QPointF &p)
{
    drawPoints(&p, 1);
}

inline void QPainter::drawPoint(int x, int y)
{
    QPoint p(x, y);
    drawPoints(&p, 1);
}

inline void QPainter::drawPoint(const QPoint &p)
{
    drawPoints(&p, 1);
}

inline void QPainter::drawPoints(const QPolygonF &points)
{
    drawPoints(points.constData(), points.size());
}

inline void QPainter::drawPoints(const QPolygon &points)
{
    drawPoints(points.constData(), points.size());
}

inline void QPainter::drawRoundRect(int x, int y, int w, int h, int xRnd, int yRnd)
{
    drawRoundRect(QRectF(x, y, w, h), xRnd, yRnd);
}

inline void QPainter::drawRoundRect(const QRect &rect, int xRnd, int yRnd)
{
    drawRoundRect(QRectF(rect), xRnd, yRnd);
}

inline void QPainter::drawRoundedRect(int x, int y, int w, int h, qreal xRadius, qreal yRadius,
                            Qt::SizeMode mode)
{
    drawRoundedRect(QRectF(x, y, w, h), xRadius, yRadius, mode);
}

inline void QPainter::drawRoundedRect(const QRect &rect, qreal xRadius, qreal yRadius,
                            Qt::SizeMode mode)
{
    drawRoundedRect(QRectF(rect), xRadius, yRadius, mode);
}

inline void QPainter::drawEllipse(int x, int y, int w, int h)
{
    drawEllipse(QRect(x, y, w, h));
}

inline void QPainter::drawEllipse(const QPointF &center, qreal rx, qreal ry)
{
    drawEllipse(QRectF(center.x() - rx, center.y() - ry, 2 * rx, 2 * ry));
}

inline void QPainter::drawEllipse(const QPoint &center, int rx, int ry)
{
    drawEllipse(QRect(center.x() - rx, center.y() - ry, 2 * rx, 2 * ry));
}

inline void QPainter::drawArc(const QRect &r, int a, int alen)
{
    drawArc(QRectF(r), a, alen);
}

inline void QPainter::drawArc(int x, int y, int w, int h, int a, int alen)
{
    drawArc(QRectF(x, y, w, h), a, alen);
}

inline void QPainter::drawPie(const QRect &rect, int a, int alen)
{
    drawPie(QRectF(rect), a, alen);
}

inline void QPainter::drawPie(int x, int y, int w, int h, int a, int alen)
{
    drawPie(QRectF(x, y, w, h), a, alen);
}

inline void QPainter::drawChord(const QRect &rect, int a, int alen)
{
    drawChord(QRectF(rect), a, alen);
}

inline void QPainter::drawChord(int x, int y, int w, int h, int a, int alen)
{
    drawChord(QRectF(x, y, w, h), a, alen);
}

inline void QPainter::setClipRect(int x, int y, int w, int h, Qt::ClipOperation op)
{
    setClipRect(QRect(x, y, w, h), op);
}

inline void QPainter::eraseRect(const QRect &rect)
{
    eraseRect(QRectF(rect));
}

inline void QPainter::eraseRect(int x, int y, int w, int h)
{
    eraseRect(QRectF(x, y, w, h));
}

inline void QPainter::fillRect(int x, int y, int w, int h, const QBrush &b)
{
    fillRect(QRect(x, y, w, h), b);
}

inline void QPainter::fillRect(int x, int y, int w, int h, const QColor &b)
{
    fillRect(QRect(x, y, w, h), b);
}

inline void QPainter::fillRect(int x, int y, int w, int h, Qt::GlobalColor c)
{
    fillRect(QRect(x, y, w, h), QColor(c));
}

inline void QPainter::fillRect(const QRect &r, Qt::GlobalColor c)
{
    fillRect(r, QColor(c));
}

inline void QPainter::fillRect(const QRectF &r, Qt::GlobalColor c)
{
    fillRect(r, QColor(c));
}

inline void QPainter::fillRect(int x, int y, int w, int h, Qt::BrushStyle style)
{
    fillRect(QRectF(x, y, w, h), QBrush(style));
}

inline void QPainter::fillRect(const QRect &r, Qt::BrushStyle style)
{
    fillRect(QRectF(r), QBrush(style));
}

inline void QPainter::fillRect(const QRectF &r, Qt::BrushStyle style)
{
    fillRect(r, QBrush(style));
}


inline void QPainter::setBrushOrigin(int x, int y)
{
    setBrushOrigin(QPoint(x, y));
}

inline void QPainter::setBrushOrigin(const QPoint &p)
{
    setBrushOrigin(QPointF(p));
}

inline void QPainter::drawTiledPixmap(const QRect &rect, const QPixmap &pm, const QPoint &offset)
{
    drawTiledPixmap(QRectF(rect), pm, QPointF(offset));
}

inline void QPainter::drawTiledPixmap(int x, int y, int w, int h, const QPixmap &pm, int sx, int sy)
{
    drawTiledPixmap(QRectF(x, y, w, h), pm, QPointF(sx, sy));
}

inline void QPainter::drawPixmap(const QRect &targetRect, const QPixmap &pixmap, const QRect &sourceRect)
{
    drawPixmap(QRectF(targetRect), pixmap, QRectF(sourceRect));
}

inline void QPainter::drawPixmap(const QPoint &p, const QPixmap &pm)
{
    drawPixmap(QPointF(p), pm);
}

inline void QPainter::drawPixmap(const QRect &r, const QPixmap &pm)
{
    drawPixmap(QRectF(r), pm, QRectF());
}

inline void QPainter::drawPixmap(int x, int y, const QPixmap &pm)
{
    drawPixmap(QPointF(x, y), pm);
}

inline void QPainter::drawPixmap(int x, int y, int w, int h, const QPixmap &pm)
{
    drawPixmap(QRectF(x, y, w, h), pm, QRectF());
}

inline void QPainter::drawPixmap(int x, int y, int w, int h, const QPixmap &pm,
                                 int sx, int sy, int sw, int sh)
{
    drawPixmap(QRectF(x, y, w, h), pm, QRectF(sx, sy, sw, sh));
}

inline void QPainter::drawPixmap(int x, int y, const QPixmap &pm,
                                 int sx, int sy, int sw, int sh)
{
    drawPixmap(QRectF(x, y, -1, -1), pm, QRectF(sx, sy, sw, sh));
}

inline void QPainter::drawPixmap(const QPointF &p, const QPixmap &pm, const QRectF &sr)
{
    drawPixmap(QRectF(p.x(), p.y(), -1, -1), pm, sr);
}

inline void QPainter::drawPixmap(const QPoint &p, const QPixmap &pm, const QRect &sr)
{
    drawPixmap(QRectF(p.x(), p.y(), -1, -1), pm, sr);
}

inline void QPainter::drawTextItem(int x, int y, const QTextItem &ti)
{
    drawTextItem(QPointF(x, y), ti);
}

inline void QPainter::drawImage(const QRect &targetRect, const QImage &image, const QRect &sourceRect,
                                Qt::ImageConversionFlags flags)
{
    drawImage(QRectF(targetRect), image, QRectF(sourceRect), flags);
}

inline void QPainter::drawImage(const QPointF &p, const QImage &image, const QRectF &sr,
                                Qt::ImageConversionFlags flags)
{
    drawImage(QRectF(p.x(), p.y(), -1, -1), image, sr, flags);
}

inline void QPainter::drawImage(const QPoint &p, const QImage &image, const QRect &sr,
                                Qt::ImageConversionFlags flags)
{
    drawImage(QRect(p.x(), p.y(), -1, -1), image, sr, flags);
}


inline void QPainter::drawImage(const QRectF &r, const QImage &image)
{
    drawImage(r, image, QRect(0, 0, image.width(), image.height()));
}

inline void QPainter::drawImage(const QRect &r, const QImage &image)
{
    drawImage(r, image, QRectF(0, 0, image.width(), image.height()));
}

inline void QPainter::drawImage(const QPoint &p, const QImage &image)
{
    drawImage(QPointF(p), image);
}

inline void QPainter::drawImage(int x, int y, const QImage &image, int sx, int sy, int sw, int sh,
                                Qt::ImageConversionFlags flags)
{
    if (sx == 0 && sy == 0 && sw == -1 && sh == -1 && flags == Qt::AutoColor)
        drawImage(QPointF(x, y), image);
    else
        drawImage(QRectF(x, y, -1, -1), image, QRectF(sx, sy, sw, sh), flags);
}

inline void QPainter::drawStaticText(const QPoint &p, const QStaticText &staticText)
{
    drawStaticText(QPointF(p), staticText);
}

inline void QPainter::drawStaticText(int x, int y, const QStaticText &staticText)
{
    drawStaticText(QPointF(x, y), staticText);
}

inline void QPainter::drawTextItem(const QPoint &p, const QTextItem &ti)
{
    drawTextItem(QPointF(p), ti);
}

inline void QPainter::drawText(const QPoint &p, const QString &s)
{
    drawText(QPointF(p), s);
}

inline void QPainter::drawText(int x, int y, int w, int h, int flags, const QString &str, QRect *br)
{
    drawText(QRect(x, y, w, h), flags, str, br);
}

inline void QPainter::drawText(int x, int y, const QString &s)
{
    drawText(QPointF(x, y), s);
}

inline QRect QPainter::boundingRect(int x, int y, int w, int h, int flags, const QString &text)
{
    return boundingRect(QRect(x, y, w, h), flags, text);
}

inline void QPainter::translate(qreal dx, qreal dy)
{
    translate(QPointF(dx, dy));
}

inline void QPainter::translate(const QPoint &offset)
{
    translate(offset.x(), offset.y());
}

inline void QPainter::setViewport(int x, int y, int w, int h)
{
    setViewport(QRect(x, y, w, h));
}

inline void QPainter::setWindow(int x, int y, int w, int h)
{
    setWindow(QRect(x, y, w, h));
}


inline void QPainter::drawPicture(int x, int y, const QPicture &p)
{
    drawPicture(QPoint(x, y), p);
}

inline void QPainter::drawPicture(const QPoint &pt, const QPicture &p)
{
    drawPicture(QPointF(pt), p);
}
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QPainter"
#line 14 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QMessageBox"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qmessagebox.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qmessagebox.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qdialog.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qdialog.h"
class QPushButton;
class QDialogPrivate;

class __declspec(dllimport) QDialog : public QWidget
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    friend class QPushButton;




public:
    explicit QDialog(QWidget *parent = 0, Qt::WindowFlags f = 0);
    ~QDialog();

    enum DialogCode { Rejected, Accepted };

    int result() const;

    void setVisible(bool visible);

    void setOrientation(Qt::Orientation orientation);
    Qt::Orientation orientation() const;

    void setExtension(QWidget* extension);
    QWidget* extension() const;

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    void setSizeGripEnabled(bool);
    bool isSizeGripEnabled() const;

    void setModal(bool modal);
    void setResult(int r);

public:
    void finished(int result);
    void accepted();
    void rejected();

public :
    virtual void open();
    virtual int exec();
    virtual void done(int);
    virtual void accept();
    virtual void reject();

    void showExtension(bool);

protected:
    QDialog(QDialogPrivate &, QWidget *parent, Qt::WindowFlags f = 0);




    void keyPressEvent(QKeyEvent *);
    void closeEvent(QCloseEvent *);
    void showEvent(QShowEvent *);
    void resizeEvent(QResizeEvent *);

    void contextMenuEvent(QContextMenuEvent *);

    bool eventFilter(QObject *, QEvent *);
    void adjustPosition(QWidget*);
private:
    inline QDialogPrivate* d_func() { return reinterpret_cast<QDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDialogPrivate* d_func() const { return reinterpret_cast<const QDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDialogPrivate;
    QDialog(const QDialog &) = delete; QDialog &operator=(const QDialog &) = delete;




};
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qmessagebox.h"







class QLabel;
class QMessageBoxPrivate;
class QAbstractButton;
class QCheckBox;

class __declspec(dllimport) QMessageBox : public QDialog
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 73 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qmessagebox.h"
public:
    enum Icon {

        NoIcon = 0,
        Information = 1,
        Warning = 2,
        Critical = 3,
        Question = 4
    };

    enum ButtonRole {

        InvalidRole = -1,
        AcceptRole,
        RejectRole,
        DestructiveRole,
        ActionRole,
        HelpRole,
        YesRole,
        NoRole,
        ResetRole,
        ApplyRole,

        NRoles
    };

    enum StandardButton {

        NoButton = 0x00000000,
        Ok = 0x00000400,
        Save = 0x00000800,
        SaveAll = 0x00001000,
        Open = 0x00002000,
        Yes = 0x00004000,
        YesToAll = 0x00008000,
        No = 0x00010000,
        NoToAll = 0x00020000,
        Abort = 0x00040000,
        Retry = 0x00080000,
        Ignore = 0x00100000,
        Close = 0x00200000,
        Cancel = 0x00400000,
        Discard = 0x00800000,
        Help = 0x01000000,
        Apply = 0x02000000,
        Reset = 0x04000000,
        RestoreDefaults = 0x08000000,

        FirstButton = Ok,
        LastButton = RestoreDefaults,

        YesAll = YesToAll,
        NoAll = NoToAll,

        Default = 0x00000100,
        Escape = 0x00000200,
        FlagMask = 0x00000300,
        ButtonMask = ~FlagMask
    };
    typedef StandardButton Button;

    typedef QFlags<StandardButton> StandardButtons;

    explicit QMessageBox(QWidget *parent = 0);
    QMessageBox(Icon icon, const QString &title, const QString &text,
                StandardButtons buttons = NoButton, QWidget *parent = 0,
                Qt::WindowFlags flags = Qt::Dialog | Qt::MSWindowsFixedSizeDialogHint);
    ~QMessageBox();

    void addButton(QAbstractButton *button, ButtonRole role);
    QPushButton *addButton(const QString &text, ButtonRole role);
    QPushButton *addButton(StandardButton button);
    void removeButton(QAbstractButton *button);
#line 156 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qmessagebox.h"
    using QDialog::open;

    void open(QObject *receiver, const char *member);

    QList<QAbstractButton *> buttons() const;
    ButtonRole buttonRole(QAbstractButton *button) const;

    void setStandardButtons(StandardButtons buttons);
    StandardButtons standardButtons() const;
    StandardButton standardButton(QAbstractButton *button) const;
    QAbstractButton *button(StandardButton which) const;

    QPushButton *defaultButton() const;
    void setDefaultButton(QPushButton *button);
    void setDefaultButton(StandardButton button);

    QAbstractButton *escapeButton() const;
    void setEscapeButton(QAbstractButton *button);
    void setEscapeButton(StandardButton button);

    QAbstractButton *clickedButton() const;

    QString text() const;
    void setText(const QString &text);

    Icon icon() const;
    void setIcon(Icon);

    QPixmap iconPixmap() const;
    void setIconPixmap(const QPixmap &pixmap);

    Qt::TextFormat textFormat() const;
    void setTextFormat(Qt::TextFormat format);

    void setTextInteractionFlags(Qt::TextInteractionFlags flags);
    Qt::TextInteractionFlags textInteractionFlags() const;

    void setCheckBox(QCheckBox *cb);
    QCheckBox* checkBox() const;

    static StandardButton information(QWidget *parent, const QString &title,
         const QString &text, StandardButtons buttons = Ok,
         StandardButton defaultButton = NoButton);
    static StandardButton question(QWidget *parent, const QString &title,
         const QString &text, StandardButtons buttons = StandardButtons(Yes | No),
         StandardButton defaultButton = NoButton);
    static StandardButton warning(QWidget *parent, const QString &title,
         const QString &text, StandardButtons buttons = Ok,
         StandardButton defaultButton = NoButton);
    static StandardButton critical(QWidget *parent, const QString &title,
         const QString &text, StandardButtons buttons = Ok,
         StandardButton defaultButton = NoButton);
    static void about(QWidget *parent, const QString &title, const QString &text);
    static void aboutQt(QWidget *parent, const QString &title = QString());



    QMessageBox(const QString &title, const QString &text, Icon icon,
                  int button0, int button1, int button2,
                  QWidget *parent = 0,
                  Qt::WindowFlags f = Qt::Dialog | Qt::MSWindowsFixedSizeDialogHint);

    static int information(QWidget *parent, const QString &title,
                           const QString& text,
                           int button0, int button1 = 0, int button2 = 0);
    static int information(QWidget *parent, const QString &title,
                           const QString& text,
                           const QString& button0Text,
                           const QString& button1Text = QString(),
                           const QString& button2Text = QString(),
                           int defaultButtonNumber = 0,
                           int escapeButtonNumber = -1);
    inline static StandardButton information(QWidget *parent, const QString &title,
                                  const QString& text,
                                  StandardButton button0, StandardButton button1 = NoButton)
    { return information(parent, title, text, StandardButtons(button0), button1); }

    static int question(QWidget *parent, const QString &title,
                        const QString& text,
                        int button0, int button1 = 0, int button2 = 0);
    static int question(QWidget *parent, const QString &title,
                        const QString& text,
                        const QString& button0Text,
                        const QString& button1Text = QString(),
                        const QString& button2Text = QString(),
                        int defaultButtonNumber = 0,
                        int escapeButtonNumber = -1);
    inline static int question(QWidget *parent, const QString &title,
                               const QString& text,
                               StandardButton button0, StandardButton button1)
    { return question(parent, title, text, StandardButtons(button0), button1); }

    static int warning(QWidget *parent, const QString &title,
                       const QString& text,
                       int button0, int button1, int button2 = 0);
    static int warning(QWidget *parent, const QString &title,
                       const QString& text,
                       const QString& button0Text,
                       const QString& button1Text = QString(),
                       const QString& button2Text = QString(),
                       int defaultButtonNumber = 0,
                       int escapeButtonNumber = -1);
    inline static int warning(QWidget *parent, const QString &title,
                              const QString& text,
                              StandardButton button0, StandardButton button1)
    { return warning(parent, title, text, StandardButtons(button0), button1); }

    static int critical(QWidget *parent, const QString &title,
                        const QString& text,
                        int button0, int button1, int button2 = 0);
    static int critical(QWidget *parent, const QString &title,
                        const QString& text,
                        const QString& button0Text,
                        const QString& button1Text = QString(),
                        const QString& button2Text = QString(),
                        int defaultButtonNumber = 0,
                        int escapeButtonNumber = -1);
    inline static int critical(QWidget *parent, const QString &title,
                               const QString& text,
                               StandardButton button0, StandardButton button1)
    { return critical(parent, title, text, StandardButtons(button0), button1); }

    QString buttonText(int button) const;
    void setButtonText(int button, const QString &text);

    QString informativeText() const;
    void setInformativeText(const QString &text);


    QString detailedText() const;
    void setDetailedText(const QString &text);


    void setWindowTitle(const QString &title);
    void setWindowModality(Qt::WindowModality windowModality);


    static QPixmap standardIcon(Icon icon);

public:
    void buttonClicked(QAbstractButton *button);






protected:
    bool event(QEvent *e);
    void resizeEvent(QResizeEvent *event);
    void showEvent(QShowEvent *event);
    void closeEvent(QCloseEvent *event);
    void keyPressEvent(QKeyEvent *event);
    void changeEvent(QEvent *event);

private:



    QMessageBox(const QMessageBox &) = delete; QMessageBox &operator=(const QMessageBox &) = delete;
    inline QMessageBoxPrivate* d_func() { return reinterpret_cast<QMessageBoxPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMessageBoxPrivate* d_func() const { return reinterpret_cast<const QMessageBoxPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMessageBoxPrivate;
};

 inline QFlags<QMessageBox::StandardButtons::enum_type> operator|(QMessageBox::StandardButtons::enum_type f1, QMessageBox::StandardButtons::enum_type f2) { return QFlags<QMessageBox::StandardButtons::enum_type>(f1) | f2; } inline QFlags<QMessageBox::StandardButtons::enum_type> operator|(QMessageBox::StandardButtons::enum_type f1, QFlags<QMessageBox::StandardButtons::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QMessageBox::StandardButtons::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QMessageBox"
#line 15 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QTranslator"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtranslator.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtranslator.h"
class QLocale;
class QTranslatorPrivate;

class __declspec(dllimport) QTranslator : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    explicit QTranslator(QObject *parent = 0);
    ~QTranslator();

    virtual QString translate(const char *context, const char *sourceText,
                              const char *disambiguation = 0, int n = -1) const;

    virtual bool isEmpty() const;

    bool load(const QString & filename,
              const QString & directory = QString(),
              const QString & search_delimiters = QString(),
              const QString & suffix = QString());
    bool load(const QLocale & locale,
              const QString & filename,
              const QString & prefix = QString(),
              const QString & directory = QString(),
              const QString & suffix = QString());
    bool load(const uchar *data, int len, const QString &directory = QString());

private:
    QTranslator(const QTranslator &) = delete; QTranslator &operator=(const QTranslator &) = delete;
    inline QTranslatorPrivate* d_func() { return reinterpret_cast<QTranslatorPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTranslatorPrivate* d_func() const { return reinterpret_cast<const QTranslatorPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTranslatorPrivate;
};
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QTranslator"
#line 16 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QScrollArea"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qscrollarea.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qscrollarea.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qabstractscrollarea.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qabstractscrollarea.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qframe.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qframe.h"
class QFramePrivate;

class __declspec(dllimport) QFrame : public QWidget
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 64 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qframe.h"
public:
    explicit QFrame(QWidget* parent = 0, Qt::WindowFlags f = 0);
    ~QFrame();

    int frameStyle() const;
    void setFrameStyle(int);

    int frameWidth() const;

    QSize sizeHint() const;

    enum Shape {
        NoFrame = 0,
        Box = 0x0001,
        Panel = 0x0002,
        WinPanel = 0x0003,
        HLine = 0x0004,
        VLine = 0x0005,
        StyledPanel = 0x0006
    };
    enum Shadow {
        Plain = 0x0010,
        Raised = 0x0020,
        Sunken = 0x0030
    };

    enum StyleMask {
        Shadow_Mask = 0x00f0,
        Shape_Mask = 0x000f
    };

    Shape frameShape() const;
    void setFrameShape(Shape);
    Shadow frameShadow() const;
    void setFrameShadow(Shadow);

    int lineWidth() const;
    void setLineWidth(int);

    int midLineWidth() const;
    void setMidLineWidth(int);

    QRect frameRect() const;
    void setFrameRect(const QRect &);

protected:
    bool event(QEvent *e);
    void paintEvent(QPaintEvent *);
    void changeEvent(QEvent *);
    void drawFrame(QPainter *);


protected:
    QFrame(QFramePrivate &dd, QWidget* parent = 0, Qt::WindowFlags f = 0);

private:
    QFrame(const QFrame &) = delete; QFrame &operator=(const QFrame &) = delete;
    inline QFramePrivate* d_func() { return reinterpret_cast<QFramePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFramePrivate* d_func() const { return reinterpret_cast<const QFramePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFramePrivate;
};
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qabstractscrollarea.h"







class QMargins;
class QScrollBar;
class QAbstractScrollAreaPrivate;

class __declspec(dllimport) QAbstractScrollArea : public QFrame
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};






public:
    explicit QAbstractScrollArea(QWidget* parent=0);
    ~QAbstractScrollArea();

    enum SizeAdjustPolicy {
        AdjustIgnored,
        AdjustToContentsOnFirstShow,
        AdjustToContents
    };

    Qt::ScrollBarPolicy verticalScrollBarPolicy() const;
    void setVerticalScrollBarPolicy(Qt::ScrollBarPolicy);
    QScrollBar *verticalScrollBar() const;
    void setVerticalScrollBar(QScrollBar *scrollbar);

    Qt::ScrollBarPolicy horizontalScrollBarPolicy() const;
    void setHorizontalScrollBarPolicy(Qt::ScrollBarPolicy);
    QScrollBar *horizontalScrollBar() const;
    void setHorizontalScrollBar(QScrollBar *scrollbar);

    QWidget *cornerWidget() const;
    void setCornerWidget(QWidget *widget);

    void addScrollBarWidget(QWidget *widget, Qt::Alignment alignment);
    QWidgetList scrollBarWidgets(Qt::Alignment alignment);

    QWidget *viewport() const;
    void setViewport(QWidget *widget);
    QSize maximumViewportSize() const;

    QSize minimumSizeHint() const;

    QSize sizeHint() const;

    virtual void setupViewport(QWidget *viewport);

    SizeAdjustPolicy sizeAdjustPolicy() const;
    void setSizeAdjustPolicy(SizeAdjustPolicy policy);

protected:
    QAbstractScrollArea(QAbstractScrollAreaPrivate &dd, QWidget *parent = 0);
    void setViewportMargins(int left, int top, int right, int bottom);
    void setViewportMargins(const QMargins &margins);

    bool eventFilter(QObject *, QEvent *);
    bool event(QEvent *);
    virtual bool viewportEvent(QEvent *);

    void resizeEvent(QResizeEvent *);
    void paintEvent(QPaintEvent *);
    void mousePressEvent(QMouseEvent *);
    void mouseReleaseEvent(QMouseEvent *);
    void mouseDoubleClickEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);

    void wheelEvent(QWheelEvent *);


    void contextMenuEvent(QContextMenuEvent *);


    void dragEnterEvent(QDragEnterEvent *);
    void dragMoveEvent(QDragMoveEvent *);
    void dragLeaveEvent(QDragLeaveEvent *);
    void dropEvent(QDropEvent *);


    void keyPressEvent(QKeyEvent *);

    virtual void scrollContentsBy(int dx, int dy);

    virtual QSize viewportSizeHint() const;

private:
    inline QAbstractScrollAreaPrivate* d_func() { return reinterpret_cast<QAbstractScrollAreaPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractScrollAreaPrivate* d_func() const { return reinterpret_cast<const QAbstractScrollAreaPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractScrollAreaPrivate;
    QAbstractScrollArea(const QAbstractScrollArea &) = delete; QAbstractScrollArea &operator=(const QAbstractScrollArea &) = delete;




    friend class QStyleSheetStyle;
    friend class QWidgetPrivate;
};
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qscrollarea.h"







class QScrollAreaPrivate;

class __declspec(dllimport) QScrollArea : public QAbstractScrollArea
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};



public:
    explicit QScrollArea(QWidget* parent=0);
    ~QScrollArea();

    QWidget *widget() const;
    void setWidget(QWidget *widget);
    QWidget *takeWidget();

    bool widgetResizable() const;
    void setWidgetResizable(bool resizable);

    QSize sizeHint() const;

    bool focusNextPrevChild(bool next);

    Qt::Alignment alignment() const;
    void setAlignment(Qt::Alignment);

    void ensureVisible(int x, int y, int xmargin = 50, int ymargin = 50);
    void ensureWidgetVisible(QWidget *childWidget, int xmargin = 50, int ymargin = 50);

protected:
    QScrollArea(QScrollAreaPrivate &dd, QWidget *parent = 0);
    bool event(QEvent *);
    bool eventFilter(QObject *, QEvent *);
    void resizeEvent(QResizeEvent *);
    void scrollContentsBy(int dx, int dy);

    QSize viewportSizeHint() const override;

private:
    inline QScrollAreaPrivate* d_func() { return reinterpret_cast<QScrollAreaPrivate *>(qGetPtrHelper(d_ptr)); } inline const QScrollAreaPrivate* d_func() const { return reinterpret_cast<const QScrollAreaPrivate *>(qGetPtrHelper(d_ptr)); } friend class QScrollAreaPrivate;
    QScrollArea(const QScrollArea &) = delete; QScrollArea &operator=(const QScrollArea &) = delete;
};
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QScrollArea"
#line 17 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QScrollBar"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qscrollbar.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qscrollbar.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qabstractslider.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qabstractslider.h"
class QAbstractSliderPrivate;

class __declspec(dllimport) QAbstractSlider : public QWidget
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 68 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qabstractslider.h"
public:
    explicit QAbstractSlider(QWidget *parent=0);
    ~QAbstractSlider();

    Qt::Orientation orientation() const;

    void setMinimum(int);
    int minimum() const;

    void setMaximum(int);
    int maximum() const;

    void setSingleStep(int);
    int singleStep() const;

    void setPageStep(int);
    int pageStep() const;

    void setTracking(bool enable);
    bool hasTracking() const;

    void setSliderDown(bool);
    bool isSliderDown() const;

    void setSliderPosition(int);
    int sliderPosition() const;

    void setInvertedAppearance(bool);
    bool invertedAppearance() const;

    void setInvertedControls(bool);
    bool invertedControls() const;

    enum SliderAction {
        SliderNoAction,
        SliderSingleStepAdd,
        SliderSingleStepSub,
        SliderPageStepAdd,
        SliderPageStepSub,
        SliderToMinimum,
        SliderToMaximum,
        SliderMove
    };

    int value() const;

    void triggerAction(SliderAction action);

public :
    void setValue(int);
    void setOrientation(Qt::Orientation);
    void setRange(int min, int max);

public:
    void valueChanged(int value);

    void sliderPressed();
    void sliderMoved(int position);
    void sliderReleased();

    void rangeChanged(int min, int max);

    void actionTriggered(int action);

protected:
    bool event(QEvent *e);

    void setRepeatAction(SliderAction action, int thresholdTime = 500, int repeatTime = 50);
    SliderAction repeatAction() const;

    enum SliderChange {
        SliderRangeChange,
        SliderOrientationChange,
        SliderStepsChange,
        SliderValueChange
    };
    virtual void sliderChange(SliderChange change);

    void keyPressEvent(QKeyEvent *ev);
    void timerEvent(QTimerEvent *);

    void wheelEvent(QWheelEvent *e);

    void changeEvent(QEvent *e);


protected:
    QAbstractSlider(QAbstractSliderPrivate &dd, QWidget *parent=0);

private:
    QAbstractSlider(const QAbstractSlider &) = delete; QAbstractSlider &operator=(const QAbstractSlider &) = delete;
    inline QAbstractSliderPrivate* d_func() { return reinterpret_cast<QAbstractSliderPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractSliderPrivate* d_func() const { return reinterpret_cast<const QAbstractSliderPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractSliderPrivate;
};
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qscrollbar.h"







class QScrollBarPrivate;
class QStyleOptionSlider;

class __declspec(dllimport) QScrollBar : public QAbstractSlider
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    explicit QScrollBar(QWidget *parent=0);
    explicit QScrollBar(Qt::Orientation, QWidget *parent=0);
    ~QScrollBar();

    QSize sizeHint() const;
    bool event(QEvent *event);

protected:

    void wheelEvent(QWheelEvent *);

    void paintEvent(QPaintEvent *);
    void mousePressEvent(QMouseEvent *);
    void mouseReleaseEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);
    void hideEvent(QHideEvent*);
    void sliderChange(SliderChange change);

    void contextMenuEvent(QContextMenuEvent *);

    void initStyleOption(QStyleOptionSlider *option) const;


private:
    friend class QAbstractScrollAreaPrivate;
    friend __declspec(dllimport) QStyleOptionSlider qt_qscrollbarStyleOption(QScrollBar *scrollBar);

    QScrollBar(const QScrollBar &) = delete; QScrollBar &operator=(const QScrollBar &) = delete;
    inline QScrollBarPrivate* d_func() { return reinterpret_cast<QScrollBarPrivate *>(qGetPtrHelper(d_ptr)); } inline const QScrollBarPrivate* d_func() const { return reinterpret_cast<const QScrollBarPrivate *>(qGetPtrHelper(d_ptr)); } friend class QScrollBarPrivate;
};
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QScrollBar"
#line 18 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QPainterPath"
#line 19 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QScrollBar"
#line 20 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QFileDialog"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qfiledialog.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qfiledialog.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qdir.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qdir.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfileinfo.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfileinfo.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfile.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfile.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfiledevice.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfiledevice.h"
class QFileDevicePrivate;

class __declspec(dllimport) QFileDevice : public QIODevice
{

    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

    inline QFileDevicePrivate* d_func() { return reinterpret_cast<QFileDevicePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFileDevicePrivate* d_func() const { return reinterpret_cast<const QFileDevicePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFileDevicePrivate;

public:
    enum FileError {
        NoError = 0,
        ReadError = 1,
        WriteError = 2,
        FatalError = 3,
        ResourceError = 4,
        OpenError = 5,
        AbortError = 6,
        TimeOutError = 7,
        UnspecifiedError = 8,
        RemoveError = 9,
        RenameError = 10,
        PositionError = 11,
        ResizeError = 12,
        PermissionsError = 13,
        CopyError = 14
    };

    enum Permission {
        ReadOwner = 0x4000, WriteOwner = 0x2000, ExeOwner = 0x1000,
        ReadUser = 0x0400, WriteUser = 0x0200, ExeUser = 0x0100,
        ReadGroup = 0x0040, WriteGroup = 0x0020, ExeGroup = 0x0010,
        ReadOther = 0x0004, WriteOther = 0x0002, ExeOther = 0x0001
    };
    typedef QFlags<Permission> Permissions;

    enum FileHandleFlag {
        AutoCloseHandle = 0x0001,
        DontCloseHandle = 0
    };
    typedef QFlags<FileHandleFlag> FileHandleFlags;

    ~QFileDevice();

    FileError error() const;
    void unsetError();

    virtual void close();

    bool isSequential() const;

    int handle() const;
    virtual QString fileName() const;

    qint64 pos() const;
    bool seek(qint64 offset);
    bool atEnd() const;
    bool flush();

    qint64 size() const;

    virtual bool resize(qint64 sz);
    virtual Permissions permissions() const;
    virtual bool setPermissions(Permissions permissionSpec);

    enum MemoryMapFlags {
        NoOptions = 0
    };

    uchar *map(qint64 offset, qint64 size, MemoryMapFlags flags = NoOptions);
    bool unmap(uchar *address);

protected:
    QFileDevice();



    explicit QFileDevice(QObject *parent);
    QFileDevice(QFileDevicePrivate &dd, QObject *parent = 0);


    qint64 readData(char *data, qint64 maxlen);
    qint64 writeData(const char *data, qint64 len);
    qint64 readLineData(char *data, qint64 maxlen);

private:
    QFileDevice(const QFileDevice &) = delete; QFileDevice &operator=(const QFileDevice &) = delete;
};

 inline QFlags<QFileDevice::Permissions::enum_type> operator|(QFileDevice::Permissions::enum_type f1, QFileDevice::Permissions::enum_type f2) { return QFlags<QFileDevice::Permissions::enum_type>(f1) | f2; } inline QFlags<QFileDevice::Permissions::enum_type> operator|(QFileDevice::Permissions::enum_type f1, QFlags<QFileDevice::Permissions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QFileDevice::Permissions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfile.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfile.h"
class QTemporaryFile;
class QFilePrivate;

class __declspec(dllimport) QFile : public QFileDevice
{

    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

    inline QFilePrivate* d_func() { return reinterpret_cast<QFilePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFilePrivate* d_func() const { return reinterpret_cast<const QFilePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFilePrivate;

public:
    QFile();
    QFile(const QString &name);

    explicit QFile(QObject *parent);
    QFile(const QString &name, QObject *parent);

    ~QFile();

    QString fileName() const;
    void setFileName(const QString &name);
#line 88 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfile.h"
    static inline QByteArray encodeName(const QString &fileName)
    {
        return fileName.toLocal8Bit();
    }
    static QString decodeName(const QByteArray &localFileName)
    {
        return QString::fromLocal8Bit(localFileName);
    }

    inline static QString decodeName(const char *localFileName)
        { return decodeName(QByteArray(localFileName)); }
#line 107 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfile.h"
    bool exists() const;
    static bool exists(const QString &fileName);

    QString readLink() const;
    static QString readLink(const QString &fileName);
    inline QString symLinkTarget() const { return readLink(); }
    inline static QString symLinkTarget(const QString &fileName) { return readLink(fileName); }

    bool remove();
    static bool remove(const QString &fileName);

    bool rename(const QString &newName);
    static bool rename(const QString &oldName, const QString &newName);

    bool link(const QString &newName);
    static bool link(const QString &oldname, const QString &newName);

    bool copy(const QString &newName);
    static bool copy(const QString &fileName, const QString &newName);

    bool open(OpenMode flags);
    bool open(FILE *f, OpenMode ioFlags, FileHandleFlags handleFlags=DontCloseHandle);
    bool open(int fd, OpenMode ioFlags, FileHandleFlags handleFlags=DontCloseHandle);

    qint64 size() const;

    bool resize(qint64 sz);
    static bool resize(const QString &filename, qint64 sz);

    Permissions permissions() const;
    static Permissions permissions(const QString &filename);
    bool setPermissions(Permissions permissionSpec);
    static bool setPermissions(const QString &filename, Permissions permissionSpec);

protected:



    QFile(QFilePrivate &dd, QObject *parent = 0);


private:
    friend class QTemporaryFile;
    QFile(const QFile &) = delete; QFile &operator=(const QFile &) = delete;
};
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfileinfo.h"








class QDir;
class QDirIteratorPrivate;
class QDateTime;
class QFileInfoPrivate;

class __declspec(dllimport) QFileInfo
{
    friend class QDirIteratorPrivate;
public:
    explicit QFileInfo(QFileInfoPrivate *d);

    QFileInfo();
    QFileInfo(const QString &file);
    QFileInfo(const QFile &file);
    QFileInfo(const QDir &dir, const QString &file);
    QFileInfo(const QFileInfo &fileinfo);
    ~QFileInfo();

    QFileInfo &operator=(const QFileInfo &fileinfo);

    inline QFileInfo&operator=(QFileInfo &&other)
    { qSwap(d_ptr, other.d_ptr); return *this; }


    inline void swap(QFileInfo &other)
    { qSwap(d_ptr, other.d_ptr); }

    bool operator==(const QFileInfo &fileinfo) const;
    inline bool operator!=(const QFileInfo &fileinfo) const { return !(operator==(fileinfo)); }

    void setFile(const QString &file);
    void setFile(const QFile &file);
    void setFile(const QDir &dir, const QString &file);
    bool exists() const;
    static bool exists(const QString &file);
    void refresh();

    QString filePath() const;
    QString absoluteFilePath() const;
    QString canonicalFilePath() const;
    QString fileName() const;
    QString baseName() const;
    QString completeBaseName() const;
    QString suffix() const;
    QString bundleName() const;
    QString completeSuffix() const;

    QString path() const;
    QString absolutePath() const;
    QString canonicalPath() const;
    QDir dir() const;
    QDir absoluteDir() const;

    bool isReadable() const;
    bool isWritable() const;
    bool isExecutable() const;
    bool isHidden() const;
    bool isNativePath() const;

    bool isRelative() const;
    inline bool isAbsolute() const { return !isRelative(); }
    bool makeAbsolute();

    bool isFile() const;
    bool isDir() const;
    bool isSymLink() const;
    bool isRoot() const;
    bool isBundle() const;

    QString readLink() const;
    inline QString symLinkTarget() const { return readLink(); }

    QString owner() const;
    uint ownerId() const;
    QString group() const;
    uint groupId() const;

    bool permission(QFile::Permissions permissions) const;
    QFile::Permissions permissions() const;

    qint64 size() const;

    QDateTime created() const;
    QDateTime lastModified() const;
    QDateTime lastRead() const;

    bool caching() const;
    void setCaching(bool on);

protected:
    QSharedDataPointer<QFileInfoPrivate> d_ptr;

private:
    QFileInfoPrivate* d_func();
    inline const QFileInfoPrivate* d_func() const
    {
        return d_ptr.constData();
    }
};

template<> class QTypeInfo<QFileInfo > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QFileInfo)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QFileInfo >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QFileInfo) }; static inline const char *name() { return "QFileInfo"; } }; template <> inline void qSwap<QFileInfo>(QFileInfo &value1, QFileInfo &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QFileInfo >(::QFileInfo &value1, ::QFileInfo &value2) { value1.swap(value2); } }

typedef QList<QFileInfo> QFileInfoList;



 template <> struct QMetaTypeId< QFileInfo > { enum { Defined = 1 }; static int qt_metatype_id() { static QBasicAtomicInt metatype_id = { (0) }; if (const int id = metatype_id.loadAcquire()) return id; const int newId = qRegisterMetaType< QFileInfo >("QFileInfo", reinterpret_cast< QFileInfo *>(quintptr(-1))); metatype_id.storeRelease(newId); return newId; } };
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qdir.h"







class QDirIterator;
class QDirPrivate;

class __declspec(dllimport) QDir
{
public:
    enum Filter { Dirs = 0x001,
                  Files = 0x002,
                  Drives = 0x004,
                  NoSymLinks = 0x008,
                  AllEntries = Dirs | Files | Drives,
                  TypeMask = 0x00f,

                  Readable = 0x010,
                  Writable = 0x020,
                  Executable = 0x040,
                  PermissionMask = 0x070,

                  Modified = 0x080,
                  Hidden = 0x100,
                  System = 0x200,

                  AccessMask = 0x3F0,

                  AllDirs = 0x400,
                  CaseSensitive = 0x800,
                  NoDot = 0x2000,
                  NoDotDot = 0x4000,
                  NoDotAndDotDot = NoDot | NoDotDot,

                  NoFilter = -1
    };
    typedef QFlags<Filter> Filters;

    enum SortFlag { Name = 0x00,
                    Time = 0x01,
                    Size = 0x02,
                    Unsorted = 0x03,
                    SortByMask = 0x03,

                    DirsFirst = 0x04,
                    Reversed = 0x08,
                    IgnoreCase = 0x10,
                    DirsLast = 0x20,
                    LocaleAware = 0x40,
                    Type = 0x80,
                    NoSort = -1
    };
    typedef QFlags<SortFlag> SortFlags;

    QDir(const QDir &);
    QDir(const QString &path = QString());
    QDir(const QString &path, const QString &nameFilter,
         SortFlags sort = SortFlags(Name | IgnoreCase), Filters filter = AllEntries);
    ~QDir();

    QDir &operator=(const QDir &);
    QDir &operator=(const QString &path);

    inline QDir &operator=(QDir &&other)
    { qSwap(d_ptr, other.d_ptr); return *this; }


    inline void swap(QDir &other)
    { qSwap(d_ptr, other.d_ptr); }

    void setPath(const QString &path);
    QString path() const;
    QString absolutePath() const;
    QString canonicalPath() const;

    static void addResourceSearchPath(const QString &path);

    static void setSearchPaths(const QString &prefix, const QStringList &searchPaths);
    static void addSearchPath(const QString &prefix, const QString &path);
    static QStringList searchPaths(const QString &prefix);

    QString dirName() const;
    QString filePath(const QString &fileName) const;
    QString absoluteFilePath(const QString &fileName) const;
    QString relativeFilePath(const QString &fileName) const;

    static QString toNativeSeparators(const QString &pathName);
    static QString fromNativeSeparators(const QString &pathName);

    bool cd(const QString &dirName);
    bool cdUp();

    QStringList nameFilters() const;
    void setNameFilters(const QStringList &nameFilters);

    Filters filter() const;
    void setFilter(Filters filter);
    SortFlags sorting() const;
    void setSorting(SortFlags sort);

    uint count() const;
    QString operator[](int) const;

    static QStringList nameFiltersFromString(const QString &nameFilter);

    QStringList entryList(Filters filters = NoFilter, SortFlags sort = NoSort) const;
    QStringList entryList(const QStringList &nameFilters, Filters filters = NoFilter,
                          SortFlags sort = NoSort) const;

    QFileInfoList entryInfoList(Filters filters = NoFilter, SortFlags sort = NoSort) const;
    QFileInfoList entryInfoList(const QStringList &nameFilters, Filters filters = NoFilter,
                                SortFlags sort = NoSort) const;

    bool mkdir(const QString &dirName) const;
    bool rmdir(const QString &dirName) const;
    bool mkpath(const QString &dirPath) const;
    bool rmpath(const QString &dirPath) const;

    bool removeRecursively();

    bool isReadable() const;
    bool exists() const;
    bool isRoot() const;

    static bool isRelativePath(const QString &path);
    inline static bool isAbsolutePath(const QString &path) { return !isRelativePath(path); }
    bool isRelative() const;
    inline bool isAbsolute() const { return !isRelative(); }
    bool makeAbsolute();

    bool operator==(const QDir &dir) const;
    inline bool operator!=(const QDir &dir) const { return !operator==(dir); }

    bool remove(const QString &fileName);
    bool rename(const QString &oldName, const QString &newName);
    bool exists(const QString &name) const;

    static QFileInfoList drives();

    static QChar separator();

    static bool setCurrent(const QString &path);
    static inline QDir current() { return QDir(currentPath()); }
    static QString currentPath();

    static inline QDir home() { return QDir(homePath()); }
    static QString homePath();
    static inline QDir root() { return QDir(rootPath()); }
    static QString rootPath();
    static inline QDir temp() { return QDir(tempPath()); }
    static QString tempPath();


    static bool match(const QStringList &filters, const QString &fileName);
    static bool match(const QString &filter, const QString &fileName);


    static QString cleanPath(const QString &path);
    void refresh() const;

protected:
    explicit QDir(QDirPrivate &d);

    QSharedDataPointer<QDirPrivate> d_ptr;

private:
    friend class QDirIterator;

    QDirPrivate* d_func();
    inline const QDirPrivate* d_func() const
    {
        return d_ptr.constData();
    }

};

template<> class QTypeInfo<QDir > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QDir)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QDir >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QDir) }; static inline const char *name() { return "QDir"; } }; template <> inline void qSwap<QDir>(QDir &value1, QDir &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QDir >(::QDir &value1, ::QDir &value2) { value1.swap(value2); } }
 inline QFlags<QDir::Filters::enum_type> operator|(QDir::Filters::enum_type f1, QDir::Filters::enum_type f2) { return QFlags<QDir::Filters::enum_type>(f1) | f2; } inline QFlags<QDir::Filters::enum_type> operator|(QDir::Filters::enum_type f1, QFlags<QDir::Filters::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QDir::Filters::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<QDir::SortFlags::enum_type> operator|(QDir::SortFlags::enum_type f1, QDir::SortFlags::enum_type f2) { return QFlags<QDir::SortFlags::enum_type>(f1) | f2; } inline QFlags<QDir::SortFlags::enum_type> operator|(QDir::SortFlags::enum_type f1, QFlags<QDir::SortFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QDir::SortFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


class QDebug;
__declspec(dllimport) QDebug operator<<(QDebug debug, QDir::Filters filters);
__declspec(dllimport) QDebug operator<<(QDebug debug, const QDir &dir);
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qfiledialog.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qurl.h"
#line 63 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qurl.h"
class QUrlQuery;
class QUrlPrivate;
class QDataStream;

template <typename E1, typename E2>
class QUrlTwoFlags
{
    int i;
    typedef int QUrlTwoFlags:: *Zero;
public:
                     inline QUrlTwoFlags(E1 f) : i(f) {}
                     inline QUrlTwoFlags(E2 f) : i(f) {}
                     inline QUrlTwoFlags(QFlag f) : i(f) {}
                     inline QUrlTwoFlags(QFlags<E1> f) : i(f.operator int()) {}
                     inline QUrlTwoFlags(QFlags<E2> f) : i(f.operator int()) {}
                     inline QUrlTwoFlags(Zero = 0) : i(0) {}

    inline QUrlTwoFlags &operator&=(int mask) { i &= mask; return *this; }
    inline QUrlTwoFlags &operator&=(uint mask) { i &= mask; return *this; }
    inline QUrlTwoFlags &operator|=(QUrlTwoFlags f) { i |= f.i; return *this; }
    inline QUrlTwoFlags &operator|=(E1 f) { i |= f; return *this; }
    inline QUrlTwoFlags &operator|=(E2 f) { i |= f; return *this; }
    inline QUrlTwoFlags &operator^=(QUrlTwoFlags f) { i ^= f.i; return *this; }
    inline QUrlTwoFlags &operator^=(E1 f) { i ^= f; return *this; }
    inline QUrlTwoFlags &operator^=(E2 f) { i ^= f; return *this; }

                     inline operator QFlags<E1>() const { return QFlag(i); }
                     inline operator QFlags<E2>() const { return QFlag(i); }
                     inline operator int() const { return i; }
                     inline bool operator!() const { return !i; }

                     inline QUrlTwoFlags operator|(QUrlTwoFlags f) const
    { return QUrlTwoFlags(QFlag(i | f.i)); }
                     inline QUrlTwoFlags operator|(E1 f) const
    { return QUrlTwoFlags(QFlag(i | f)); }
                     inline QUrlTwoFlags operator|(E2 f) const
    { return QUrlTwoFlags(QFlag(i | f)); }
                     inline QUrlTwoFlags operator^(QUrlTwoFlags f) const
    { return QUrlTwoFlags(QFlag(i ^ f.i)); }
                     inline QUrlTwoFlags operator^(E1 f) const
    { return QUrlTwoFlags(QFlag(i ^ f)); }
                     inline QUrlTwoFlags operator^(E2 f) const
    { return QUrlTwoFlags(QFlag(i ^ f)); }
                     inline QUrlTwoFlags operator&(int mask) const
    { return QUrlTwoFlags(QFlag(i & mask)); }
                     inline QUrlTwoFlags operator&(uint mask) const
    { return QUrlTwoFlags(QFlag(i & mask)); }
                     inline QUrlTwoFlags operator&(E1 f) const
    { return QUrlTwoFlags(QFlag(i & f)); }
                     inline QUrlTwoFlags operator&(E2 f) const
    { return QUrlTwoFlags(QFlag(i & f)); }
                     inline QUrlTwoFlags operator~() const
    { return QUrlTwoFlags(QFlag(~i)); }

                     inline bool testFlag(E1 f) const { return (i & f) == f && (f != 0 || i == int(f)); }
                     inline bool testFlag(E2 f) const { return (i & f) == f && (f != 0 || i == int(f)); }
};

template<typename E1, typename E2>
class QTypeInfo<QUrlTwoFlags<E1, E2> > : public QTypeInfoMerger<QUrlTwoFlags<E1, E2>, E1, E2> {};

class QUrl;

__declspec(dllimport) uint qHash(const QUrl &url, uint seed = 0) throw();

class __declspec(dllimport) QUrl
{
public:
    enum ParsingMode {
        TolerantMode,
        StrictMode,
        DecodedMode
    };


    enum UrlFormattingOption {
        None = 0x0,
        RemoveScheme = 0x1,
        RemovePassword = 0x2,
        RemoveUserInfo = RemovePassword | 0x4,
        RemovePort = 0x8,
        RemoveAuthority = RemoveUserInfo | RemovePort | 0x10,
        RemovePath = 0x20,
        RemoveQuery = 0x40,
        RemoveFragment = 0x80,

        PreferLocalFile = 0x200,
        StripTrailingSlash = 0x400,
        RemoveFilename = 0x800,
        NormalizePathSegments = 0x1000
    };

    enum ComponentFormattingOption {
        PrettyDecoded = 0x000000,
        EncodeSpaces = 0x100000,
        EncodeUnicode = 0x200000,
        EncodeDelimiters = 0x400000 | 0x800000,
        EncodeReserved = 0x1000000,
        DecodeReserved = 0x2000000,


        FullyEncoded = EncodeSpaces | EncodeUnicode | EncodeDelimiters | EncodeReserved,
        FullyDecoded = FullyEncoded | DecodeReserved | 0x4000000
    };
    typedef QFlags<ComponentFormattingOption> ComponentFormattingOptions;



    typedef QUrlTwoFlags<UrlFormattingOption, ComponentFormattingOption> FormattingOptions;


    QUrl();
    QUrl(const QUrl &copy);
    QUrl &operator =(const QUrl &copy);



    QUrl(const QString &url, ParsingMode mode = TolerantMode);
    QUrl &operator=(const QString &url);


    QUrl(QUrl &&other) : d(0)
    { qSwap(d, other.d); }
    inline QUrl &operator=(QUrl &&other)
    { qSwap(d, other.d); return *this; }

    ~QUrl();

    inline void swap(QUrl &other) { qSwap(d, other.d); }

    void setUrl(const QString &url, ParsingMode mode = TolerantMode);
    QString url(FormattingOptions options = FormattingOptions(PrettyDecoded)) const;
    QString toString(FormattingOptions options = FormattingOptions(PrettyDecoded)) const;
    QString toDisplayString(FormattingOptions options = FormattingOptions(PrettyDecoded)) const;
    QUrl adjusted(FormattingOptions options) const;

    QByteArray toEncoded(FormattingOptions options = FullyEncoded) const;
    static QUrl fromEncoded(const QByteArray &url, ParsingMode mode = TolerantMode);

    static QUrl fromUserInput(const QString &userInput);

    bool isValid() const;
    QString errorString() const;

    bool isEmpty() const;
    void clear();

    void setScheme(const QString &scheme);
    QString scheme() const;

    void setAuthority(const QString &authority, ParsingMode mode = TolerantMode);
    QString authority(ComponentFormattingOptions options = PrettyDecoded) const;

    void setUserInfo(const QString &userInfo, ParsingMode mode = TolerantMode);
    QString userInfo(ComponentFormattingOptions options = PrettyDecoded) const;

    void setUserName(const QString &userName, ParsingMode mode = DecodedMode);
    QString userName(ComponentFormattingOptions options = FullyDecoded) const;

    void setPassword(const QString &password, ParsingMode mode = DecodedMode);
    QString password(ComponentFormattingOptions = FullyDecoded) const;

    void setHost(const QString &host, ParsingMode mode = DecodedMode);
    QString host(ComponentFormattingOptions = FullyDecoded) const;
    QString topLevelDomain(ComponentFormattingOptions options = FullyDecoded) const;

    void setPort(int port);
    int port(int defaultPort = -1) const;

    void setPath(const QString &path, ParsingMode mode = DecodedMode);
    QString path(ComponentFormattingOptions options = FullyDecoded) const;
    QString fileName(ComponentFormattingOptions options = FullyDecoded) const;

    bool hasQuery() const;
    void setQuery(const QString &query, ParsingMode mode = TolerantMode);
    void setQuery(const QUrlQuery &query);
    QString query(ComponentFormattingOptions = PrettyDecoded) const;

    bool hasFragment() const;
    QString fragment(ComponentFormattingOptions options = PrettyDecoded) const;
    void setFragment(const QString &fragment, ParsingMode mode = TolerantMode);

    QUrl resolved(const QUrl &relative) const;

    bool isRelative() const;
    bool isParentOf(const QUrl &url) const;

    bool isLocalFile() const;
    static QUrl fromLocalFile(const QString &localfile);
    QString toLocalFile() const;

    void detach();
    bool isDetached() const;

    bool operator <(const QUrl &url) const;
    bool operator ==(const QUrl &url) const;
    bool operator !=(const QUrl &url) const;

    bool matches(const QUrl &url, FormattingOptions options) const;

    static QString fromPercentEncoding(const QByteArray &);
    static QByteArray toPercentEncoding(const QString &,
                                        const QByteArray &exclude = QByteArray(),
                                        const QByteArray &include = QByteArray());
#line 342 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qurl.h"
private:
    static QString fromEncodedComponent_helper(const QByteArray &ba);

public:
    static QString fromAce(const QByteArray &);
    static QByteArray toAce(const QString &);
    static QStringList idnWhitelist();
    static QStringList toStringList(const QList<QUrl> &uris, FormattingOptions options = FormattingOptions(PrettyDecoded));
    static QList<QUrl> fromStringList(const QStringList &uris, ParsingMode mode = TolerantMode);

    static void setIdnWhitelist(const QStringList &);
    friend __declspec(dllimport) uint qHash(const QUrl &url, uint seed) throw();

private:
    QUrlPrivate *d;
    friend class QUrlQuery;

public:
    typedef QUrlPrivate * DataPtr;
    inline DataPtr &data_ptr() { return d; }
};

template<> class QTypeInfo<QUrl > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QUrl)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QUrl >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QUrl) }; static inline const char *name() { return "QUrl"; } }; template <> inline void qSwap<QUrl>(QUrl &value1, QUrl &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QUrl >(::QUrl &value1, ::QUrl &value2) { value1.swap(value2); } }
 inline QFlags<QUrl::ComponentFormattingOptions::enum_type> operator|(QUrl::ComponentFormattingOptions::enum_type f1, QUrl::ComponentFormattingOptions::enum_type f2) { return QFlags<QUrl::ComponentFormattingOptions::enum_type>(f1) | f2; } inline QFlags<QUrl::ComponentFormattingOptions::enum_type> operator|(QUrl::ComponentFormattingOptions::enum_type f1, QFlags<QUrl::ComponentFormattingOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QUrl::ComponentFormattingOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


                 inline QUrl::FormattingOptions operator|(QUrl::UrlFormattingOption f1, QUrl::UrlFormattingOption f2)
{ return QUrl::FormattingOptions(f1) | f2; }
                 inline QUrl::FormattingOptions operator|(QUrl::UrlFormattingOption f1, QUrl::FormattingOptions f2)
{ return f2 | f1; }
                 inline QIncompatibleFlag operator|(QUrl::UrlFormattingOption f1, int f2)
{ return QIncompatibleFlag(int(f1) | f2); }


inline QUrl::FormattingOptions &operator|=(QUrl::FormattingOptions &i, QUrl::ComponentFormattingOptions f)
{ i |= QUrl::UrlFormattingOption(int(f)); return i; }
                 inline QUrl::FormattingOptions operator|(QUrl::UrlFormattingOption i, QUrl::ComponentFormattingOption f)
{ return i | QUrl::UrlFormattingOption(int(f)); }
                 inline QUrl::FormattingOptions operator|(QUrl::UrlFormattingOption i, QUrl::ComponentFormattingOptions f)
{ return i | QUrl::UrlFormattingOption(int(f)); }
                 inline QUrl::FormattingOptions operator|(QUrl::ComponentFormattingOption f, QUrl::UrlFormattingOption i)
{ return i | QUrl::UrlFormattingOption(int(f)); }
                 inline QUrl::FormattingOptions operator|(QUrl::ComponentFormattingOptions f, QUrl::UrlFormattingOption i)
{ return i | QUrl::UrlFormattingOption(int(f)); }
                 inline QUrl::FormattingOptions operator|(QUrl::FormattingOptions i, QUrl::ComponentFormattingOptions f)
{ return i | QUrl::UrlFormattingOption(int(f)); }
                 inline QUrl::FormattingOptions operator|(QUrl::ComponentFormattingOption f, QUrl::FormattingOptions i)
{ return i | QUrl::UrlFormattingOption(int(f)); }
                 inline QUrl::FormattingOptions operator|(QUrl::ComponentFormattingOptions f, QUrl::FormattingOptions i)
{ return i | QUrl::UrlFormattingOption(int(f)); }





__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QUrl &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QUrl &);



__declspec(dllimport) QDebug operator<<(QDebug, const QUrl &);
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qfiledialog.h"








class QModelIndex;
class QItemSelection;
struct QFileDialogArgs;
class QFileIconProvider;
class QFileDialogPrivate;
class QAbstractItemDelegate;
class QAbstractProxyModel;

class __declspec(dllimport) QFileDialog : public QDialog
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 79 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qfiledialog.h"
public:
    enum ViewMode { Detail, List };
    enum FileMode { AnyFile, ExistingFile, Directory, ExistingFiles, DirectoryOnly };
    enum AcceptMode { AcceptOpen, AcceptSave };
    enum DialogLabel { LookIn, FileName, FileType, Accept, Reject };

    enum Option
    {
        ShowDirsOnly = 0x00000001,
        DontResolveSymlinks = 0x00000002,
        DontConfirmOverwrite = 0x00000004,
        DontUseSheet = 0x00000008,
        DontUseNativeDialog = 0x00000010,
        ReadOnly = 0x00000020,
        HideNameFilterDetails = 0x00000040,
        DontUseCustomDirectoryIcons = 0x00000080
    };
    typedef QFlags<Option> Options;

    QFileDialog(QWidget *parent, Qt::WindowFlags f);
    explicit QFileDialog(QWidget *parent = 0,
                         const QString &caption = QString(),
                         const QString &directory = QString(),
                         const QString &filter = QString());
    ~QFileDialog();

    void setDirectory(const QString &directory);
    inline void setDirectory(const QDir &directory);
    QDir directory() const;

    void setDirectoryUrl(const QUrl &directory);
    QUrl directoryUrl() const;

    void selectFile(const QString &filename);
    QStringList selectedFiles() const;

    void selectUrl(const QUrl &url);
    QList<QUrl> selectedUrls() const;

    void setNameFilterDetailsVisible(bool enabled);
    bool isNameFilterDetailsVisible() const;

    void setNameFilter(const QString &filter);
    void setNameFilters(const QStringList &filters);
    QStringList nameFilters() const;
    void selectNameFilter(const QString &filter);
    QString selectedNameFilter() const;

    void setMimeTypeFilters(const QStringList &filters);
    QStringList mimeTypeFilters() const;
    void selectMimeTypeFilter(const QString &filter);

    QDir::Filters filter() const;
    void setFilter(QDir::Filters filters);

    void setViewMode(ViewMode mode);
    ViewMode viewMode() const;

    void setFileMode(FileMode mode);
    FileMode fileMode() const;

    void setAcceptMode(AcceptMode mode);
    AcceptMode acceptMode() const;

    void setReadOnly(bool enabled);
    bool isReadOnly() const;

    void setResolveSymlinks(bool enabled);
    bool resolveSymlinks() const;

    void setSidebarUrls(const QList<QUrl> &urls);
    QList<QUrl> sidebarUrls() const;

    QByteArray saveState() const;
    bool restoreState(const QByteArray &state);

    void setConfirmOverwrite(bool enabled);
    bool confirmOverwrite() const;

    void setDefaultSuffix(const QString &suffix);
    QString defaultSuffix() const;

    void setHistory(const QStringList &paths);
    QStringList history() const;

    void setItemDelegate(QAbstractItemDelegate *delegate);
    QAbstractItemDelegate *itemDelegate() const;

    void setIconProvider(QFileIconProvider *provider);
    QFileIconProvider *iconProvider() const;

    void setLabelText(DialogLabel label, const QString &text);
    QString labelText(DialogLabel label) const;


    void setProxyModel(QAbstractProxyModel *model);
    QAbstractProxyModel *proxyModel() const;


    void setOption(Option option, bool on = true);
    bool testOption(Option option) const;
    void setOptions(Options options);
    Options options() const;






    using QDialog::open;

    void open(QObject *receiver, const char *member);
    void setVisible(bool visible);

public:
    void fileSelected(const QString &file);
    void filesSelected(const QStringList &files);
    void currentChanged(const QString &path);
    void directoryEntered(const QString &directory);

    void urlSelected(const QUrl &url);
    void urlsSelected(const QList<QUrl> &urls);
    void currentUrlChanged(const QUrl &url);
    void directoryUrlEntered(const QUrl &directory);

    void filterSelected(const QString &filter);

public:

    static QString getOpenFileName(QWidget *parent = 0,
                                   const QString &caption = QString(),
                                   const QString &dir = QString(),
                                   const QString &filter = QString(),
                                   QString *selectedFilter = 0,
                                   Options options = 0);

    static QUrl getOpenFileUrl(QWidget *parent = 0,
                               const QString &caption = QString(),
                               const QUrl &dir = QUrl(),
                               const QString &filter = QString(),
                               QString *selectedFilter = 0,
                               Options options = 0,
                               const QStringList &supportedSchemes = QStringList());

    static QString getSaveFileName(QWidget *parent = 0,
                                   const QString &caption = QString(),
                                   const QString &dir = QString(),
                                   const QString &filter = QString(),
                                   QString *selectedFilter = 0,
                                   Options options = 0);

    static QUrl getSaveFileUrl(QWidget *parent = 0,
                               const QString &caption = QString(),
                               const QUrl &dir = QUrl(),
                               const QString &filter = QString(),
                               QString *selectedFilter = 0,
                               Options options = 0,
                               const QStringList &supportedSchemes = QStringList());

    static QString getExistingDirectory(QWidget *parent = 0,
                                        const QString &caption = QString(),
                                        const QString &dir = QString(),
                                        Options options = ShowDirsOnly);

    static QUrl getExistingDirectoryUrl(QWidget *parent = 0,
                                        const QString &caption = QString(),
                                        const QUrl &dir = QUrl(),
                                        Options options = ShowDirsOnly,
                                        const QStringList &supportedSchemes = QStringList());

    static QStringList getOpenFileNames(QWidget *parent = 0,
                                        const QString &caption = QString(),
                                        const QString &dir = QString(),
                                        const QString &filter = QString(),
                                        QString *selectedFilter = 0,
                                        Options options = 0);

    static QList<QUrl> getOpenFileUrls(QWidget *parent = 0,
                                       const QString &caption = QString(),
                                       const QUrl &dir = QUrl(),
                                       const QString &filter = QString(),
                                       QString *selectedFilter = 0,
                                       Options options = 0,
                                       const QStringList &supportedSchemes = QStringList());


protected:
    QFileDialog(const QFileDialogArgs &args);
    void done(int result);
    void accept();
    void changeEvent(QEvent *e);

private:
    inline QFileDialogPrivate* d_func() { return reinterpret_cast<QFileDialogPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFileDialogPrivate* d_func() const { return reinterpret_cast<const QFileDialogPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFileDialogPrivate;
    QFileDialog(const QFileDialog &) = delete; QFileDialog &operator=(const QFileDialog &) = delete;
#line 304 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qfiledialog.h"
    friend class QPlatformDialogHelper;
};

inline void QFileDialog::setDirectory(const QDir &adirectory)
{ setDirectory(adirectory.absolutePath()); }

 inline QFlags<QFileDialog::Options::enum_type> operator|(QFileDialog::Options::enum_type f1, QFileDialog::Options::enum_type f2) { return QFlags<QFileDialog::Options::enum_type>(f1) | f2; } inline QFlags<QFileDialog::Options::enum_type> operator|(QFileDialog::Options::enum_type f1, QFlags<QFileDialog::Options::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QFileDialog::Options::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QFileDialog"
#line 21 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QLineEdit"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qlineedit.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qlineedit.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtextcursor.h"
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtextcursor.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtextformat.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtextformat.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariant.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariant.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariant.h"




#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h"
#line 73 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h"
template <class Key> inline bool qMapLessThanKey(const Key &key1, const Key &key2)
{
    return key1 < key2;
}

template <class Ptr> inline bool qMapLessThanKey(const Ptr *key1, const Ptr *key2)
{
    static_assert(bool(sizeof(quintptr) == sizeof(const Ptr *)), "sizeof(quintptr) == sizeof(const Ptr *)");
    return quintptr(key1) < quintptr(key2);
}

struct QMapDataBase;
template <class Key, class T> struct QMapData;

struct __declspec(dllimport) QMapNodeBase
{
    quintptr p;
    QMapNodeBase *left;
    QMapNodeBase *right;

    enum Color { Red = 0, Black = 1 };
    enum { Mask = 3 };

    const QMapNodeBase *nextNode() const;
    QMapNodeBase *nextNode() { return const_cast<QMapNodeBase *>(const_cast<const QMapNodeBase *>(this)->nextNode()); }
    const QMapNodeBase *previousNode() const;
    QMapNodeBase *previousNode() { return const_cast<QMapNodeBase *>(const_cast<const QMapNodeBase *>(this)->previousNode()); }

    Color color() const { return Color(p & 1); }
    void setColor(Color c) { if (c == Black) p |= Black; else p &= ~Black; }
    QMapNodeBase *parent() const { return reinterpret_cast<QMapNodeBase *>(p & ~Mask); }
    void setParent(QMapNodeBase *pp) { p = (p & Mask) | quintptr(pp); }
};

template <class Key, class T>
struct QMapNode : public QMapNodeBase
{
    Key key;
    T value;

    inline QMapNode *leftNode() const { return static_cast<QMapNode *>(left); }
    inline QMapNode *rightNode() const { return static_cast<QMapNode *>(right); }

    inline const QMapNode *nextNode() const { return static_cast<const QMapNode *>(QMapNodeBase::nextNode()); }
    inline const QMapNode *previousNode() const { return static_cast<const QMapNode *>(QMapNodeBase::previousNode()); }
    inline QMapNode *nextNode() { return static_cast<QMapNode *>(QMapNodeBase::nextNode()); }
    inline QMapNode *previousNode() { return static_cast<QMapNode *>(QMapNodeBase::previousNode()); }

    QMapNode<Key, T> *copy(QMapData<Key, T> *d) const;

    void destroySubTree();

    QMapNode<Key, T> *lowerBound(const Key &key);
    QMapNode<Key, T> *upperBound(const Key &key);

private:
    QMapNode() = delete;
    QMapNode(const QMapNode &) = delete; QMapNode &operator=(const QMapNode &) = delete;
};

template <class Key, class T>
inline QMapNode<Key, T> *QMapNode<Key, T>::lowerBound(const Key &akey)
{
    QMapNode<Key, T> *n = this;
    QMapNode<Key, T> *lastNode = 0;
    while (n) {
        if (!qMapLessThanKey(n->key, akey)) {
            lastNode = n;
            n = n->leftNode();
        } else {
            n = n->rightNode();
        }
    }
    return lastNode;
}

template <class Key, class T>
inline QMapNode<Key, T> *QMapNode<Key, T>::upperBound(const Key &akey)
{
    QMapNode<Key, T> *n = this;
    QMapNode<Key, T> *lastNode = 0;
    while (n) {
        if (qMapLessThanKey(akey, n->key)) {
            lastNode = n;
            n = n->leftNode();
        } else {
            n = n->rightNode();
        }
    }
    return lastNode;
}



struct __declspec(dllimport) QMapDataBase
{
    QtPrivate::RefCount ref;
    int size;
    QMapNodeBase header;
    QMapNodeBase *mostLeftNode;

    void rotateLeft(QMapNodeBase *x);
    void rotateRight(QMapNodeBase *x);
    void rebalance(QMapNodeBase *x);
    void freeNodeAndRebalance(QMapNodeBase *z);
    void recalcMostLeftNode();

    QMapNodeBase *createNode(int size, int alignment, QMapNodeBase *parent, bool left);
    void freeTree(QMapNodeBase *root, int alignment);

    static const QMapDataBase shared_null;

    static QMapDataBase *createData();
    static void freeData(QMapDataBase *d);
};

template <class Key, class T>
struct QMapData : public QMapDataBase
{
    typedef QMapNode<Key, T> Node;

    Node *root() const { return static_cast<Node *>(header.left); }

    const Node *end() const { return static_cast<const Node *>(&header); }
    Node *end() { return static_cast<Node *>(&header); }
    const Node *begin() const { if (root()) return static_cast<const Node*>(mostLeftNode); return end(); }
    Node *begin() { if (root()) return static_cast<Node*>(mostLeftNode); return end(); }

    void deleteNode(Node *z);
    Node *findNode(const Key &akey) const;
    void nodeRange(const Key &akey, Node **firstNode, Node **lastNode);

    Node *createNode(const Key &k, const T &v, Node *parent = 0, bool left = false)
    {
        Node *n = static_cast<Node *>(QMapDataBase::createNode(sizeof(Node), __alignof(Node),
                                      parent, left));
        try {
            new (&n->key) Key(k);
            try {
                new (&n->value) T(v);
            } catch (...) {
                n->key.~Key();
                throw;
            }
        } catch (...) {
            QMapDataBase::freeNodeAndRebalance(n);
            throw;
        }
        return n;
    }

    static QMapData *create() {
        return static_cast<QMapData *>(createData());
    }

    void destroy() {
        if (root()) {
            root()->destroySubTree();
            freeTree(header.left, __alignof(Node));
        }
        freeData(this);
    }
};

template <class Key, class T>
QMapNode<Key, T> *QMapNode<Key, T>::copy(QMapData<Key, T> *d) const
{
    QMapNode<Key, T> *n = d->createNode(key, value);
    n->setColor(color());
    if (left) {
        n->left = leftNode()->copy(d);
        n->left->setParent(n);
    } else {
        n->left = 0;
    }
    if (right) {
        n->right = rightNode()->copy(d);
        n->right->setParent(n);
    } else {
        n->right = 0;
    }
    return n;
}


#pragma warning(push)
#pragma warning(disable: 4127)


template <class Key, class T>
void QMapNode<Key, T>::destroySubTree()
{
    if (QTypeInfo<Key>::isComplex)
        key.~Key();
    if (QTypeInfo<T>::isComplex)
        value.~T();
    if (QTypeInfo<Key>::isComplex || QTypeInfo<T>::isComplex) {
        if (left)
            leftNode()->destroySubTree();
        if (right)
            rightNode()->destroySubTree();
    }
}


#pragma warning(pop)


template <class Key, class T>
void QMapData<Key, T>::deleteNode(QMapNode<Key, T> *z)
{
    if (QTypeInfo<Key>::isComplex)
        z->key.~Key();
    if (QTypeInfo<T>::isComplex)
        z->value.~T();
    freeNodeAndRebalance(z);
}

template <class Key, class T>
QMapNode<Key, T> *QMapData<Key, T>::findNode(const Key &akey) const
{
    if (Node *r = root()) {
        Node *lb = r->lowerBound(akey);
        if (lb && !qMapLessThanKey(akey, lb->key))
            return lb;
    }
    return 0;
}


template <class Key, class T>
void QMapData<Key, T>::nodeRange(const Key &akey, QMapNode<Key, T> **firstNode, QMapNode<Key, T> **lastNode)
{
    Node *n = root();
    Node *l = end();
    while (n) {
        if (qMapLessThanKey(akey, n->key)) {
            l = n;
            n = n->leftNode();
        } else if (qMapLessThanKey(n->key, akey)) {
            n = n->rightNode();
        } else {
            *firstNode = n->leftNode() ? n->leftNode()->lowerBound(akey) : 0;
            if (!*firstNode)
                *firstNode = n;
            *lastNode = n->rightNode() ? n->rightNode()->upperBound(akey) : 0;
            if (!*lastNode)
                *lastNode = l;
            return;
        }
    }
    *firstNode = *lastNode = l;
}


template <class Key, class T>
class QMap
{
    typedef QMapNode<Key, T> Node;

    QMapData<Key, T> *d;

public:
    inline QMap() : d(static_cast<QMapData<Key, T> *>(const_cast<QMapDataBase *>(&QMapDataBase::shared_null))) { }
#line 345 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h"
    QMap(const QMap<Key, T> &other);

    inline ~QMap() { if (!d->ref.deref()) d->destroy(); }

    QMap<Key, T> &operator=(const QMap<Key, T> &other);

    inline QMap(QMap<Key, T> &&other)
        : d(other.d)
    {
        other.d = static_cast<QMapData<Key, T> *>(
                const_cast<QMapDataBase *>(&QMapDataBase::shared_null));
    }

    inline QMap<Key, T> &operator=(QMap<Key, T> &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QMap<Key, T> &other) { qSwap(d, other.d); }
    explicit QMap(const typename std::map<Key, T> &other);
    std::map<Key, T> toStdMap() const;

    bool operator==(const QMap<Key, T> &other) const;
    inline bool operator!=(const QMap<Key, T> &other) const { return !(*this == other); }

    inline int size() const { return d->size; }

    inline bool isEmpty() const { return d->size == 0; }

    inline void detach() { if (d->ref.isShared()) detach_helper(); }
    inline bool isDetached() const { return !d->ref.isShared(); }

    inline void setSharable(bool sharable)
    {
        if (sharable == d->ref.isSharable())
            return;
        if (!sharable)
            detach();

        d->ref.setSharable(sharable);
    }

    inline bool isSharedWith(const QMap<Key, T> &other) const { return d == other.d; }

    void clear();

    int remove(const Key &key);
    T take(const Key &key);

    bool contains(const Key &key) const;
    const Key key(const T &value, const Key &defaultKey = Key()) const;
    const T value(const Key &key, const T &defaultValue = T()) const;
    T &operator[](const Key &key);
    const T operator[](const Key &key) const;

    QList<Key> uniqueKeys() const;
    QList<Key> keys() const;
    QList<Key> keys(const T &value) const;
    QList<T> values() const;
    QList<T> values(const Key &key) const;
    int count(const Key &key) const;

    inline const Key &firstKey() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",405) : qt_noop()); return constBegin().key(); }
    inline const Key &lastKey() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",406) : qt_noop()); return (constEnd() - 1).key(); }

    inline T &first() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",408) : qt_noop()); return *begin(); }
    inline const T &first() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",409) : qt_noop()); return *constBegin(); }
    inline T &last() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",410) : qt_noop()); return *(end() - 1); }
    inline const T &last() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",411) : qt_noop()); return *(constEnd() - 1); }

    class const_iterator;

    class iterator
    {
        friend class const_iterator;
        Node *i;

    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;

        inline iterator() : i(0) { }
        inline iterator(Node *node) : i(node) { }

        inline const Key &key() const { return i->key; }
        inline T &value() const { return i->value; }
        inline T &operator*() const { return i->value; }
        inline T *operator->() const { return &i->value; }
        inline bool operator==(const iterator &o) const { return i == o.i; }
        inline bool operator!=(const iterator &o) const { return i != o.i; }

        inline iterator &operator++() {
            i = i->nextNode();
            return *this;
        }
        inline iterator operator++(int) {
            iterator r = *this;
            i = i->nextNode();
            return r;
        }
        inline iterator &operator--() {
            i = i->previousNode();
            return *this;
        }
        inline iterator operator--(int) {
            iterator r = *this;
            i = i->previousNode();
            return r;
        }
        inline iterator operator+(int j) const
        { iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
        inline iterator operator-(int j) const { return operator+(-j); }
        inline iterator &operator+=(int j) { return *this = *this + j; }
        inline iterator &operator-=(int j) { return *this = *this - j; }


    public:
        inline bool operator==(const const_iterator &o) const
            { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const
            { return i != o.i; }

        friend class QMap<Key, T>;
    };
    friend class iterator;

    class const_iterator
    {
        friend class iterator;
        const Node *i;

    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef const T *pointer;
        typedef const T &reference;

        inline const_iterator() : i(0) { }
        inline const_iterator(const Node *node) : i(node) { }



        inline const_iterator(const iterator &o)

        { i = o.i; }

        inline const Key &key() const { return i->key; }
        inline const T &value() const { return i->value; }
        inline const T &operator*() const { return i->value; }
        inline const T *operator->() const { return &i->value; }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }

        inline const_iterator &operator++() {
            i = i->nextNode();
            return *this;
        }
        inline const_iterator operator++(int) {
            const_iterator r = *this;
            i = i->nextNode();
            return r;
        }
        inline const_iterator &operator--() {
            i = i->previousNode();
            return *this;
        }
        inline const_iterator operator--(int) {
            const_iterator r = *this;
            i = i->previousNode();
            return r;
        }
        inline const_iterator operator+(int j) const
        { const_iterator r = *this; if (j > 0) while (j--) ++r; else while (j++) --r; return r; }
        inline const_iterator operator-(int j) const { return operator+(-j); }
        inline const_iterator &operator+=(int j) { return *this = *this + j; }
        inline const_iterator &operator-=(int j) { return *this = *this - j; }






        friend class QMap<Key, T>;
    };
    friend class const_iterator;


    inline iterator begin() { detach(); return iterator(d->begin()); }
    inline const_iterator begin() const { return const_iterator(d->begin()); }
    inline const_iterator constBegin() const { return const_iterator(d->begin()); }
    inline const_iterator cbegin() const { return const_iterator(d->begin()); }
    inline iterator end() { detach(); return iterator(d->end()); }
    inline const_iterator end() const { return const_iterator(d->end()); }
    inline const_iterator constEnd() const { return const_iterator(d->end()); }
    inline const_iterator cend() const { return const_iterator(d->end()); }
    iterator erase(iterator it);


    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    inline int count() const { return d->size; }
    iterator find(const Key &key);
    const_iterator find(const Key &key) const;
    const_iterator constFind(const Key &key) const;
    iterator lowerBound(const Key &key);
    const_iterator lowerBound(const Key &key) const;
    iterator upperBound(const Key &key);
    const_iterator upperBound(const Key &key) const;
    iterator insert(const Key &key, const T &value);
    iterator insert(const_iterator pos, const Key &key, const T &value);
    iterator insertMulti(const Key &key, const T &value);
    iterator insertMulti(const_iterator pos, const Key &akey, const T &avalue);
    QMap<Key, T> &unite(const QMap<Key, T> &other);


    typedef Key key_type;
    typedef T mapped_type;
    typedef qptrdiff difference_type;
    typedef int size_type;
    inline bool empty() const { return isEmpty(); }
    QPair<iterator, iterator> equal_range(const Key &akey);





private:
    void detach_helper();
    bool isValidIterator(const const_iterator &ci) const
    {

        const QMapNodeBase *n = ci.i;
        while (n->parent())
            n = n->parent();
        return n->left == d->root();




    }
};

template <class Key, class T>
inline QMap<Key, T>::QMap(const QMap<Key, T> &other)
{
    if (other.d->ref.ref()) {
        d = other.d;
    } else {
        d = QMapData<Key, T>::create();
        if (other.d->header.left) {
            d->header.left = static_cast<Node *>(other.d->header.left)->copy(d);
            d->header.left->setParent(&d->header);
            d->recalcMostLeftNode();
        }
    }
}

template <class Key, class T>
inline QMap<Key, T> &QMap<Key, T>::operator=(const QMap<Key, T> &other)
{
    if (d != other.d) {
        QMap<Key, T> tmp(other);
        tmp.swap(*this);
    }
    return *this;
}

template <class Key, class T>
inline void QMap<Key, T>::clear()
{
    *this = QMap<Key, T>();
}


template <class Key, class T>
inline const T QMap<Key, T>::value(const Key &akey, const T &adefaultValue) const
{
    Node *n = d->findNode(akey);
    return n ? n->value : adefaultValue;
}

template <class Key, class T>
inline const T QMap<Key, T>::operator[](const Key &akey) const
{
    return value(akey);
}

template <class Key, class T>
inline T &QMap<Key, T>::operator[](const Key &akey)
{
    detach();
    Node *n = d->findNode(akey);
    if (!n)
        return *insert(akey, T());
    return n->value;
}

template <class Key, class T>
inline int QMap<Key, T>::count(const Key &akey) const
{
    Node *firstNode;
    Node *lastNode;
    d->nodeRange(akey, &firstNode, &lastNode);

    const_iterator ci_first(firstNode);
    const const_iterator ci_last(lastNode);
    int cnt = 0;
    while (ci_first != ci_last) {
        ++cnt;
        ++ci_first;
    }
    return cnt;
}

template <class Key, class T>
inline bool QMap<Key, T>::contains(const Key &akey) const
{
    return d->findNode(akey) != 0;
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::insert(const Key &akey, const T &avalue)
{
    detach();
    Node *n = d->root();
    Node *y = d->end();
    Node *lastNode = 0;
    bool left = true;
    while (n) {
        y = n;
        if (!qMapLessThanKey(n->key, akey)) {
            lastNode = n;
            left = true;
            n = n->leftNode();
        } else {
            left = false;
            n = n->rightNode();
        }
    }
    if (lastNode && !qMapLessThanKey(akey, lastNode->key)) {
        lastNode->value = avalue;
        return iterator(lastNode);
    }
    Node *z = d->createNode(akey, avalue, y, left);
    return iterator(z);
}

template <class Key, class T>
typename QMap<Key, T>::iterator QMap<Key, T>::insert(const_iterator pos, const Key &akey, const T &avalue)
{
    if (d->ref.isShared())
        return this->insert(akey, avalue);

    ((!(isValidIterator(pos))) ? qt_assert_x("QMap::insert", "The specified const_iterator argument 'it' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",700) : qt_noop());

    if (pos == constEnd()) {

        Node *n = static_cast<Node *>(pos.i->left);
        if (n) {
            while (n->right)
                n = static_cast<Node *>(n->right);

            if (!qMapLessThanKey(n->key, akey))
                return this->insert(akey, avalue);




            Node *z = d->createNode(akey, avalue, n, false);
            return iterator(z);
        }
        return this->insert(akey, avalue);
    } else {


        Node *next = const_cast<Node*>(pos.i);
        if (qMapLessThanKey(next->key, akey))
            return this->insert(akey, avalue);

        if (pos == constBegin()) {


            if (!qMapLessThanKey(akey, next->key)) {
                next->value = avalue;
                return iterator(next);
            }

            Node *z = d->createNode(akey, avalue, begin().i, true);
            return iterator(z);
        } else {
            Node *prev = const_cast<Node*>(pos.i->previousNode());
            if (!qMapLessThanKey(prev->key, akey)) {
                return this->insert(akey, avalue);
            }

            if (!qMapLessThanKey(akey, next->key)) {
                next->value = avalue;
                return iterator(next);
            }


            if (prev->right == 0) {
                Node *z = d->createNode(akey, avalue, prev, false);
                return iterator(z);
            }
            if (next->left == 0) {
                Node *z = d->createNode(akey, avalue, next, true);
                return iterator(z);
            }
            ((!(false)) ? qt_assert("false","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",756) : qt_noop());
            return this->insert(akey, avalue);
        }
    }
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::insertMulti(const Key &akey,
                                                                            const T &avalue)
{
    detach();
    Node* y = d->end();
    Node* x = static_cast<Node *>(d->root());
    bool left = true;
    while (x != 0) {
        left = !qMapLessThanKey(x->key, akey);
        y = x;
        x = left ? x->leftNode() : x->rightNode();
    }
    Node *z = d->createNode(akey, avalue, y, left);
    return iterator(z);
}

template <class Key, class T>
typename QMap<Key, T>::iterator QMap<Key, T>::insertMulti(const_iterator pos, const Key &akey, const T &avalue)
{
    if (d->ref.isShared())
        return this->insertMulti(akey, avalue);

    ((!(isValidIterator(pos))) ? qt_assert_x("QMap::insertMulti", "The specified const_iterator argument 'pos' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",785) : qt_noop());

    if (pos == constEnd()) {

        Node *n = static_cast<Node *>(pos.i->left);
        if (n) {
            while (n->right)
                n = static_cast<Node *>(n->right);

            if (!qMapLessThanKey(n->key, akey))
                return this->insertMulti(akey, avalue);
            Node *z = d->createNode(akey, avalue, n, false);
            return iterator(z);
        }
        return this->insertMulti(akey, avalue);
    } else {


        Node *next = const_cast<Node*>(pos.i);
        if (qMapLessThanKey(next->key, akey))
            return this->insertMulti(akey, avalue);

        if (pos == constBegin()) {

            Node *z = d->createNode(akey, avalue, begin().i, true);
            return iterator(z);
        } else {
            Node *prev = const_cast<Node*>(pos.i->previousNode());
            if (!qMapLessThanKey(prev->key, akey))
                return this->insertMulti(akey, avalue);


            if (prev->right == 0) {
                Node *z = d->createNode(akey, avalue, prev, false);
                return iterator(z);
            }
            if (next->left == 0) {
                Node *z = d->createNode(akey, avalue, next, true);
                return iterator(z);
            }
            ((!(false)) ? qt_assert("false","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",825) : qt_noop());
            return this->insertMulti(akey, avalue);
        }
    }
}


template <class Key, class T>
inline typename QMap<Key, T>::const_iterator QMap<Key, T>::constFind(const Key &akey) const
{
    Node *n = d->findNode(akey);
    return const_iterator(n ? n : d->end());
}

template <class Key, class T>
inline typename QMap<Key, T>::const_iterator QMap<Key, T>::find(const Key &akey) const
{
    return constFind(akey);
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::find(const Key &akey)
{
    detach();
    Node *n = d->findNode(akey);
    return iterator(n ? n : d->end());
}

template <class Key, class T>
inline QMap<Key, T> &QMap<Key, T>::unite(const QMap<Key, T> &other)
{
    QMap<Key, T> copy(other);
    const_iterator it = copy.constEnd();
    const const_iterator b = copy.constBegin();
    while (it != b) {
        --it;
        insertMulti(it.key(), it.value());
    }
    return *this;
}

template <class Key, class T>
QPair<typename QMap<Key, T>::iterator, typename QMap<Key, T>::iterator> QMap<Key, T>::equal_range(const Key &akey)
{
    detach();
    Node *firstNode, *lastNode;
    d->nodeRange(akey, &firstNode, &lastNode);
    return QPair<iterator, iterator>(iterator(firstNode), iterator(lastNode));
}
#line 897 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h"
template <class Key, class T>
inline int QMap<Key, T>::remove(const Key &akey)
{
    detach();
    int n = 0;
    while (Node *node = d->findNode(akey)) {
        d->deleteNode(node);
        ++n;
    }
    return n;
}

template <class Key, class T>
inline T QMap<Key, T>::take(const Key &akey)
{
    detach();

    Node *node = d->findNode(akey);
    if (node) {
        T t = node->value;
        d->deleteNode(node);
        return t;
    }
    return T();
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::erase(iterator it)
{
    if (it == iterator(d->end()))
        return it;

    ((!(isValidIterator(const_iterator(it)))) ? qt_assert_x("QMap::erase", "The specified iterator argument 'it' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",929) : qt_noop());

    if (d->ref.isShared()) {
        const_iterator oldBegin = constBegin();
        const_iterator old = const_iterator(it);
        int backStepsWithSameKey = 0;

        while (old != oldBegin) {
            --old;
            if (qMapLessThanKey(old.key(), it.key()))
                break;
            ++backStepsWithSameKey;
        }

        it = find(old.key());
        ((!(it != iterator(d->end()))) ? qt_assert_x("QMap::erase", "Unable to locate same key in erase after detach.","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",944) : qt_noop());

        while (backStepsWithSameKey > 0) {
            ++it;
            --backStepsWithSameKey;
        }
    }

    Node *n = it.i;
    ++it;
    d->deleteNode(n);
    return it;
}

template <class Key, class T>
inline void QMap<Key, T>::detach_helper()
{
    QMapData<Key, T> *x = QMapData<Key, T>::create();
    if (d->header.left) {
        x->header.left = static_cast<Node *>(d->header.left)->copy(x);
        x->header.left->setParent(&x->header);
    }
    if (!d->ref.deref())
        d->destroy();
    d = x;
    d->recalcMostLeftNode();
}

template <class Key, class T>
inline QList<Key> QMap<Key, T>::uniqueKeys() const
{
    QList<Key> res;
    res.reserve(size());
    const_iterator i = begin();
    if (i != end()) {
        for (;;) {
            const Key &aKey = i.key();
            res.append(aKey);
            do {
                if (++i == end())
                    goto break_out_of_outer_loop;
            } while (!qMapLessThanKey(aKey, i.key()));
        }
    }
break_out_of_outer_loop:
    return res;
}

template <class Key, class T>
inline QList<Key> QMap<Key, T>::keys() const
{
    QList<Key> res;
    res.reserve(size());
    const_iterator i = begin();
    while (i != end()) {
        res.append(i.key());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline QList<Key> QMap<Key, T>::keys(const T &avalue) const
{
    QList<Key> res;
    const_iterator i = begin();
    while (i != end()) {
        if (i.value() == avalue)
            res.append(i.key());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline const Key QMap<Key, T>::key(const T &avalue, const Key &defaultKey) const
{
    const_iterator i = begin();
    while (i != end()) {
        if (i.value() == avalue)
            return i.key();
        ++i;
    }

    return defaultKey;
}

template <class Key, class T>
inline QList<T> QMap<Key, T>::values() const
{
    QList<T> res;
    res.reserve(size());
    const_iterator i = begin();
    while (i != end()) {
        res.append(i.value());
        ++i;
    }
    return res;
}

template <class Key, class T>
inline QList<T> QMap<Key, T>::values(const Key &akey) const
{
    QList<T> res;
    Node *n = d->findNode(akey);
    if (n) {
        const_iterator it(n);
        do {
            res.append(*it);
            ++it;
        } while (it != constEnd() && !qMapLessThanKey<Key>(akey, it.key()));
    }
    return res;
}

template <class Key, class T>
inline typename QMap<Key, T>::const_iterator QMap<Key, T>::lowerBound(const Key &akey) const
{
    Node *lb = d->root() ? d->root()->lowerBound(akey) : 0;
    if (!lb)
        lb = d->end();
    return const_iterator(lb);
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::lowerBound(const Key &akey)
{
    detach();
    Node *lb = d->root() ? d->root()->lowerBound(akey) : 0;
    if (!lb)
        lb = d->end();
    return iterator(lb);
}

template <class Key, class T>
inline typename QMap<Key, T>::const_iterator
QMap<Key, T>::upperBound(const Key &akey) const
{
    Node *ub = d->root() ? d->root()->upperBound(akey) : 0;
    if (!ub)
        ub = d->end();
    return const_iterator(ub);
}

template <class Key, class T>
inline typename QMap<Key, T>::iterator QMap<Key, T>::upperBound(const Key &akey)
{
    detach();
    Node *ub = d->root() ? d->root()->upperBound(akey) : 0;
    if (!ub)
        ub = d->end();
    return iterator(ub);
}

template <class Key, class T>
inline bool QMap<Key, T>::operator==(const QMap<Key, T> &other) const
{
    if (size() != other.size())
        return false;
    if (d == other.d)
        return true;

    const_iterator it1 = begin();
    const_iterator it2 = other.begin();

    while (it1 != end()) {
        if (!(it1.value() == it2.value()) || qMapLessThanKey(it1.key(), it2.key()) || qMapLessThanKey(it2.key(), it1.key()))
            return false;
        ++it2;
        ++it1;
    }
    return true;
}

template <class Key, class T>
inline QMap<Key, T>::QMap(const std::map<Key, T> &other)
{
    d = QMapData<Key, T>::create();
    typename std::map<Key,T>::const_iterator it = other.end();
    while (it != other.begin()) {
        --it;
        d->createNode((*it).first, (*it).second, d->begin(), true);
    }
}

template <class Key, class T>
inline std::map<Key, T> QMap<Key, T>::toStdMap() const
{
    std::map<Key, T> map;
    const_iterator it = end();
    while (it != begin()) {
        --it;
        map.insert(map.begin(), std::pair<Key, T>(it.key(), it.value()));
    }
    return map;
}

template <class Key, class T>
class QMultiMap : public QMap<Key, T>
{
public:
    QMultiMap() {}







    QMultiMap(const QMap<Key, T> &other) : QMap<Key, T>(other) {}
    inline void swap(QMultiMap<Key, T> &other) { QMap<Key, T>::swap(other); }

    inline typename QMap<Key, T>::iterator replace(const Key &key, const T &value)
    { return QMap<Key, T>::insert(key, value); }
    inline typename QMap<Key, T>::iterator insert(const Key &key, const T &value)
    { return QMap<Key, T>::insertMulti(key, value); }
    inline typename QMap<Key, T>::iterator insert(typename QMap<Key, T>::const_iterator pos, const Key &key, const T &value)
    { return QMap<Key, T>::insertMulti(pos, key, value); }

    inline QMultiMap &operator+=(const QMultiMap &other)
    { this->unite(other); return *this; }
    inline QMultiMap operator+(const QMultiMap &other) const
    { QMultiMap result = *this; result += other; return result; }



    using QMap<Key, T>::contains;
    using QMap<Key, T>::remove;
    using QMap<Key, T>::count;
    using QMap<Key, T>::find;
    using QMap<Key, T>::constFind;
#line 1192 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h"
    bool contains(const Key &key, const T &value) const;

    int remove(const Key &key, const T &value);

    int count(const Key &key, const T &value) const;

    typename QMap<Key, T>::iterator find(const Key &key, const T &value) {
        typename QMap<Key, T>::iterator i(find(key));
        typename QMap<Key, T>::iterator end(this->end());
        while (i != end && !qMapLessThanKey<Key>(key, i.key())) {
            if (i.value() == value)
                return i;
            ++i;
        }
        return end;
    }
    typename QMap<Key, T>::const_iterator find(const Key &key, const T &value) const {
        typename QMap<Key, T>::const_iterator i(constFind(key));
        typename QMap<Key, T>::const_iterator end(QMap<Key, T>::constEnd());
        while (i != end && !qMapLessThanKey<Key>(key, i.key())) {
            if (i.value() == value)
                return i;
            ++i;
        }
        return end;
    }
    typename QMap<Key, T>::const_iterator constFind(const Key &key, const T &value) const
        { return find(key, value); }
private:
    T &operator[](const Key &key);
    const T operator[](const Key &key) const;
};

template <class Key, class T>
inline bool QMultiMap<Key, T>::contains(const Key &key, const T &value) const
{
    return constFind(key, value) != QMap<Key, T>::constEnd();
}

template <class Key, class T>
inline int QMultiMap<Key, T>::remove(const Key &key, const T &value)
{
    int n = 0;
    typename QMap<Key, T>::iterator i(find(key));
    typename QMap<Key, T>::iterator end(QMap<Key, T>::end());
    while (i != end && !qMapLessThanKey<Key>(key, i.key())) {
        if (i.value() == value) {
            i = this->erase(i);
            ++n;
        } else {
            ++i;
        }
    }
    return n;
}

template <class Key, class T>
inline int QMultiMap<Key, T>::count(const Key &key, const T &value) const
{
    int n = 0;
    typename QMap<Key, T>::const_iterator i(constFind(key));
    typename QMap<Key, T>::const_iterator end(QMap<Key, T>::constEnd());
    while (i != end && !qMapLessThanKey<Key>(key, i.key())) {
        if (i.value() == value)
            ++n;
        ++i;
    }
    return n;
}

template <class Key, class T> class QMapIterator { typedef typename QMap<Key,T>::const_iterator const_iterator; typedef const_iterator Item; QMap<Key,T> c; const_iterator i, n; inline bool item_exists() const { return n != c.constEnd(); } public: inline QMapIterator(const QMap<Key,T> &container) : c(container), i(c.constBegin()), n(c.constEnd()) {} inline QMapIterator &operator=(const QMap<Key,T> &container) { c = container; i = c.constBegin(); n = c.constEnd(); return *this; } inline void toFront() { i = c.constBegin(); n = c.constEnd(); } inline void toBack() { i = c.constEnd(); n = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { const_iterator p = i; return --p; } inline const T &value() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",1262) : qt_noop()); return *n; } inline const Key &key() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",1262) : qt_noop()); return n.key(); } inline bool findNext(const T &t) { while ((n = i) != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(n = --i) == t) return true; n = c.constEnd(); return false; } };
template <class Key, class T> class QMutableMapIterator { typedef typename QMap<Key,T>::iterator iterator; typedef typename QMap<Key,T>::const_iterator const_iterator; typedef iterator Item; QMap<Key,T> *c; iterator i, n; inline bool item_exists() const { return const_iterator(n) != c->constEnd(); } public: inline QMutableMapIterator(QMap<Key,T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableMapIterator() { c->setSharable(true); } inline QMutableMapIterator &operator=(QMap<Key,T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = c->end(); } inline bool hasNext() const { return const_iterator(i) != c->constEnd(); } inline Item next() { n = i++; return n; } inline Item peekNext() const { return i; } inline bool hasPrevious() const { return const_iterator(i) != c->constBegin(); } inline Item previous() { n = --i; return n; } inline Item peekPrevious() const { iterator p = i; return --p; } inline void remove() { if (const_iterator(n) != c->constEnd()) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) { if (const_iterator(n) != c->constEnd()) *n = t; } inline T &value() { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",1263) : qt_noop()); return *n; } inline const T &value() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",1263) : qt_noop()); return *n; } inline const Key &key() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmap.h",1263) : qt_noop()); return n.key(); } inline bool findNext(const T &t) { while (const_iterator(n = i) != c->constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (const_iterator(i) != c->constBegin()) if (*(n = --i) == t) return true; n = c->end(); return false; } };
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariant.h"
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariant.h"
class QBitArray;
class QDataStream;
class QDate;
class QDateTime;
class QEasingCurve;
class QLine;
class QLineF;
class QLocale;
class QMatrix;
class QTransform;
class QStringList;
class QTime;
class QPoint;
class QPointF;
class QSize;
class QSizeF;
class QRect;
class QRectF;

class QRegExp;


class QRegularExpression;

class QTextFormat;
class QTextLength;
class QUrl;
class QVariant;
class QVariantComparisonHelper;

template <typename T>
inline QVariant qVariantFromValue(const T &);

template<typename T>
inline T qvariant_cast(const QVariant &);

namespace QtPrivate {

    template <typename Derived, typename Argument, typename ReturnType>
    struct ObjectInvoker
    {
        static ReturnType invoke(Argument a)
        {
            return Derived::object(a);
        }
    };

    template <typename Derived, typename Argument, typename ReturnType>
    struct MetaTypeInvoker
    {
        static ReturnType invoke(Argument a)
        {
            return Derived::metaType(a);
        }
    };

    template <typename Derived, typename T, typename Argument, typename ReturnType, bool = IsPointerToTypeDerivedFromQObject<T>::Value>
    struct TreatAsQObjectBeforeMetaType : ObjectInvoker<Derived, Argument, ReturnType>
    {
    };

    template <typename Derived, typename T, typename Argument, typename ReturnType>
    struct TreatAsQObjectBeforeMetaType<Derived, T, Argument, ReturnType, false> : MetaTypeInvoker<Derived, Argument, ReturnType>
    {
    };

    template<typename T> struct QVariantValueHelper;
}

class __declspec(dllimport) QVariant
{
 public:
    enum Type {
        Invalid = QMetaType::UnknownType,
        Bool = QMetaType::Bool,
        Int = QMetaType::Int,
        UInt = QMetaType::UInt,
        LongLong = QMetaType::LongLong,
        ULongLong = QMetaType::ULongLong,
        Double = QMetaType::Double,
        Char = QMetaType::QChar,
        Map = QMetaType::QVariantMap,
        List = QMetaType::QVariantList,
        String = QMetaType::QString,
        StringList = QMetaType::QStringList,
        ByteArray = QMetaType::QByteArray,
        BitArray = QMetaType::QBitArray,
        Date = QMetaType::QDate,
        Time = QMetaType::QTime,
        DateTime = QMetaType::QDateTime,
        Url = QMetaType::QUrl,
        Locale = QMetaType::QLocale,
        Rect = QMetaType::QRect,
        RectF = QMetaType::QRectF,
        Size = QMetaType::QSize,
        SizeF = QMetaType::QSizeF,
        Line = QMetaType::QLine,
        LineF = QMetaType::QLineF,
        Point = QMetaType::QPoint,
        PointF = QMetaType::QPointF,
        RegExp = QMetaType::QRegExp,
        RegularExpression = QMetaType::QRegularExpression,
        Hash = QMetaType::QVariantHash,
        EasingCurve = QMetaType::QEasingCurve,
        Uuid = QMetaType::QUuid,
        ModelIndex = QMetaType::QModelIndex,
        LastCoreType = QMetaType::LastCoreType,

        Font = QMetaType::QFont,
        Pixmap = QMetaType::QPixmap,
        Brush = QMetaType::QBrush,
        Color = QMetaType::QColor,
        Palette = QMetaType::QPalette,
        Image = QMetaType::QImage,
        Polygon = QMetaType::QPolygon,
        Region = QMetaType::QRegion,
        Bitmap = QMetaType::QBitmap,
        Cursor = QMetaType::QCursor,
        KeySequence = QMetaType::QKeySequence,
        Pen = QMetaType::QPen,
        TextLength = QMetaType::QTextLength,
        TextFormat = QMetaType::QTextFormat,
        Matrix = QMetaType::QMatrix,
        Transform = QMetaType::QTransform,
        Matrix4x4 = QMetaType::QMatrix4x4,
        Vector2D = QMetaType::QVector2D,
        Vector3D = QMetaType::QVector3D,
        Vector4D = QMetaType::QVector4D,
        Quaternion = QMetaType::QQuaternion,
        PolygonF = QMetaType::QPolygonF,
        Icon = QMetaType::QIcon,
        LastGuiType = QMetaType::LastGuiType,

        SizePolicy = QMetaType::QSizePolicy,

        UserType = QMetaType::User,
        LastType = 0xffffffff
    };

    inline QVariant();
    ~QVariant();
    QVariant(Type type);
    QVariant(int typeId, const void *copy);
    QVariant(int typeId, const void *copy, uint flags);
    QVariant(const QVariant &other);


    QVariant(QDataStream &s);


    QVariant(int i);
    QVariant(uint ui);
    QVariant(qlonglong ll);
    QVariant(qulonglong ull);
    QVariant(bool b);
    QVariant(double d);
    QVariant(float f);

                       QVariant(const char *str);


    QVariant(const QByteArray &bytearray);
    QVariant(const QBitArray &bitarray);
    QVariant(const QString &string);
    QVariant(QLatin1String string);
    QVariant(const QStringList &stringlist);
    QVariant(QChar qchar);
    QVariant(const QDate &date);
    QVariant(const QTime &time);
    QVariant(const QDateTime &datetime);
    QVariant(const QList<QVariant> &list);
    QVariant(const QMap<QString,QVariant> &map);
    QVariant(const QHash<QString,QVariant> &hash);

    QVariant(const QSize &size);
    QVariant(const QSizeF &size);
    QVariant(const QPoint &pt);
    QVariant(const QPointF &pt);
    QVariant(const QLine &line);
    QVariant(const QLineF &line);
    QVariant(const QRect &rect);
    QVariant(const QRectF &rect);

    QVariant(const QLocale &locale);

    QVariant(const QRegExp &regExp);



    QVariant(const QRegularExpression &re);

    QVariant(const QUrl &url);
    QVariant(const QEasingCurve &easing);
    QVariant(const QUuid &uuid);
    QVariant(const QModelIndex &modelIndex);
    QVariant(const QJsonValue &jsonValue);
    QVariant(const QJsonObject &jsonObject);
    QVariant(const QJsonArray &jsonArray);
    QVariant(const QJsonDocument &jsonDocument);


    QVariant& operator=(const QVariant &other);

    inline QVariant(QVariant &&other) : d(other.d)
    { other.d = Private(); }
    inline QVariant &operator=(QVariant &&other)
    { qSwap(d, other.d); return *this; }


    inline void swap(QVariant &other) { qSwap(d, other.d); }

    Type type() const;
    int userType() const;
    const char *typeName() const;

    bool canConvert(int targetTypeId) const;
    bool convert(int targetTypeId);

    inline bool isValid() const;
    bool isNull() const;

    void clear();

    void detach();
    inline bool isDetached() const;

    int toInt(bool *ok = 0) const;
    uint toUInt(bool *ok = 0) const;
    qlonglong toLongLong(bool *ok = 0) const;
    qulonglong toULongLong(bool *ok = 0) const;
    bool toBool() const;
    double toDouble(bool *ok = 0) const;
    float toFloat(bool *ok = 0) const;
    qreal toReal(bool *ok = 0) const;
    QByteArray toByteArray() const;
    QBitArray toBitArray() const;
    QString toString() const;
    QStringList toStringList() const;
    QChar toChar() const;
    QDate toDate() const;
    QTime toTime() const;
    QDateTime toDateTime() const;
    QList<QVariant> toList() const;
    QMap<QString, QVariant> toMap() const;
    QHash<QString, QVariant> toHash() const;


    QPoint toPoint() const;
    QPointF toPointF() const;
    QRect toRect() const;
    QSize toSize() const;
    QSizeF toSizeF() const;
    QLine toLine() const;
    QLineF toLineF() const;
    QRectF toRectF() const;

    QLocale toLocale() const;

    QRegExp toRegExp() const;



    QRegularExpression toRegularExpression() const;

    QUrl toUrl() const;
    QEasingCurve toEasingCurve() const;
    QUuid toUuid() const;
    QModelIndex toModelIndex() const;
    QJsonValue toJsonValue() const;
    QJsonObject toJsonObject() const;
    QJsonArray toJsonArray() const;
    QJsonDocument toJsonDocument() const;



    void load(QDataStream &ds);
    void save(QDataStream &ds) const;

    static const char *typeToName(int typeId);
    static Type nameToType(const char *name);

    void *data();
    const void *constData() const;
    inline const void *data() const { return constData(); }

    template<typename T>
    inline void setValue(const T &value);

    template<typename T>
    inline T value() const
    { return qvariant_cast<T>(*this); }

    template<typename T>
    static inline QVariant fromValue(const T &value)
    { return qVariantFromValue(value); }

    template<typename T>
    bool canConvert() const
    { return canConvert(qMetaTypeId<T>()); }

 public:

    struct PrivateShared
    {
        inline PrivateShared(void *v) : ptr(v), ref(1) { }
        void *ptr;
        QAtomicInt ref;
    };
    struct Private
    {
        inline Private(): type(Invalid), is_shared(false), is_null(true)
        { data.ptr = 0; }


        explicit inline Private(uint variantType)
            : type(variantType), is_shared(false), is_null(false)
        {}

        inline Private(const Private &other)
            : data(other.data), type(other.type),
              is_shared(other.is_shared), is_null(other.is_null)
        {}
        union Data
        {
            char c;
            uchar uc;
            short s;
            signed char sc;
            ushort us;
            int i;
            uint u;
            long l;
            ulong ul;
            bool b;
            double d;
            float f;
            qreal real;
            qlonglong ll;
            qulonglong ull;
            QObject *o;
            void *ptr;
            PrivateShared *shared;
        } data;
        uint type : 30;
        uint is_shared : 1;
        uint is_null : 1;
    };
 public:
    typedef void (*f_construct)(Private *, const void *);
    typedef void (*f_clear)(Private *);
    typedef bool (*f_null)(const Private *);

    typedef void (*f_load)(Private *, QDataStream &);
    typedef void (*f_save)(const Private *, QDataStream &);

    typedef bool (*f_compare)(const Private *, const Private *);
    typedef bool (*f_convert)(const QVariant::Private *d, int t, void *, bool *);
    typedef bool (*f_canConvert)(const QVariant::Private *d, int t);
    typedef void (*f_debugStream)(QDebug, const QVariant &);
    struct Handler {
        f_construct construct;
        f_clear clear;
        f_null isNull;

        f_load load;
        f_save save;

        f_compare compare;
        f_convert convert;
        f_canConvert canConvert;
        f_debugStream debugStream;
    };


    inline bool operator==(const QVariant &v) const
    { return cmp(v); }
    inline bool operator!=(const QVariant &v) const
    { return !cmp(v); }
    inline bool operator<(const QVariant &v) const
    { return compare(v) < 0; }
    inline bool operator<=(const QVariant &v) const
    { return compare(v) <= 0; }
    inline bool operator>(const QVariant &v) const
    { return compare(v) > 0; }
    inline bool operator>=(const QVariant &v) const
    { return compare(v) >= 0; }

protected:
    friend inline bool operator==(const QVariant &, const QVariantComparisonHelper &);

    friend __declspec(dllimport) QDebug operator<<(QDebug, const QVariant &);







public:

    Private d;
    void create(int type, const void *copy);
    bool cmp(const QVariant &other) const;
    int compare(const QVariant &other) const;
    bool convert(const int t, void *ptr) const;

private:

    inline QVariant(void *) = delete;






    QVariant(QMetaType::Type) = delete;






    QVariant(Qt::GlobalColor) = delete;
    QVariant(Qt::BrushStyle) = delete;
    QVariant(Qt::PenStyle) = delete;
    QVariant(Qt::CursorShape) = delete;




public:
    typedef Private DataPtr;
    inline DataPtr &data_ptr() { return d; }
    inline const DataPtr &data_ptr() const { return d; }
};

template <typename T>
inline QVariant qVariantFromValue(const T &t)
{
    return QVariant(qMetaTypeId<T>(), &t, QTypeInfo<T>::isPointer);
}

template <>
inline QVariant qVariantFromValue(const QVariant &t) { return t; }

template <typename T>
inline void qVariantSetValue(QVariant &v, const T &t)
{

    const uint type = qMetaTypeId<T>();
    QVariant::Private &d = v.data_ptr();
    if (v.isDetached() && (type == d.type || (type <= uint(QVariant::Char) && d.type <= uint(QVariant::Char)))) {
        d.type = type;
        d.is_null = false;
        T *old = reinterpret_cast<T*>(d.is_shared ? d.data.shared->ptr : &d.data.ptr);
        if (QTypeInfo<T>::isComplex)
            old->~T();
        new (old) T(t);
    } else {
        v = QVariant(type, &t, QTypeInfo<T>::isPointer);
    }
}

template <>
inline void qVariantSetValue<QVariant>(QVariant &v, const QVariant &t)
{
    v = t;
}


inline QVariant::QVariant() {}
inline bool QVariant::isValid() const { return d.type != Invalid; }

template<typename T>
inline void QVariant::setValue(const T &avalue)
{ qVariantSetValue(*this, avalue); }


__declspec(dllimport) QDataStream& operator>> (QDataStream& s, QVariant& p);
__declspec(dllimport) QDataStream& operator<< (QDataStream& s, const QVariant& p);
__declspec(dllimport) QDataStream& operator>> (QDataStream& s, QVariant::Type& p);
__declspec(dllimport) QDataStream& operator<< (QDataStream& s, const QVariant::Type p);


inline bool QVariant::isDetached() const
{ return !d.is_shared || d.data.shared->ref.load() == 1; }
#line 554 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariant.h"
class QVariantComparisonHelper
{
public:
    inline QVariantComparisonHelper(const QVariant &var)
        : v(&var) {}
private:
    friend inline bool operator==(const QVariant &, const QVariantComparisonHelper &);
    const QVariant *v;
};

inline bool operator==(const QVariant &v1, const QVariantComparisonHelper &v2)
{
    return v1.cmp(*v2.v);
}

inline bool operator!=(const QVariant &v1, const QVariantComparisonHelper &v2)
{
    return !operator==(v1, v2);
}


class __declspec(dllimport) QSequentialIterable
{
    QtMetaTypePrivate::QSequentialIterableImpl m_impl;
public:
    struct __declspec(dllimport) const_iterator
    {
    private:
        QtMetaTypePrivate::QSequentialIterableImpl m_impl;
        QAtomicInt *ref;
        friend class QSequentialIterable;
        explicit const_iterator(const QSequentialIterable &iter, QAtomicInt *ref_);

        explicit const_iterator(const QtMetaTypePrivate::QSequentialIterableImpl &impl, QAtomicInt *ref_);

        void begin();
        void end();
    public:
        ~const_iterator();

        const_iterator(const const_iterator &other);

        const_iterator& operator=(const const_iterator &other);

        const QVariant operator*() const;
        bool operator==(const const_iterator &o) const;
        bool operator!=(const const_iterator &o) const;
        const_iterator &operator++();
        const_iterator operator++(int);
        const_iterator &operator--();
        const_iterator operator--(int);
        const_iterator &operator+=(int j);
        const_iterator &operator-=(int j);
        const_iterator operator+(int j) const;
        const_iterator operator-(int j) const;
    };

    friend struct const_iterator;

    explicit QSequentialIterable(QtMetaTypePrivate::QSequentialIterableImpl impl);

    const_iterator begin() const;
    const_iterator end() const;

    QVariant at(int idx) const;
    int size() const;

    bool canReverseIterate() const;
};

class __declspec(dllimport) QAssociativeIterable
{
    QtMetaTypePrivate::QAssociativeIterableImpl m_impl;
public:
    struct __declspec(dllimport) const_iterator
    {
    private:
        QtMetaTypePrivate::QAssociativeIterableImpl m_impl;
        QAtomicInt *ref;
        friend class QAssociativeIterable;
        explicit const_iterator(const QAssociativeIterable &iter, QAtomicInt *ref_);

        explicit const_iterator(const QtMetaTypePrivate::QAssociativeIterableImpl &impl, QAtomicInt *ref_);

        void begin();
        void end();
    public:
        ~const_iterator();
        const_iterator(const const_iterator &other);

        const_iterator& operator=(const const_iterator &other);

        const QVariant key() const;

        const QVariant value() const;

        const QVariant operator*() const;
        bool operator==(const const_iterator &o) const;
        bool operator!=(const const_iterator &o) const;
        const_iterator &operator++();
        const_iterator operator++(int);
        const_iterator &operator--();
        const_iterator operator--(int);
        const_iterator &operator+=(int j);
        const_iterator &operator-=(int j);
        const_iterator operator+(int j) const;
        const_iterator operator-(int j) const;
    };

    friend struct const_iterator;

    explicit QAssociativeIterable(QtMetaTypePrivate::QAssociativeIterableImpl impl);

    const_iterator begin() const;
    const_iterator end() const;

    QVariant value(const QVariant &key) const;

    int size() const;
};


namespace QtPrivate {
    template<typename T>
    struct QVariantValueHelper : TreatAsQObjectBeforeMetaType<QVariantValueHelper<T>, T, const QVariant &, T>
    {
        static T metaType(const QVariant &v)
        {
            const int vid = qMetaTypeId<T>();
            if (vid == v.userType())
                return *reinterpret_cast<const T *>(v.constData());
            T t;
            if (v.convert(vid, &t))
                return t;
            return T();
        }

        static T object(const QVariant &v)
        {
            return qobject_cast<T>(QMetaType::typeFlags(v.userType()) & QMetaType::PointerToQObject
                ? v.d.data.o
                : QVariantValueHelper::metaType(v));
        }

    };

    template<typename T>
    struct QVariantValueHelperInterface : QVariantValueHelper<T>
    {
    };

    template<>
    struct QVariantValueHelperInterface<QSequentialIterable>
    {
        static QSequentialIterable invoke(const QVariant &v)
        {
            if (v.userType() == qMetaTypeId<QVariantList>()) {
                return QSequentialIterable(QtMetaTypePrivate::QSequentialIterableImpl(reinterpret_cast<const QVariantList*>(v.constData())));
            }
            if (v.userType() == qMetaTypeId<QStringList>()) {
                return QSequentialIterable(QtMetaTypePrivate::QSequentialIterableImpl(reinterpret_cast<const QStringList*>(v.constData())));
            }
            return QSequentialIterable(v.value<QtMetaTypePrivate::QSequentialIterableImpl>());
        }
    };
    template<>
    struct QVariantValueHelperInterface<QAssociativeIterable>
    {
        static QAssociativeIterable invoke(const QVariant &v)
        {
            if (v.userType() == qMetaTypeId<QVariantMap>()) {
                return QAssociativeIterable(QtMetaTypePrivate::QAssociativeIterableImpl(reinterpret_cast<const QVariantMap*>(v.constData())));
            }
            if (v.userType() == qMetaTypeId<QVariantHash>()) {
                return QAssociativeIterable(QtMetaTypePrivate::QAssociativeIterableImpl(reinterpret_cast<const QVariantHash*>(v.constData())));
            }
            return QAssociativeIterable(v.value<QtMetaTypePrivate::QAssociativeIterableImpl>());
        }
    };
    template<>
    struct QVariantValueHelperInterface<QVariantList>
    {
        static QVariantList invoke(const QVariant &v)
        {
            if (v.userType() == qMetaTypeId<QStringList>() || QMetaType::hasRegisteredConverterFunction(v.userType(), qMetaTypeId<QtMetaTypePrivate::QSequentialIterableImpl>())) {
                QSequentialIterable iter = QVariantValueHelperInterface<QSequentialIterable>::invoke(v);
                QVariantList l;
                l.reserve(iter.size());
                for (QSequentialIterable::const_iterator it = iter.begin(), end = iter.end(); it != end; ++it)
                    l << *it;
                return l;
            }
            return QVariantValueHelper<QVariantList>::invoke(v);
        }
    };
    template<>
    struct QVariantValueHelperInterface<QVariantHash>
    {
        static QVariantHash invoke(const QVariant &v)
        {
            if (QMetaType::hasRegisteredConverterFunction(v.userType(), qMetaTypeId<QtMetaTypePrivate::QAssociativeIterableImpl>())) {
                QAssociativeIterable iter = QVariantValueHelperInterface<QAssociativeIterable>::invoke(v);
                QVariantHash l;
                l.reserve(iter.size());
                for (QAssociativeIterable::const_iterator it = iter.begin(), end = iter.end(); it != end; ++it)
                    l.insert(it.key().toString(), it.value());
                return l;
            }
            return QVariantValueHelper<QVariantHash>::invoke(v);
        }
    };
    template<>
    struct QVariantValueHelperInterface<QVariantMap>
    {
        static QVariantMap invoke(const QVariant &v)
        {
            if (QMetaType::hasRegisteredConverterFunction(v.userType(), qMetaTypeId<QtMetaTypePrivate::QAssociativeIterableImpl>())) {
                QAssociativeIterable iter = QVariantValueHelperInterface<QAssociativeIterable>::invoke(v);
                QVariantMap l;
                for (QAssociativeIterable::const_iterator it = iter.begin(), end = iter.end(); it != end; ++it)
                    l.insert(it.key().toString(), it.value());
                return l;
            }
            return QVariantValueHelper<QVariantMap>::invoke(v);
        }
    };
    template<>
    struct QVariantValueHelperInterface<QPair<QVariant, QVariant> >
    {
        static QPair<QVariant, QVariant> invoke(const QVariant &v)
        {
            if (v.userType() == qMetaTypeId<QPair<QVariant, QVariant> >())
                return QVariantValueHelper<QPair<QVariant, QVariant> >::invoke(v);

            if (QMetaType::hasRegisteredConverterFunction(v.userType(), qMetaTypeId<QtMetaTypePrivate::QPairVariantInterfaceImpl>())) {
                QtMetaTypePrivate::QPairVariantInterfaceImpl pi = v.value<QtMetaTypePrivate::QPairVariantInterfaceImpl>();

                const QtMetaTypePrivate::VariantData d1 = pi.first();
                QVariant v1(d1.metaTypeId, d1.data, d1.flags);
                if (d1.metaTypeId == qMetaTypeId<QVariant>())
                    v1 = *reinterpret_cast<const QVariant*>(d1.data);

                const QtMetaTypePrivate::VariantData d2 = pi.second();
                QVariant v2(d2.metaTypeId, d2.data, d2.flags);
                if (d2.metaTypeId == qMetaTypeId<QVariant>())
                    v2 = *reinterpret_cast<const QVariant*>(d2.data);

                return QPair<QVariant, QVariant>(v1, v2);
            }
            return QVariantValueHelper<QPair<QVariant, QVariant> >::invoke(v);
        }
    };
}

template<typename T> inline T qvariant_cast(const QVariant &v)
{
    return QtPrivate::QVariantValueHelperInterface<T>::invoke(v);
}

template<> inline QVariant qvariant_cast<QVariant>(const QVariant &v)
{
    if (v.userType() == QMetaType::QVariant)
        return *reinterpret_cast<const QVariant *>(v.constData());
    return v;
}
#line 831 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariant.h"
template<> class QTypeInfo<QVariant > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QVariant)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QVariant >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QVariant) }; static inline const char *name() { return "QVariant"; } }; template <> inline void qSwap<QVariant>(QVariant &value1, QVariant &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QVariant >(::QVariant &value1, ::QVariant &value2) { value1.swap(value2); } }


__declspec(dllimport) QDebug operator<<(QDebug, const QVariant &);
__declspec(dllimport) QDebug operator<<(QDebug, const QVariant::Type);
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtextformat.h"








class QString;
class QVariant;
class QFont;

class QTextFormatCollection;
class QTextFormatPrivate;
class QTextBlockFormat;
class QTextCharFormat;
class QTextListFormat;
class QTextTableFormat;
class QTextFrameFormat;
class QTextImageFormat;
class QTextTableCellFormat;
class QTextFormat;
class QTextObject;
class QTextCursor;
class QTextDocument;
class QTextLength;


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTextLength &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QTextLength &);



__declspec(dllimport) QDebug operator<<(QDebug, const QTextLength &);


class __declspec(dllimport) QTextLength
{
public:
    enum Type { VariableLength = 0, FixedLength, PercentageLength };

    inline QTextLength() : lengthType(VariableLength), fixedValueOrPercentage(0) {}

    inline explicit QTextLength(Type type, qreal value);

    inline Type type() const { return lengthType; }
    inline qreal value(qreal maximumLength) const
    {
        switch (lengthType) {
            case FixedLength: return fixedValueOrPercentage;
            case VariableLength: return maximumLength;
            case PercentageLength: return fixedValueOrPercentage * maximumLength / qreal(100);
        }
        return -1;
    }

    inline qreal rawValue() const { return fixedValueOrPercentage; }

    inline bool operator==(const QTextLength &other) const
    { return lengthType == other.lengthType
             && qFuzzyCompare(fixedValueOrPercentage, other.fixedValueOrPercentage); }
    inline bool operator!=(const QTextLength &other) const
    { return lengthType != other.lengthType
             || !qFuzzyCompare(fixedValueOrPercentage, other.fixedValueOrPercentage); }
    operator QVariant() const;

private:
    Type lengthType;
    qreal fixedValueOrPercentage;
    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTextLength &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QTextLength &);
};

inline QTextLength::QTextLength(Type atype, qreal avalue)
    : lengthType(atype), fixedValueOrPercentage(avalue) {}


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTextFormat &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QTextFormat &);



__declspec(dllimport) QDebug operator<<(QDebug, const QTextFormat &);


class __declspec(dllimport) QTextFormat
{
    public: static const QMetaObject staticMetaObject; private:

public:
    enum FormatType {
        InvalidFormat = -1,
        BlockFormat = 1,
        CharFormat = 2,
        ListFormat = 3,

        TableFormat = 4,

        FrameFormat = 5,

        UserFormat = 100
    };

    enum Property {
        ObjectIndex = 0x0,


        CssFloat = 0x0800,
        LayoutDirection = 0x0801,

        OutlinePen = 0x810,
        BackgroundBrush = 0x820,
        ForegroundBrush = 0x821,

        BackgroundImageUrl = 0x823,


        BlockAlignment = 0x1010,
        BlockTopMargin = 0x1030,
        BlockBottomMargin = 0x1031,
        BlockLeftMargin = 0x1032,
        BlockRightMargin = 0x1033,
        TextIndent = 0x1034,
        TabPositions = 0x1035,
        BlockIndent = 0x1040,
        LineHeight = 0x1048,
        LineHeightType = 0x1049,
        BlockNonBreakableLines = 0x1050,
        BlockTrailingHorizontalRulerWidth = 0x1060,


        FirstFontProperty = 0x1FE0,
        FontCapitalization = FirstFontProperty,
        FontLetterSpacingType = 0x2033,
        FontLetterSpacing = 0x1FE1,
        FontWordSpacing = 0x1FE2,
        FontStretch = 0x2034,
        FontStyleHint = 0x1FE3,
        FontStyleStrategy = 0x1FE4,
        FontKerning = 0x1FE5,
        FontHintingPreference = 0x1FE6,
        FontFamily = 0x2000,
        FontPointSize = 0x2001,
        FontSizeAdjustment = 0x2002,
        FontSizeIncrement = FontSizeAdjustment,
        FontWeight = 0x2003,
        FontItalic = 0x2004,
        FontUnderline = 0x2005,
        FontOverline = 0x2006,
        FontStrikeOut = 0x2007,
        FontFixedPitch = 0x2008,
        FontPixelSize = 0x2009,
        LastFontProperty = FontPixelSize,

        TextUnderlineColor = 0x2010,
        TextVerticalAlignment = 0x2021,
        TextOutline = 0x2022,
        TextUnderlineStyle = 0x2023,
        TextToolTip = 0x2024,

        IsAnchor = 0x2030,
        AnchorHref = 0x2031,
        AnchorName = 0x2032,
        ObjectType = 0x2f00,


        ListStyle = 0x3000,
        ListIndent = 0x3001,
        ListNumberPrefix = 0x3002,
        ListNumberSuffix = 0x3003,


        FrameBorder = 0x4000,
        FrameMargin = 0x4001,
        FramePadding = 0x4002,
        FrameWidth = 0x4003,
        FrameHeight = 0x4004,
        FrameTopMargin = 0x4005,
        FrameBottomMargin = 0x4006,
        FrameLeftMargin = 0x4007,
        FrameRightMargin = 0x4008,
        FrameBorderBrush = 0x4009,
        FrameBorderStyle = 0x4010,

        TableColumns = 0x4100,
        TableColumnWidthConstraints = 0x4101,
        TableCellSpacing = 0x4102,
        TableCellPadding = 0x4103,
        TableHeaderRowCount = 0x4104,


        TableCellRowSpan = 0x4810,
        TableCellColumnSpan = 0x4811,

        TableCellTopPadding = 0x4812,
        TableCellBottomPadding = 0x4813,
        TableCellLeftPadding = 0x4814,
        TableCellRightPadding = 0x4815,


        ImageName = 0x5000,
        ImageWidth = 0x5010,
        ImageHeight = 0x5011,
#line 260 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtextformat.h"
        FullWidthSelection = 0x06000,


        PageBreakPolicy = 0x7000,


        UserProperty = 0x100000
    };

    enum ObjectTypes {
        NoObject,
        ImageObject,
        TableObject,
        TableCellObject,

        UserObject = 0x1000
    };

    enum PageBreakFlag {
        PageBreak_Auto = 0,
        PageBreak_AlwaysBefore = 0x001,
        PageBreak_AlwaysAfter = 0x010

    };
    typedef QFlags<PageBreakFlag> PageBreakFlags;

    QTextFormat();

    explicit QTextFormat(int type);

    QTextFormat(const QTextFormat &rhs);
    QTextFormat &operator=(const QTextFormat &rhs);
    ~QTextFormat();

    void swap(QTextFormat &other)
    { qSwap(d, other.d); qSwap(format_type, other.format_type); }

    void merge(const QTextFormat &other);

    inline bool isValid() const { return type() != InvalidFormat; }
    inline bool isEmpty() const { return propertyCount() == 0; }

    int type() const;

    int objectIndex() const;
    void setObjectIndex(int object);

    QVariant property(int propertyId) const;
    void setProperty(int propertyId, const QVariant &value);
    void clearProperty(int propertyId);
    bool hasProperty(int propertyId) const;

    bool boolProperty(int propertyId) const;
    int intProperty(int propertyId) const;
    qreal doubleProperty(int propertyId) const;
    QString stringProperty(int propertyId) const;
    QColor colorProperty(int propertyId) const;
    QPen penProperty(int propertyId) const;
    QBrush brushProperty(int propertyId) const;
    QTextLength lengthProperty(int propertyId) const;
    QVector<QTextLength> lengthVectorProperty(int propertyId) const;

    void setProperty(int propertyId, const QVector<QTextLength> &lengths);

    QMap<int, QVariant> properties() const;
    int propertyCount() const;

    inline void setObjectType(int type);
    inline int objectType() const
    { return intProperty(ObjectType); }

    inline bool isCharFormat() const { return type() == CharFormat; }
    inline bool isBlockFormat() const { return type() == BlockFormat; }
    inline bool isListFormat() const { return type() == ListFormat; }
    inline bool isFrameFormat() const { return type() == FrameFormat; }
    inline bool isImageFormat() const { return type() == CharFormat && objectType() == ImageObject; }
    inline bool isTableFormat() const { return type() == FrameFormat && objectType() == TableObject; }
    inline bool isTableCellFormat() const { return type() == CharFormat && objectType() == TableCellObject; }

    QTextBlockFormat toBlockFormat() const;
    QTextCharFormat toCharFormat() const;
    QTextListFormat toListFormat() const;
    QTextTableFormat toTableFormat() const;
    QTextFrameFormat toFrameFormat() const;
    QTextImageFormat toImageFormat() const;
    QTextTableCellFormat toTableCellFormat() const;

    bool operator==(const QTextFormat &rhs) const;
    inline bool operator!=(const QTextFormat &rhs) const { return !operator==(rhs); }
    operator QVariant() const;

    inline void setLayoutDirection(Qt::LayoutDirection direction)
        { setProperty(QTextFormat::LayoutDirection, direction); }
    inline Qt::LayoutDirection layoutDirection() const
        { return Qt::LayoutDirection(intProperty(QTextFormat::LayoutDirection)); }

    inline void setBackground(const QBrush &brush)
    { setProperty(BackgroundBrush, brush); }
    inline QBrush background() const
    { return brushProperty(BackgroundBrush); }
    inline void clearBackground()
    { clearProperty(BackgroundBrush); }

    inline void setForeground(const QBrush &brush)
    { setProperty(ForegroundBrush, brush); }
    inline QBrush foreground() const
    { return brushProperty(ForegroundBrush); }
    inline void clearForeground()
    { clearProperty(ForegroundBrush); }

private:
    QSharedDataPointer<QTextFormatPrivate> d;
    qint32 format_type;

    friend class QTextFormatCollection;
    friend class QTextCharFormat;
    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTextFormat &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QTextFormat &);
};

template<> class QTypeInfo<QTextFormat > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextFormat)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTextFormat >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTextFormat) }; static inline const char *name() { return "QTextFormat"; } }; template <> inline void qSwap<QTextFormat>(QTextFormat &value1, QTextFormat &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QTextFormat >(::QTextFormat &value1, ::QTextFormat &value2) { value1.swap(value2); } }

inline void QTextFormat::setObjectType(int atype)
{ setProperty(ObjectType, atype); }

 inline QFlags<QTextFormat::PageBreakFlags::enum_type> operator|(QTextFormat::PageBreakFlags::enum_type f1, QTextFormat::PageBreakFlags::enum_type f2) { return QFlags<QTextFormat::PageBreakFlags::enum_type>(f1) | f2; } inline QFlags<QTextFormat::PageBreakFlags::enum_type> operator|(QTextFormat::PageBreakFlags::enum_type f1, QFlags<QTextFormat::PageBreakFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextFormat::PageBreakFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class __declspec(dllimport) QTextCharFormat : public QTextFormat
{
public:
    enum VerticalAlignment {
        AlignNormal = 0,
        AlignSuperScript,
        AlignSubScript,
        AlignMiddle,
        AlignTop,
        AlignBottom,
        AlignBaseline
    };
    enum UnderlineStyle {
        NoUnderline,
        SingleUnderline,
        DashUnderline,
        DotLine,
        DashDotLine,
        DashDotDotLine,
        WaveUnderline,
        SpellCheckUnderline
    };

    QTextCharFormat();

    bool isValid() const { return isCharFormat(); }

    enum FontPropertiesInheritanceBehavior {
        FontPropertiesSpecifiedOnly,
        FontPropertiesAll
    };
    void setFont(const QFont &font, FontPropertiesInheritanceBehavior behavior);
    void setFont(const QFont &font);
    QFont font() const;

    inline void setFontFamily(const QString &family)
    { setProperty(FontFamily, family); }
    inline QString fontFamily() const
    { return stringProperty(FontFamily); }

    inline void setFontPointSize(qreal size)
    { setProperty(FontPointSize, size); }
    inline qreal fontPointSize() const
    { return doubleProperty(FontPointSize); }

    inline void setFontWeight(int weight)
    { if (weight == QFont::Normal) weight = 0; setProperty(FontWeight, weight); }
    inline int fontWeight() const
    { int weight = intProperty(FontWeight); if (weight == 0) weight = QFont::Normal; return weight; }
    inline void setFontItalic(bool italic)
    { setProperty(FontItalic, italic); }
    inline bool fontItalic() const
    { return boolProperty(FontItalic); }
    inline void setFontCapitalization(QFont::Capitalization capitalization)
    { setProperty(FontCapitalization, capitalization); }
    inline QFont::Capitalization fontCapitalization() const
    { return static_cast<QFont::Capitalization>(intProperty(FontCapitalization)); }
    inline void setFontLetterSpacingType(QFont::SpacingType letterSpacingType)
    { setProperty(FontLetterSpacingType, letterSpacingType); }
    inline QFont::SpacingType fontLetterSpacingType() const
    { return static_cast<QFont::SpacingType>(intProperty(FontLetterSpacingType)); }
    inline void setFontLetterSpacing(qreal spacing)
    { setProperty(FontLetterSpacing, spacing); }
    inline qreal fontLetterSpacing() const
    { return doubleProperty(FontLetterSpacing); }
    inline void setFontWordSpacing(qreal spacing)
    { setProperty(FontWordSpacing, spacing); }
    inline qreal fontWordSpacing() const
    { return doubleProperty(FontWordSpacing); }

    inline void setFontUnderline(bool underline)
    { setProperty(TextUnderlineStyle, underline ? SingleUnderline : NoUnderline); }
    bool fontUnderline() const;

    inline void setFontOverline(bool overline)
    { setProperty(FontOverline, overline); }
    inline bool fontOverline() const
    { return boolProperty(FontOverline); }

    inline void setFontStrikeOut(bool strikeOut)
    { setProperty(FontStrikeOut, strikeOut); }
    inline bool fontStrikeOut() const
    { return boolProperty(FontStrikeOut); }

    inline void setUnderlineColor(const QColor &color)
    { setProperty(TextUnderlineColor, color); }
    inline QColor underlineColor() const
    { return colorProperty(TextUnderlineColor); }

    inline void setFontFixedPitch(bool fixedPitch)
    { setProperty(FontFixedPitch, fixedPitch); }
    inline bool fontFixedPitch() const
    { return boolProperty(FontFixedPitch); }

    inline void setFontStretch(int factor)
    { setProperty(FontStretch, factor); }
    inline int fontStretch() const
    { return intProperty(FontStretch); }

    inline void setFontStyleHint(QFont::StyleHint hint, QFont::StyleStrategy strategy = QFont::PreferDefault)
    { setProperty(FontStyleHint, hint); setProperty(FontStyleStrategy, strategy); }
    inline void setFontStyleStrategy(QFont::StyleStrategy strategy)
    { setProperty(FontStyleStrategy, strategy); }
    QFont::StyleHint fontStyleHint() const
    { return static_cast<QFont::StyleHint>(intProperty(FontStyleHint)); }
    QFont::StyleStrategy fontStyleStrategy() const
    { return static_cast<QFont::StyleStrategy>(intProperty(FontStyleStrategy)); }

    inline void setFontHintingPreference(QFont::HintingPreference hintingPreference)
    {
        setProperty(FontHintingPreference, hintingPreference);
    }

    inline QFont::HintingPreference fontHintingPreference() const
    {
        return static_cast<QFont::HintingPreference>(intProperty(FontHintingPreference));
    }

    inline void setFontKerning(bool enable)
    { setProperty(FontKerning, enable); }
    inline bool fontKerning() const
    { return boolProperty(FontKerning); }

    void setUnderlineStyle(UnderlineStyle style);
    inline UnderlineStyle underlineStyle() const
    { return static_cast<UnderlineStyle>(intProperty(TextUnderlineStyle)); }

    inline void setVerticalAlignment(VerticalAlignment alignment)
    { setProperty(TextVerticalAlignment, alignment); }
    inline VerticalAlignment verticalAlignment() const
    { return static_cast<VerticalAlignment>(intProperty(TextVerticalAlignment)); }

    inline void setTextOutline(const QPen &pen)
    { setProperty(TextOutline, pen); }
    inline QPen textOutline() const
    { return penProperty(TextOutline); }

    inline void setToolTip(const QString &tip)
    { setProperty(TextToolTip, tip); }
    inline QString toolTip() const
    { return stringProperty(TextToolTip); }

    inline void setAnchor(bool anchor)
    { setProperty(IsAnchor, anchor); }
    inline bool isAnchor() const
    { return boolProperty(IsAnchor); }

    inline void setAnchorHref(const QString &value)
    { setProperty(AnchorHref, value); }
    inline QString anchorHref() const
    { return stringProperty(AnchorHref); }

    inline void setAnchorName(const QString &name)
    { setAnchorNames(QStringList(name)); }
    QString anchorName() const;

    inline void setAnchorNames(const QStringList &names)
    { setProperty(AnchorName, names); }
    QStringList anchorNames() const;

    inline void setTableCellRowSpan(int tableCellRowSpan);
    inline int tableCellRowSpan() const
    { int s = intProperty(TableCellRowSpan); if (s == 0) s = 1; return s; }
    inline void setTableCellColumnSpan(int tableCellColumnSpan);
    inline int tableCellColumnSpan() const
    { int s = intProperty(TableCellColumnSpan); if (s == 0) s = 1; return s; }

protected:
    explicit QTextCharFormat(const QTextFormat &fmt);
    friend class QTextFormat;
};

template<> class QTypeInfo<QTextCharFormat > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextCharFormat)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTextCharFormat >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTextCharFormat) }; static inline const char *name() { return "QTextCharFormat"; } }; template <> inline void qSwap<QTextCharFormat>(QTextCharFormat &value1, QTextCharFormat &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QTextCharFormat >(::QTextCharFormat &value1, ::QTextCharFormat &value2) { value1.swap(value2); } }

inline void QTextCharFormat::setTableCellRowSpan(int _tableCellRowSpan)
{
    if (_tableCellRowSpan <= 1)
        clearProperty(TableCellRowSpan);
    else
        setProperty(TableCellRowSpan, _tableCellRowSpan);
}

inline void QTextCharFormat::setTableCellColumnSpan(int _tableCellColumnSpan)
{
    if (_tableCellColumnSpan <= 1)
        clearProperty(TableCellColumnSpan);
    else
        setProperty(TableCellColumnSpan, _tableCellColumnSpan);
}

class __declspec(dllimport) QTextBlockFormat : public QTextFormat
{
public:
    enum LineHeightTypes {
        SingleHeight = 0,
        ProportionalHeight = 1,
        FixedHeight = 2,
        MinimumHeight = 3,
        LineDistanceHeight = 4
    };

    QTextBlockFormat();

    bool isValid() const { return isBlockFormat(); }

    inline void setAlignment(Qt::Alignment alignment);
    inline Qt::Alignment alignment() const
    { int a = intProperty(BlockAlignment); if (a == 0) a = Qt::AlignLeft; return QFlag(a); }

    inline void setTopMargin(qreal margin)
    { setProperty(BlockTopMargin, margin); }
    inline qreal topMargin() const
    { return doubleProperty(BlockTopMargin); }

    inline void setBottomMargin(qreal margin)
    { setProperty(BlockBottomMargin, margin); }
    inline qreal bottomMargin() const
    { return doubleProperty(BlockBottomMargin); }

    inline void setLeftMargin(qreal margin)
    { setProperty(BlockLeftMargin, margin); }
    inline qreal leftMargin() const
    { return doubleProperty(BlockLeftMargin); }

    inline void setRightMargin(qreal margin)
    { setProperty(BlockRightMargin, margin); }
    inline qreal rightMargin() const
    { return doubleProperty(BlockRightMargin); }

    inline void setTextIndent(qreal aindent)
    { setProperty(TextIndent, aindent); }
    inline qreal textIndent() const
    { return doubleProperty(TextIndent); }

    inline void setIndent(int indent);
    inline int indent() const
    { return intProperty(BlockIndent); }

    inline void setLineHeight(qreal height, int heightType)
    { setProperty(LineHeight, height); setProperty(LineHeightType, heightType); }
    inline qreal lineHeight(qreal scriptLineHeight, qreal scaling) const;
    inline qreal lineHeight() const
    { return doubleProperty(LineHeight); }
    inline int lineHeightType() const
    { return intProperty(LineHeightType); }

    inline void setNonBreakableLines(bool b)
    { setProperty(BlockNonBreakableLines, b); }
    inline bool nonBreakableLines() const
    { return boolProperty(BlockNonBreakableLines); }

    inline void setPageBreakPolicy(PageBreakFlags flags)
    { setProperty(PageBreakPolicy, int(flags)); }
    inline PageBreakFlags pageBreakPolicy() const
    { return PageBreakFlags(intProperty(PageBreakPolicy)); }

    void setTabPositions(const QList<QTextOption::Tab> &tabs);
    QList<QTextOption::Tab> tabPositions() const;

protected:
    explicit QTextBlockFormat(const QTextFormat &fmt);
    friend class QTextFormat;
};

template<> class QTypeInfo<QTextBlockFormat > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextBlockFormat)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTextBlockFormat >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTextBlockFormat) }; static inline const char *name() { return "QTextBlockFormat"; } }; template <> inline void qSwap<QTextBlockFormat>(QTextBlockFormat &value1, QTextBlockFormat &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QTextBlockFormat >(::QTextBlockFormat &value1, ::QTextBlockFormat &value2) { value1.swap(value2); } }

inline void QTextBlockFormat::setAlignment(Qt::Alignment aalignment)
{ setProperty(BlockAlignment, int(aalignment)); }

inline void QTextBlockFormat::setIndent(int aindent)
{ setProperty(BlockIndent, aindent); }

inline qreal QTextBlockFormat::lineHeight(qreal scriptLineHeight, qreal scaling = 1.0) const
{
  switch(intProperty(LineHeightType)) {
    case SingleHeight:
      return(scriptLineHeight);
    case ProportionalHeight:
      return(scriptLineHeight * doubleProperty(LineHeight) / 100.0);
    case FixedHeight:
      return(doubleProperty(LineHeight) * scaling);
    case MinimumHeight:
      return(qMax(scriptLineHeight, doubleProperty(LineHeight) * scaling));
    case LineDistanceHeight:
      return(scriptLineHeight + doubleProperty(LineHeight) * scaling);
  }
  return(0);
}

class __declspec(dllimport) QTextListFormat : public QTextFormat
{
public:
    QTextListFormat();

    bool isValid() const { return isListFormat(); }

    enum Style {
        ListDisc = -1,
        ListCircle = -2,
        ListSquare = -3,
        ListDecimal = -4,
        ListLowerAlpha = -5,
        ListUpperAlpha = -6,
        ListLowerRoman = -7,
        ListUpperRoman = -8,
        ListStyleUndefined = 0
    };

    inline void setStyle(Style style);
    inline Style style() const
    { return static_cast<Style>(intProperty(ListStyle)); }

    inline void setIndent(int indent);
    inline int indent() const
    { return intProperty(ListIndent); }

    inline void setNumberPrefix(const QString &numberPrefix);
    inline QString numberPrefix() const
    { return stringProperty(ListNumberPrefix); }

    inline void setNumberSuffix(const QString &numberSuffix);
    inline QString numberSuffix() const
    { return stringProperty(ListNumberSuffix); }

protected:
    explicit QTextListFormat(const QTextFormat &fmt);
    friend class QTextFormat;
};

template<> class QTypeInfo<QTextListFormat > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextListFormat)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTextListFormat >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTextListFormat) }; static inline const char *name() { return "QTextListFormat"; } }; template <> inline void qSwap<QTextListFormat>(QTextListFormat &value1, QTextListFormat &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QTextListFormat >(::QTextListFormat &value1, ::QTextListFormat &value2) { value1.swap(value2); } }

inline void QTextListFormat::setStyle(Style astyle)
{ setProperty(ListStyle, astyle); }

inline void QTextListFormat::setIndent(int aindent)
{ setProperty(ListIndent, aindent); }

inline void QTextListFormat::setNumberPrefix(const QString &np)
{ setProperty(ListNumberPrefix, np); }

inline void QTextListFormat::setNumberSuffix(const QString &ns)
{ setProperty(ListNumberSuffix, ns); }

class __declspec(dllimport) QTextImageFormat : public QTextCharFormat
{
public:
    QTextImageFormat();

    bool isValid() const { return isImageFormat(); }

    inline void setName(const QString &name);
    inline QString name() const
    { return stringProperty(ImageName); }

    inline void setWidth(qreal width);
    inline qreal width() const
    { return doubleProperty(ImageWidth); }

    inline void setHeight(qreal height);
    inline qreal height() const
    { return doubleProperty(ImageHeight); }

protected:
    explicit QTextImageFormat(const QTextFormat &format);
    friend class QTextFormat;
};

template<> class QTypeInfo<QTextImageFormat > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextImageFormat)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTextImageFormat >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTextImageFormat) }; static inline const char *name() { return "QTextImageFormat"; } }; template <> inline void qSwap<QTextImageFormat>(QTextImageFormat &value1, QTextImageFormat &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QTextImageFormat >(::QTextImageFormat &value1, ::QTextImageFormat &value2) { value1.swap(value2); } }

inline void QTextImageFormat::setName(const QString &aname)
{ setProperty(ImageName, aname); }

inline void QTextImageFormat::setWidth(qreal awidth)
{ setProperty(ImageWidth, awidth); }

inline void QTextImageFormat::setHeight(qreal aheight)
{ setProperty(ImageHeight, aheight); }

class __declspec(dllimport) QTextFrameFormat : public QTextFormat
{
public:
    QTextFrameFormat();

    bool isValid() const { return isFrameFormat(); }

    enum Position {
        InFlow,
        FloatLeft,
        FloatRight


    };

    enum BorderStyle {
        BorderStyle_None,
        BorderStyle_Dotted,
        BorderStyle_Dashed,
        BorderStyle_Solid,
        BorderStyle_Double,
        BorderStyle_DotDash,
        BorderStyle_DotDotDash,
        BorderStyle_Groove,
        BorderStyle_Ridge,
        BorderStyle_Inset,
        BorderStyle_Outset
    };

    inline void setPosition(Position f)
    { setProperty(CssFloat, f); }
    inline Position position() const
    { return static_cast<Position>(intProperty(CssFloat)); }

    inline void setBorder(qreal border);
    inline qreal border() const
    { return doubleProperty(FrameBorder); }

    inline void setBorderBrush(const QBrush &brush)
    { setProperty(FrameBorderBrush, brush); }
    inline QBrush borderBrush() const
    { return brushProperty(FrameBorderBrush); }

    inline void setBorderStyle(BorderStyle style)
    { setProperty(FrameBorderStyle, style); }
    inline BorderStyle borderStyle() const
    { return static_cast<BorderStyle>(intProperty(FrameBorderStyle)); }

    void setMargin(qreal margin);
    inline qreal margin() const
    { return doubleProperty(FrameMargin); }

    inline void setTopMargin(qreal margin);
    qreal topMargin() const;

    inline void setBottomMargin(qreal margin);
    qreal bottomMargin() const;

    inline void setLeftMargin(qreal margin);
    qreal leftMargin() const;

    inline void setRightMargin(qreal margin);
    qreal rightMargin() const;

    inline void setPadding(qreal padding);
    inline qreal padding() const
    { return doubleProperty(FramePadding); }

    inline void setWidth(qreal width);
    inline void setWidth(const QTextLength &length)
    { setProperty(FrameWidth, length); }
    inline QTextLength width() const
    { return lengthProperty(FrameWidth); }

    inline void setHeight(qreal height);
    inline void setHeight(const QTextLength &height);
    inline QTextLength height() const
    { return lengthProperty(FrameHeight); }

    inline void setPageBreakPolicy(PageBreakFlags flags)
    { setProperty(PageBreakPolicy, int(flags)); }
    inline PageBreakFlags pageBreakPolicy() const
    { return PageBreakFlags(intProperty(PageBreakPolicy)); }

protected:
    explicit QTextFrameFormat(const QTextFormat &fmt);
    friend class QTextFormat;
};

template<> class QTypeInfo<QTextFrameFormat > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextFrameFormat)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTextFrameFormat >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTextFrameFormat) }; static inline const char *name() { return "QTextFrameFormat"; } }; template <> inline void qSwap<QTextFrameFormat>(QTextFrameFormat &value1, QTextFrameFormat &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QTextFrameFormat >(::QTextFrameFormat &value1, ::QTextFrameFormat &value2) { value1.swap(value2); } }

inline void QTextFrameFormat::setBorder(qreal aborder)
{ setProperty(FrameBorder, aborder); }

inline void QTextFrameFormat::setPadding(qreal apadding)
{ setProperty(FramePadding, apadding); }

inline void QTextFrameFormat::setWidth(qreal awidth)
{ setProperty(FrameWidth, QTextLength(QTextLength::FixedLength, awidth)); }

inline void QTextFrameFormat::setHeight(qreal aheight)
{ setProperty(FrameHeight, QTextLength(QTextLength::FixedLength, aheight)); }
inline void QTextFrameFormat::setHeight(const QTextLength &aheight)
{ setProperty(FrameHeight, aheight); }

inline void QTextFrameFormat::setTopMargin(qreal amargin)
{ setProperty(FrameTopMargin, amargin); }

inline void QTextFrameFormat::setBottomMargin(qreal amargin)
{ setProperty(FrameBottomMargin, amargin); }

inline void QTextFrameFormat::setLeftMargin(qreal amargin)
{ setProperty(FrameLeftMargin, amargin); }

inline void QTextFrameFormat::setRightMargin(qreal amargin)
{ setProperty(FrameRightMargin, amargin); }

class __declspec(dllimport) QTextTableFormat : public QTextFrameFormat
{
public:
    QTextTableFormat();

    inline bool isValid() const { return isTableFormat(); }

    inline int columns() const
    { int cols = intProperty(TableColumns); if (cols == 0) cols = 1; return cols; }
    inline void setColumns(int columns);

    inline void setColumnWidthConstraints(const QVector<QTextLength> &constraints)
    { setProperty(TableColumnWidthConstraints, constraints); }

    inline QVector<QTextLength> columnWidthConstraints() const
    { return lengthVectorProperty(TableColumnWidthConstraints); }

    inline void clearColumnWidthConstraints()
    { clearProperty(TableColumnWidthConstraints); }

    inline qreal cellSpacing() const
    { return doubleProperty(TableCellSpacing); }
    inline void setCellSpacing(qreal spacing)
    { setProperty(TableCellSpacing, spacing); }

    inline qreal cellPadding() const
    { return doubleProperty(TableCellPadding); }
    inline void setCellPadding(qreal padding);

    inline void setAlignment(Qt::Alignment alignment);
    inline Qt::Alignment alignment() const
    { return QFlag(intProperty(BlockAlignment)); }

    inline void setHeaderRowCount(int count)
    { setProperty(TableHeaderRowCount, count); }
    inline int headerRowCount() const
    { return intProperty(TableHeaderRowCount); }

protected:
    explicit QTextTableFormat(const QTextFormat &fmt);
    friend class QTextFormat;
};

template<> class QTypeInfo<QTextTableFormat > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextTableFormat)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTextTableFormat >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTextTableFormat) }; static inline const char *name() { return "QTextTableFormat"; } }; template <> inline void qSwap<QTextTableFormat>(QTextTableFormat &value1, QTextTableFormat &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QTextTableFormat >(::QTextTableFormat &value1, ::QTextTableFormat &value2) { value1.swap(value2); } }

inline void QTextTableFormat::setColumns(int acolumns)
{
    if (acolumns == 1)
        acolumns = 0;
    setProperty(TableColumns, acolumns);
}

inline void QTextTableFormat::setCellPadding(qreal apadding)
{ setProperty(TableCellPadding, apadding); }

inline void QTextTableFormat::setAlignment(Qt::Alignment aalignment)
{ setProperty(BlockAlignment, int(aalignment)); }

class __declspec(dllimport) QTextTableCellFormat : public QTextCharFormat
{
public:
    QTextTableCellFormat();

    inline bool isValid() const { return isTableCellFormat(); }

    inline void setTopPadding(qreal padding);
    inline qreal topPadding() const;

    inline void setBottomPadding(qreal padding);
    inline qreal bottomPadding() const;

    inline void setLeftPadding(qreal padding);
    inline qreal leftPadding() const;

    inline void setRightPadding(qreal padding);
    inline qreal rightPadding() const;

    inline void setPadding(qreal padding);

protected:
    explicit QTextTableCellFormat(const QTextFormat &fmt);
    friend class QTextFormat;
};

template<> class QTypeInfo<QTextTableCellFormat > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextTableCellFormat)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTextTableCellFormat >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTextTableCellFormat) }; static inline const char *name() { return "QTextTableCellFormat"; } }; template <> inline void qSwap<QTextTableCellFormat>(QTextTableCellFormat &value1, QTextTableCellFormat &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QTextTableCellFormat >(::QTextTableCellFormat &value1, ::QTextTableCellFormat &value2) { value1.swap(value2); } }

inline void QTextTableCellFormat::setTopPadding(qreal padding)
{
    setProperty(TableCellTopPadding, padding);
}

inline qreal QTextTableCellFormat::topPadding() const
{
    return doubleProperty(TableCellTopPadding);
}

inline void QTextTableCellFormat::setBottomPadding(qreal padding)
{
    setProperty(TableCellBottomPadding, padding);
}

inline qreal QTextTableCellFormat::bottomPadding() const
{
    return doubleProperty(TableCellBottomPadding);
}

inline void QTextTableCellFormat::setLeftPadding(qreal padding)
{
    setProperty(TableCellLeftPadding, padding);
}

inline qreal QTextTableCellFormat::leftPadding() const
{
    return doubleProperty(TableCellLeftPadding);
}

inline void QTextTableCellFormat::setRightPadding(qreal padding)
{
    setProperty(TableCellRightPadding, padding);
}

inline qreal QTextTableCellFormat::rightPadding() const
{
    return doubleProperty(TableCellRightPadding);
}

inline void QTextTableCellFormat::setPadding(qreal padding)
{
    setTopPadding(padding);
    setBottomPadding(padding);
    setLeftPadding(padding);
    setRightPadding(padding);
}
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtextcursor.h"





class QTextDocument;
class QTextCursorPrivate;
class QTextDocumentFragment;
class QTextCharFormat;
class QTextBlockFormat;
class QTextListFormat;
class QTextTableFormat;
class QTextFrameFormat;
class QTextImageFormat;
class QTextDocumentPrivate;
class QTextList;
class QTextTable;
class QTextFrame;
class QTextBlock;

class __declspec(dllimport) QTextCursor
{
public:
    QTextCursor();
    explicit QTextCursor(QTextDocument *document);
    QTextCursor(QTextDocumentPrivate *p, int pos);
    explicit QTextCursor(QTextFrame *frame);
    explicit QTextCursor(const QTextBlock &block);
    explicit QTextCursor(QTextCursorPrivate *d);
    QTextCursor(const QTextCursor &cursor);
    QTextCursor &operator=(const QTextCursor &other);
    ~QTextCursor();

    void swap(QTextCursor &other) { qSwap(d, other.d); }

    bool isNull() const;

    enum MoveMode {
        MoveAnchor,
        KeepAnchor
    };

    void setPosition(int pos, MoveMode mode = MoveAnchor);
    int position() const;
    int positionInBlock() const;

    int anchor() const;

    void insertText(const QString &text);
    void insertText(const QString &text, const QTextCharFormat &format);

    enum MoveOperation {
        NoMove,

        Start,
        Up,
        StartOfLine,
        StartOfBlock,
        StartOfWord,
        PreviousBlock,
        PreviousCharacter,
        PreviousWord,
        Left,
        WordLeft,

        End,
        Down,
        EndOfLine,
        EndOfWord,
        EndOfBlock,
        NextBlock,
        NextCharacter,
        NextWord,
        Right,
        WordRight,

        NextCell,
        PreviousCell,
        NextRow,
        PreviousRow
    };

    bool movePosition(MoveOperation op, MoveMode = MoveAnchor, int n = 1);

    bool visualNavigation() const;
    void setVisualNavigation(bool b);

    void setVerticalMovementX(int x);
    int verticalMovementX() const;

    void setKeepPositionOnInsert(bool b);
    bool keepPositionOnInsert() const;

    void deleteChar();
    void deletePreviousChar();

    enum SelectionType {
        WordUnderCursor,
        LineUnderCursor,
        BlockUnderCursor,
        Document
    };
    void select(SelectionType selection);

    bool hasSelection() const;
    bool hasComplexSelection() const;
    void removeSelectedText();
    void clearSelection();
    int selectionStart() const;
    int selectionEnd() const;

    QString selectedText() const;
    QTextDocumentFragment selection() const;
    void selectedTableCells(int *firstRow, int *numRows, int *firstColumn, int *numColumns) const;

    QTextBlock block() const;

    QTextCharFormat charFormat() const;
    void setCharFormat(const QTextCharFormat &format);
    void mergeCharFormat(const QTextCharFormat &modifier);

    QTextBlockFormat blockFormat() const;
    void setBlockFormat(const QTextBlockFormat &format);
    void mergeBlockFormat(const QTextBlockFormat &modifier);

    QTextCharFormat blockCharFormat() const;
    void setBlockCharFormat(const QTextCharFormat &format);
    void mergeBlockCharFormat(const QTextCharFormat &modifier);

    bool atBlockStart() const;
    bool atBlockEnd() const;
    bool atStart() const;
    bool atEnd() const;

    void insertBlock();
    void insertBlock(const QTextBlockFormat &format);
    void insertBlock(const QTextBlockFormat &format, const QTextCharFormat &charFormat);

    QTextList *insertList(const QTextListFormat &format);
    QTextList *insertList(QTextListFormat::Style style);

    QTextList *createList(const QTextListFormat &format);
    QTextList *createList(QTextListFormat::Style style);
    QTextList *currentList() const;

    QTextTable *insertTable(int rows, int cols, const QTextTableFormat &format);
    QTextTable *insertTable(int rows, int cols);
    QTextTable *currentTable() const;

    QTextFrame *insertFrame(const QTextFrameFormat &format);
    QTextFrame *currentFrame() const;

    void insertFragment(const QTextDocumentFragment &fragment);


    void insertHtml(const QString &html);


    void insertImage(const QTextImageFormat &format, QTextFrameFormat::Position alignment);
    void insertImage(const QTextImageFormat &format);
    void insertImage(const QString &name);
    void insertImage(const QImage &image, const QString &name = QString());

    void beginEditBlock();
    void joinPreviousEditBlock();
    void endEditBlock();

    bool operator!=(const QTextCursor &rhs) const;
    bool operator<(const QTextCursor &rhs) const;
    bool operator<=(const QTextCursor &rhs) const;
    bool operator==(const QTextCursor &rhs) const;
    bool operator>=(const QTextCursor &rhs) const;
    bool operator>(const QTextCursor &rhs) const;

    bool isCopyOf(const QTextCursor &other) const;

    int blockNumber() const;
    int columnNumber() const;

    QTextDocument *document() const;

private:
    QSharedDataPointer<QTextCursorPrivate> d;
    friend class QTextCursorPrivate;
    friend class QTextDocumentFragmentPrivate;
    friend class QTextCopyHelper;
    friend class QWidgetTextControlPrivate;
};

template<> class QTypeInfo<QTextCursor > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTextCursor)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTextCursor >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTextCursor) }; static inline const char *name() { return "QTextCursor"; } }; template <> inline void qSwap<QTextCursor>(QTextCursor &value1, QTextCursor &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QTextCursor >(::QTextCursor &value1, ::QTextCursor &value2) { value1.swap(value2); } }
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qlineedit.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qlineedit.h"
class QValidator;
class QMenu;
class QLineEditPrivate;
class QCompleter;
class QStyleOptionFrame;
class QAbstractSpinBox;
class QDateTimeEdit;
class QIcon;
class QToolButton;

class __declspec(dllimport) QLineEdit : public QWidget
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 89 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qlineedit.h"
public:
    enum ActionPosition {
        LeadingPosition,
        TrailingPosition
    };

    explicit QLineEdit(QWidget* parent=0);
    explicit QLineEdit(const QString &, QWidget* parent=0);
    ~QLineEdit();

    QString text() const;

    QString displayText() const;

    QString placeholderText() const;
    void setPlaceholderText(const QString &);

    int maxLength() const;
    void setMaxLength(int);

    void setFrame(bool);
    bool hasFrame() const;

    void setClearButtonEnabled(bool enable);
    bool isClearButtonEnabled() const;

    enum EchoMode { Normal, NoEcho, Password, PasswordEchoOnEdit };
    EchoMode echoMode() const;
    void setEchoMode(EchoMode);

    bool isReadOnly() const;
    void setReadOnly(bool);


    void setValidator(const QValidator *);
    const QValidator * validator() const;



    void setCompleter(QCompleter *completer);
    QCompleter *completer() const;


    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    int cursorPosition() const;
    void setCursorPosition(int);
    int cursorPositionAt(const QPoint &pos);

    void setAlignment(Qt::Alignment flag);
    Qt::Alignment alignment() const;

    void cursorForward(bool mark, int steps = 1);
    void cursorBackward(bool mark, int steps = 1);
    void cursorWordForward(bool mark);
    void cursorWordBackward(bool mark);
    void backspace();
    void del();
    void home(bool mark);
    void end(bool mark);

    bool isModified() const;
    void setModified(bool);

    void setSelection(int, int);
    bool hasSelectedText() const;
    QString selectedText() const;
    int selectionStart() const;

    bool isUndoAvailable() const;
    bool isRedoAvailable() const;

    void setDragEnabled(bool b);
    bool dragEnabled() const;

    void setCursorMoveStyle(Qt::CursorMoveStyle style);
    Qt::CursorMoveStyle cursorMoveStyle() const;

    QString inputMask() const;
    void setInputMask(const QString &inputMask);
    bool hasAcceptableInput() const;

    void setTextMargins(int left, int top, int right, int bottom);
    void setTextMargins(const QMargins &margins);
    void getTextMargins(int *left, int *top, int *right, int *bottom) const;
    QMargins textMargins() const;





    using QWidget::addAction;


    void addAction(QAction *action, ActionPosition position);
    QAction *addAction(const QIcon &icon, ActionPosition position);

public :
    void setText(const QString &);
    void clear();
    void selectAll();
    void undo();
    void redo();

    void cut();
    void copy() const;
    void paste();


public:
    void deselect();
    void insert(const QString &);

    QMenu *createStandardContextMenu();


public:
    void textChanged(const QString &);
    void textEdited(const QString &);
    void cursorPositionChanged(int, int);
    void returnPressed();
    void editingFinished();
    void selectionChanged();

protected:
    void mousePressEvent(QMouseEvent *);
    void mouseMoveEvent(QMouseEvent *);
    void mouseReleaseEvent(QMouseEvent *);
    void mouseDoubleClickEvent(QMouseEvent *);
    void keyPressEvent(QKeyEvent *);
    void focusInEvent(QFocusEvent *);
    void focusOutEvent(QFocusEvent *);
    void paintEvent(QPaintEvent *);

    void dragEnterEvent(QDragEnterEvent *);
    void dragMoveEvent(QDragMoveEvent *e);
    void dragLeaveEvent(QDragLeaveEvent *e);
    void dropEvent(QDropEvent *);

    void changeEvent(QEvent *);

    void contextMenuEvent(QContextMenuEvent *);


    void inputMethodEvent(QInputMethodEvent *);
    void initStyleOption(QStyleOptionFrame *option) const;
public:
    QVariant inputMethodQuery(Qt::InputMethodQuery) const;
    bool event(QEvent *);
protected:
    QRect cursorRect() const;

public:

private:
    friend class QAbstractSpinBox;
    friend class QAccessibleLineEdit;



    QLineEdit(const QLineEdit &) = delete; QLineEdit &operator=(const QLineEdit &) = delete;
    inline QLineEditPrivate* d_func() { return reinterpret_cast<QLineEditPrivate *>(qGetPtrHelper(d_ptr)); } inline const QLineEditPrivate* d_func() const { return reinterpret_cast<const QLineEditPrivate *>(qGetPtrHelper(d_ptr)); } friend class QLineEditPrivate;
#line 264 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qlineedit.h"
};
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QLineEdit"
#line 22 "./mainwidget.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QProcess"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qprocess.h"
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qprocess.h"
typedef struct _PROCESS_INFORMATION *Q_PID;



class QProcessPrivate;
class QProcessEnvironmentPrivate;

class __declspec(dllimport) QProcessEnvironment
{
public:
    QProcessEnvironment();
    QProcessEnvironment(const QProcessEnvironment &other);
    ~QProcessEnvironment();
    QProcessEnvironment &operator=(const QProcessEnvironment &other);

    inline void swap(QProcessEnvironment &other) { qSwap(d, other.d); }

    bool operator==(const QProcessEnvironment &other) const;
    inline bool operator!=(const QProcessEnvironment &other) const
    { return !(*this == other); }

    bool isEmpty() const;
    void clear();

    bool contains(const QString &name) const;
    void insert(const QString &name, const QString &value);
    void remove(const QString &name);
    QString value(const QString &name, const QString &defaultValue = QString()) const;

    QStringList toStringList() const;

    QStringList keys() const;

    void insert(const QProcessEnvironment &e);

    static QProcessEnvironment systemEnvironment();

private:
    friend class QProcessPrivate;
    friend class QProcessEnvironmentPrivate;
    QSharedDataPointer<QProcessEnvironmentPrivate> d;
};

template<> class QTypeInfo<QProcessEnvironment > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QProcessEnvironment)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QProcessEnvironment >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QProcessEnvironment) }; static inline const char *name() { return "QProcessEnvironment"; } }; template <> inline void qSwap<QProcessEnvironment>(QProcessEnvironment &value1, QProcessEnvironment &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QProcessEnvironment >(::QProcessEnvironment &value1, ::QProcessEnvironment &value2) { value1.swap(value2); } }

class __declspec(dllimport) QProcess : public QIODevice
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    enum ProcessError {
        FailedToStart,
        Crashed,
        Timedout,
        ReadError,
        WriteError,
        UnknownError
    };
    enum ProcessState {
        NotRunning,
        Starting,
        Running
    };
    enum ProcessChannel {
        StandardOutput,
        StandardError
    };
    enum ProcessChannelMode {
        SeparateChannels,
        MergedChannels,
        ForwardedChannels,
        ForwardedOutputChannel,
        ForwardedErrorChannel
    };
    enum InputChannelMode {
        ManagedInputChannel,
        ForwardedInputChannel
    };
    enum ExitStatus {
        NormalExit,
        CrashExit
    };

    explicit QProcess(QObject *parent = 0);
    virtual ~QProcess();

    void start(const QString &program, const QStringList &arguments, OpenMode mode = ReadWrite);
    void start(const QString &command, OpenMode mode = ReadWrite);
    void start(OpenMode mode = ReadWrite);
    bool open(OpenMode mode = ReadWrite) override;

    QString program() const;
    void setProgram(const QString &program);

    QStringList arguments() const;
    void setArguments(const QStringList & arguments);

    ProcessChannelMode readChannelMode() const;
    void setReadChannelMode(ProcessChannelMode mode);
    ProcessChannelMode processChannelMode() const;
    void setProcessChannelMode(ProcessChannelMode mode);
    InputChannelMode inputChannelMode() const;
    void setInputChannelMode(InputChannelMode mode);

    ProcessChannel readChannel() const;
    void setReadChannel(ProcessChannel channel);

    void closeReadChannel(ProcessChannel channel);
    void closeWriteChannel();

    void setStandardInputFile(const QString &fileName);
    void setStandardOutputFile(const QString &fileName, OpenMode mode = Truncate);
    void setStandardErrorFile(const QString &fileName, OpenMode mode = Truncate);
    void setStandardOutputProcess(QProcess *destination);


    QString nativeArguments() const;
    void setNativeArguments(const QString &arguments);


    QString workingDirectory() const;
    void setWorkingDirectory(const QString &dir);

    void setEnvironment(const QStringList &environment);
    QStringList environment() const;
    void setProcessEnvironment(const QProcessEnvironment &environment);
    QProcessEnvironment processEnvironment() const;

    QProcess::ProcessError error() const;
    QProcess::ProcessState state() const;


    Q_PID pid() const;
    qint64 processId() const;

    bool waitForStarted(int msecs = 30000);
    bool waitForReadyRead(int msecs = 30000);
    bool waitForBytesWritten(int msecs = 30000);
    bool waitForFinished(int msecs = 30000);

    QByteArray readAllStandardOutput();
    QByteArray readAllStandardError();

    int exitCode() const;
    QProcess::ExitStatus exitStatus() const;


    qint64 bytesAvailable() const;
    qint64 bytesToWrite() const;
    bool isSequential() const;
    bool canReadLine() const;
    void close();
    bool atEnd() const;

    static int execute(const QString &program, const QStringList &arguments);
    static int execute(const QString &command);

    static bool startDetached(const QString &program, const QStringList &arguments,
                              const QString &workingDirectory



                              , qint64 *pid = 0);

    static bool startDetached(const QString &program, const QStringList &arguments);

    static bool startDetached(const QString &command);

    static QStringList systemEnvironment();

    static QString nullDevice();

public :
    void terminate();
    void kill();

public:
    void started(

        QPrivateSignal

    );
    void finished(int exitCode);
    void finished(int exitCode, QProcess::ExitStatus exitStatus);
    void error(QProcess::ProcessError error);
    void stateChanged(QProcess::ProcessState state

        , QPrivateSignal

    );

    void readyReadStandardOutput(

        QPrivateSignal

    );
    void readyReadStandardError(

        QPrivateSignal

    );

protected:
    void setProcessState(ProcessState state);

    virtual void setupChildProcess();


    qint64 readData(char *data, qint64 maxlen);
    qint64 writeData(const char *data, qint64 len);

private:
    inline QProcessPrivate* d_func() { return reinterpret_cast<QProcessPrivate *>(qGetPtrHelper(d_ptr)); } inline const QProcessPrivate* d_func() const { return reinterpret_cast<const QProcessPrivate *>(qGetPtrHelper(d_ptr)); } friend class QProcessPrivate;
    QProcess(const QProcess &) = delete; QProcess &operator=(const QProcess &) = delete;







    friend class QProcessManager;
};
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QProcess"
#line 23 "./mainwidget.h"

#line 1 "./zc_install.h"





#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QDialog"
#line 6 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QLabel"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qlabel.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qlabel.h"
class QLabelPrivate;

class __declspec(dllimport) QLabel : public QFrame
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 68 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qlabel.h"
public:
    explicit QLabel(QWidget *parent=0, Qt::WindowFlags f=0);
    explicit QLabel(const QString &text, QWidget *parent=0, Qt::WindowFlags f=0);
    ~QLabel();

    QString text() const;
    const QPixmap *pixmap() const;

    const QPicture *picture() const;


    QMovie *movie() const;


    Qt::TextFormat textFormat() const;
    void setTextFormat(Qt::TextFormat);

    Qt::Alignment alignment() const;
    void setAlignment(Qt::Alignment);

    void setWordWrap(bool on);
    bool wordWrap() const;

    int indent() const;
    void setIndent(int);

    int margin() const;
    void setMargin(int);

    bool hasScaledContents() const;
    void setScaledContents(bool);
    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    void setBuddy(QWidget *);
    QWidget *buddy() const;

    int heightForWidth(int) const;

    bool openExternalLinks() const;
    void setOpenExternalLinks(bool open);

    void setTextInteractionFlags(Qt::TextInteractionFlags flags);
    Qt::TextInteractionFlags textInteractionFlags() const;

    void setSelection(int, int);
    bool hasSelectedText() const;
    QString selectedText() const;
    int selectionStart() const;

public :
    void setText(const QString &);
    void setPixmap(const QPixmap &);

    void setPicture(const QPicture &);


    void setMovie(QMovie *movie);

    void setNum(int);
    void setNum(double);
    void clear();

public:
    void linkActivated(const QString& link);
    void linkHovered(const QString& link);

protected:
    bool event(QEvent *e);
    void keyPressEvent(QKeyEvent *ev);
    void paintEvent(QPaintEvent *);
    void changeEvent(QEvent *);
    void mousePressEvent(QMouseEvent *ev);
    void mouseMoveEvent(QMouseEvent *ev);
    void mouseReleaseEvent(QMouseEvent *ev);
    void contextMenuEvent(QContextMenuEvent *ev);
    void focusInEvent(QFocusEvent *ev);
    void focusOutEvent(QFocusEvent *ev);
    bool focusNextPrevChild(bool next);


private:
    QLabel(const QLabel &) = delete; QLabel &operator=(const QLabel &) = delete;
    inline QLabelPrivate* d_func() { return reinterpret_cast<QLabelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QLabelPrivate* d_func() const { return reinterpret_cast<const QLabelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QLabelPrivate;






    friend class QTipLabel;
    friend class QMessageBoxPrivate;
    friend class QBalloonTip;
};
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QLabel"
#line 7 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QWidget"
#line 8 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QPainter"
#line 9 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QMouseEvent"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qevent.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qevent.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qset.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qset.h"
template <class T>
class QSet
{
    typedef QHash<T, QHashDummyValue> Hash;

public:
    inline QSet() {}
#line 68 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qset.h"
    inline QSet(const QSet<T> &other) : q_hash(other.q_hash) {}

    inline QSet<T> &operator=(const QSet<T> &other)
        { q_hash = other.q_hash; return *this; }

    inline QSet(QSet &&other) : q_hash(std::move(other.q_hash)) {}
    inline QSet<T> &operator=(QSet<T> &&other)
        { qSwap(q_hash, other.q_hash); return *this; }

    inline void swap(QSet<T> &other) { q_hash.swap(other.q_hash); }

    inline bool operator==(const QSet<T> &other) const
        { return q_hash == other.q_hash; }
    inline bool operator!=(const QSet<T> &other) const
        { return q_hash != other.q_hash; }

    inline int size() const { return q_hash.size(); }

    inline bool isEmpty() const { return q_hash.isEmpty(); }

    inline int capacity() const { return q_hash.capacity(); }
    inline void reserve(int size);
    inline void squeeze() { q_hash.squeeze(); }

    inline void detach() { q_hash.detach(); }
    inline bool isDetached() const { return q_hash.isDetached(); }

    inline void setSharable(bool sharable) { q_hash.setSharable(sharable); }


    inline void clear() { q_hash.clear(); }

    inline bool remove(const T &value) { return q_hash.remove(value) != 0; }

    inline bool contains(const T &value) const { return q_hash.contains(value); }

    bool contains(const QSet<T> &set) const;

    class const_iterator;

    class iterator
    {
        typedef QHash<T, QHashDummyValue> Hash;
        typename Hash::iterator i;
        friend class const_iterator;

    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef const T *pointer;
        typedef const T &reference;

        inline iterator() {}
        inline iterator(typename Hash::iterator o) : i(o) {}
        inline iterator(const iterator &o) : i(o.i) {}
        inline iterator &operator=(const iterator &o) { i = o.i; return *this; }
        inline const T &operator*() const { return i.key(); }
        inline const T *operator->() const { return &i.key(); }
        inline bool operator==(const iterator &o) const { return i == o.i; }
        inline bool operator!=(const iterator &o) const { return i != o.i; }
        inline bool operator==(const const_iterator &o) const
            { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const
            { return i != o.i; }
        inline iterator &operator++() { ++i; return *this; }
        inline iterator operator++(int) { iterator r = *this; ++i; return r; }
        inline iterator &operator--() { --i; return *this; }
        inline iterator operator--(int) { iterator r = *this; --i; return r; }
        inline iterator operator+(int j) const { return i + j; }
        inline iterator operator-(int j) const { return i - j; }
        inline iterator &operator+=(int j) { i += j; return *this; }
        inline iterator &operator-=(int j) { i -= j; return *this; }
    };

    class const_iterator
    {
        typedef QHash<T, QHashDummyValue> Hash;
        typename Hash::const_iterator i;
        friend class iterator;

    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef const T *pointer;
        typedef const T &reference;

        inline const_iterator() {}
        inline const_iterator(typename Hash::const_iterator o) : i(o) {}
        inline const_iterator(const const_iterator &o) : i(o.i) {}
        inline const_iterator(const iterator &o)
            : i(o.i) {}
        inline const_iterator &operator=(const const_iterator &o) { i = o.i; return *this; }
        inline const T &operator*() const { return i.key(); }
        inline const T *operator->() const { return &i.key(); }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }
        inline const_iterator &operator++() { ++i; return *this; }
        inline const_iterator operator++(int) { const_iterator r = *this; ++i; return r; }
        inline const_iterator &operator--() { --i; return *this; }
        inline const_iterator operator--(int) { const_iterator r = *this; --i; return r; }
        inline const_iterator operator+(int j) const { return i + j; }
        inline const_iterator operator-(int j) const { return i - j; }
        inline const_iterator &operator+=(int j) { i += j; return *this; }
        inline const_iterator &operator-=(int j) { i -= j; return *this; }
    };


    inline iterator begin() { return q_hash.begin(); }
    inline const_iterator begin() const { return q_hash.begin(); }
    inline const_iterator cbegin() const { return q_hash.begin(); }
    inline const_iterator constBegin() const { return q_hash.constBegin(); }
    inline iterator end() { return q_hash.end(); }
    inline const_iterator end() const { return q_hash.end(); }
    inline const_iterator cend() const { return q_hash.end(); }
    inline const_iterator constEnd() const { return q_hash.constEnd(); }
    iterator erase(iterator i)
    {
        ((!(isValidIterator(i))) ? qt_assert_x("QSet::erase", "The specified const_iterator argument 'i' is invalid","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qset.h",187) : qt_noop());
        return q_hash.erase(reinterpret_cast<typename Hash::iterator &>(i));
    }


    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    inline int count() const { return q_hash.count(); }
    inline iterator insert(const T &value)
        { return static_cast<typename Hash::iterator>(q_hash.insert(value, QHashDummyValue())); }
    iterator find(const T &value) { return q_hash.find(value); }
    const_iterator find(const T &value) const { return q_hash.find(value); }
    inline const_iterator constFind(const T &value) const { return find(value); }
    QSet<T> &unite(const QSet<T> &other);
    QSet<T> &intersect(const QSet<T> &other);
    QSet<T> &subtract(const QSet<T> &other);


    typedef T key_type;
    typedef T value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;
    typedef qptrdiff difference_type;
    typedef int size_type;

    inline bool empty() const { return isEmpty(); }

    inline QSet<T> &operator<<(const T &value) { insert(value); return *this; }
    inline QSet<T> &operator|=(const QSet<T> &other) { unite(other); return *this; }
    inline QSet<T> &operator|=(const T &value) { insert(value); return *this; }
    inline QSet<T> &operator&=(const QSet<T> &other) { intersect(other); return *this; }
    inline QSet<T> &operator&=(const T &value)
        { QSet<T> result; if (contains(value)) result.insert(value); return (*this = result); }
    inline QSet<T> &operator+=(const QSet<T> &other) { unite(other); return *this; }
    inline QSet<T> &operator+=(const T &value) { insert(value); return *this; }
    inline QSet<T> &operator-=(const QSet<T> &other) { subtract(other); return *this; }
    inline QSet<T> &operator-=(const T &value) { remove(value); return *this; }
    inline QSet<T> operator|(const QSet<T> &other) const
        { QSet<T> result = *this; result |= other; return result; }
    inline QSet<T> operator&(const QSet<T> &other) const
        { QSet<T> result = *this; result &= other; return result; }
    inline QSet<T> operator+(const QSet<T> &other) const
        { QSet<T> result = *this; result += other; return result; }
    inline QSet<T> operator-(const QSet<T> &other) const
        { QSet<T> result = *this; result -= other; return result; }

    QList<T> toList() const;
    inline QList<T> values() const { return toList(); }

    static QSet<T> fromList(const QList<T> &list);

private:
    Hash q_hash;
    bool isValidIterator(const iterator &i) const
    {
        return q_hash.isValidIterator(reinterpret_cast<const typename Hash::iterator&>(i));
    }
};

template <class T>
inline void QSet<T>::reserve(int asize) { q_hash.reserve(asize); }

template <class T>
inline QSet<T> &QSet<T>::unite(const QSet<T> &other)
{
    QSet<T> copy(other);
    typename QSet<T>::const_iterator i = copy.constEnd();
    while (i != copy.constBegin()) {
        --i;
        insert(*i);
    }
    return *this;
}

template <class T>
inline QSet<T> &QSet<T>::intersect(const QSet<T> &other)
{
    QSet<T> copy1;
    QSet<T> copy2;
    if (size() <= other.size()) {
        copy1 = *this;
        copy2 = other;
    } else {
        copy1 = other;
        copy2 = *this;
        *this = copy1;
    }
    typename QSet<T>::const_iterator i = copy1.constEnd();
    while (i != copy1.constBegin()) {
        --i;
        if (!copy2.contains(*i))
            remove(*i);
    }
    return *this;
}

template <class T>
inline QSet<T> &QSet<T>::subtract(const QSet<T> &other)
{
    QSet<T> copy1(*this);
    QSet<T> copy2(other);
    typename QSet<T>::const_iterator i = copy1.constEnd();
    while (i != copy1.constBegin()) {
        --i;
        if (copy2.contains(*i))
            remove(*i);
    }
    return *this;
}

template <class T>
inline bool QSet<T>::contains(const QSet<T> &other) const
{
    typename QSet<T>::const_iterator i = other.constBegin();
    while (i != other.constEnd()) {
        if (!contains(*i))
            return false;
        ++i;
    }
    return true;
}

template <typename T>
inline QList<T> QSet<T>::toList() const
{
    QList<T> result;
    result.reserve(size());
    typename QSet<T>::const_iterator i = constBegin();
    while (i != constEnd()) {
        result.append(*i);
        ++i;
    }
    return result;
}

template <typename T>
inline QSet<T> QList<T>::toSet() const
{
    QSet<T> result;
    result.reserve(size());
    for (int i = 0; i < size(); ++i)
        result.insert(at(i));
    return result;
}

template <typename T>
QSet<T> QSet<T>::fromList(const QList<T> &list)
{
    return list.toSet();
}

template <typename T>
QList<T> QList<T>::fromSet(const QSet<T> &set)
{
    return set.toList();
}

template <class T> class QSetIterator { typedef typename QSet<T>::const_iterator const_iterator; QSet<T> c; const_iterator i; public: inline QSetIterator(const QSet<T> &container) : c(container), i(c.constBegin()) {} inline QSetIterator &operator=(const QSet<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };

template <typename T>
class QMutableSetIterator
{
    typedef typename QSet<T>::iterator iterator;
    QSet<T> *c;
    iterator i, n;
    inline bool item_exists() const { return c->constEnd() != n; }

public:
    inline QMutableSetIterator(QSet<T> &container)
        : c(&container)
    { c->setSharable(false); i = c->begin(); n = c->end(); }
    inline ~QMutableSetIterator()
    { c->setSharable(true); }
    inline QMutableSetIterator &operator=(QSet<T> &container)
    { c->setSharable(true); c = &container; c->setSharable(false);
      i = c->begin(); n = c->end(); return *this; }
    inline void toFront() { i = c->begin(); n = c->end(); }
    inline void toBack() { i = c->end(); n = i; }
    inline bool hasNext() const { return c->constEnd() != i; }
    inline const T &next() { n = i++; return *n; }
    inline const T &peekNext() const { return *i; }
    inline bool hasPrevious() const { return c->constBegin() != i; }
    inline const T &previous() { n = --i; return *n; }
    inline const T &peekPrevious() const { iterator p = i; return *--p; }
    inline void remove()
    { if (c->constEnd() != n) { i = c->erase(n); n = c->end(); } }
    inline const T &value() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qset.h",375) : qt_noop()); return *n; }
    inline bool findNext(const T &t)
    { while (c->constEnd() != (n = i)) if (*i++ == t) return true; return false; }
    inline bool findPrevious(const T &t)
    { while (c->constBegin() != i) if (*(n = --i) == t) return true;
      n = c->end(); return false; }
};
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qevent.h"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qvector2d.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qvector2d.h"
class QVector3D;
class QVector4D;
class QVariant;



class __declspec(dllimport) QVector2D
{
public:
                     QVector2D();
                     QVector2D(float xpos, float ypos);
                     explicit QVector2D(const QPoint& point);
                     explicit QVector2D(const QPointF& point);

    explicit QVector2D(const QVector3D& vector);


    explicit QVector2D(const QVector4D& vector);


    bool isNull() const;

                     float x() const;
                     float y() const;

    void setX(float x);
    void setY(float y);

    float &operator[](int i);
    float operator[](int i) const;

    float length() const;
    float lengthSquared() const;

    QVector2D normalized() const;
    void normalize();

    float distanceToPoint(const QVector2D &point) const;
    float distanceToLine(const QVector2D& point, const QVector2D& direction) const;

    QVector2D &operator+=(const QVector2D &vector);
    QVector2D &operator-=(const QVector2D &vector);
    QVector2D &operator*=(float factor);
    QVector2D &operator*=(const QVector2D &vector);
    QVector2D &operator/=(float divisor);

    static float dotProduct(const QVector2D& v1, const QVector2D& v2);

                     friend inline bool operator==(const QVector2D &v1, const QVector2D &v2);
                     friend inline bool operator!=(const QVector2D &v1, const QVector2D &v2);
                     friend inline const QVector2D operator+(const QVector2D &v1, const QVector2D &v2);
                     friend inline const QVector2D operator-(const QVector2D &v1, const QVector2D &v2);
                     friend inline const QVector2D operator*(float factor, const QVector2D &vector);
                     friend inline const QVector2D operator*(const QVector2D &vector, float factor);
                     friend inline const QVector2D operator*(const QVector2D &v1, const QVector2D &v2);
                     friend inline const QVector2D operator-(const QVector2D &vector);
                     friend inline const QVector2D operator/(const QVector2D &vector, float divisor);

                     friend inline bool qFuzzyCompare(const QVector2D& v1, const QVector2D& v2);


    QVector3D toVector3D() const;


    QVector4D toVector4D() const;


                     QPoint toPoint() const;
                     QPointF toPointF() const;

    operator QVariant() const;

private:
    float xp, yp;

    friend class QVector3D;
    friend class QVector4D;
};

template<> class QTypeInfo<QVector2D > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QVector2D)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QVector2D >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QVector2D) }; static inline const char *name() { return "QVector2D"; } };

                 inline QVector2D::QVector2D() : xp(0.0f), yp(0.0f) {}

                 inline QVector2D::QVector2D(float xpos, float ypos) : xp(xpos), yp(ypos) {}

                 inline QVector2D::QVector2D(const QPoint& point) : xp(point.x()), yp(point.y()) {}

                 inline QVector2D::QVector2D(const QPointF& point) : xp(point.x()), yp(point.y()) {}

inline bool QVector2D::isNull() const
{
    return qIsNull(xp) && qIsNull(yp);
}

                 inline float QVector2D::x() const { return xp; }
                 inline float QVector2D::y() const { return yp; }

inline void QVector2D::setX(float aX) { xp = aX; }
inline void QVector2D::setY(float aY) { yp = aY; }

inline float &QVector2D::operator[](int i)
{
    ((!(uint(i) < 2u)) ? qt_assert("uint(i) < 2u","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qvector2d.h",153) : qt_noop());
    return *(&xp + i);
}

inline float QVector2D::operator[](int i) const
{
    ((!(uint(i) < 2u)) ? qt_assert("uint(i) < 2u","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qvector2d.h",159) : qt_noop());
    return *(&xp + i);
}

inline QVector2D &QVector2D::operator+=(const QVector2D &vector)
{
    xp += vector.xp;
    yp += vector.yp;
    return *this;
}

inline QVector2D &QVector2D::operator-=(const QVector2D &vector)
{
    xp -= vector.xp;
    yp -= vector.yp;
    return *this;
}

inline QVector2D &QVector2D::operator*=(float factor)
{
    xp *= factor;
    yp *= factor;
    return *this;
}

inline QVector2D &QVector2D::operator*=(const QVector2D &vector)
{
    xp *= vector.xp;
    yp *= vector.yp;
    return *this;
}

inline QVector2D &QVector2D::operator/=(float divisor)
{
    xp /= divisor;
    yp /= divisor;
    return *this;
}

                 inline bool operator==(const QVector2D &v1, const QVector2D &v2)
{
    return v1.xp == v2.xp && v1.yp == v2.yp;
}

                 inline bool operator!=(const QVector2D &v1, const QVector2D &v2)
{
    return v1.xp != v2.xp || v1.yp != v2.yp;
}

                 inline const QVector2D operator+(const QVector2D &v1, const QVector2D &v2)
{
    return QVector2D(v1.xp + v2.xp, v1.yp + v2.yp);
}

                 inline const QVector2D operator-(const QVector2D &v1, const QVector2D &v2)
{
    return QVector2D(v1.xp - v2.xp, v1.yp - v2.yp);
}

                 inline const QVector2D operator*(float factor, const QVector2D &vector)
{
    return QVector2D(vector.xp * factor, vector.yp * factor);
}

                 inline const QVector2D operator*(const QVector2D &vector, float factor)
{
    return QVector2D(vector.xp * factor, vector.yp * factor);
}

                 inline const QVector2D operator*(const QVector2D &v1, const QVector2D &v2)
{
    return QVector2D(v1.xp * v2.xp, v1.yp * v2.yp);
}

                 inline const QVector2D operator-(const QVector2D &vector)
{
    return QVector2D(-vector.xp, -vector.yp);
}

                 inline const QVector2D operator/(const QVector2D &vector, float divisor)
{
    return QVector2D(vector.xp / divisor, vector.yp / divisor);
}

                 inline bool qFuzzyCompare(const QVector2D& v1, const QVector2D& v2)
{
    return qFuzzyCompare(v1.xp, v2.xp) && qFuzzyCompare(v1.yp, v2.yp);
}

                 inline QPoint QVector2D::toPoint() const
{
    return QPoint(qRound(xp), qRound(yp));
}

                 inline QPointF QVector2D::toPointF() const
{
    return QPointF(qreal(xp), qreal(yp));
}


__declspec(dllimport) QDebug operator<<(QDebug dbg, const QVector2D &vector);



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QVector2D &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QVector2D &);
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qevent.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtouchdevice.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qtouchdevice.h"
class QTouchDevicePrivate;

class __declspec(dllimport) QTouchDevice
{
public:
    enum DeviceType {
        TouchScreen,
        TouchPad
    };

    enum CapabilityFlag {
        Position = 0x0001,
        Area = 0x0002,
        Pressure = 0x0004,
        Velocity = 0x0008,
        RawPositions = 0x0010,
        NormalizedPosition = 0x0020
    };
    typedef QFlags<CapabilityFlag> Capabilities;

    QTouchDevice();
    ~QTouchDevice();

    static QList<const QTouchDevice *> devices();

    QString name() const;
    DeviceType type() const;
    Capabilities capabilities() const;
    int maximumTouchPoints() const;

    void setName(const QString &name);
    void setType(DeviceType devType);
    void setCapabilities(Capabilities caps);
    void setMaximumTouchPoints(int max);

private:
    QTouchDevicePrivate *d;
};

 inline QFlags<QTouchDevice::Capabilities::enum_type> operator|(QTouchDevice::Capabilities::enum_type f1, QTouchDevice::Capabilities::enum_type f2) { return QFlags<QTouchDevice::Capabilities::enum_type>(f1) | f2; } inline QFlags<QTouchDevice::Capabilities::enum_type> operator|(QTouchDevice::Capabilities::enum_type f1, QFlags<QTouchDevice::Capabilities::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTouchDevice::Capabilities::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
#line 59 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qevent.h"





class QAction;

class QGesture;

class QScreen;

class __declspec(dllimport) QInputEvent : public QEvent
{
public:
    explicit QInputEvent(Type type, Qt::KeyboardModifiers modifiers = Qt::NoModifier);
    ~QInputEvent();
    inline Qt::KeyboardModifiers modifiers() const { return modState; }
    inline void setModifiers(Qt::KeyboardModifiers amodifiers) { modState = amodifiers; }
    inline ulong timestamp() const { return ts; }
    inline void setTimestamp(ulong atimestamp) { ts = atimestamp; }
protected:
    Qt::KeyboardModifiers modState;
    ulong ts;
};

class __declspec(dllimport) QEnterEvent : public QEvent
{
public:
    QEnterEvent(const QPointF &localPos, const QPointF &windowPos, const QPointF &screenPos);
    ~QEnterEvent();


    inline QPoint pos() const { return l.toPoint(); }
    inline QPoint globalPos() const { return s.toPoint(); }
    inline int x() const { return qRound(l.x()); }
    inline int y() const { return qRound(l.y()); }
    inline int globalX() const { return qRound(s.x()); }
    inline int globalY() const { return qRound(s.y()); }

    const QPointF &localPos() const { return l; }
    const QPointF &windowPos() const { return w; }
    const QPointF &screenPos() const { return s; }

protected:
    QPointF l, w, s;
};

class __declspec(dllimport) QMouseEvent : public QInputEvent
{
public:
    QMouseEvent(Type type, const QPointF &localPos, Qt::MouseButton button,
                Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers);
    QMouseEvent(Type type, const QPointF &localPos, const QPointF &screenPos,
                Qt::MouseButton button, Qt::MouseButtons buttons,
                Qt::KeyboardModifiers modifiers);
    QMouseEvent(Type type, const QPointF &localPos, const QPointF &windowPos, const QPointF &screenPos,
                Qt::MouseButton button, Qt::MouseButtons buttons,
                Qt::KeyboardModifiers modifiers);
    ~QMouseEvent();


    inline QPoint pos() const { return l.toPoint(); }
    inline QPoint globalPos() const { return s.toPoint(); }
    inline int x() const { return qRound(l.x()); }
    inline int y() const { return qRound(l.y()); }
    inline int globalX() const { return qRound(s.x()); }
    inline int globalY() const { return qRound(s.y()); }

    const QPointF &localPos() const { return l; }
    const QPointF &windowPos() const { return w; }
    const QPointF &screenPos() const { return s; }

    inline Qt::MouseButton button() const { return b; }
    inline Qt::MouseButtons buttons() const { return mouseState; }





    Qt::MouseEventSource source() const;
    Qt::MouseEventFlags flags() const;

protected:
    QPointF l, w, s;
    Qt::MouseButton b;
    Qt::MouseButtons mouseState;
    int caps;
    QVector2D velocity;

    friend class QGuiApplicationPrivate;
};

class __declspec(dllimport) QHoverEvent : public QInputEvent
{
public:
    QHoverEvent(Type type, const QPointF &pos, const QPointF &oldPos, Qt::KeyboardModifiers modifiers = Qt::NoModifier);
    ~QHoverEvent();


    inline QPoint pos() const { return p.toPoint(); }
    inline QPoint oldPos() const { return op.toPoint(); }


    inline const QPointF &posF() const { return p; }
    inline const QPointF &oldPosF() const { return op; }

protected:
    QPointF p, op;
};


class __declspec(dllimport) QWheelEvent : public QInputEvent
{
public:
    QWheelEvent(const QPointF &pos, int delta,
                Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers,
                Qt::Orientation orient = Qt::Vertical);
    QWheelEvent(const QPointF &pos, const QPointF& globalPos, int delta,
                Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers,
                Qt::Orientation orient = Qt::Vertical);
    QWheelEvent(const QPointF &pos, const QPointF& globalPos,
                QPoint pixelDelta, QPoint angleDelta, int qt4Delta, Qt::Orientation qt4Orientation,
                Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers);
    QWheelEvent(const QPointF &pos, const QPointF& globalPos,
                QPoint pixelDelta, QPoint angleDelta, int qt4Delta, Qt::Orientation qt4Orientation,
                Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Qt::ScrollPhase phase);

    ~QWheelEvent();


    inline QPoint pixelDelta() const { return pixelD; }
    inline QPoint angleDelta() const { return angleD; }

    inline int delta() const { return qt4D; }
    inline Qt::Orientation orientation() const { return qt4O; }


    inline QPoint pos() const { return p.toPoint(); }
    inline QPoint globalPos() const { return g.toPoint(); }
    inline int x() const { return p.x(); }
    inline int y() const { return p.y(); }
    inline int globalX() const { return g.x(); }
    inline int globalY() const { return g.y(); }

    inline const QPointF &posF() const { return p; }
    inline const QPointF &globalPosF() const { return g; }

    inline Qt::MouseButtons buttons() const { return mouseState; }

    inline Qt::ScrollPhase phase() const { return Qt::ScrollPhase(ph); }

protected:
    QPointF p;
    QPointF g;
    QPoint pixelD;
    QPoint angleD;
    int qt4D;
    Qt::Orientation qt4O;
    Qt::MouseButtons mouseState;
    uint ph : 2;
    int reserved : 30;
};



class __declspec(dllimport) QTabletEvent : public QInputEvent
{
public:
    enum TabletDevice { NoDevice, Puck, Stylus, Airbrush, FourDMouse,
                        XFreeEraser , RotationStylus };
    enum PointerType { UnknownPointer, Pen, Cursor, Eraser };
    QTabletEvent(Type t, const QPointF &pos, const QPointF &globalPos,
                 int device, int pointerType, qreal pressure, int xTilt, int yTilt,
                 qreal tangentialPressure, qreal rotation, int z,
                 Qt::KeyboardModifiers keyState, qint64 uniqueID);
    ~QTabletEvent();

    inline QPoint pos() const { return mPos.toPoint(); }
    inline QPoint globalPos() const { return mGPos.toPoint(); }




    inline const QPointF &posF() const { return mPos; }
    inline const QPointF &globalPosF() const { return mGPos; }

    inline int x() const { return qRound(mPos.x()); }
    inline int y() const { return qRound(mPos.y()); }
    inline int globalX() const { return qRound(mGPos.x()); }
    inline int globalY() const { return qRound(mGPos.y()); }
    inline qreal hiResGlobalX() const { return mGPos.x(); }
    inline qreal hiResGlobalY() const { return mGPos.y(); }
    inline TabletDevice device() const { return TabletDevice(mDev); }
    inline PointerType pointerType() const { return PointerType(mPointerType); }
    inline qint64 uniqueId() const { return mUnique; }
    inline qreal pressure() const { return mPress; }
    inline int z() const { return mZ; }
    inline qreal tangentialPressure() const { return mTangential; }
    inline qreal rotation() const { return mRot; }
    inline int xTilt() const { return mXT; }
    inline int yTilt() const { return mYT; }

protected:
    QPointF mPos, mGPos;
    int mDev, mPointerType, mXT, mYT, mZ;
    qreal mPress, mTangential, mRot;
    qint64 mUnique;




    void *mExtra;
};



class __declspec(dllimport) QNativeGestureEvent : public QInputEvent
{
public:
    QNativeGestureEvent(Qt::NativeGestureType type, const QPointF &localPos, const QPointF &windowPos,
                        const QPointF &screenPos, qreal value, ulong sequenceId, quint64 intArgument);
    Qt::NativeGestureType gestureType() const { return mGestureType; }
    qreal value() const { return mRealValue; }


    inline const QPoint pos() const { return mLocalPos.toPoint(); }
    inline const QPoint globalPos() const { return mScreenPos.toPoint(); }

    const QPointF &localPos() const { return mLocalPos; }
    const QPointF &windowPos() const { return mWindowPos; }
    const QPointF &screenPos() const { return mScreenPos; }

protected:
    Qt::NativeGestureType mGestureType;
    QPointF mLocalPos;
    QPointF mWindowPos;
    QPointF mScreenPos;
    qreal mRealValue;
    ulong mSequenceId;
    quint64 mIntValue;
};


class __declspec(dllimport) QKeyEvent : public QInputEvent
{
public:
    QKeyEvent(Type type, int key, Qt::KeyboardModifiers modifiers, const QString& text = QString(),
              bool autorep = false, ushort count = 1);
    QKeyEvent(Type type, int key, Qt::KeyboardModifiers modifiers,
              quint32 nativeScanCode, quint32 nativeVirtualKey, quint32 nativeModifiers,
              const QString &text = QString(), bool autorep = false, ushort count = 1);
    ~QKeyEvent();

    int key() const { return k; }

    bool matches(QKeySequence::StandardKey key) const;

    Qt::KeyboardModifiers modifiers() const;
    inline QString text() const { return txt; }
    inline bool isAutoRepeat() const { return autor; }
    inline int count() const { return int(c); }

    inline quint32 nativeScanCode() const { return nScanCode; }
    inline quint32 nativeVirtualKey() const { return nVirtualKey; }
    inline quint32 nativeModifiers() const { return nModifiers; }
#line 341 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qevent.h"
protected:
    QString txt;
    int k;
    quint32 nScanCode;
    quint32 nVirtualKey;
    quint32 nModifiers;
    ushort c;
    ushort autor:1;

};


class __declspec(dllimport) QFocusEvent : public QEvent
{
public:
    explicit QFocusEvent(Type type, Qt::FocusReason reason=Qt::OtherFocusReason);
    ~QFocusEvent();

    inline bool gotFocus() const { return type() == FocusIn; }
    inline bool lostFocus() const { return type() == FocusOut; }

    Qt::FocusReason reason() const;

private:
    Qt::FocusReason m_reason;
};


class __declspec(dllimport) QPaintEvent : public QEvent
{
public:
    explicit QPaintEvent(const QRegion& paintRegion);
    explicit QPaintEvent(const QRect &paintRect);
    ~QPaintEvent();

    inline const QRect &rect() const { return m_rect; }
    inline const QRegion &region() const { return m_region; }

protected:
    friend class QApplication;
    friend class QCoreApplication;
    QRect m_rect;
    QRegion m_region;
    bool m_erased;
};

class __declspec(dllimport) QMoveEvent : public QEvent
{
public:
    QMoveEvent(const QPoint &pos, const QPoint &oldPos);
    ~QMoveEvent();

    inline const QPoint &pos() const { return p; }
    inline const QPoint &oldPos() const { return oldp;}
protected:
    QPoint p, oldp;
    friend class QApplication;
    friend class QCoreApplication;
};

class __declspec(dllimport) QExposeEvent : public QEvent
{
public:
    explicit QExposeEvent(const QRegion &rgn);
    ~QExposeEvent();

    inline const QRegion &region() const { return rgn; }

protected:
    QRegion rgn;
};

class __declspec(dllimport) QResizeEvent : public QEvent
{
public:
    QResizeEvent(const QSize &size, const QSize &oldSize);
    ~QResizeEvent();

    inline const QSize &size() const { return s; }
    inline const QSize &oldSize()const { return olds;}
protected:
    QSize s, olds;
    friend class QApplication;
    friend class QCoreApplication;
};


class __declspec(dllimport) QCloseEvent : public QEvent
{
public:
    QCloseEvent();
    ~QCloseEvent();
};


class __declspec(dllimport) QIconDragEvent : public QEvent
{
public:
    QIconDragEvent();
    ~QIconDragEvent();
};


class __declspec(dllimport) QShowEvent : public QEvent
{
public:
    QShowEvent();
    ~QShowEvent();
};


class __declspec(dllimport) QHideEvent : public QEvent
{
public:
    QHideEvent();
    ~QHideEvent();
};


class __declspec(dllimport) QContextMenuEvent : public QInputEvent
{
public:
    enum Reason { Mouse, Keyboard, Other };

    QContextMenuEvent(Reason reason, const QPoint &pos, const QPoint &globalPos,
                      Qt::KeyboardModifiers modifiers);
    QContextMenuEvent(Reason reason, const QPoint &pos, const QPoint &globalPos);
    QContextMenuEvent(Reason reason, const QPoint &pos);
    ~QContextMenuEvent();

    inline int x() const { return p.x(); }
    inline int y() const { return p.y(); }
    inline int globalX() const { return gp.x(); }
    inline int globalY() const { return gp.y(); }

    inline const QPoint& pos() const { return p; }
    inline const QPoint& globalPos() const { return gp; }

    inline Reason reason() const { return Reason(reas); }

protected:
    QPoint p;
    QPoint gp;
    uint reas : 8;
};



class __declspec(dllimport) QInputMethodEvent : public QEvent
{
public:
    enum AttributeType {
       TextFormat,
       Cursor,
       Language,
       Ruby,
       Selection
    };
    class Attribute {
    public:
        Attribute(AttributeType t, int s, int l, QVariant val) : type(t), start(s), length(l), value(val) {}
        AttributeType type;

        int start;
        int length;
        QVariant value;
    };
    QInputMethodEvent();
    QInputMethodEvent(const QString &preeditText, const QList<Attribute> &attributes);
    void setCommitString(const QString &commitString, int replaceFrom = 0, int replaceLength = 0);
    inline const QList<Attribute> &attributes() const { return attrs; }
    inline const QString &preeditString() const { return preedit; }

    inline const QString &commitString() const { return commit; }
    inline int replacementStart() const { return replace_from; }
    inline int replacementLength() const { return replace_length; }

    QInputMethodEvent(const QInputMethodEvent &other);

private:
    QString preedit;
    QList<Attribute> attrs;
    QString commit;
    int replace_from;
    int replace_length;
};
template<> class QTypeInfo<QInputMethodEvent::Attribute > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QInputMethodEvent::Attribute)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QInputMethodEvent::Attribute >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QInputMethodEvent::Attribute) }; static inline const char *name() { return "QInputMethodEvent::Attribute"; } };

class __declspec(dllimport) QInputMethodQueryEvent : public QEvent
{
public:
    explicit QInputMethodQueryEvent(Qt::InputMethodQueries queries);
    ~QInputMethodQueryEvent();

    Qt::InputMethodQueries queries() const { return m_queries; }

    void setValue(Qt::InputMethodQuery query, const QVariant &value);
    QVariant value(Qt::InputMethodQuery query) const;
private:
    Qt::InputMethodQueries m_queries;
    struct QueryPair {
        Qt::InputMethodQuery query;
        QVariant value;
    };
    QVector<QueryPair> m_values;
};





class QMimeData;

class __declspec(dllimport) QDropEvent : public QEvent
{
public:
    QDropEvent(const QPointF& pos, Qt::DropActions actions, const QMimeData *data,
               Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Type type = Drop);
    ~QDropEvent();

    inline QPoint pos() const { return p.toPoint(); }
    inline const QPointF &posF() const { return p; }
    inline Qt::MouseButtons mouseButtons() const { return mouseState; }
    inline Qt::KeyboardModifiers keyboardModifiers() const { return modState; }

    inline Qt::DropActions possibleActions() const { return act; }
    inline Qt::DropAction proposedAction() const { return default_action; }
    inline void acceptProposedAction() { drop_action = default_action; accept(); }

    inline Qt::DropAction dropAction() const { return drop_action; }
    void setDropAction(Qt::DropAction action);

    QObject* source() const;
    inline const QMimeData *mimeData() const { return mdata; }

protected:
    friend class QApplication;
    QPointF p;
    Qt::MouseButtons mouseState;
    Qt::KeyboardModifiers modState;
    Qt::DropActions act;
    Qt::DropAction drop_action;
    Qt::DropAction default_action;
    const QMimeData *mdata;
};


class __declspec(dllimport) QDragMoveEvent : public QDropEvent
{
public:
    QDragMoveEvent(const QPoint &pos, Qt::DropActions actions, const QMimeData *data,
                   Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers, Type type = DragMove);
    ~QDragMoveEvent();

    inline QRect answerRect() const { return rect; }

    inline void accept() { QDropEvent::accept(); }
    inline void ignore() { QDropEvent::ignore(); }

    inline void accept(const QRect & r) { accept(); rect = r; }
    inline void ignore(const QRect & r) { ignore(); rect = r; }

protected:
    friend class QApplication;
    QRect rect;
};


class __declspec(dllimport) QDragEnterEvent : public QDragMoveEvent
{
public:
    QDragEnterEvent(const QPoint &pos, Qt::DropActions actions, const QMimeData *data,
                    Qt::MouseButtons buttons, Qt::KeyboardModifiers modifiers);
    ~QDragEnterEvent();
};


class __declspec(dllimport) QDragLeaveEvent : public QEvent
{
public:
    QDragLeaveEvent();
    ~QDragLeaveEvent();
};



class __declspec(dllimport) QHelpEvent : public QEvent
{
public:
    QHelpEvent(Type type, const QPoint &pos, const QPoint &globalPos);
    ~QHelpEvent();

    inline int x() const { return p.x(); }
    inline int y() const { return p.y(); }
    inline int globalX() const { return gp.x(); }
    inline int globalY() const { return gp.y(); }

    inline const QPoint& pos() const { return p; }
    inline const QPoint& globalPos() const { return gp; }

private:
    QPoint p;
    QPoint gp;
};


class __declspec(dllimport) QStatusTipEvent : public QEvent
{
public:
    explicit QStatusTipEvent(const QString &tip);
    ~QStatusTipEvent();

    inline QString tip() const { return s; }
private:
    QString s;
};



class __declspec(dllimport) QWhatsThisClickedEvent : public QEvent
{
public:
    explicit QWhatsThisClickedEvent(const QString &href);
    ~QWhatsThisClickedEvent();

    inline QString href() const { return s; }
private:
    QString s;
};



class __declspec(dllimport) QActionEvent : public QEvent
{
    QAction *act, *bef;
public:
    QActionEvent(int type, QAction *action, QAction *before = 0);
    ~QActionEvent();

    inline QAction *action() const { return act; }
    inline QAction *before() const { return bef; }
};


class __declspec(dllimport) QFileOpenEvent : public QEvent
{
public:
    explicit QFileOpenEvent(const QString &file);
    explicit QFileOpenEvent(const QUrl &url);
    ~QFileOpenEvent();

    inline QString file() const { return f; }
    QUrl url() const { return m_url; }
    bool openFile(QFile &file, QIODevice::OpenMode flags) const;
private:
    QString f;
    QUrl m_url;
};


class __declspec(dllimport) QToolBarChangeEvent : public QEvent
{
public:
    explicit QToolBarChangeEvent(bool t);
    ~QToolBarChangeEvent();

    inline bool toggle() const { return tog; }
private:
    uint tog : 1;
};



class __declspec(dllimport) QShortcutEvent : public QEvent
{
public:
    QShortcutEvent(const QKeySequence &key, int id, bool ambiguous = false);
    ~QShortcutEvent();

    inline const QKeySequence &key() const { return sequence; }
    inline int shortcutId() const { return sid; }
    inline bool isAmbiguous() const { return ambig; }
protected:
    QKeySequence sequence;
    bool ambig;
    int sid;
};


class __declspec(dllimport) QWindowStateChangeEvent: public QEvent
{
public:
    explicit QWindowStateChangeEvent(Qt::WindowStates aOldState, bool isOverride = false);
    ~QWindowStateChangeEvent();

    inline Qt::WindowStates oldState() const { return ostate; }
    bool isOverride() const;

private:
    Qt::WindowStates ostate;
    bool m_override;
};


__declspec(dllimport) QDebug operator<<(QDebug, const QEvent *);



inline bool operator==(QKeyEvent *e, QKeySequence::StandardKey key){return (e ? e->matches(key) : false);}
inline bool operator==(QKeySequence::StandardKey key, QKeyEvent *e){return (e ? e->matches(key) : false);}


class QTouchEventTouchPointPrivate;
class __declspec(dllimport) QTouchEvent : public QInputEvent
{
public:
    class __declspec(dllimport) TouchPoint
    {
    public:
        enum InfoFlag {
            Pen = 0x0001
        };
        typedef QFlags<InfoFlag> InfoFlags;

        explicit TouchPoint(int id = -1);
        TouchPoint(const TouchPoint &other);

        TouchPoint(TouchPoint &&other) : d(other.d) { other.d = 0; }
        TouchPoint &operator=(TouchPoint &&other)
        { qSwap(d, other.d); return *this; }

        ~TouchPoint();

        TouchPoint &operator=(const TouchPoint &other)
        { if ( d != other.d ) { TouchPoint copy(other); swap(copy); } return *this; }

        void swap(TouchPoint &other) { qSwap(d, other.d); }

        int id() const;

        Qt::TouchPointState state() const;

        QPointF pos() const;
        QPointF startPos() const;
        QPointF lastPos() const;

        QPointF scenePos() const;
        QPointF startScenePos() const;
        QPointF lastScenePos() const;

        QPointF screenPos() const;
        QPointF startScreenPos() const;
        QPointF lastScreenPos() const;

        QPointF normalizedPos() const;
        QPointF startNormalizedPos() const;
        QPointF lastNormalizedPos() const;

        QRectF rect() const;
        QRectF sceneRect() const;
        QRectF screenRect() const;

        qreal pressure() const;
        QVector2D velocity() const;
        InfoFlags flags() const;
        QVector<QPointF> rawScreenPositions() const;


        void setId(int id);
        void setState(Qt::TouchPointStates state);
        void setPos(const QPointF &pos);
        void setScenePos(const QPointF &scenePos);
        void setScreenPos(const QPointF &screenPos);
        void setNormalizedPos(const QPointF &normalizedPos);
        void setStartPos(const QPointF &startPos);
        void setStartScenePos(const QPointF &startScenePos);
        void setStartScreenPos(const QPointF &startScreenPos);
        void setStartNormalizedPos(const QPointF &startNormalizedPos);
        void setLastPos(const QPointF &lastPos);
        void setLastScenePos(const QPointF &lastScenePos);
        void setLastScreenPos(const QPointF &lastScreenPos);
        void setLastNormalizedPos(const QPointF &lastNormalizedPos);
        void setRect(const QRectF &rect);
        void setSceneRect(const QRectF &sceneRect);
        void setScreenRect(const QRectF &screenRect);
        void setPressure(qreal pressure);
        void setVelocity(const QVector2D &v);
        void setFlags(InfoFlags flags);
        void setRawScreenPositions(const QVector<QPointF> &positions);

    private:
        QTouchEventTouchPointPrivate *d;
        friend class QGuiApplication;
        friend class QGuiApplicationPrivate;
        friend class QApplication;
        friend class QApplicationPrivate;
    };
#line 846 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qevent.h"
    explicit QTouchEvent(QEvent::Type eventType,
                         QTouchDevice *device = 0,
                         Qt::KeyboardModifiers modifiers = Qt::NoModifier,
                         Qt::TouchPointStates touchPointStates = 0,
                         const QList<QTouchEvent::TouchPoint> &touchPoints = QList<QTouchEvent::TouchPoint>());
    ~QTouchEvent();

    inline QWindow *window() const { return _window; }
    inline QObject *target() const { return _target; }



    inline Qt::TouchPointStates touchPointStates() const { return _touchPointStates; }
    inline const QList<QTouchEvent::TouchPoint> &touchPoints() const { return _touchPoints; }
    inline QTouchDevice *device() const { return _device; }


    inline void setWindow(QWindow *awindow) { _window = awindow; }
    inline void setTarget(QObject *atarget) { _target = atarget; }
    inline void setTouchPointStates(Qt::TouchPointStates aTouchPointStates) { _touchPointStates = aTouchPointStates; }
    inline void setTouchPoints(const QList<QTouchEvent::TouchPoint> &atouchPoints) { _touchPoints = atouchPoints; }
    inline void setDevice(QTouchDevice *adevice) { _device = adevice; }

protected:
    QWindow *_window;
    QObject *_target;
    QTouchDevice *_device;
    Qt::TouchPointStates _touchPointStates;
    QList<QTouchEvent::TouchPoint> _touchPoints;

    friend class QGuiApplication;
    friend class QGuiApplicationPrivate;
    friend class QApplication;
    friend class QApplicationPrivate;
};
template<> class QTypeInfo<QTouchEvent::TouchPoint > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTouchEvent::TouchPoint)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTouchEvent::TouchPoint >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTouchEvent::TouchPoint) }; static inline const char *name() { return "QTouchEvent::TouchPoint"; } };
 inline QFlags<QTouchEvent::TouchPoint::InfoFlags::enum_type> operator|(QTouchEvent::TouchPoint::InfoFlags::enum_type f1, QTouchEvent::TouchPoint::InfoFlags::enum_type f2) { return QFlags<QTouchEvent::TouchPoint::InfoFlags::enum_type>(f1) | f2; } inline QFlags<QTouchEvent::TouchPoint::InfoFlags::enum_type> operator|(QTouchEvent::TouchPoint::InfoFlags::enum_type f1, QFlags<QTouchEvent::TouchPoint::InfoFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTouchEvent::TouchPoint::InfoFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class __declspec(dllimport) QScrollPrepareEvent : public QEvent
{
public:
    explicit QScrollPrepareEvent(const QPointF &startPos);
    ~QScrollPrepareEvent();

    QPointF startPos() const;

    QSizeF viewportSize() const;
    QRectF contentPosRange() const;
    QPointF contentPos() const;

    void setViewportSize(const QSizeF &size);
    void setContentPosRange(const QRectF &rect);
    void setContentPos(const QPointF &pos);

private:
    QObject* m_target;
    QPointF m_startPos;
    QSizeF m_viewportSize;
    QRectF m_contentPosRange;
    QPointF m_contentPos;
};


class __declspec(dllimport) QScrollEvent : public QEvent
{
public:
    enum ScrollState
    {
        ScrollStarted,
        ScrollUpdated,
        ScrollFinished
    };

    QScrollEvent(const QPointF &contentPos, const QPointF &overshoot, ScrollState scrollState);
    ~QScrollEvent();

    QPointF contentPos() const;
    QPointF overshootDistance() const;
    ScrollState scrollState() const;

private:
    QPointF m_contentPos;
    QPointF m_overshoot;
    QScrollEvent::ScrollState m_state;
};

class __declspec(dllimport) QScreenOrientationChangeEvent : public QEvent
{
public:
    QScreenOrientationChangeEvent(QScreen *screen, Qt::ScreenOrientation orientation);
    ~QScreenOrientationChangeEvent();

    QScreen *screen() const;
    Qt::ScreenOrientation orientation() const;

private:
    QScreen *m_screen;
    Qt::ScreenOrientation m_orientation;
};

class __declspec(dllimport) QApplicationStateChangeEvent : public QEvent
{
public:
    explicit QApplicationStateChangeEvent(Qt::ApplicationState state);
    Qt::ApplicationState applicationState() const;

private:
    Qt::ApplicationState m_applicationState;
};
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QMouseEvent"
#line 10 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QMessageBox"
#line 11 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\qmath.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\qmath.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\math.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\qmath.h"
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\qmath.h"
extern __declspec(dllimport) const qreal qt_sine_table[256];

inline int qCeil(qreal v)
{





        return int(ceil(v));
}

inline int qFloor(qreal v)
{





        return int(floor(v));
}

inline qreal qFabs(qreal v)
{





        return fabs(v);
}

inline qreal qSin(qreal v)
{





        return sin(v);
}

inline qreal qCos(qreal v)
{





        return cos(v);
}

inline qreal qTan(qreal v)
{





        return tan(v);
}

inline qreal qAcos(qreal v)
{





       return acos(v);
}

inline qreal qAsin(qreal v)
{





        return asin(v);
}

inline qreal qAtan(qreal v)
{





        return atan(v);
}

inline qreal qAtan2(qreal y, qreal x)
{





        return atan2(y, x);
}

inline qreal qSqrt(qreal v)
{





        return sqrt(v);
}

inline qreal qLn(qreal v)
{





        return log(v);
}

inline qreal qExp(qreal v)
{


    return exp(v);
}

inline qreal qPow(qreal x, qreal y)
{





        return pow(x, y);
}
#line 249 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\qmath.h"
inline qreal qFastSin(qreal x)
{
    int si = int(x * (0.5 * 256 / (3.14159265358979323846)));
    qreal d = x - si * (2.0 * (3.14159265358979323846) / 256);
    int ci = si + 256 / 4;
    si &= 256 - 1;
    ci &= 256 - 1;
    return qt_sine_table[si] + (qt_sine_table[ci] - 0.5 * qt_sine_table[si] * d) * d;
}

inline qreal qFastCos(qreal x)
{
    int ci = int(x * (0.5 * 256 / (3.14159265358979323846)));
    qreal d = x - ci * (2.0 * (3.14159265358979323846) / 256);
    int si = ci + 256 / 4;
    si &= 256 - 1;
    ci &= 256 - 1;
    return qt_sine_table[si] - (qt_sine_table[ci] + 0.5 * qt_sine_table[si] * d) * d;
}

                 inline float qDegreesToRadians(float degrees)
{
    return degrees * float((3.14159265358979323846)/180);
}

                 inline double qDegreesToRadians(double degrees)
{
    return degrees * ((3.14159265358979323846) / 180);
}

                 inline float qRadiansToDegrees(float radians)
{
    return radians * float(180/(3.14159265358979323846));
}

                 inline double qRadiansToDegrees(double radians)
{
    return radians * (180 / (3.14159265358979323846));
}
#line 12 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QPoint"
#line 13 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QDialog"
#line 14 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QPainterPath"
#line 15 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QFont"
#line 16 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QSysInfo"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsysinfo.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QSysInfo"
#line 17 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QHBoxLayout"
#line 18 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QVBoxLayout"
#line 19 "./zc_install.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QTimer"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtimer.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtimer.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbasictimer.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qbasictimer.h"
class QObject;

class __declspec(dllimport) QBasicTimer
{
    int id;
public:
    inline QBasicTimer() : id(0) {}
    inline ~QBasicTimer() { if (id) stop(); }

    inline bool isActive() const { return id != 0; }
    inline int timerId() const { return id; }

    void start(int msec, QObject *obj);
    void start(int msec, Qt::TimerType timerType, QObject *obj);
    void stop();
};
template<> class QTypeInfo<QBasicTimer > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QBasicTimer)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QBasicTimer >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QBasicTimer) }; static inline const char *name() { return "QBasicTimer"; } };
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtimer.h"






class __declspec(dllimport) QTimer : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};





public:
    explicit QTimer(QObject *parent = 0);
    ~QTimer();

    inline bool isActive() const { return id >= 0; }
    int timerId() const { return id; }

    void setInterval(int msec);
    int interval() const { return inter; }

    int remainingTime() const;

    void setTimerType(Qt::TimerType atype) { this->type = atype; }
    Qt::TimerType timerType() const { return Qt::TimerType(type); }

    inline void setSingleShot(bool singleShot);
    inline bool isSingleShot() const { return single; }

    static void singleShot(int msec, const QObject *receiver, const char *member);
    static void singleShot(int msec, Qt::TimerType timerType, const QObject *receiver, const char *member);

public :
    void start(int msec);

    void start();
    void stop();

public:
    void timeout(

      QPrivateSignal

    );

protected:
    void timerEvent(QTimerEvent *);

private:
    QTimer(const QTimer &) = delete; QTimer &operator=(const QTimer &) = delete;

    inline int startTimer(int){ return -1;}
    inline void killTimer(int){}

    int id, inter, del;
    uint single : 1;
    uint nulltimer : 1;
    uint type : 2;

};

inline void QTimer::setSingleShot(bool asingleShot) { single = asingleShot; }
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore\\QTimer"
#line 20 "./zc_install.h"

#line 1 "./push_button.h"
#line 14 "./push_button.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QPushButton"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qpushbutton.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qpushbutton.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qabstractbutton.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qabstractbutton.h"
class QButtonGroup;
class QAbstractButtonPrivate;

class __declspec(dllimport) QAbstractButton : public QWidget
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 73 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtWidgets/qabstractbutton.h"
public:
    explicit QAbstractButton(QWidget* parent=0);
    ~QAbstractButton();

    void setText(const QString &text);
    QString text() const;

    void setIcon(const QIcon &icon);
    QIcon icon() const;

    QSize iconSize() const;


    void setShortcut(const QKeySequence &key);
    QKeySequence shortcut() const;


    void setCheckable(bool);
    bool isCheckable() const;

    bool isChecked() const;

    void setDown(bool);
    bool isDown() const;

    void setAutoRepeat(bool);
    bool autoRepeat() const;

    void setAutoRepeatDelay(int);
    int autoRepeatDelay() const;

    void setAutoRepeatInterval(int);
    int autoRepeatInterval() const;

    void setAutoExclusive(bool);
    bool autoExclusive() const;


    QButtonGroup *group() const;


public :
    void setIconSize(const QSize &size);
    void animateClick(int msec = 100);
    void click();
    void toggle();
    void setChecked(bool);

public:
    void pressed();
    void released();
    void clicked(bool checked = false);
    void toggled(bool checked);

protected:
    virtual void paintEvent(QPaintEvent *e) = 0;
    virtual bool hitButton(const QPoint &pos) const;
    virtual void checkStateSet();
    virtual void nextCheckState();

    bool event(QEvent *e);
    void keyPressEvent(QKeyEvent *e);
    void keyReleaseEvent(QKeyEvent *e);
    void mousePressEvent(QMouseEvent *e);
    void mouseReleaseEvent(QMouseEvent *e);
    void mouseMoveEvent(QMouseEvent *e);
    void focusInEvent(QFocusEvent *e);
    void focusOutEvent(QFocusEvent *e);
    void changeEvent(QEvent *e);
    void timerEvent(QTimerEvent *e);


protected:
    QAbstractButton(QAbstractButtonPrivate &dd, QWidget* parent = 0);

private:
    inline QAbstractButtonPrivate* d_func() { return reinterpret_cast<QAbstractButtonPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractButtonPrivate* d_func() const { return reinterpret_cast<const QAbstractButtonPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractButtonPrivate;
    QAbstractButton(const QAbstractButton &) = delete; QAbstractButton &operator=(const QAbstractButton &) = delete;
    friend class QButtonGroup;
};
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets/qpushbutton.h"





class QPushButtonPrivate;
class QMenu;
class QStyleOptionButton;

class __declspec(dllimport) QPushButton : public QAbstractButton
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};





public:
    explicit QPushButton(QWidget *parent=0);
    explicit QPushButton(const QString &text, QWidget *parent=0);
    QPushButton(const QIcon& icon, const QString &text, QWidget *parent=0);
    ~QPushButton();

    QSize sizeHint() const;
    QSize minimumSizeHint() const;

    bool autoDefault() const;
    void setAutoDefault(bool);
    bool isDefault() const;
    void setDefault(bool);


    void setMenu(QMenu* menu);
    QMenu* menu() const;


    void setFlat(bool);
    bool isFlat() const;

public :

    void showMenu();


protected:
    bool event(QEvent *e);



    void paintEvent(QPaintEvent *);
    void keyPressEvent(QKeyEvent *);
    void focusInEvent(QFocusEvent *);
    void focusOutEvent(QFocusEvent *);
    void initStyleOption(QStyleOptionButton *option) const;
    QPushButton(QPushButtonPrivate &dd, QWidget* parent = 0);

public:

private:
    QPushButton(const QPushButton &) = delete; QPushButton &operator=(const QPushButton &) = delete;
    inline QPushButtonPrivate* d_func() { return reinterpret_cast<QPushButtonPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPushButtonPrivate* d_func() const { return reinterpret_cast<const QPushButtonPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPushButtonPrivate;



};
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QPushButton"
#line 14 "./push_button.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QPainter"
#line 15 "./push_button.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QMouseEvent"
#line 16 "./push_button.h"


class CheckButton;

class PushButton : public QPushButton
{
 public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

public:

 explicit PushButton(QWidget *parent = 0);
 ~PushButton();
 void setPicName(QString pic_name);

protected:

 void enterEvent(QEvent *);
 void leaveEvent(QEvent *);
 void mousePressEvent(QMouseEvent *event);
 void mouseReleaseEvent(QMouseEvent *event);
 void paintEvent(QPaintEvent *);

private:


 enum ButtonStatus{NORMAL, ENTER, PRESS, NOSTATUS};
 ButtonStatus status;
 QString pic_name;

 int btn_width;
 int btn_height;
 bool mouse_press;
};

class CheckButton : public QPushButton
{
 public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public :

 void clicked();
public:
 CheckButton(QWidget *parent = 0);
 ~CheckButton();

 void setPicName(QString pic_name);

protected:
 void paintEvent(QPaintEvent *event);
 void mouseReleaseEvent(QMouseEvent *ev);
private:
 QString pic_name;
};
#line 21 "./zc_install.h"




class ZC_install : public QWidget
{
 public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

public:
 explicit ZC_install(QWidget *parent = 0);
 ~ZC_install();

 void setSkinName(const QString skinName) { m_skinName = skinName; }
 PushButton *m_closeButton;
 PushButton *m_miniButton;
 QLabel *m_versionLabel;
 void setdrawArc(bool b);
 void setPercent(double percent);
protected:
 void paintEvent(QPaintEvent *event);
 QPointF calcEndPoint(int alen);
 bool m_openDrawArc;
 int m_startAngle;
protected :
 void doUpdate();

private:
 QString m_skinName;
 QTimer *m_updateTimer;
 int m_percent;
};
#line 24 "./mainwidget.h"

#line 1 "./myclicklabel.h"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtWidgets\\QLabel"
#line 4 "./myclicklabel.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/QtGuiDepends"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCoreDepends"
#line 3 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractanimation.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractanimation.h"
class QAnimationGroup;
class QSequentialAnimationGroup;
class QAnimationDriver;

class QAbstractAnimationPrivate;
class __declspec(dllimport) QAbstractAnimation : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 69 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractanimation.h"
public:
    enum Direction {
        Forward,
        Backward
    };

    enum State {
        Stopped,
        Paused,
        Running
    };

    enum DeletionPolicy {
        KeepWhenStopped = 0,
        DeleteWhenStopped
    };

    QAbstractAnimation(QObject *parent = 0);
    virtual ~QAbstractAnimation();

    State state() const;

    QAnimationGroup *group() const;

    Direction direction() const;
    void setDirection(Direction direction);

    int currentTime() const;
    int currentLoopTime() const;

    int loopCount() const;
    void setLoopCount(int loopCount);
    int currentLoop() const;

    virtual int duration() const = 0;
    int totalDuration() const;

public:
    void finished();
    void stateChanged(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);
    void currentLoopChanged(int currentLoop);
    void directionChanged(QAbstractAnimation::Direction);

public :
    void start(QAbstractAnimation::DeletionPolicy policy = KeepWhenStopped);
    void pause();
    void resume();
    void setPaused(bool);
    void stop();
    void setCurrentTime(int msecs);

protected:
    QAbstractAnimation(QAbstractAnimationPrivate &dd, QObject *parent = 0);
    bool event(QEvent *event);

    virtual void updateCurrentTime(int currentTime) = 0;
    virtual void updateState(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);
    virtual void updateDirection(QAbstractAnimation::Direction direction);

private:
    QAbstractAnimation(const QAbstractAnimation &) = delete; QAbstractAnimation &operator=(const QAbstractAnimation &) = delete;
    inline QAbstractAnimationPrivate* d_func() { return reinterpret_cast<QAbstractAnimationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractAnimationPrivate* d_func() const { return reinterpret_cast<const QAbstractAnimationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractAnimationPrivate;
};

class QAnimationDriverPrivate;
class __declspec(dllimport) QAnimationDriver : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QAnimationDriverPrivate* d_func() { return reinterpret_cast<QAnimationDriverPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAnimationDriverPrivate* d_func() const { return reinterpret_cast<const QAnimationDriverPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAnimationDriverPrivate;

public:
    QAnimationDriver(QObject *parent = 0);
    ~QAnimationDriver();

    virtual void advance();

    void install();
    void uninstall();

    bool isRunning() const;

    virtual qint64 elapsed() const;

    void setStartTime(qint64 startTime);
    qint64 startTime() const;

public:
    void started();
    void stopped();

protected:
    void advanceAnimation(qint64 timeStep = -1);
    virtual void start();
    virtual void stop();

    QAnimationDriver(QAnimationDriverPrivate &dd, QObject *parent = 0);

private:
    friend class QUnifiedTimer;

};
#line 4 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qanimationgroup.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qanimationgroup.h"
class QAnimationGroupPrivate;
class __declspec(dllimport) QAnimationGroup : public QAbstractAnimation
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

public:
    QAnimationGroup(QObject *parent = 0);
    ~QAnimationGroup();

    QAbstractAnimation *animationAt(int index) const;
    int animationCount() const;
    int indexOfAnimation(QAbstractAnimation *animation) const;
    void addAnimation(QAbstractAnimation *animation);
    void insertAnimation(int index, QAbstractAnimation *animation);
    void removeAnimation(QAbstractAnimation *animation);
    QAbstractAnimation *takeAnimation(int index);
    void clear();

protected:
    QAnimationGroup(QAnimationGroupPrivate &dd, QObject *parent);
    bool event(QEvent *event);

private:
    QAnimationGroup(const QAnimationGroup &) = delete; QAnimationGroup &operator=(const QAnimationGroup &) = delete;
    inline QAnimationGroupPrivate* d_func() { return reinterpret_cast<QAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAnimationGroupPrivate* d_func() const { return reinterpret_cast<const QAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAnimationGroupPrivate;
};
#line 5 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qparallelanimationgroup.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qparallelanimationgroup.h"
class QParallelAnimationGroupPrivate;
class __declspec(dllimport) QParallelAnimationGroup : public QAnimationGroup
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

public:
    QParallelAnimationGroup(QObject *parent = 0);
    ~QParallelAnimationGroup();

    int duration() const;

protected:
    QParallelAnimationGroup(QParallelAnimationGroupPrivate &dd, QObject *parent);
    bool event(QEvent *event);

    void updateCurrentTime(int currentTime);
    void updateState(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);
    void updateDirection(QAbstractAnimation::Direction direction);

private:
    QParallelAnimationGroup(const QParallelAnimationGroup &) = delete; QParallelAnimationGroup &operator=(const QParallelAnimationGroup &) = delete;
    inline QParallelAnimationGroupPrivate* d_func() { return reinterpret_cast<QParallelAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QParallelAnimationGroupPrivate* d_func() const { return reinterpret_cast<const QParallelAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QParallelAnimationGroupPrivate;

};
#line 6 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qpauseanimation.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qpauseanimation.h"
class QPauseAnimationPrivate;

class __declspec(dllimport) QPauseAnimation : public QAbstractAnimation
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

public:
    QPauseAnimation(QObject *parent = 0);
    QPauseAnimation(int msecs, QObject *parent = 0);
    ~QPauseAnimation();

    int duration() const;
    void setDuration(int msecs);

protected:
    bool event(QEvent *e);
    void updateCurrentTime(int);

private:
    QPauseAnimation(const QPauseAnimation &) = delete; QPauseAnimation &operator=(const QPauseAnimation &) = delete;
    inline QPauseAnimationPrivate* d_func() { return reinterpret_cast<QPauseAnimationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPauseAnimationPrivate* d_func() const { return reinterpret_cast<const QPauseAnimationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPauseAnimationPrivate;
};
#line 7 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qpropertyanimation.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qpropertyanimation.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariantanimation.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariantanimation.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qeasingcurve.h"
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qeasingcurve.h"
class QEasingCurvePrivate;
class QPointF;
class __declspec(dllimport) QEasingCurve
{
    public: static const QMetaObject staticMetaObject; private:

public:
    enum Type {
        Linear,
        InQuad, OutQuad, InOutQuad, OutInQuad,
        InCubic, OutCubic, InOutCubic, OutInCubic,
        InQuart, OutQuart, InOutQuart, OutInQuart,
        InQuint, OutQuint, InOutQuint, OutInQuint,
        InSine, OutSine, InOutSine, OutInSine,
        InExpo, OutExpo, InOutExpo, OutInExpo,
        InCirc, OutCirc, InOutCirc, OutInCirc,
        InElastic, OutElastic, InOutElastic, OutInElastic,
        InBack, OutBack, InOutBack, OutInBack,
        InBounce, OutBounce, InOutBounce, OutInBounce,
        InCurve, OutCurve, SineCurve, CosineCurve,
        BezierSpline, TCBSpline, Custom, NCurveTypes
    };

    QEasingCurve(Type type = Linear);
    QEasingCurve(const QEasingCurve &other);
    ~QEasingCurve();

    QEasingCurve &operator=(const QEasingCurve &other)
    { if ( this != &other ) { QEasingCurve copy(other); swap(copy); } return *this; }

    QEasingCurve(QEasingCurve &&other) : d_ptr(other.d_ptr) { other.d_ptr = 0; }
    QEasingCurve &operator=(QEasingCurve &&other)
    { qSwap(d_ptr, other.d_ptr); return *this; }


    inline void swap(QEasingCurve &other) { qSwap(d_ptr, other.d_ptr); }

    bool operator==(const QEasingCurve &other) const;
    inline bool operator!=(const QEasingCurve &other) const
    { return !(this->operator==(other)); }

    qreal amplitude() const;
    void setAmplitude(qreal amplitude);

    qreal period() const;
    void setPeriod(qreal period);

    qreal overshoot() const;
    void setOvershoot(qreal overshoot);

    void addCubicBezierSegment(const QPointF & c1, const QPointF & c2, const QPointF & endPoint);
    void addTCBSegment(const QPointF &nextPoint, qreal t, qreal c, qreal b);
    QVector<QPointF> toCubicSpline() const;




    Type type() const;
    void setType(Type type);
    typedef qreal (*EasingFunction)(qreal progress);
    void setCustomType(EasingFunction func);
    EasingFunction customType() const;

    qreal valueForProgress(qreal progress) const;
private:
    QEasingCurvePrivate *d_ptr;

    friend __declspec(dllimport) QDebug operator<<(QDebug debug, const QEasingCurve &item);


    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QEasingCurve&);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QEasingCurve &);

};
template<> class QTypeInfo<QEasingCurve > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QEasingCurve)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QEasingCurve >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QEasingCurve) }; static inline const char *name() { return "QEasingCurve"; } };


__declspec(dllimport) QDebug operator<<(QDebug debug, const QEasingCurve &item);



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QEasingCurve&);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QEasingCurve &);
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariantanimation.h"
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qvariantanimation.h"
class QVariantAnimationPrivate;
class __declspec(dllimport) QVariantAnimation : public QAbstractAnimation
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};






public:
    typedef QPair<qreal, QVariant> KeyValue;
    typedef QVector<KeyValue> KeyValues;

    QVariantAnimation(QObject *parent = 0);
    ~QVariantAnimation();

    QVariant startValue() const;
    void setStartValue(const QVariant &value);

    QVariant endValue() const;
    void setEndValue(const QVariant &value);

    QVariant keyValueAt(qreal step) const;
    void setKeyValueAt(qreal step, const QVariant &value);

    KeyValues keyValues() const;
    void setKeyValues(const KeyValues &values);

    QVariant currentValue() const;

    int duration() const;
    void setDuration(int msecs);

    QEasingCurve easingCurve() const;
    void setEasingCurve(const QEasingCurve &easing);

    typedef QVariant (*Interpolator)(const void *from, const void *to, qreal progress);

public:
    void valueChanged(const QVariant &value);

protected:
    QVariantAnimation(QVariantAnimationPrivate &dd, QObject *parent = 0);
    bool event(QEvent *event);

    void updateCurrentTime(int);
    void updateState(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);

    virtual void updateCurrentValue(const QVariant &value);
    virtual QVariant interpolated(const QVariant &from, const QVariant &to, qreal progress) const;

private:
    template <typename T> friend void qRegisterAnimationInterpolator(QVariant (*func)(const T &, const T &, qreal));
    static void registerInterpolator(Interpolator func, int interpolationType);

    QVariantAnimation(const QVariantAnimation &) = delete; QVariantAnimation &operator=(const QVariantAnimation &) = delete;
    inline QVariantAnimationPrivate* d_func() { return reinterpret_cast<QVariantAnimationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QVariantAnimationPrivate* d_func() const { return reinterpret_cast<const QVariantAnimationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QVariantAnimationPrivate;
};

template <typename T>
void qRegisterAnimationInterpolator(QVariant (*func)(const T &from, const T &to, qreal progress)) {
    QVariantAnimation::registerInterpolator(reinterpret_cast<QVariantAnimation::Interpolator>(func), qMetaTypeId<T>());
}
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qpropertyanimation.h"







class QPropertyAnimationPrivate;
class __declspec(dllimport) QPropertyAnimation : public QVariantAnimation
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};



public:
    QPropertyAnimation(QObject *parent = 0);
    QPropertyAnimation(QObject *target, const QByteArray &propertyName, QObject *parent = 0);
    ~QPropertyAnimation();

    QObject *targetObject() const;
    void setTargetObject(QObject *target);

    QByteArray propertyName() const;
    void setPropertyName(const QByteArray &propertyName);

protected:
    bool event(QEvent *event);
    void updateCurrentValue(const QVariant &value);
    void updateState(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);

private:
    QPropertyAnimation(const QPropertyAnimation &) = delete; QPropertyAnimation &operator=(const QPropertyAnimation &) = delete;
    inline QPropertyAnimationPrivate* d_func() { return reinterpret_cast<QPropertyAnimationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QPropertyAnimationPrivate* d_func() const { return reinterpret_cast<const QPropertyAnimationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QPropertyAnimationPrivate;
};
#line 8 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsequentialanimationgroup.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsequentialanimationgroup.h"
class QPauseAnimation;
class QSequentialAnimationGroupPrivate;

class __declspec(dllimport) QSequentialAnimationGroup : public QAnimationGroup
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};


public:
    QSequentialAnimationGroup(QObject *parent = 0);
    ~QSequentialAnimationGroup();

    QPauseAnimation *addPause(int msecs);
    QPauseAnimation *insertPause(int index, int msecs);

    QAbstractAnimation *currentAnimation() const;
    int duration() const;

public:
    void currentAnimationChanged(QAbstractAnimation *current);

protected:
    QSequentialAnimationGroup(QSequentialAnimationGroupPrivate &dd, QObject *parent);
    bool event(QEvent *event);

    void updateCurrentTime(int);
    void updateState(QAbstractAnimation::State newState, QAbstractAnimation::State oldState);
    void updateDirection(QAbstractAnimation::Direction direction);

private:
    QSequentialAnimationGroup(const QSequentialAnimationGroup &) = delete; QSequentialAnimationGroup &operator=(const QSequentialAnimationGroup &) = delete;
    inline QSequentialAnimationGroupPrivate* d_func() { return reinterpret_cast<QSequentialAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSequentialAnimationGroupPrivate* d_func() const { return reinterpret_cast<const QSequentialAnimationGroupPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSequentialAnimationGroupPrivate;

};
#line 9 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtextcodec.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtextcodec.h"
class QTextCodec;
class QIODevice;

class QTextDecoder;
class QTextEncoder;

class __declspec(dllimport) QTextCodec
{
    QTextCodec(const QTextCodec &) = delete; QTextCodec &operator=(const QTextCodec &) = delete;
public:
    static QTextCodec* codecForName(const QByteArray &name);
    static QTextCodec* codecForName(const char *name) { return codecForName(QByteArray(name)); }
    static QTextCodec* codecForMib(int mib);

    static QList<QByteArray> availableCodecs();
    static QList<int> availableMibs();

    static QTextCodec* codecForLocale();
    static void setCodecForLocale(QTextCodec *c);





    static QTextCodec *codecForHtml(const QByteArray &ba);
    static QTextCodec *codecForHtml(const QByteArray &ba, QTextCodec *defaultCodec);

    static QTextCodec *codecForUtfText(const QByteArray &ba);
    static QTextCodec *codecForUtfText(const QByteArray &ba, QTextCodec *defaultCodec);

    bool canEncode(QChar) const;
    bool canEncode(const QString&) const;

    QString toUnicode(const QByteArray&) const;
    QString toUnicode(const char* chars) const;
    QByteArray fromUnicode(const QString& uc) const;
    enum ConversionFlag {
        DefaultConversion,
        ConvertInvalidToNull = 0x80000000,
        IgnoreHeader = 0x1,
        FreeFunction = 0x2
    };
    typedef QFlags<ConversionFlag> ConversionFlags;

    struct __declspec(dllimport) ConverterState {
        ConverterState(ConversionFlags f = DefaultConversion)
            : flags(f), remainingChars(0), invalidChars(0), d(0) { state_data[0] = state_data[1] = state_data[2] = 0; }
        ~ConverterState();
        ConversionFlags flags;
        int remainingChars;
        int invalidChars;
        uint state_data[3];
        void *d;
    private:
        ConverterState(const ConverterState &) = delete; ConverterState &operator=(const ConverterState &) = delete;
    };

    QString toUnicode(const char *in, int length, ConverterState *state = 0) const
        { return convertToUnicode(in, length, state); }
    QByteArray fromUnicode(const QChar *in, int length, ConverterState *state = 0) const
        { return convertFromUnicode(in, length, state); }

    QTextDecoder* makeDecoder(ConversionFlags flags = DefaultConversion) const;
    QTextEncoder* makeEncoder(ConversionFlags flags = DefaultConversion) const;

    virtual QByteArray name() const = 0;
    virtual QList<QByteArray> aliases() const;
    virtual int mibEnum() const = 0;

protected:
    virtual QString convertToUnicode(const char *in, int length, ConverterState *state) const = 0;
    virtual QByteArray convertFromUnicode(const QChar *in, int length, ConverterState *state) const = 0;

    QTextCodec();
    virtual ~QTextCodec();

private:
    friend struct QCoreGlobalData;
};
 inline QFlags<QTextCodec::ConversionFlags::enum_type> operator|(QTextCodec::ConversionFlags::enum_type f1, QTextCodec::ConversionFlags::enum_type f2) { return QFlags<QTextCodec::ConversionFlags::enum_type>(f1) | f2; } inline QFlags<QTextCodec::ConversionFlags::enum_type> operator|(QTextCodec::ConversionFlags::enum_type f1, QFlags<QTextCodec::ConversionFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextCodec::ConversionFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class __declspec(dllimport) QTextEncoder {
    QTextEncoder(const QTextEncoder &) = delete; QTextEncoder &operator=(const QTextEncoder &) = delete;
public:
    explicit QTextEncoder(const QTextCodec *codec) : c(codec), state() {}
    QTextEncoder(const QTextCodec *codec, QTextCodec::ConversionFlags flags);
    ~QTextEncoder();
    QByteArray fromUnicode(const QString& str);
    QByteArray fromUnicode(const QChar *uc, int len);
    bool hasFailure() const;
private:
    const QTextCodec *c;
    QTextCodec::ConverterState state;
};

class __declspec(dllimport) QTextDecoder {
    QTextDecoder(const QTextDecoder &) = delete; QTextDecoder &operator=(const QTextDecoder &) = delete;
public:
    explicit QTextDecoder(const QTextCodec *codec) : c(codec), state() {}
    QTextDecoder(const QTextCodec *codec, QTextCodec::ConversionFlags flags);
    ~QTextDecoder();
    QString toUnicode(const char* chars, int len);
    QString toUnicode(const QByteArray &ba);
    void toUnicode(QString *target, const char *chars, int len);
    bool hasFailure() const;
private:
    const QTextCodec *c;
    QTextCodec::ConverterState state;
};
#line 11 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcompilerdetection.h"
#line 12 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qendian.h"
#line 61 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qendian.h"
inline void qbswap_helper(const uchar *src, uchar *dest, int size)
{
    for (int i = 0; i < size ; ++i) dest[i] = src[size - 1 - i];
}







template <typename T> inline void qbswap(const T src, uchar *dest)
{
    qbswap_helper(reinterpret_cast<const uchar *>(&src), dest, sizeof(T));
}



template <typename T> inline void qToUnaligned(const T src, uchar *dest)
{


    const size_t size = sizeof(T);
    memcpy(dest, &src, size);
}
#line 135 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qendian.h"
template <typename T> inline T qFromLittleEndian(const uchar *src);
template <> inline quint64 qFromLittleEndian<quint64>(const uchar *src)
{
    return 0
        | src[0]
        | src[1] * 0x0000000000000100ui64
        | src[2] * 0x0000000000010000ui64
        | src[3] * 0x0000000001000000ui64
        | src[4] * 0x0000000100000000ui64
        | src[5] * 0x0000010000000000ui64
        | src[6] * 0x0001000000000000ui64
        | src[7] * 0x0100000000000000ui64;
}

template <> inline quint32 qFromLittleEndian<quint32>(const uchar *src)
{
    return 0
        | src[0]
        | src[1] * quint32(0x00000100)
        | src[2] * quint32(0x00010000)
        | src[3] * quint32(0x01000000);
}

template <> inline quint16 qFromLittleEndian<quint16>(const uchar *src)
{
    return quint16(0
                   | src[0]
                   | src[1] * 0x0100);
}


template <> inline qint64 qFromLittleEndian<qint64>(const uchar *src)
{ return static_cast<qint64>(qFromLittleEndian<quint64>(src)); }

template <> inline qint32 qFromLittleEndian<qint32>(const uchar *src)
{ return static_cast<qint32>(qFromLittleEndian<quint32>(src)); }

template <> inline qint16 qFromLittleEndian<qint16>(const uchar *src)
{ return static_cast<qint16>(qFromLittleEndian<quint16>(src)); }


template <> inline quint8 qFromLittleEndian<quint8>(const uchar *src)
{ return static_cast<quint8>(src[0]); }
template <> inline qint8 qFromLittleEndian<qint8>(const uchar *src)
{ return static_cast<qint8>(src[0]); }
#line 229 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qendian.h"
template <class T> inline T qFromBigEndian(const uchar *src);
template<>
inline quint64 qFromBigEndian<quint64>(const uchar *src)
{
    return 0
        | src[7]
        | src[6] * 0x0000000000000100ui64
        | src[5] * 0x0000000000010000ui64
        | src[4] * 0x0000000001000000ui64
        | src[3] * 0x0000000100000000ui64
        | src[2] * 0x0000010000000000ui64
        | src[1] * 0x0001000000000000ui64
        | src[0] * 0x0100000000000000ui64;
}

template<>
inline quint32 qFromBigEndian<quint32>(const uchar *src)
{
    return 0
        | src[3]
        | src[2] * quint32(0x00000100)
        | src[1] * quint32(0x00010000)
        | src[0] * quint32(0x01000000);
}

template<>
inline quint16 qFromBigEndian<quint16>(const uchar *src)
{
    return quint16( 0
                    | src[1]
                    | src[0] * quint16(0x0100));
}



template <> inline qint64 qFromBigEndian<qint64>(const uchar *src)
{ return static_cast<qint64>(qFromBigEndian<quint64>(src)); }

template <> inline qint32 qFromBigEndian<qint32>(const uchar *src)
{ return static_cast<qint32>(qFromBigEndian<quint32>(src)); }

template <> inline qint16 qFromBigEndian<qint16>(const uchar *src)
{ return static_cast<qint16>(qFromBigEndian<quint16>(src)); }


template <> inline quint8 qFromBigEndian<quint8>(const uchar *src)
{ return static_cast<quint8>(src[0]); }
template <> inline qint8 qFromBigEndian<qint8>(const uchar *src)
{ return static_cast<qint8>(src[0]); }







template <typename T> T qbswap(T source);
#line 301 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qendian.h"
template <> inline quint64 qbswap<quint64>(quint64 source)
{
    return 0
        | ((source & 0x00000000000000ffui64) << 56)
        | ((source & 0x000000000000ff00ui64) << 40)
        | ((source & 0x0000000000ff0000ui64) << 24)
        | ((source & 0x00000000ff000000ui64) << 8)
        | ((source & 0x000000ff00000000ui64) >> 8)
        | ((source & 0x0000ff0000000000ui64) >> 24)
        | ((source & 0x00ff000000000000ui64) >> 40)
        | ((source & 0xff00000000000000ui64) >> 56);
}

template <> inline quint32 qbswap<quint32>(quint32 source)
{
    return 0
        | ((source & 0x000000ff) << 24)
        | ((source & 0x0000ff00) << 8)
        | ((source & 0x00ff0000) >> 8)
        | ((source & 0xff000000) >> 24);
}

template <> inline quint16 qbswap<quint16>(quint16 source)
{
    return quint16( 0
                    | ((source & 0x00ff) << 8)
                    | ((source & 0xff00) >> 8) );
}



template <> inline qint64 qbswap<qint64>(qint64 source)
{
    return qbswap<quint64>(quint64(source));
}

template <> inline qint32 qbswap<qint32>(qint32 source)
{
    return qbswap<quint32>(quint32(source));
}

template <> inline qint16 qbswap<qint16>(qint16 source)
{
    return qbswap<quint16>(quint16(source));
}
#line 363 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qendian.h"
template <typename T> inline T qToBigEndian(T source)
{ return qbswap<T>(source); }
template <typename T> inline T qFromBigEndian(T source)
{ return qbswap<T>(source); }
template <typename T> inline T qToLittleEndian(T source)
{ return source; }
template <typename T> inline T qFromLittleEndian(T source)
{ return source; }
template <typename T> inline void qToBigEndian(T src, uchar *dest)
{ qbswap<T>(src, dest); }
template <typename T> inline void qToLittleEndian(T src, uchar *dest)
{ qToUnaligned<T>(src, dest); }



template <> inline quint8 qbswap<quint8>(quint8 source)
{
    return source;
}

template <> inline qint8 qbswap<qint8>(qint8 source)
{
    return source;
}
#line 13 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qflags.h"
#line 14 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qglobalstatic.h"
#line 16 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qisenum.h"
#line 17 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlibraryinfo.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlibraryinfo.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qdatetime.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qdatetime.h"
class QTimeZone;

class __declspec(dllimport) QDate
{
public:
    enum MonthNameType {
        DateFormat = 0,
        StandaloneFormat
    };
public:
    QDate() { jd = nullJd(); }
    QDate(int y, int m, int d);

    bool isNull() const { return !isValid(); }
    bool isValid() const { return jd >= minJd() && jd <= maxJd(); }

    int year() const;
    int month() const;
    int day() const;
    int dayOfWeek() const;
    int dayOfYear() const;
    int daysInMonth() const;
    int daysInYear() const;
    int weekNumber(int *yearNum = 0) const;


    static QString shortMonthName(int month, MonthNameType type = DateFormat);
    static QString shortDayName(int weekday, MonthNameType type = DateFormat);
    static QString longMonthName(int month, MonthNameType type = DateFormat);
    static QString longDayName(int weekday, MonthNameType type = DateFormat);


    QString toString(Qt::DateFormat f = Qt::TextDate) const;
    QString toString(const QString &format) const;






    bool setDate(int year, int month, int day);

    void getDate(int *year, int *month, int *day);

    QDate addDays(qint64 days) const;
    QDate addMonths(int months) const;
    QDate addYears(int years) const;
    qint64 daysTo(const QDate &) const;

    bool operator==(const QDate &other) const { return jd == other.jd; }
    bool operator!=(const QDate &other) const { return jd != other.jd; }
    bool operator<(const QDate &other) const { return jd < other.jd; }
    bool operator<=(const QDate &other) const { return jd <= other.jd; }
    bool operator>(const QDate &other) const { return jd > other.jd; }
    bool operator>=(const QDate &other) const { return jd >= other.jd; }

    static QDate currentDate();

    static QDate fromString(const QString &s, Qt::DateFormat f = Qt::TextDate);
    static QDate fromString(const QString &s, const QString &format);

    static bool isValid(int y, int m, int d);
    static bool isLeapYear(int year);

    static inline QDate fromJulianDay(qint64 jd)
    { QDate d; if (jd >= minJd() && jd <= maxJd()) d.jd = jd; return d; }
    inline qint64 toJulianDay() const { return jd; }

private:
    static inline qint64 nullJd() { return std::numeric_limits<qint64>::min(); }
    static inline qint64 minJd() { return -784350574879i64; }
    static inline qint64 maxJd() { return 784354017364i64; }

    qint64 jd;

    friend class QDateTime;
    friend class QDateTimePrivate;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QDate &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QDate &);

};
template<> class QTypeInfo<QDate > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QDate)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QDate >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QDate) }; static inline const char *name() { return "QDate"; } };

class __declspec(dllimport) QTime
{
public:
    QTime(): mds(NullTime)



    {}
    QTime(int h, int m, int s = 0, int ms = 0);

    bool isNull() const { return mds == NullTime; }
    bool isValid() const;

    int hour() const;
    int minute() const;
    int second() const;
    int msec() const;

    QString toString(Qt::DateFormat f = Qt::TextDate) const;
    QString toString(const QString &format) const;

    bool setHMS(int h, int m, int s, int ms = 0);

    QTime addSecs(int secs) const;
    int secsTo(const QTime &) const;
    QTime addMSecs(int ms) const;
    int msecsTo(const QTime &) const;

    bool operator==(const QTime &other) const { return mds == other.mds; }
    bool operator!=(const QTime &other) const { return mds != other.mds; }
    bool operator<(const QTime &other) const { return mds < other.mds; }
    bool operator<=(const QTime &other) const { return mds <= other.mds; }
    bool operator>(const QTime &other) const { return mds > other.mds; }
    bool operator>=(const QTime &other) const { return mds >= other.mds; }

    static inline QTime fromMSecsSinceStartOfDay(int msecs) { QTime t; t.mds = msecs; return t; }
    inline int msecsSinceStartOfDay() const { return mds == NullTime ? 0 : mds; }

    static QTime currentTime();

    static QTime fromString(const QString &s, Qt::DateFormat f = Qt::TextDate);
    static QTime fromString(const QString &s, const QString &format);

    static bool isValid(int h, int m, int s, int ms = 0);

    void start();
    int restart();
    int elapsed() const;
private:
    enum TimeFlag { NullTime = -1 };
    inline int ds() const { return mds == -1 ? 0 : mds; }
    int mds;




    friend class QDateTime;
    friend class QDateTimePrivate;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTime &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QTime &);

};
template<> class QTypeInfo<QTime > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTime)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTime >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTime) }; static inline const char *name() { return "QTime"; } };

class QDateTimePrivate;

class __declspec(dllimport) QDateTime
{
public:
    QDateTime();
    explicit QDateTime(const QDate &);
    QDateTime(const QDate &, const QTime &, Qt::TimeSpec spec = Qt::LocalTime);

    QDateTime(const QDate &date, const QTime &time, Qt::TimeSpec spec, int offsetSeconds);

    QDateTime(const QDate &date, const QTime &time, const QTimeZone &timeZone);

    QDateTime(const QDateTime &other);
    ~QDateTime();

    QDateTime &operator=(const QDateTime &other);

    inline void swap(QDateTime &other) { qSwap(d, other.d); }

    bool isNull() const;
    bool isValid() const;

    QDate date() const;
    QTime time() const;
    Qt::TimeSpec timeSpec() const;
    int offsetFromUtc() const;

    QTimeZone timeZone() const;

    QString timeZoneAbbreviation() const;
    bool isDaylightTime() const;

    qint64 toMSecsSinceEpoch() const;

    uint toTime_t() const;

    void setDate(const QDate &date);
    void setTime(const QTime &time);
    void setTimeSpec(Qt::TimeSpec spec);
    void setOffsetFromUtc(int offsetSeconds);

    void setTimeZone(const QTimeZone &toZone);

    void setMSecsSinceEpoch(qint64 msecs);

    void setTime_t(uint secsSince1Jan1970UTC);


    QString toString(Qt::DateFormat f = Qt::TextDate) const;
    QString toString(const QString &format) const;

    QDateTime addDays(qint64 days) const;
    QDateTime addMonths(int months) const;
    QDateTime addYears(int years) const;
    QDateTime addSecs(qint64 secs) const;
    QDateTime addMSecs(qint64 msecs) const;

    QDateTime toTimeSpec(Qt::TimeSpec spec) const;
    inline QDateTime toLocalTime() const { return toTimeSpec(Qt::LocalTime); }
    inline QDateTime toUTC() const { return toTimeSpec(Qt::UTC); }
    QDateTime toOffsetFromUtc(int offsetSeconds) const;

    QDateTime toTimeZone(const QTimeZone &toZone) const;


    qint64 daysTo(const QDateTime &) const;
    qint64 secsTo(const QDateTime &) const;
    qint64 msecsTo(const QDateTime &) const;

    bool operator==(const QDateTime &other) const;
    inline bool operator!=(const QDateTime &other) const { return !(*this == other); }
    bool operator<(const QDateTime &other) const;
    inline bool operator<=(const QDateTime &other) const { return !(other < *this); }
    inline bool operator>(const QDateTime &other) const { return other < *this; }
    inline bool operator>=(const QDateTime &other) const { return !(*this < other); }


                  void setUtcOffset(int seconds);
                  int utcOffset() const;


    static QDateTime currentDateTime();
    static QDateTime currentDateTimeUtc();

    static QDateTime fromString(const QString &s, Qt::DateFormat f = Qt::TextDate);
    static QDateTime fromString(const QString &s, const QString &format);


    static QDateTime fromTime_t(uint secsSince1Jan1970UTC);

    static QDateTime fromTime_t(uint secsSince1Jan1970UTC, Qt::TimeSpec spec,
                                int offsetFromUtc = 0);

    static QDateTime fromTime_t(uint secsSince1Jan1970UTC, const QTimeZone &timeZone);

    static QDateTime fromMSecsSinceEpoch(qint64 msecs);

    static QDateTime fromMSecsSinceEpoch(qint64 msecs, Qt::TimeSpec spec, int offsetFromUtc = 0);

    static QDateTime fromMSecsSinceEpoch(qint64 msecs, const QTimeZone &timeZone);

    static qint64 currentMSecsSinceEpoch() throw();

private:
    friend class QDateTimePrivate;
    void detach();




    QExplicitlySharedDataPointer<QDateTimePrivate> d;


    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QDateTime &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QDateTime &);



    friend __declspec(dllimport) QDebug operator<<(QDebug, const QDateTime &);

};
template<> class QTypeInfo<QDateTime > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QDateTime)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QDateTime >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QDateTime) }; static inline const char *name() { return "QDateTime"; } }; template <> inline void qSwap<QDateTime>(QDateTime &value1, QDateTime &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QDateTime >(::QDateTime &value1, ::QDateTime &value2) { value1.swap(value2); } }


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QDate &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QDate &);
__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QTime &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QTime &);
__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QDateTime &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QDateTime &);



__declspec(dllimport) QDebug operator<<(QDebug, const QDate &);
__declspec(dllimport) QDebug operator<<(QDebug, const QTime &);
__declspec(dllimport) QDebug operator<<(QDebug, const QDateTime &);




__declspec(dllimport) uint qHash(const QDateTime &key, uint seed = 0);
__declspec(dllimport) uint qHash(const QDate &key, uint seed = 0) throw();
__declspec(dllimport) uint qHash(const QTime &key, uint seed = 0) throw();
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlibraryinfo.h"




class QStringList;

class __declspec(dllimport) QLibraryInfo
{
public:
    static QString licensee();
    static QString licensedProducts();


    static QDate buildDate();


    static const char * build() throw();

    static bool isDebugBuild();

    enum LibraryLocation
    {
        PrefixPath = 0,
        DocumentationPath,
        HeadersPath,
        LibrariesPath,
        LibraryExecutablesPath,
        BinariesPath,
        PluginsPath,
        ImportsPath,
        Qml2ImportsPath,
        ArchDataPath,
        DataPath,
        TranslationsPath,
        ExamplesPath,
        TestsPath,
#line 95 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlibraryinfo.h"
        SettingsPath = 100
    };
    static QString location(LibraryLocation);





    static QStringList platformPluginArguments(const QString &platformName);

private:
    QLibraryInfo();
};
#line 18 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qprocessordetection.h"
#line 21 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsysinfo.h"
#line 22 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qsystemdetection.h"
#line 23 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypeinfo.h"
#line 24 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtypetraits.h"
#line 25 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbuffer.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbuffer.h"
class QObject;
class QBufferPrivate;

class __declspec(dllimport) QBuffer : public QIODevice
{

    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};


public:

     explicit QBuffer(QObject *parent = 0);
     QBuffer(QByteArray *buf, QObject *parent = 0);




    ~QBuffer();

    QByteArray &buffer();
    const QByteArray &buffer() const;
    void setBuffer(QByteArray *a);

    void setData(const QByteArray &data);
    inline void setData(const char *data, int len);
    const QByteArray &data() const;

    bool open(OpenMode openMode);

    void close();
    qint64 size() const;
    qint64 pos() const;
    bool seek(qint64 off);
    bool atEnd() const;
    bool canReadLine() const;

protected:

    void connectNotify(const QMetaMethod &);
    void disconnectNotify(const QMetaMethod &);

    qint64 readData(char *data, qint64 maxlen);
    qint64 writeData(const char *data, qint64 len);

private:
    inline QBufferPrivate* d_func() { return reinterpret_cast<QBufferPrivate *>(qGetPtrHelper(d_ptr)); } inline const QBufferPrivate* d_func() const { return reinterpret_cast<const QBufferPrivate *>(qGetPtrHelper(d_ptr)); } friend class QBufferPrivate;
    QBuffer(const QBuffer &) = delete; QBuffer &operator=(const QBuffer &) = delete;


};

inline void QBuffer::setData(const char *adata, int alen)
{ setData(QByteArray(adata, alen)); }
#line 26 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qdebug.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qdebug.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtextstream.h"
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtextstream.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlocale.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qlocale.h"
class QDataStream;
class QDate;
class QDateTime;
class QTime;
class QVariant;
class QTextStream;
class QTextStreamPrivate;

class QLocalePrivate;

class __declspec(dllimport) QLocale
{
    public: static const QMetaObject staticMetaObject; private:



    friend class QString;
    friend class QStringRef;
    friend class QByteArray;
    friend class QIntValidator;
    friend class QDoubleValidatorPrivate;
    friend class QTextStream;
    friend class QTextStreamPrivate;

public:


    enum Language {
        AnyLanguage = 0,
        C = 1,
        Abkhazian = 2,
        Oromo = 3,
        Afar = 4,
        Afrikaans = 5,
        Albanian = 6,
        Amharic = 7,
        Arabic = 8,
        Armenian = 9,
        Assamese = 10,
        Aymara = 11,
        Azerbaijani = 12,
        Bashkir = 13,
        Basque = 14,
        Bengali = 15,
        Dzongkha = 16,
        Bihari = 17,
        Bislama = 18,
        Breton = 19,
        Bulgarian = 20,
        Burmese = 21,
        Belarusian = 22,
        Khmer = 23,
        Catalan = 24,
        Chinese = 25,
        Corsican = 26,
        Croatian = 27,
        Czech = 28,
        Danish = 29,
        Dutch = 30,
        English = 31,
        Esperanto = 32,
        Estonian = 33,
        Faroese = 34,
        Fijian = 35,
        Finnish = 36,
        French = 37,
        WesternFrisian = 38,
        Gaelic = 39,
        Galician = 40,
        Georgian = 41,
        German = 42,
        Greek = 43,
        Greenlandic = 44,
        Guarani = 45,
        Gujarati = 46,
        Hausa = 47,
        Hebrew = 48,
        Hindi = 49,
        Hungarian = 50,
        Icelandic = 51,
        Indonesian = 52,
        Interlingua = 53,
        Interlingue = 54,
        Inuktitut = 55,
        Inupiak = 56,
        Irish = 57,
        Italian = 58,
        Japanese = 59,
        Javanese = 60,
        Kannada = 61,
        Kashmiri = 62,
        Kazakh = 63,
        Kinyarwanda = 64,
        Kirghiz = 65,
        Korean = 66,
        Kurdish = 67,
        Rundi = 68,
        Lao = 69,
        Latin = 70,
        Latvian = 71,
        Lingala = 72,
        Lithuanian = 73,
        Macedonian = 74,
        Malagasy = 75,
        Malay = 76,
        Malayalam = 77,
        Maltese = 78,
        Maori = 79,
        Marathi = 80,
        Marshallese = 81,
        Mongolian = 82,
        NauruLanguage = 83,
        Nepali = 84,
        NorwegianBokmal = 85,
        Occitan = 86,
        Oriya = 87,
        Pashto = 88,
        Persian = 89,
        Polish = 90,
        Portuguese = 91,
        Punjabi = 92,
        Quechua = 93,
        Romansh = 94,
        Romanian = 95,
        Russian = 96,
        Samoan = 97,
        Sango = 98,
        Sanskrit = 99,
        Serbian = 100,
        Ossetic = 101,
        SouthernSotho = 102,
        Tswana = 103,
        Shona = 104,
        Sindhi = 105,
        Sinhala = 106,
        Swati = 107,
        Slovak = 108,
        Slovenian = 109,
        Somali = 110,
        Spanish = 111,
        Sundanese = 112,
        Swahili = 113,
        Swedish = 114,
        Sardinian = 115,
        Tajik = 116,
        Tamil = 117,
        Tatar = 118,
        Telugu = 119,
        Thai = 120,
        Tibetan = 121,
        Tigrinya = 122,
        Tongan = 123,
        Tsonga = 124,
        Turkish = 125,
        Turkmen = 126,
        Tahitian = 127,
        Uighur = 128,
        Ukrainian = 129,
        Urdu = 130,
        Uzbek = 131,
        Vietnamese = 132,
        Volapuk = 133,
        Welsh = 134,
        Wolof = 135,
        Xhosa = 136,
        Yiddish = 137,
        Yoruba = 138,
        Zhuang = 139,
        Zulu = 140,
        NorwegianNynorsk = 141,
        Bosnian = 142,
        Divehi = 143,
        Manx = 144,
        Cornish = 145,
        Akan = 146,
        Konkani = 147,
        Ga = 148,
        Igbo = 149,
        Kamba = 150,
        Syriac = 151,
        Blin = 152,
        Geez = 153,
        Koro = 154,
        Sidamo = 155,
        Atsam = 156,
        Tigre = 157,
        Jju = 158,
        Friulian = 159,
        Venda = 160,
        Ewe = 161,
        Walamo = 162,
        Hawaiian = 163,
        Tyap = 164,
        Nyanja = 165,
        Filipino = 166,
        SwissGerman = 167,
        SichuanYi = 168,
        Kpelle = 169,
        LowGerman = 170,
        SouthNdebele = 171,
        NorthernSotho = 172,
        NorthernSami = 173,
        Taroko = 174,
        Gusii = 175,
        Taita = 176,
        Fulah = 177,
        Kikuyu = 178,
        Samburu = 179,
        Sena = 180,
        NorthNdebele = 181,
        Rombo = 182,
        Tachelhit = 183,
        Kabyle = 184,
        Nyankole = 185,
        Bena = 186,
        Vunjo = 187,
        Bambara = 188,
        Embu = 189,
        Cherokee = 190,
        Morisyen = 191,
        Makonde = 192,
        Langi = 193,
        Ganda = 194,
        Bemba = 195,
        Kabuverdianu = 196,
        Meru = 197,
        Kalenjin = 198,
        Nama = 199,
        Machame = 200,
        Colognian = 201,
        Masai = 202,
        Soga = 203,
        Luyia = 204,
        Asu = 205,
        Teso = 206,
        Saho = 207,
        KoyraChiini = 208,
        Rwa = 209,
        Luo = 210,
        Chiga = 211,
        CentralMoroccoTamazight = 212,
        KoyraboroSenni = 213,
        Shambala = 214,
        Bodo = 215,
        Avaric = 216,
        Chamorro = 217,
        Chechen = 218,
        Church = 219,
        Chuvash = 220,
        Cree = 221,
        Haitian = 222,
        Herero = 223,
        HiriMotu = 224,
        Kanuri = 225,
        Komi = 226,
        Kongo = 227,
        Kwanyama = 228,
        Limburgish = 229,
        LubaKatanga = 230,
        Luxembourgish = 231,
        Navaho = 232,
        Ndonga = 233,
        Ojibwa = 234,
        Pali = 235,
        Walloon = 236,
        Aghem = 237,
        Basaa = 238,
        Zarma = 239,
        Duala = 240,
        JolaFonyi = 241,
        Ewondo = 242,
        Bafia = 243,
        MakhuwaMeetto = 244,
        Mundang = 245,
        Kwasio = 246,
        Nuer = 247,
        Sakha = 248,
        Sangu = 249,
        CongoSwahili = 250,
        Tasawaq = 251,
        Vai = 252,
        Walser = 253,
        Yangben = 254,
        Avestan = 255,
        Asturian = 256,
        Ngomba = 257,
        Kako = 258,
        Meta = 259,
        Ngiemboon = 260,
        Aragonese = 261,
        Akkadian = 262,
        AncientEgyptian = 263,
        AncientGreek = 264,
        Aramaic = 265,
        Balinese = 266,
        Bamun = 267,
        BatakToba = 268,
        Buginese = 269,
        Buhid = 270,
        Carian = 271,
        Chakma = 272,
        ClassicalMandaic = 273,
        Coptic = 274,
        Dogri = 275,
        EasternCham = 276,
        EasternKayah = 277,
        Etruscan = 278,
        Gothic = 279,
        Hanunoo = 280,
        Ingush = 281,
        LargeFloweryMiao = 282,
        Lepcha = 283,
        Limbu = 284,
        Lisu = 285,
        Lu = 286,
        Lycian = 287,
        Lydian = 288,
        Mandingo = 289,
        Manipuri = 290,
        Meroitic = 291,
        NorthernThai = 292,
        OldIrish = 293,
        OldNorse = 294,
        OldPersian = 295,
        OldTurkish = 296,
        Pahlavi = 297,
        Parthian = 298,
        Phoenician = 299,
        PrakritLanguage = 300,
        Rejang = 301,
        Sabaean = 302,
        Samaritan = 303,
        Santali = 304,
        Saurashtra = 305,
        Sora = 306,
        Sylheti = 307,
        Tagbanwa = 308,
        TaiDam = 309,
        TaiNua = 310,
        Ugaritic = 311,
        Akoose = 312,
        Lakota = 313,
        StandardMoroccanTamazight = 314,
        Norwegian = NorwegianBokmal,
        Moldavian = Romanian,
        SerboCroatian = Serbian,
        Tagalog = Filipino,
        Twi = Akan,
        Afan = Oromo,
        Byelorussian = Belarusian,
        Bhutani = Dzongkha,
        Cambodian = Khmer,
        Kurundi = Rundi,
        RhaetoRomance = Romansh,
        Chewa = Nyanja,
        Frisian = WesternFrisian,
        Uigur = Uighur,
        LastLanguage = StandardMoroccanTamazight
    };

    enum Script {
        AnyScript = 0,
        ArabicScript = 1,
        CyrillicScript = 2,
        DeseretScript = 3,
        GurmukhiScript = 4,
        SimplifiedHanScript = 5,
        TraditionalHanScript = 6,
        LatinScript = 7,
        MongolianScript = 8,
        TifinaghScript = 9,
        ArmenianScript = 10,
        BengaliScript = 11,
        CherokeeScript = 12,
        DevanagariScript = 13,
        EthiopicScript = 14,
        GeorgianScript = 15,
        GreekScript = 16,
        GujaratiScript = 17,
        HebrewScript = 18,
        JapaneseScript = 19,
        KhmerScript = 20,
        KannadaScript = 21,
        KoreanScript = 22,
        LaoScript = 23,
        MalayalamScript = 24,
        MyanmarScript = 25,
        OriyaScript = 26,
        TamilScript = 27,
        TeluguScript = 28,
        ThaanaScript = 29,
        ThaiScript = 30,
        TibetanScript = 31,
        SinhalaScript = 32,
        SyriacScript = 33,
        YiScript = 34,
        VaiScript = 35,
        AvestanScript = 36,
        BalineseScript = 37,
        BamumScript = 38,
        BatakScript = 39,
        BopomofoScript = 40,
        BrahmiScript = 41,
        BugineseScript = 42,
        BuhidScript = 43,
        CanadianAboriginalScript = 44,
        CarianScript = 45,
        ChakmaScript = 46,
        ChamScript = 47,
        CopticScript = 48,
        CypriotScript = 49,
        EgyptianHieroglyphsScript = 50,
        FraserScript = 51,
        GlagoliticScript = 52,
        GothicScript = 53,
        HanScript = 54,
        HangulScript = 55,
        HanunooScript = 56,
        ImperialAramaicScript = 57,
        InscriptionalPahlaviScript = 58,
        InscriptionalParthianScript = 59,
        JavaneseScript = 60,
        KaithiScript = 61,
        KatakanaScript = 62,
        KayahLiScript = 63,
        KharoshthiScript = 64,
        LannaScript = 65,
        LepchaScript = 66,
        LimbuScript = 67,
        LinearBScript = 68,
        LycianScript = 69,
        LydianScript = 70,
        MandaeanScript = 71,
        MeiteiMayekScript = 72,
        MeroiticScript = 73,
        MeroiticCursiveScript = 74,
        NkoScript = 75,
        NewTaiLueScript = 76,
        OghamScript = 77,
        OlChikiScript = 78,
        OldItalicScript = 79,
        OldPersianScript = 80,
        OldSouthArabianScript = 81,
        OrkhonScript = 82,
        OsmanyaScript = 83,
        PhagsPaScript = 84,
        PhoenicianScript = 85,
        PollardPhoneticScript = 86,
        RejangScript = 87,
        RunicScript = 88,
        SamaritanScript = 89,
        SaurashtraScript = 90,
        SharadaScript = 91,
        ShavianScript = 92,
        SoraSompengScript = 93,
        CuneiformScript = 94,
        SundaneseScript = 95,
        SylotiNagriScript = 96,
        TagalogScript = 97,
        TagbanwaScript = 98,
        TaiLeScript = 99,
        TaiVietScript = 100,
        TakriScript = 101,
        UgariticScript = 102,
        BrailleScript = 103,
        HiraganaScript = 104,
        SimplifiedChineseScript = SimplifiedHanScript,
        TraditionalChineseScript = TraditionalHanScript,
        LastScript = HiraganaScript
    };
    enum Country {
        AnyCountry = 0,
        Afghanistan = 1,
        Albania = 2,
        Algeria = 3,
        AmericanSamoa = 4,
        Andorra = 5,
        Angola = 6,
        Anguilla = 7,
        Antarctica = 8,
        AntiguaAndBarbuda = 9,
        Argentina = 10,
        Armenia = 11,
        Aruba = 12,
        Australia = 13,
        Austria = 14,
        Azerbaijan = 15,
        Bahamas = 16,
        Bahrain = 17,
        Bangladesh = 18,
        Barbados = 19,
        Belarus = 20,
        Belgium = 21,
        Belize = 22,
        Benin = 23,
        Bermuda = 24,
        Bhutan = 25,
        Bolivia = 26,
        BosniaAndHerzegowina = 27,
        Botswana = 28,
        BouvetIsland = 29,
        Brazil = 30,
        BritishIndianOceanTerritory = 31,
        Brunei = 32,
        Bulgaria = 33,
        BurkinaFaso = 34,
        Burundi = 35,
        Cambodia = 36,
        Cameroon = 37,
        Canada = 38,
        CapeVerde = 39,
        CaymanIslands = 40,
        CentralAfricanRepublic = 41,
        Chad = 42,
        Chile = 43,
        China = 44,
        ChristmasIsland = 45,
        CocosIslands = 46,
        Colombia = 47,
        Comoros = 48,
        CongoKinshasa = 49,
        CongoBrazzaville = 50,
        CookIslands = 51,
        CostaRica = 52,
        IvoryCoast = 53,
        Croatia = 54,
        Cuba = 55,
        Cyprus = 56,
        CzechRepublic = 57,
        Denmark = 58,
        Djibouti = 59,
        Dominica = 60,
        DominicanRepublic = 61,
        EastTimor = 62,
        Ecuador = 63,
        Egypt = 64,
        ElSalvador = 65,
        EquatorialGuinea = 66,
        Eritrea = 67,
        Estonia = 68,
        Ethiopia = 69,
        FalklandIslands = 70,
        FaroeIslands = 71,
        Fiji = 72,
        Finland = 73,
        France = 74,
        Guernsey = 75,
        FrenchGuiana = 76,
        FrenchPolynesia = 77,
        FrenchSouthernTerritories = 78,
        Gabon = 79,
        Gambia = 80,
        Georgia = 81,
        Germany = 82,
        Ghana = 83,
        Gibraltar = 84,
        Greece = 85,
        Greenland = 86,
        Grenada = 87,
        Guadeloupe = 88,
        Guam = 89,
        Guatemala = 90,
        Guinea = 91,
        GuineaBissau = 92,
        Guyana = 93,
        Haiti = 94,
        HeardAndMcDonaldIslands = 95,
        Honduras = 96,
        HongKong = 97,
        Hungary = 98,
        Iceland = 99,
        India = 100,
        Indonesia = 101,
        Iran = 102,
        Iraq = 103,
        Ireland = 104,
        Israel = 105,
        Italy = 106,
        Jamaica = 107,
        Japan = 108,
        Jordan = 109,
        Kazakhstan = 110,
        Kenya = 111,
        Kiribati = 112,
        NorthKorea = 113,
        SouthKorea = 114,
        Kuwait = 115,
        Kyrgyzstan = 116,
        Laos = 117,
        Latvia = 118,
        Lebanon = 119,
        Lesotho = 120,
        Liberia = 121,
        Libya = 122,
        Liechtenstein = 123,
        Lithuania = 124,
        Luxembourg = 125,
        Macau = 126,
        Macedonia = 127,
        Madagascar = 128,
        Malawi = 129,
        Malaysia = 130,
        Maldives = 131,
        Mali = 132,
        Malta = 133,
        MarshallIslands = 134,
        Martinique = 135,
        Mauritania = 136,
        Mauritius = 137,
        Mayotte = 138,
        Mexico = 139,
        Micronesia = 140,
        Moldova = 141,
        Monaco = 142,
        Mongolia = 143,
        Montserrat = 144,
        Morocco = 145,
        Mozambique = 146,
        Myanmar = 147,
        Namibia = 148,
        NauruCountry = 149,
        Nepal = 150,
        Netherlands = 151,
        CuraSao = 152,
        NewCaledonia = 153,
        NewZealand = 154,
        Nicaragua = 155,
        Niger = 156,
        Nigeria = 157,
        Niue = 158,
        NorfolkIsland = 159,
        NorthernMarianaIslands = 160,
        Norway = 161,
        Oman = 162,
        Pakistan = 163,
        Palau = 164,
        PalestinianTerritories = 165,
        Panama = 166,
        PapuaNewGuinea = 167,
        Paraguay = 168,
        Peru = 169,
        Philippines = 170,
        Pitcairn = 171,
        Poland = 172,
        Portugal = 173,
        PuertoRico = 174,
        Qatar = 175,
        Reunion = 176,
        Romania = 177,
        Russia = 178,
        Rwanda = 179,
        SaintKittsAndNevis = 180,
        SaintLucia = 181,
        SaintVincentAndTheGrenadines = 182,
        Samoa = 183,
        SanMarino = 184,
        SaoTomeAndPrincipe = 185,
        SaudiArabia = 186,
        Senegal = 187,
        Seychelles = 188,
        SierraLeone = 189,
        Singapore = 190,
        Slovakia = 191,
        Slovenia = 192,
        SolomonIslands = 193,
        Somalia = 194,
        SouthAfrica = 195,
        SouthGeorgiaAndTheSouthSandwichIslands = 196,
        Spain = 197,
        SriLanka = 198,
        SaintHelena = 199,
        SaintPierreAndMiquelon = 200,
        Sudan = 201,
        Suriname = 202,
        SvalbardAndJanMayenIslands = 203,
        Swaziland = 204,
        Sweden = 205,
        Switzerland = 206,
        Syria = 207,
        Taiwan = 208,
        Tajikistan = 209,
        Tanzania = 210,
        Thailand = 211,
        Togo = 212,
        Tokelau = 213,
        Tonga = 214,
        TrinidadAndTobago = 215,
        Tunisia = 216,
        Turkey = 217,
        Turkmenistan = 218,
        TurksAndCaicosIslands = 219,
        Tuvalu = 220,
        Uganda = 221,
        Ukraine = 222,
        UnitedArabEmirates = 223,
        UnitedKingdom = 224,
        UnitedStates = 225,
        UnitedStatesMinorOutlyingIslands = 226,
        Uruguay = 227,
        Uzbekistan = 228,
        Vanuatu = 229,
        VaticanCityState = 230,
        Venezuela = 231,
        Vietnam = 232,
        BritishVirginIslands = 233,
        UnitedStatesVirginIslands = 234,
        WallisAndFutunaIslands = 235,
        WesternSahara = 236,
        Yemen = 237,
        CanaryIslands = 238,
        Zambia = 239,
        Zimbabwe = 240,
        ClippertonIsland = 241,
        Montenegro = 242,
        Serbia = 243,
        SaintBarthelemy = 244,
        SaintMartin = 245,
        LatinAmericaAndTheCaribbean = 246,
        AscensionIsland = 247,
        AlandIslands = 248,
        DiegoGarcia = 249,
        CeutaAndMelilla = 250,
        IsleOfMan = 251,
        Jersey = 252,
        TristanDaCunha = 253,
        SouthSudan = 254,
        Bonaire = 255,
        SintMaarten = 256,
        Kosovo = 257,
        DemocraticRepublicOfCongo = CongoKinshasa,
        PeoplesRepublicOfCongo = CongoBrazzaville,
        DemocraticRepublicOfKorea = NorthKorea,
        RepublicOfKorea = SouthKorea,
        RussianFederation = Russia,
        SyrianArabRepublic = Syria,
        LastCountry = Kosovo
    };


    enum MeasurementSystem {
        MetricSystem,
        ImperialUSSystem,
        ImperialUKSystem,
        ImperialSystem = ImperialUSSystem
    };

    enum FormatType { LongFormat, ShortFormat, NarrowFormat };
    enum NumberOption {
        OmitGroupSeparator = 0x01,
        RejectGroupSeparator = 0x02
    };
    typedef QFlags<NumberOption> NumberOptions;

    enum CurrencySymbolFormat {
        CurrencyIsoCode,
        CurrencySymbol,
        CurrencyDisplayName
    };

    QLocale();
    QLocale(const QString &name);
    QLocale(Language language, Country country = AnyCountry);
    QLocale(Language language, Script script, Country country);
    QLocale(const QLocale &other);
    ~QLocale();

    QLocale &operator=(const QLocale &other);

    Language language() const;
    Script script() const;
    Country country() const;
    QString name() const;

    QString bcp47Name() const;
    QString nativeLanguageName() const;
    QString nativeCountryName() const;

    short toShort(const QString &s, bool *ok = 0) const;
    ushort toUShort(const QString &s, bool *ok = 0) const;
    int toInt(const QString &s, bool *ok = 0) const;
    uint toUInt(const QString &s, bool *ok = 0) const;
    qlonglong toLongLong(const QString &s, bool *ok = 0) const;
    qulonglong toULongLong(const QString &s, bool *ok = 0) const;
    float toFloat(const QString &s, bool *ok = 0) const;
    double toDouble(const QString &s, bool *ok = 0) const;

    short toShort(const QStringRef &s, bool *ok = 0) const;
    ushort toUShort(const QStringRef &s, bool *ok = 0) const;
    int toInt(const QStringRef &s, bool *ok = 0) const;
    uint toUInt(const QStringRef &s, bool *ok = 0) const;
    qlonglong toLongLong(const QStringRef &s, bool *ok = 0) const;
    qulonglong toULongLong(const QStringRef &s, bool *ok = 0) const;
    float toFloat(const QStringRef &s, bool *ok = 0) const;
    double toDouble(const QStringRef &s, bool *ok = 0) const;

    QString toString(qlonglong i) const;
    QString toString(qulonglong i) const;
    inline QString toString(short i) const;
    inline QString toString(ushort i) const;
    inline QString toString(int i) const;
    inline QString toString(uint i) const;
    QString toString(double i, char f = 'g', int prec = 6) const;
    inline QString toString(float i, char f = 'g', int prec = 6) const;
    QString toString(const QDate &date, const QString &formatStr) const;
    QString toString(const QDate &date, FormatType format = LongFormat) const;
    QString toString(const QTime &time, const QString &formatStr) const;
    QString toString(const QTime &time, FormatType format = LongFormat) const;
    QString toString(const QDateTime &dateTime, FormatType format = LongFormat) const;
    QString toString(const QDateTime &dateTime, const QString &format) const;

    QString dateFormat(FormatType format = LongFormat) const;
    QString timeFormat(FormatType format = LongFormat) const;
    QString dateTimeFormat(FormatType format = LongFormat) const;

    QDate toDate(const QString &string, FormatType = LongFormat) const;
    QTime toTime(const QString &string, FormatType = LongFormat) const;
    QDateTime toDateTime(const QString &string, FormatType format = LongFormat) const;
    QDate toDate(const QString &string, const QString &format) const;
    QTime toTime(const QString &string, const QString &format) const;
    QDateTime toDateTime(const QString &string, const QString &format) const;




    QChar decimalPoint() const;
    QChar groupSeparator() const;
    QChar percent() const;
    QChar zeroDigit() const;
    QChar negativeSign() const;
    QChar positiveSign() const;
    QChar exponential() const;

    QString monthName(int, FormatType format = LongFormat) const;
    QString standaloneMonthName(int, FormatType format = LongFormat) const;
    QString dayName(int, FormatType format = LongFormat) const;
    QString standaloneDayName(int, FormatType format = LongFormat) const;

    Qt::DayOfWeek firstDayOfWeek() const;
    QList<Qt::DayOfWeek> weekdays() const;

    QString amText() const;
    QString pmText() const;

    MeasurementSystem measurementSystem() const;

    Qt::LayoutDirection textDirection() const;

    QString toUpper(const QString &str) const;
    QString toLower(const QString &str) const;

    QString currencySymbol(CurrencySymbolFormat = CurrencySymbol) const;
    QString toCurrencyString(qlonglong, const QString &symbol = QString()) const;
    QString toCurrencyString(qulonglong, const QString &symbol = QString()) const;
    inline QString toCurrencyString(short, const QString &symbol = QString()) const;
    inline QString toCurrencyString(ushort, const QString &symbol = QString()) const;
    inline QString toCurrencyString(int, const QString &symbol = QString()) const;
    inline QString toCurrencyString(uint, const QString &symbol = QString()) const;
    QString toCurrencyString(double, const QString &symbol = QString()) const;
    inline QString toCurrencyString(float, const QString &symbol = QString()) const;

    QStringList uiLanguages() const;

    bool operator==(const QLocale &other) const;
    bool operator!=(const QLocale &other) const;

    static QString languageToString(Language language);
    static QString countryToString(Country country);
    static QString scriptToString(Script script);
    static void setDefault(const QLocale &locale);

    static QLocale c() { return QLocale(C); }
    static QLocale system();

    static QList<QLocale> matchingLocales(QLocale::Language language, QLocale::Script script, QLocale::Country country);
    static QList<Country> countriesForLanguage(Language lang);

    void setNumberOptions(NumberOptions options);
    NumberOptions numberOptions() const;

    enum QuotationStyle { StandardQuotation, AlternateQuotation };
    QString quoteString(const QString &str, QuotationStyle style = StandardQuotation) const;
    QString quoteString(const QStringRef &str, QuotationStyle style = StandardQuotation) const;

    QString createSeparatedList(const QStringList &strl) const;

private:
    QLocale(QLocalePrivate &dd);
    friend class QLocalePrivate;
    QSharedDataPointer<QLocalePrivate> d;
};
template<> class QTypeInfo<QLocale > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QLocale)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QLocale >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QLocale) }; static inline const char *name() { return "QLocale"; } };
 inline QFlags<QLocale::NumberOptions::enum_type> operator|(QLocale::NumberOptions::enum_type f1, QLocale::NumberOptions::enum_type f2) { return QFlags<QLocale::NumberOptions::enum_type>(f1) | f2; } inline QFlags<QLocale::NumberOptions::enum_type> operator|(QLocale::NumberOptions::enum_type f1, QFlags<QLocale::NumberOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QLocale::NumberOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

inline QString QLocale::toString(short i) const
    { return toString(qlonglong(i)); }
inline QString QLocale::toString(ushort i) const
    { return toString(qulonglong(i)); }
inline QString QLocale::toString(int i) const
    { return toString(qlonglong(i)); }
inline QString QLocale::toString(uint i) const
    { return toString(qulonglong(i)); }
inline QString QLocale::toString(float i, char f, int prec) const
    { return toString(double(i), f, prec); }

inline QString QLocale::toCurrencyString(short i, const QString &symbol) const
    { return toCurrencyString(qlonglong(i), symbol); }
inline QString QLocale::toCurrencyString(ushort i, const QString &symbol) const
    { return toCurrencyString(qulonglong(i), symbol); }
inline QString QLocale::toCurrencyString(int i, const QString &symbol) const
{ return toCurrencyString(qlonglong(i), symbol); }
inline QString QLocale::toCurrencyString(uint i, const QString &symbol) const
{ return toCurrencyString(qulonglong(i), symbol); }
inline QString QLocale::toCurrencyString(float i, const QString &symbol) const
{ return toCurrencyString(double(i), symbol); }


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QLocale &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QLocale &);



__declspec(dllimport) QDebug operator<<(QDebug, const QLocale &);
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtextstream.h"
#line 60 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qtextstream.h"
class QTextCodec;
class QTextDecoder;

class QTextStreamPrivate;
class __declspec(dllimport) QTextStream
{
    inline QTextStreamPrivate* d_func() { return reinterpret_cast<QTextStreamPrivate *>(qGetPtrHelper(d_ptr)); } inline const QTextStreamPrivate* d_func() const { return reinterpret_cast<const QTextStreamPrivate *>(qGetPtrHelper(d_ptr)); } friend class QTextStreamPrivate;

public:
    enum RealNumberNotation {
        SmartNotation,
        FixedNotation,
        ScientificNotation
    };
    enum FieldAlignment {
        AlignLeft,
        AlignRight,
        AlignCenter,
        AlignAccountingStyle
    };
    enum Status {
        Ok,
        ReadPastEnd,
        ReadCorruptData,
        WriteFailed
    };
    enum NumberFlag {
        ShowBase = 0x1,
        ForcePoint = 0x2,
        ForceSign = 0x4,
        UppercaseBase = 0x8,
        UppercaseDigits = 0x10
    };
    typedef QFlags<NumberFlag> NumberFlags;

    QTextStream();
    explicit QTextStream(QIODevice *device);
    explicit QTextStream(FILE *fileHandle, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    explicit QTextStream(QString *string, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    explicit QTextStream(QByteArray *array, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    explicit QTextStream(const QByteArray &array, QIODevice::OpenMode openMode = QIODevice::ReadOnly);
    virtual ~QTextStream();


    void setCodec(QTextCodec *codec);
    void setCodec(const char *codecName);
    QTextCodec *codec() const;
    void setAutoDetectUnicode(bool enabled);
    bool autoDetectUnicode() const;
    void setGenerateByteOrderMark(bool generate);
    bool generateByteOrderMark() const;


    void setLocale(const QLocale &locale);
    QLocale locale() const;

    void setDevice(QIODevice *device);
    QIODevice *device() const;

    void setString(QString *string, QIODevice::OpenMode openMode = QIODevice::ReadWrite);
    QString *string() const;

    Status status() const;
    void setStatus(Status status);
    void resetStatus();

    bool atEnd() const;
    void reset();
    void flush();
    bool seek(qint64 pos);
    qint64 pos() const;

    void skipWhiteSpace();

    QString readLine(qint64 maxlen = 0);
    QString readAll();
    QString read(qint64 maxlen);

    void setFieldAlignment(FieldAlignment alignment);
    FieldAlignment fieldAlignment() const;

    void setPadChar(QChar ch);
    QChar padChar() const;

    void setFieldWidth(int width);
    int fieldWidth() const;

    void setNumberFlags(NumberFlags flags);
    NumberFlags numberFlags() const;

    void setIntegerBase(int base);
    int integerBase() const;

    void setRealNumberNotation(RealNumberNotation notation);
    RealNumberNotation realNumberNotation() const;

    void setRealNumberPrecision(int precision);
    int realNumberPrecision() const;

    QTextStream &operator>>(QChar &ch);
    QTextStream &operator>>(char &ch);
    QTextStream &operator>>(signed short &i);
    QTextStream &operator>>(unsigned short &i);
    QTextStream &operator>>(signed int &i);
    QTextStream &operator>>(unsigned int &i);
    QTextStream &operator>>(signed long &i);
    QTextStream &operator>>(unsigned long &i);
    QTextStream &operator>>(qlonglong &i);
    QTextStream &operator>>(qulonglong &i);
    QTextStream &operator>>(float &f);
    QTextStream &operator>>(double &f);
    QTextStream &operator>>(QString &s);
    QTextStream &operator>>(QByteArray &array);
    QTextStream &operator>>(char *c);

    QTextStream &operator<<(QChar ch);
    QTextStream &operator<<(char ch);
    QTextStream &operator<<(signed short i);
    QTextStream &operator<<(unsigned short i);
    QTextStream &operator<<(signed int i);
    QTextStream &operator<<(unsigned int i);
    QTextStream &operator<<(signed long i);
    QTextStream &operator<<(unsigned long i);
    QTextStream &operator<<(qlonglong i);
    QTextStream &operator<<(qulonglong i);
    QTextStream &operator<<(float f);
    QTextStream &operator<<(double f);
    QTextStream &operator<<(const QString &s);
    QTextStream &operator<<(QLatin1String s);
    QTextStream &operator<<(const QByteArray &array);
    QTextStream &operator<<(const char *c);
    QTextStream &operator<<(const void *ptr);

private:
    QTextStream(const QTextStream &) = delete; QTextStream &operator=(const QTextStream &) = delete;
    friend class QDebugStateSaverPrivate;

    QScopedPointer<QTextStreamPrivate> d_ptr;
};

 inline QFlags<QTextStream::NumberFlags::enum_type> operator|(QTextStream::NumberFlags::enum_type f1, QTextStream::NumberFlags::enum_type f2) { return QFlags<QTextStream::NumberFlags::enum_type>(f1) | f2; } inline QFlags<QTextStream::NumberFlags::enum_type> operator|(QTextStream::NumberFlags::enum_type f1, QFlags<QTextStream::NumberFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextStream::NumberFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }





typedef QTextStream & (*QTextStreamFunction)(QTextStream &);
typedef void (QTextStream::*QTSMFI)(int);
typedef void (QTextStream::*QTSMFC)(QChar);


class __declspec(dllimport) QTextStreamManipulator
{
public:
    QTextStreamManipulator(QTSMFI m, int a) { mf = m; mc = 0; arg = a; }
    QTextStreamManipulator(QTSMFC m, QChar c) { mf = 0; mc = m; ch = c; arg = -1; }
    void exec(QTextStream &s) { if (mf) { (s.*mf)(arg); } else { (s.*mc)(ch); } }

private:
    QTSMFI mf;
    QTSMFC mc;
    int arg;
    QChar ch;
};

inline QTextStream &operator>>(QTextStream &s, QTextStreamFunction f)
{ return (*f)(s); }

inline QTextStream &operator<<(QTextStream &s, QTextStreamFunction f)
{ return (*f)(s); }

inline QTextStream &operator<<(QTextStream &s, QTextStreamManipulator m)
{ m.exec(s); return s; }

__declspec(dllimport) QTextStream &bin(QTextStream &s);
__declspec(dllimport) QTextStream &oct(QTextStream &s);
__declspec(dllimport) QTextStream &dec(QTextStream &s);
__declspec(dllimport) QTextStream &hex(QTextStream &s);

__declspec(dllimport) QTextStream &showbase(QTextStream &s);
__declspec(dllimport) QTextStream &forcesign(QTextStream &s);
__declspec(dllimport) QTextStream &forcepoint(QTextStream &s);
__declspec(dllimport) QTextStream &noshowbase(QTextStream &s);
__declspec(dllimport) QTextStream &noforcesign(QTextStream &s);
__declspec(dllimport) QTextStream &noforcepoint(QTextStream &s);

__declspec(dllimport) QTextStream &uppercasebase(QTextStream &s);
__declspec(dllimport) QTextStream &uppercasedigits(QTextStream &s);
__declspec(dllimport) QTextStream &lowercasebase(QTextStream &s);
__declspec(dllimport) QTextStream &lowercasedigits(QTextStream &s);

__declspec(dllimport) QTextStream &fixed(QTextStream &s);
__declspec(dllimport) QTextStream &scientific(QTextStream &s);

__declspec(dllimport) QTextStream &left(QTextStream &s);
__declspec(dllimport) QTextStream &right(QTextStream &s);
__declspec(dllimport) QTextStream &center(QTextStream &s);

__declspec(dllimport) QTextStream &endl(QTextStream &s);
__declspec(dllimport) QTextStream &flush(QTextStream &s);
__declspec(dllimport) QTextStream &reset(QTextStream &s);

__declspec(dllimport) QTextStream &bom(QTextStream &s);

__declspec(dllimport) QTextStream &ws(QTextStream &s);

inline QTextStreamManipulator qSetFieldWidth(int width)
{
    QTSMFI func = &QTextStream::setFieldWidth;
    return QTextStreamManipulator(func,width);
}

inline QTextStreamManipulator qSetPadChar(QChar ch)
{
    QTSMFC func = &QTextStream::setPadChar;
    return QTextStreamManipulator(func, ch);
}

inline QTextStreamManipulator qSetRealNumberPrecision(int precision)
{
    QTSMFI func = &QTextStream::setRealNumberPrecision;
    return QTextStreamManipulator(func, precision);
}
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qdebug.h"




#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h"
struct __declspec(dllimport) QContiguousCacheData
{
    QBasicAtomicInt ref;
    int alloc;
    int count;
    int start;
    int offset;
    uint sharable : 1;
    uint reserved : 31;






    static QContiguousCacheData *allocateData(int size, int alignment);
    static void freeData(QContiguousCacheData *data);




};

template <typename T>
struct QContiguousCacheTypedData: private QContiguousCacheData
{

    T array[1];

    static inline void freeData(QContiguousCacheTypedData *data) { QContiguousCacheData::freeData(data); }
};

template<typename T>
class QContiguousCache {
    typedef QContiguousCacheTypedData<T> Data;
    union { QContiguousCacheData *d; QContiguousCacheTypedData<T> *p; };
public:

    typedef T value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef qptrdiff difference_type;
    typedef int size_type;

    explicit QContiguousCache(int capacity = 0);
    QContiguousCache(const QContiguousCache<T> &v) : d(v.d) { d->ref.ref(); if (!d->sharable) detach_helper(); }

    inline ~QContiguousCache() { if (!d) return; if (!d->ref.deref()) freeData(p); }

    inline void detach() { if (d->ref.load() != 1) detach_helper(); }
    inline bool isDetached() const { return d->ref.load() == 1; }

    inline void setSharable(bool sharable) { if (!sharable) detach(); d->sharable = sharable; }


    QContiguousCache<T> &operator=(const QContiguousCache<T> &other);

    inline QContiguousCache<T> &operator=(QContiguousCache<T> &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QContiguousCache<T> &other) { qSwap(d, other.d); }
    bool operator==(const QContiguousCache<T> &other) const;
    inline bool operator!=(const QContiguousCache<T> &other) const { return !(*this == other); }

    inline int capacity() const {return d->alloc; }
    inline int count() const { return d->count; }
    inline int size() const { return d->count; }

    inline bool isEmpty() const { return d->count == 0; }
    inline bool isFull() const { return d->count == d->alloc; }
    inline int available() const { return d->alloc - d->count; }

    void clear();
    void setCapacity(int size);

    const T &at(int pos) const;
    T &operator[](int i);
    const T &operator[](int i) const;

    void append(const T &value);
    void prepend(const T &value);
    void insert(int pos, const T &value);

    inline bool containsIndex(int pos) const { return pos >= d->offset && pos - d->offset < d->count; }
    inline int firstIndex() const { return d->offset; }
    inline int lastIndex() const { return d->offset + d->count - 1; }

    inline const T &first() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h",143) : qt_noop()); return p->array[d->start]; }
    inline const T &last() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h",144) : qt_noop()); return p->array[(d->start + d->count -1) % d->alloc]; }
    inline T &first() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h",145) : qt_noop()); detach(); return p->array[d->start]; }
    inline T &last() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h",146) : qt_noop()); detach(); return p->array[(d->start + d->count -1) % d->alloc]; }

    void removeFirst();
    T takeFirst();
    void removeLast();
    T takeLast();

    inline bool areIndexesValid() const
    { return d->offset >= 0 && d->offset < 2147483647 - d->count && (d->offset % d->alloc) == d->start; }

    inline void normalizeIndexes() { d->offset = d->start; }




private:
    void detach_helper();

    QContiguousCacheData *allocateData(int aalloc);
    void freeData(Data *x);
    int sizeOfTypedData() {


        return reinterpret_cast<const char *>(&(reinterpret_cast<const Data *>(this))->array[1]) - reinterpret_cast<const char *>(this);
    }
    int alignOfTypedData() const
    {
        return qMax<int>(sizeof(void*), __alignof(Data));
    }
};

template <typename T>
void QContiguousCache<T>::detach_helper()
{
    union { QContiguousCacheData *d; QContiguousCacheTypedData<T> *p; } x;

    x.d = allocateData(d->alloc);
    x.d->ref.store(1);
    x.d->count = d->count;
    x.d->start = d->start;
    x.d->offset = d->offset;
    x.d->alloc = d->alloc;
    x.d->sharable = true;
    x.d->reserved = 0;

    T *dest = x.p->array + x.d->start;
    T *src = p->array + d->start;
    int oldcount = x.d->count;
    while (oldcount--) {
        if (QTypeInfo<T>::isComplex) {
            new (dest) T(*src);
        } else {
            *dest = *src;
        }
        dest++;
        if (dest == x.p->array + x.d->alloc)
            dest = x.p->array;
        src++;
        if (src == p->array + d->alloc)
            src = p->array;
    }

    if (!d->ref.deref())
        freeData(p);
    d = x.d;
}

template <typename T>
void QContiguousCache<T>::setCapacity(int asize)
{
    if (asize == d->alloc)
        return;
    detach();
    union { QContiguousCacheData *d; QContiguousCacheTypedData<T> *p; } x;
    x.d = allocateData(asize);
    x.d->alloc = asize;
    x.d->count = qMin(d->count, asize);
    x.d->offset = d->offset + d->count - x.d->count;
    if(asize)
        x.d->start = x.d->offset % x.d->alloc;
    else
        x.d->start = 0;

    int oldcount = x.d->count;
    if(oldcount)
    {
        T *dest = x.p->array + (x.d->start + x.d->count-1) % x.d->alloc;
        T *src = p->array + (d->start + d->count-1) % d->alloc;
        while (oldcount--) {
            if (QTypeInfo<T>::isComplex) {
                new (dest) T(*src);
            } else {
                *dest = *src;
            }
            if (dest == x.p->array)
                dest = x.p->array + x.d->alloc;
            dest--;
            if (src == p->array)
                src = p->array + d->alloc;
            src--;
        }
    }

    freeData(p);
    d = x.d;
}

template <typename T>
void QContiguousCache<T>::clear()
{
    if (d->ref.load() == 1) {
        if (QTypeInfo<T>::isComplex) {
            int oldcount = d->count;
            T * i = p->array + d->start;
            T * e = p->array + d->alloc;
            while (oldcount--) {
                i->~T();
                i++;
                if (i == e)
                    i = p->array;
            }
        }
        d->count = d->start = d->offset = 0;
    } else {
        union { QContiguousCacheData *d; QContiguousCacheTypedData<T> *p; } x;
        x.d = allocateData(d->alloc);
        x.d->ref.store(1);
        x.d->alloc = d->alloc;
        x.d->count = x.d->start = x.d->offset = 0;
        x.d->sharable = true;
        if (!d->ref.deref()) freeData(p);
        d = x.d;
    }
}

template <typename T>
inline QContiguousCacheData *QContiguousCache<T>::allocateData(int aalloc)
{
    return QContiguousCacheData::allocateData(sizeOfTypedData() + (aalloc - 1) * sizeof(T), alignOfTypedData());
}

template <typename T>
QContiguousCache<T>::QContiguousCache(int cap)
{
    d = allocateData(cap);
    d->ref.store(1);
    d->alloc = cap;
    d->count = d->start = d->offset = 0;
    d->sharable = true;
}

template <typename T>
QContiguousCache<T> &QContiguousCache<T>::operator=(const QContiguousCache<T> &other)
{
    other.d->ref.ref();
    if (!d->ref.deref())
        freeData(d);
    d = other.d;
    if (!d->sharable)
        detach_helper();
    return *this;
}

template <typename T>
bool QContiguousCache<T>::operator==(const QContiguousCache<T> &other) const
{
    if (other.d == d)
        return true;
    if (other.d->start != d->start
            || other.d->count != d->count
            || other.d->offset != d->offset
            || other.d->alloc != d->alloc)
        return false;
    for (int i = firstIndex(); i <= lastIndex(); ++i)
        if (!(at(i) == other.at(i)))
            return false;
    return true;
}

template <typename T>
void QContiguousCache<T>::freeData(Data *x)
{
    if (QTypeInfo<T>::isComplex) {
        int oldcount = d->count;
        T * i = p->array + d->start;
        T * e = p->array + d->alloc;
        while (oldcount--) {
            i->~T();
            i++;
            if (i == e)
                i = p->array;
        }
    }
    x->freeData(x);
}
template <typename T>
void QContiguousCache<T>::append(const T &value)
{
    if (!d->alloc)
        return;
    detach();
    if (QTypeInfo<T>::isComplex) {
        if (d->count == d->alloc)
            (p->array + (d->start+d->count) % d->alloc)->~T();
        new (p->array + (d->start+d->count) % d->alloc) T(value);
    } else {
        p->array[(d->start+d->count) % d->alloc] = value;
    }

    if (d->count == d->alloc) {
        d->start++;
        d->start %= d->alloc;
        d->offset++;
    } else {
        d->count++;
    }
}

template<typename T>
void QContiguousCache<T>::prepend(const T &value)
{
    if (!d->alloc)
        return;
    detach();
    if (d->start)
        d->start--;
    else
        d->start = d->alloc-1;
    d->offset--;

    if (d->count != d->alloc)
        d->count++;
    else
        if (d->count == d->alloc)
            (p->array + d->start)->~T();

    if (QTypeInfo<T>::isComplex)
        new (p->array + d->start) T(value);
    else
        p->array[d->start] = value;
}

template<typename T>
void QContiguousCache<T>::insert(int pos, const T &value)
{
    ((!(pos >= 0 && pos < 2147483647)) ? qt_assert_x("QContiguousCache<T>::insert", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h",391) : qt_noop());
    if (!d->alloc)
        return;
    detach();
    if (containsIndex(pos)) {
        if (QTypeInfo<T>::isComplex) {
            (p->array + pos % d->alloc)->~T();
            new (p->array + pos % d->alloc) T(value);
        } else {
            p->array[pos % d->alloc] = value;
        }
    } else if (pos == d->offset-1)
        prepend(value);
    else if (pos == d->offset+d->count)
        append(value);
    else {

        clear();
        d->offset = pos;
        d->start = pos % d->alloc;
        d->count = 1;
        if (QTypeInfo<T>::isComplex)
            new (p->array + d->start) T(value);
        else
            p->array[d->start] = value;
    }
}

template <typename T>
inline const T &QContiguousCache<T>::at(int pos) const
{ ((!(pos >= d->offset && pos - d->offset < d->count)) ? qt_assert_x("QContiguousCache<T>::at", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h",421) : qt_noop()); return p->array[pos % d->alloc]; }
template <typename T>
inline const T &QContiguousCache<T>::operator[](int pos) const
{ ((!(pos >= d->offset && pos - d->offset < d->count)) ? qt_assert_x("QContiguousCache<T>::at", "index out of range","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h",424) : qt_noop()); return p->array[pos % d->alloc]; }

template <typename T>
inline T &QContiguousCache<T>::operator[](int pos)
{
    detach();
    if (!containsIndex(pos))
        insert(pos, T());
    return p->array[pos % d->alloc];
}

template <typename T>
inline void QContiguousCache<T>::removeFirst()
{
    ((!(d->count > 0)) ? qt_assert("d->count > 0","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h",438) : qt_noop());
    detach();
    d->count--;
    if (QTypeInfo<T>::isComplex)
        (p->array + d->start)->~T();
    d->start = (d->start + 1) % d->alloc;
    d->offset++;
}

template <typename T>
inline void QContiguousCache<T>::removeLast()
{
    ((!(d->count > 0)) ? qt_assert("d->count > 0","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qcontiguouscache.h",450) : qt_noop());
    detach();
    d->count--;
    if (QTypeInfo<T>::isComplex)
        (p->array + (d->start + d->count) % d->alloc)->~T();
}

template <typename T>
inline T QContiguousCache<T>::takeFirst()
{ T t = first(); removeFirst(); return t; }

template <typename T>
inline T QContiguousCache<T>::takeLast()
{ T t = last(); removeLast(); return t; }
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qdebug.h"





class __declspec(dllimport) QDebug
{
    friend class QMessageLogger;
    friend class QDebugStateSaverPrivate;
    struct Stream {
        Stream(QIODevice *device) : ts(device), ref(1), type(QtDebugMsg), space(true), message_output(false) {}
        Stream(QString *string) : ts(string, QIODevice::WriteOnly), ref(1), type(QtDebugMsg), space(true), message_output(false) {}
        Stream(QtMsgType t) : ts(&buffer, QIODevice::WriteOnly), ref(1), type(t), space(true), message_output(true) {}
        QTextStream ts;
        QString buffer;
        int ref;
        QtMsgType type;
        bool space;
        bool message_output;
        QMessageLogContext context;
    } *stream;
public:
    inline QDebug(QIODevice *device) : stream(new Stream(device)) {}
    inline QDebug(QString *string) : stream(new Stream(string)) {}
    inline QDebug(QtMsgType t) : stream(new Stream(t)) {}
    inline QDebug(const QDebug &o):stream(o.stream) { ++stream->ref; }
    inline QDebug &operator=(const QDebug &other);
    inline ~QDebug() {
        if (!--stream->ref) {
            if (stream->space && stream->buffer.endsWith(QLatin1Char(' ')))
                stream->buffer.chop(1);
            if (stream->message_output) {
                try {
                    qt_message_output(stream->type,
                                      stream->context,
                                      stream->buffer);
                } catch (std::bad_alloc&) { }
            }
            delete stream;
        }
    }
    inline void swap(QDebug &other) { qSwap(stream, other.stream); }

    inline QDebug &space() { stream->space = true; stream->ts << ' '; return *this; }
    inline QDebug &nospace() { stream->space = false; return *this; }
    inline QDebug &maybeSpace() { if (stream->space) stream->ts << ' '; return *this; }

    bool autoInsertSpaces() const { return stream->space; }
    void setAutoInsertSpaces(bool b) { stream->space = b; }

    inline QDebug &operator<<(QChar t) { stream->ts << '\'' << t << '\''; return maybeSpace(); }
    inline QDebug &operator<<(bool t) { stream->ts << (t ? "true" : "false"); return maybeSpace(); }
    inline QDebug &operator<<(char t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(signed short t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(unsigned short t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(signed int t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(unsigned int t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(signed long t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(unsigned long t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(qint64 t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(quint64 t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(float t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(double t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(const char* t) { stream->ts << QString::fromUtf8(t); return maybeSpace(); }
    inline QDebug &operator<<(const QString & t) { stream->ts << '\"' << t << '\"'; return maybeSpace(); }
    inline QDebug &operator<<(const QStringRef & t) { return operator<<(t.toString()); }
    inline QDebug &operator<<(QLatin1String t) { stream->ts << '\"' << t << '\"'; return maybeSpace(); }
    inline QDebug &operator<<(const QByteArray & t) { stream->ts << '\"' << t << '\"'; return maybeSpace(); }
    inline QDebug &operator<<(const void * t) { stream->ts << t; return maybeSpace(); }
    inline QDebug &operator<<(QTextStreamFunction f) {
        stream->ts << f;
        return *this;
    }

    inline QDebug &operator<<(QTextStreamManipulator m)
    { stream->ts << m; return *this; }
};

template<> class QTypeInfo<QDebug > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QDebug)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QDebug >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QDebug) }; static inline const char *name() { return "QDebug"; } }; template <> inline void qSwap<QDebug>(QDebug &value1, QDebug &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QDebug >(::QDebug &value1, ::QDebug &value2) { value1.swap(value2); } }

class QDebugStateSaverPrivate;
class __declspec(dllimport) QDebugStateSaver
{
public:
    QDebugStateSaver(QDebug &dbg);
    ~QDebugStateSaver();
private:
    QDebugStateSaver(const QDebugStateSaver &) = delete; QDebugStateSaver &operator=(const QDebugStateSaver &) = delete;
    QScopedPointer<QDebugStateSaverPrivate> d;
};

class QNoDebug
{
public:
    inline QNoDebug &operator<<(QTextStreamFunction) { return *this; }
    inline QNoDebug &operator<<(QTextStreamManipulator) { return *this; }
    inline QNoDebug &space() { return *this; }
    inline QNoDebug &nospace() { return *this; }
    inline QNoDebug &maybeSpace() { return *this; }

    template<typename T>
    inline QNoDebug &operator<<(const T &) { return *this; }
};

inline QDebug &QDebug::operator=(const QDebug &other)
{
    if (this != &other) {
        QDebug copy(other);
        qSwap(stream, copy.stream);
    }
    return *this;
}





template <class T>
inline QDebug operator<<(QDebug debug, const QList<T> &list)

{
    const bool oldSetting = debug.autoInsertSpaces();
    debug.nospace() << '(';
    for (typename QList<T>::size_type i = 0; i < list.count(); ++i) {
        if (i)
            debug << ", ";
        debug << list.at(i);
    }
    debug << ')';
    debug.setAutoInsertSpaces(oldSetting);
    return debug.maybeSpace();
}





template <typename T>
inline QDebug operator<<(QDebug debug, const QVector<T> &vec)

{
    const bool oldSetting = debug.autoInsertSpaces();
    debug.nospace() << "QVector";
    debug.setAutoInsertSpaces(oldSetting);
    return operator<<(debug, vec.toList());
}





template <class aKey, class aT>
inline QDebug operator<<(QDebug debug, const QMap<aKey, aT> &map)

{
    const bool oldSetting = debug.autoInsertSpaces();
    debug.nospace() << "QMap(";
    for (typename QMap<aKey, aT>::const_iterator it = map.constBegin();
         it != map.constEnd(); ++it) {
        debug << '(' << it.key() << ", " << it.value() << ')';
    }
    debug << ')';
    debug.setAutoInsertSpaces(oldSetting);
    return debug.maybeSpace();
}





template <class aKey, class aT>
inline QDebug operator<<(QDebug debug, const QHash<aKey, aT> &hash)

{
    const bool oldSetting = debug.autoInsertSpaces();
    debug.nospace() << "QHash(";
    for (typename QHash<aKey, aT>::const_iterator it = hash.constBegin();
            it != hash.constEnd(); ++it)
        debug << '(' << it.key() << ", " << it.value() << ')';
    debug << ')';
    debug.setAutoInsertSpaces(oldSetting);
    return debug.maybeSpace();
}





template <class T1, class T2>
inline QDebug operator<<(QDebug debug, const QPair<T1, T2> &pair)

{
    const bool oldSetting = debug.autoInsertSpaces();
    debug.nospace() << "QPair(" << pair.first << ',' << pair.second << ')';
    debug.setAutoInsertSpaces(oldSetting);
    return debug.maybeSpace();
}

template <typename T>
inline QDebug operator<<(QDebug debug, const QSet<T> &set)
{
    const bool oldSetting = debug.autoInsertSpaces();
    debug.nospace() << "QSet";
    debug.setAutoInsertSpaces(oldSetting);
    return operator<<(debug, set.toList());
}





template <class T>
inline QDebug operator<<(QDebug debug, const QContiguousCache<T> &cache)

{
    const bool oldSetting = debug.autoInsertSpaces();
    debug.nospace() << "QContiguousCache(";
    for (int i = cache.firstIndex(); i <= cache.lastIndex(); ++i) {
        debug << cache[i];
        if (i != cache.lastIndex())
            debug << ", ";
    }
    debug << ')';
    debug.setAutoInsertSpaces(oldSetting);
    return debug.maybeSpace();
}





template <class T>
inline QDebug operator<<(QDebug debug, const QFlags<T> &flags)

{
    const bool oldSetting = debug.autoInsertSpaces();
    debug.nospace() << "QFlags(";
    bool needSeparator = false;
    for (uint i = 0; i < sizeof(T) * 8; ++i) {
        if (flags.testFlag(T(1 << i))) {
            if (needSeparator)
                debug.nospace() << '|';
            else
                needSeparator = true;
            debug.nospace() << "0x" << QByteArray::number(typename QFlags<T>::Int(1) << i, 16).constData();
        }
    }
    debug << ')';
    debug.setAutoInsertSpaces(oldSetting);
    return debug.maybeSpace();
}
#line 28 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qdiriterator.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qdiriterator.h"
class QDirIteratorPrivate;
class __declspec(dllimport) QDirIterator {
public:
    enum IteratorFlag {
        NoIteratorFlags = 0x0,
        FollowSymlinks = 0x1,
        Subdirectories = 0x2
    };
    typedef QFlags<IteratorFlag> IteratorFlags;

    QDirIterator(const QDir &dir, IteratorFlags flags = NoIteratorFlags);
    QDirIterator(const QString &path,
                 IteratorFlags flags = NoIteratorFlags);
    QDirIterator(const QString &path,
                 QDir::Filters filter,
                 IteratorFlags flags = NoIteratorFlags);
    QDirIterator(const QString &path,
                 const QStringList &nameFilters,
                 QDir::Filters filters = QDir::NoFilter,
                 IteratorFlags flags = NoIteratorFlags);

    ~QDirIterator();

    QString next();
    bool hasNext() const;

    QString fileName() const;
    QString filePath() const;
    QFileInfo fileInfo() const;
    QString path() const;

private:
    QDirIterator(const QDirIterator &) = delete; QDirIterator &operator=(const QDirIterator &) = delete;

    QScopedPointer<QDirIteratorPrivate> d;
    friend class QDir;
};

 inline QFlags<QDirIterator::IteratorFlags::enum_type> operator|(QDirIterator::IteratorFlags::enum_type f1, QDirIterator::IteratorFlags::enum_type f2) { return QFlags<QDirIterator::IteratorFlags::enum_type>(f1) | f2; } inline QFlags<QDirIterator::IteratorFlags::enum_type> operator|(QDirIterator::IteratorFlags::enum_type f1, QFlags<QDirIterator::IteratorFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QDirIterator::IteratorFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
#line 30 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"




#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfileselector.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfileselector.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QObject"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfileselector.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QStringList"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfileselector.h"




class QFileSelectorPrivate;
class __declspec(dllimport) QFileSelector : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    explicit QFileSelector(QObject *parent = 0);
    ~QFileSelector();

    QString select(const QString &filePath) const;
    QUrl select(const QUrl &filePath) const;

    QStringList extraSelectors() const;
    void setExtraSelectors(const QStringList &list);

    QStringList allSelectors() const;

private:
    inline QFileSelectorPrivate* d_func() { return reinterpret_cast<QFileSelectorPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFileSelectorPrivate* d_func() const { return reinterpret_cast<const QFileSelectorPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFileSelectorPrivate;
};
#line 34 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfilesystemwatcher.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfilesystemwatcher.h"
class QFileSystemWatcherPrivate;

class __declspec(dllimport) QFileSystemWatcher : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QFileSystemWatcherPrivate* d_func() { return reinterpret_cast<QFileSystemWatcherPrivate *>(qGetPtrHelper(d_ptr)); } inline const QFileSystemWatcherPrivate* d_func() const { return reinterpret_cast<const QFileSystemWatcherPrivate *>(qGetPtrHelper(d_ptr)); } friend class QFileSystemWatcherPrivate;

public:
    QFileSystemWatcher(QObject *parent = 0);
    QFileSystemWatcher(const QStringList &paths, QObject *parent = 0);
    ~QFileSystemWatcher();

    bool addPath(const QString &file);
    QStringList addPaths(const QStringList &files);
    bool removePath(const QString &file);
    QStringList removePaths(const QStringList &files);

    QStringList files() const;
    QStringList directories() const;

public:
    void fileChanged(const QString &path

        , QPrivateSignal

    );
    void directoryChanged(const QString &path

        , QPrivateSignal

    );

private:


};
#line 35 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlockfile.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlockfile.h"
class QLockFilePrivate;

class __declspec(dllimport) QLockFile
{
public:
    QLockFile(const QString &fileName);
    ~QLockFile();

    bool lock();
    bool tryLock(int timeout = 0);
    void unlock();

    void setStaleLockTime(int);
    int staleLockTime() const;

    bool isLocked() const;
    bool getLockInfo(qint64 *pid, QString *hostname, QString *appname) const;
    bool removeStaleLockFile();

    enum LockError {
        NoError = 0,
        LockFailedError = 1,
        PermissionError = 2,
        UnknownError = 3
    };
    LockError error() const;

protected:
    QScopedPointer<QLockFilePrivate> d_ptr;

private:
    inline QLockFilePrivate* d_func() { return reinterpret_cast<QLockFilePrivate *>(qGetPtrHelper(d_ptr)); } inline const QLockFilePrivate* d_func() const { return reinterpret_cast<const QLockFilePrivate *>(qGetPtrHelper(d_ptr)); } friend class QLockFilePrivate;
    QLockFile(const QLockFile &) = delete; QLockFile &operator=(const QLockFile &) = delete;
};
#line 37 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qloggingcategory.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qloggingcategory.h"
class __declspec(dllimport) QLoggingCategory
{
    QLoggingCategory(const QLoggingCategory &) = delete; QLoggingCategory &operator=(const QLoggingCategory &) = delete;
public:
    explicit QLoggingCategory(const char *category);
    ~QLoggingCategory();

    bool isEnabled(QtMsgType type) const;
    void setEnabled(QtMsgType type, bool enable);






    bool isDebugEnabled() const { return enabled.load() >> DebugShift & 1; }
    bool isWarningEnabled() const { return enabled.load() >> WarningShift & 1; }
    bool isCriticalEnabled() const { return enabled.load() >> CriticalShift & 1; }

    const char *categoryName() const { return name; }


    QLoggingCategory &operator()() { return *this; }
    const QLoggingCategory &operator()() const { return *this; }

    static QLoggingCategory *defaultCategory();

    typedef void (*CategoryFilter)(QLoggingCategory*);
    static CategoryFilter installFilter(CategoryFilter);

    static void setFilterRules(const QString &rules);

private:
    void *d;
    const char *name;


    enum { DebugShift = 0, WarningShift = 8, CriticalShift = 16 };




    struct AtomicBools {





    };
    union {
        AtomicBools bools;
        QBasicAtomicInt enabled;
    };
    bool placeholder[4];
};
#line 38 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qresource.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qresource.h"
class QResourcePrivate;

class __declspec(dllimport) QResource
{
public:
    QResource(const QString &file=QString(), const QLocale &locale=QLocale());
    ~QResource();

    void setFileName(const QString &file);
    QString fileName() const;
    QString absoluteFilePath() const;

    void setLocale(const QLocale &locale);
    QLocale locale() const;

    bool isValid() const;

    bool isCompressed() const;
    qint64 size() const;
    const uchar *data() const;

    static void addSearchPath(const QString &path);
    static QStringList searchPaths();

    static bool registerResource(const QString &rccFilename, const QString &resourceRoot=QString());
    static bool unregisterResource(const QString &rccFilename, const QString &resourceRoot=QString());

    static bool registerResource(const uchar *rccData, const QString &resourceRoot=QString());
    static bool unregisterResource(const uchar *rccData, const QString &resourceRoot=QString());

protected:
    friend class QResourceFileEngine;
    friend class QResourceFileEngineIterator;
    bool isDir() const;
    inline bool isFile() const { return !isDir(); }
    QStringList children() const;

protected:
    QScopedPointer<QResourcePrivate> d_ptr;

private:
    inline QResourcePrivate* d_func() { return reinterpret_cast<QResourcePrivate *>(qGetPtrHelper(d_ptr)); } inline const QResourcePrivate* d_func() const { return reinterpret_cast<const QResourcePrivate *>(qGetPtrHelper(d_ptr)); } friend class QResourcePrivate;
};
#line 40 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsavefile.h"
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsavefile.h"
class QAbstractFileEngine;
class QSaveFilePrivate;

class __declspec(dllimport) QSaveFile : public QFileDevice
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QSaveFilePrivate* d_func() { return reinterpret_cast<QSaveFilePrivate *>(qGetPtrHelper(d_ptr)); } inline const QSaveFilePrivate* d_func() const { return reinterpret_cast<const QSaveFilePrivate *>(qGetPtrHelper(d_ptr)); } friend class QSaveFilePrivate;

public:

    explicit QSaveFile(const QString &name);
    explicit QSaveFile(QObject *parent = 0);
    explicit QSaveFile(const QString &name, QObject *parent);
    ~QSaveFile();

    QString fileName() const override;
    void setFileName(const QString &name);

    bool open(OpenMode flags) override;
    bool commit();

    void cancelWriting();

    void setDirectWriteFallback(bool enabled);
    bool directWriteFallback() const;

protected:
    qint64 writeData(const char *data, qint64 len) override;

private:
    void close() override;

private:
    QSaveFile(const QSaveFile &) = delete; QSaveFile &operator=(const QSaveFile &) = delete;
};
#line 41 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsettings.h"
#line 63 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsettings.h"
class QIODevice;
class QSettingsPrivate;


class __declspec(dllimport) QSettings : public QObject



{

    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};



    inline QSettingsPrivate* d_func() { return reinterpret_cast<QSettingsPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSettingsPrivate* d_func() const { return reinterpret_cast<const QSettingsPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSettingsPrivate;

public:
    enum Status {
        NoError = 0,
        AccessError,
        FormatError
    };

    enum Format {
        NativeFormat,
        IniFormat,

        InvalidFormat = 16,
        CustomFormat1,
        CustomFormat2,
        CustomFormat3,
        CustomFormat4,
        CustomFormat5,
        CustomFormat6,
        CustomFormat7,
        CustomFormat8,
        CustomFormat9,
        CustomFormat10,
        CustomFormat11,
        CustomFormat12,
        CustomFormat13,
        CustomFormat14,
        CustomFormat15,
        CustomFormat16
    };

    enum Scope {
        UserScope,
        SystemScope
    };


    explicit QSettings(const QString &organization,
                       const QString &application = QString(), QObject *parent = 0);
    QSettings(Scope scope, const QString &organization,
              const QString &application = QString(), QObject *parent = 0);
    QSettings(Format format, Scope scope, const QString &organization,
              const QString &application = QString(), QObject *parent = 0);
    QSettings(const QString &fileName, Format format, QObject *parent = 0);
    explicit QSettings(QObject *parent = 0);
#line 132 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsettings.h"
    ~QSettings();

    void clear();
    void sync();
    Status status() const;

    void beginGroup(const QString &prefix);
    void endGroup();
    QString group() const;

    int beginReadArray(const QString &prefix);
    void beginWriteArray(const QString &prefix, int size = -1);
    void endArray();
    void setArrayIndex(int i);

    QStringList allKeys() const;
    QStringList childKeys() const;
    QStringList childGroups() const;
    bool isWritable() const;

    void setValue(const QString &key, const QVariant &value);
    QVariant value(const QString &key, const QVariant &defaultValue = QVariant()) const;

    void remove(const QString &key);
    bool contains(const QString &key) const;

    void setFallbacksEnabled(bool b);
    bool fallbacksEnabled() const;

    QString fileName() const;
    Format format() const;
    Scope scope() const;
    QString organizationName() const;
    QString applicationName() const;


    void setIniCodec(QTextCodec *codec);
    void setIniCodec(const char *codecName);
    QTextCodec *iniCodec() const;


    static void setDefaultFormat(Format format);
    static Format defaultFormat();
    static void setSystemIniPath(const QString &dir);
    static void setUserIniPath(const QString &dir);
    static void setPath(Format format, Scope scope, const QString &path);

    typedef QMap<QString, QVariant> SettingsMap;
    typedef bool (*ReadFunc)(QIODevice &device, SettingsMap &map);
    typedef bool (*WriteFunc)(QIODevice &device, const SettingsMap &map);

    static Format registerFormat(const QString &extension, ReadFunc readFunc, WriteFunc writeFunc,
                                 Qt::CaseSensitivity caseSensitivity = Qt::CaseSensitive);

protected:

    bool event(QEvent *event);


private:
    QSettings(const QSettings &) = delete; QSettings &operator=(const QSettings &) = delete;
};
#line 42 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstandardpaths.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstandardpaths.h"
class __declspec(dllimport) QStandardPaths
{
public:

    enum StandardLocation {
        DesktopLocation,
        DocumentsLocation,
        FontsLocation,
        ApplicationsLocation,
        MusicLocation,
        MoviesLocation,
        PicturesLocation,
        TempLocation,
        HomeLocation,
        DataLocation,
        CacheLocation,
        GenericDataLocation,
        RuntimeLocation,
        ConfigLocation,
        DownloadLocation,
        GenericCacheLocation,
        GenericConfigLocation
    };

    static QString writableLocation(StandardLocation type);
    static QStringList standardLocations(StandardLocation type);

    enum LocateOption {
        LocateFile = 0x0,
        LocateDirectory = 0x1
    };
    typedef QFlags<LocateOption> LocateOptions;

    static QString locate(StandardLocation type, const QString &fileName, LocateOptions options = LocateFile);
    static QStringList locateAll(StandardLocation type, const QString &fileName, LocateOptions options = LocateFile);

    static QString displayName(StandardLocation type);


    static QString findExecutable(const QString &executableName, const QStringList &paths = QStringList());


    static void enableTestMode(bool testMode);

    static void setTestModeEnabled(bool testMode);
    static bool isTestModeEnabled();

private:

    QStandardPaths();
    ~QStandardPaths();
};
#line 43 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtemporarydir.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtemporarydir.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QScopedPointer"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtemporarydir.h"







class QTemporaryDirPrivate;

class __declspec(dllimport) QTemporaryDir
{
public:
    QTemporaryDir();
    explicit QTemporaryDir(const QString &templateName);
    ~QTemporaryDir();

    bool isValid() const;

    bool autoRemove() const;
    void setAutoRemove(bool b);
    bool remove();

    QString path() const;

private:
    QScopedPointer<QTemporaryDirPrivate> d_ptr;

    QTemporaryDir(const QTemporaryDir &) = delete; QTemporaryDir &operator=(const QTemporaryDir &) = delete;
};
#line 44 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtemporaryfile.h"
#line 57 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtemporaryfile.h"
class QTemporaryFilePrivate;
class QLockFilePrivate;

class __declspec(dllimport) QTemporaryFile : public QFile
{

    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

    inline QTemporaryFilePrivate* d_func() { return reinterpret_cast<QTemporaryFilePrivate *>(qGetPtrHelper(d_ptr)); } inline const QTemporaryFilePrivate* d_func() const { return reinterpret_cast<const QTemporaryFilePrivate *>(qGetPtrHelper(d_ptr)); } friend class QTemporaryFilePrivate;

public:
    QTemporaryFile();
    explicit QTemporaryFile(const QString &templateName);

    explicit QTemporaryFile(QObject *parent);
    QTemporaryFile(const QString &templateName, QObject *parent);

    ~QTemporaryFile();

    bool autoRemove() const;
    void setAutoRemove(bool b);


    bool open() { return open(QIODevice::ReadWrite); }

    QString fileName() const;
    QString fileTemplate() const;
    void setFileTemplate(const QString &name);

                  inline static QTemporaryFile *createLocalFile(const QString &fileName)
        { return createNativeFile(fileName); }
                  inline static QTemporaryFile *createLocalFile(QFile &file)
        { return createNativeFile(file); }

    inline static QTemporaryFile *createNativeFile(const QString &fileName)
        { QFile file(fileName); return createNativeFile(file); }
    static QTemporaryFile *createNativeFile(QFile &file);

protected:
    bool open(OpenMode flags);

private:
    friend class QFile;
    friend class QLockFilePrivate;
    QTemporaryFile(const QTemporaryFile &) = delete; QTemporaryFile &operator=(const QTemporaryFile &) = delete;
};
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qurlquery.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qurlquery.h"
class QUrlQueryPrivate;
class __declspec(dllimport) QUrlQuery
{
public:
    QUrlQuery();
    explicit QUrlQuery(const QUrl &url);
    explicit QUrlQuery(const QString &queryString);
    QUrlQuery(const QUrlQuery &other);
    QUrlQuery &operator=(const QUrlQuery &other);

    QUrlQuery &operator=(QUrlQuery &&other)
    { qSwap(d, other.d); return *this; }

    ~QUrlQuery();

    bool operator==(const QUrlQuery &other) const;
    bool operator!=(const QUrlQuery &other) const
    { return !(*this == other); }

    void swap(QUrlQuery &other) { qSwap(d, other.d); }

    bool isEmpty() const;
    bool isDetached() const;
    void clear();

    QString query(QUrl::ComponentFormattingOptions encoding = QUrl::PrettyDecoded) const;
    void setQuery(const QString &queryString);
    QString toString(QUrl::ComponentFormattingOptions encoding = QUrl::PrettyDecoded) const
    { return query(encoding); }

    void setQueryDelimiters(QChar valueDelimiter, QChar pairDelimiter);
    QChar queryValueDelimiter() const;
    QChar queryPairDelimiter() const;

    void setQueryItems(const QList<QPair<QString, QString> > &query);
    QList<QPair<QString, QString> > queryItems(QUrl::ComponentFormattingOptions encoding = QUrl::PrettyDecoded) const;

    bool hasQueryItem(const QString &key) const;
    void addQueryItem(const QString &key, const QString &value);
    void removeQueryItem(const QString &key);
    QString queryItemValue(const QString &key, QUrl::ComponentFormattingOptions encoding = QUrl::PrettyDecoded) const;
    QStringList allQueryItemValues(const QString &key, QUrl::ComponentFormattingOptions encoding = QUrl::PrettyDecoded) const;
    void removeAllQueryItems(const QString &key);

    static QChar defaultQueryValueDelimiter()
    { return QChar(ushort('=')); }
    static QChar defaultQueryPairDelimiter()
    { return QChar(ushort('&')); }

private:
    friend class QUrl;
    QSharedDataPointer<QUrlQueryPrivate> d;
public:
    typedef QSharedDataPointer<QUrlQueryPrivate> DataPtr;
    inline DataPtr &data_ptr() { return d; }
};

template<> class QTypeInfo<QUrlQuery > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QUrlQuery)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QUrlQuery >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QUrlQuery) }; static inline const char *name() { return "QUrlQuery"; } }; template <> inline void qSwap<QUrlQuery>(QUrlQuery &value1, QUrlQuery &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QUrlQuery >(::QUrlQuery &value1, ::QUrlQuery &value2) { value1.swap(value2); } }
#line 48 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractitemmodel.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractitemmodel.h"
class QAbstractItemModel;
class QPersistentModelIndex;

class __declspec(dllimport) QModelIndex
{
    friend class QAbstractItemModel;
public:
                     inline QModelIndex() : r(-1), c(-1), i(0), m(0) {}

                     inline int row() const { return r; }
                     inline int column() const { return c; }
                     inline quintptr internalId() const { return i; }
    inline void *internalPointer() const { return reinterpret_cast<void*>(i); }
    inline QModelIndex parent() const;
    inline QModelIndex sibling(int row, int column) const;
    inline QModelIndex child(int row, int column) const;
    inline QVariant data(int role = Qt::DisplayRole) const;
    inline Qt::ItemFlags flags() const;
                     inline const QAbstractItemModel *model() const { return m; }
                     inline bool isValid() const { return (r >= 0) && (c >= 0) && (m != 0); }
                     inline bool operator==(const QModelIndex &other) const
        { return (other.r == r) && (other.i == i) && (other.c == c) && (other.m == m); }
                     inline bool operator!=(const QModelIndex &other) const
        { return !(*this == other); }
                     inline bool operator<(const QModelIndex &other) const
        {
            return r < other.r
                || (r == other.r && (c < other.c
                                 || (c == other.c && (i < other.i
                                                  || (i == other.i && m < other.m )))));
        }
private:
    inline QModelIndex(int arow, int acolumn, void *ptr, const QAbstractItemModel *amodel)
        : r(arow), c(acolumn), i(reinterpret_cast<quintptr>(ptr)), m(amodel) {}
                     inline QModelIndex(int arow, int acolumn, quintptr id, const QAbstractItemModel *amodel)
        : r(arow), c(acolumn), i(id), m(amodel) {}
    int r, c;
    quintptr i;
    const QAbstractItemModel *m;
};
template<> class QTypeInfo<QModelIndex > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QModelIndex)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QModelIndex >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QModelIndex) }; static inline const char *name() { return "QModelIndex"; } };


__declspec(dllimport) QDebug operator<<(QDebug, const QModelIndex &);


class QPersistentModelIndexData;


uint qHash(const QPersistentModelIndex &index, uint seed = 0);

class __declspec(dllimport) QPersistentModelIndex
{
public:
    QPersistentModelIndex();
    QPersistentModelIndex(const QModelIndex &index);
    QPersistentModelIndex(const QPersistentModelIndex &other);
    ~QPersistentModelIndex();
    bool operator<(const QPersistentModelIndex &other) const;
    bool operator==(const QPersistentModelIndex &other) const;
    inline bool operator!=(const QPersistentModelIndex &other) const
    { return !operator==(other); }
    QPersistentModelIndex &operator=(const QPersistentModelIndex &other);

    inline QPersistentModelIndex(QPersistentModelIndex &&other) : d(other.d) { other.d = 0; }
    inline QPersistentModelIndex &operator=(QPersistentModelIndex &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QPersistentModelIndex &other) { qSwap(d, other.d); }
    bool operator==(const QModelIndex &other) const;
    bool operator!=(const QModelIndex &other) const;
    QPersistentModelIndex &operator=(const QModelIndex &other);
    operator const QModelIndex&() const;
    int row() const;
    int column() const;
    void *internalPointer() const;
    quintptr internalId() const;
    QModelIndex parent() const;
    QModelIndex sibling(int row, int column) const;
    QModelIndex child(int row, int column) const;
    QVariant data(int role = Qt::DisplayRole) const;
    Qt::ItemFlags flags() const;
    const QAbstractItemModel *model() const;
    bool isValid() const;
private:
    QPersistentModelIndexData *d;
    friend uint qHash(const QPersistentModelIndex &, uint seed);

    friend __declspec(dllimport) QDebug operator<<(QDebug, const QPersistentModelIndex &);

};
template<> class QTypeInfo<QPersistentModelIndex > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPersistentModelIndex)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QPersistentModelIndex >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QPersistentModelIndex) }; static inline const char *name() { return "QPersistentModelIndex"; } }; template <> inline void qSwap<QPersistentModelIndex>(QPersistentModelIndex &value1, QPersistentModelIndex &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QPersistentModelIndex >(::QPersistentModelIndex &value1, ::QPersistentModelIndex &value2) { value1.swap(value2); } }

inline uint qHash(const QPersistentModelIndex &index, uint seed)
{ return qHash(index.d, seed); }



__declspec(dllimport) QDebug operator<<(QDebug, const QPersistentModelIndex &);


template<typename T> class QList;
typedef QList<QModelIndex> QModelIndexList;

class QMimeData;
class QAbstractItemModelPrivate;
template <class Key, class T> class QMap;


class __declspec(dllimport) QAbstractItemModel : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};


    friend class QPersistentModelIndexData;
    friend class QAbstractItemViewPrivate;
    friend class QIdentityProxyModel;
public:

    explicit QAbstractItemModel(QObject *parent = 0);
    virtual ~QAbstractItemModel();

    bool hasIndex(int row, int column, const QModelIndex &parent = QModelIndex()) const;
    virtual QModelIndex index(int row, int column,
                              const QModelIndex &parent = QModelIndex()) const = 0;
    virtual QModelIndex parent(const QModelIndex &child) const = 0;

    virtual QModelIndex sibling(int row, int column, const QModelIndex &idx) const;
    virtual int rowCount(const QModelIndex &parent = QModelIndex()) const = 0;
    virtual int columnCount(const QModelIndex &parent = QModelIndex()) const = 0;
    virtual bool hasChildren(const QModelIndex &parent = QModelIndex()) const;

    virtual QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const = 0;
    virtual bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

    virtual QVariant headerData(int section, Qt::Orientation orientation,
                                int role = Qt::DisplayRole) const;
    virtual bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
                               int role = Qt::EditRole);

    virtual QMap<int, QVariant> itemData(const QModelIndex &index) const;
    virtual bool setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles);

    virtual QStringList mimeTypes() const;
    virtual QMimeData *mimeData(const QModelIndexList &indexes) const;
    virtual bool canDropMimeData(const QMimeData *data, Qt::DropAction action,
                                 int row, int column, const QModelIndex &parent) const;
    virtual bool dropMimeData(const QMimeData *data, Qt::DropAction action,
                              int row, int column, const QModelIndex &parent);
    virtual Qt::DropActions supportedDropActions() const;

    virtual Qt::DropActions supportedDragActions() const;





    virtual bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
    virtual bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
    virtual bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
    virtual bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());
    virtual bool moveRows(const QModelIndex &sourceParent, int sourceRow, int count,
                          const QModelIndex &destinationParent, int destinationChild);
    virtual bool moveColumns(const QModelIndex &sourceParent, int sourceColumn, int count,
                             const QModelIndex &destinationParent, int destinationChild);

    inline bool insertRow(int row, const QModelIndex &parent = QModelIndex());
    inline bool insertColumn(int column, const QModelIndex &parent = QModelIndex());
    inline bool removeRow(int row, const QModelIndex &parent = QModelIndex());
    inline bool removeColumn(int column, const QModelIndex &parent = QModelIndex());
    inline bool moveRow(const QModelIndex &sourceParent, int sourceRow,
                        const QModelIndex &destinationParent, int destinationChild);
    inline bool moveColumn(const QModelIndex &sourceParent, int sourceColumn,
                           const QModelIndex &destinationParent, int destinationChild);

    virtual void fetchMore(const QModelIndex &parent);
    virtual bool canFetchMore(const QModelIndex &parent) const;
    virtual Qt::ItemFlags flags(const QModelIndex &index) const;
    virtual void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);
    virtual QModelIndex buddy(const QModelIndex &index) const;
    virtual QModelIndexList match(const QModelIndex &start, int role,
                                  const QVariant &value, int hits = 1,
                                  Qt::MatchFlags flags =
                                  Qt::MatchFlags(Qt::MatchStartsWith|Qt::MatchWrap)) const;
    virtual QSize span(const QModelIndex &index) const;

    virtual QHash<int,QByteArray> roleNames() const;




    using QObject::parent;


    enum LayoutChangeHint
    {
        NoLayoutChangeHint,
        VerticalSortHint,
        HorizontalSortHint
    };

public:
    void dataChanged(const QModelIndex &topLeft, const QModelIndex &bottomRight, const QVector<int> &roles = QVector<int>());
    void headerDataChanged(Qt::Orientation orientation, int first, int last);
    void layoutChanged(const QList<QPersistentModelIndex> &parents = QList<QPersistentModelIndex>(), QAbstractItemModel::LayoutChangeHint hint = QAbstractItemModel::NoLayoutChangeHint);
    void layoutAboutToBeChanged(const QList<QPersistentModelIndex> &parents = QList<QPersistentModelIndex>(), QAbstractItemModel::LayoutChangeHint hint = QAbstractItemModel::NoLayoutChangeHint);

    void rowsAboutToBeInserted(const QModelIndex &parent, int first, int last

      , QPrivateSignal

    );
    void rowsInserted(const QModelIndex &parent, int first, int last

      , QPrivateSignal

    );

    void rowsAboutToBeRemoved(const QModelIndex &parent, int first, int last

      , QPrivateSignal

    );
    void rowsRemoved(const QModelIndex &parent, int first, int last

      , QPrivateSignal

    );

    void columnsAboutToBeInserted(const QModelIndex &parent, int first, int last

      , QPrivateSignal

    );
    void columnsInserted(const QModelIndex &parent, int first, int last

      , QPrivateSignal

    );

    void columnsAboutToBeRemoved(const QModelIndex &parent, int first, int last

      , QPrivateSignal

    );
    void columnsRemoved(const QModelIndex &parent, int first, int last

      , QPrivateSignal

    );

    void modelAboutToBeReset(

      QPrivateSignal

    );
    void modelReset(

      QPrivateSignal

    );

    void rowsAboutToBeMoved( const QModelIndex &sourceParent, int sourceStart, int sourceEnd, const QModelIndex &destinationParent, int destinationRow

      , QPrivateSignal

    );
    void rowsMoved( const QModelIndex &parent, int start, int end, const QModelIndex &destination, int row

      , QPrivateSignal

    );

    void columnsAboutToBeMoved( const QModelIndex &sourceParent, int sourceStart, int sourceEnd, const QModelIndex &destinationParent, int destinationColumn

      , QPrivateSignal

    );
    void columnsMoved( const QModelIndex &parent, int start, int end, const QModelIndex &destination, int column

      , QPrivateSignal

    );

public :
    virtual bool submit();
    virtual void revert();

protected :

    void resetInternalData();

protected:
    QAbstractItemModel(QAbstractItemModelPrivate &dd, QObject *parent = 0);

    inline QModelIndex createIndex(int row, int column, void *data = 0) const;
    inline QModelIndex createIndex(int row, int column, quintptr id) const;

    void encodeData(const QModelIndexList &indexes, QDataStream &stream) const;
    bool decodeData(int row, int column, const QModelIndex &parent, QDataStream &stream);

    void beginInsertRows(const QModelIndex &parent, int first, int last);
    void endInsertRows();

    void beginRemoveRows(const QModelIndex &parent, int first, int last);
    void endRemoveRows();

    bool beginMoveRows(const QModelIndex &sourceParent, int sourceFirst, int sourceLast, const QModelIndex &destinationParent, int destinationRow);
    void endMoveRows();

    void beginInsertColumns(const QModelIndex &parent, int first, int last);
    void endInsertColumns();

    void beginRemoveColumns(const QModelIndex &parent, int first, int last);
    void endRemoveColumns();

    bool beginMoveColumns(const QModelIndex &sourceParent, int sourceFirst, int sourceLast, const QModelIndex &destinationParent, int destinationColumn);
    void endMoveColumns();
#line 381 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractitemmodel.h"
    void beginResetModel();
    void endResetModel();

    void changePersistentIndex(const QModelIndex &from, const QModelIndex &to);
    void changePersistentIndexList(const QModelIndexList &from, const QModelIndexList &to);
    QModelIndexList persistentIndexList() const;
#line 395 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractitemmodel.h"
private:
    void doSetRoleNames(const QHash<int,QByteArray> &roleNames);
    void doSetSupportedDragActions(Qt::DropActions actions);

    inline QAbstractItemModelPrivate* d_func() { return reinterpret_cast<QAbstractItemModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractItemModelPrivate* d_func() const { return reinterpret_cast<const QAbstractItemModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractItemModelPrivate;
    QAbstractItemModel(const QAbstractItemModel &) = delete; QAbstractItemModel &operator=(const QAbstractItemModel &) = delete;
};

inline bool QAbstractItemModel::insertRow(int arow, const QModelIndex &aparent)
{ return insertRows(arow, 1, aparent); }
inline bool QAbstractItemModel::insertColumn(int acolumn, const QModelIndex &aparent)
{ return insertColumns(acolumn, 1, aparent); }
inline bool QAbstractItemModel::removeRow(int arow, const QModelIndex &aparent)
{ return removeRows(arow, 1, aparent); }
inline bool QAbstractItemModel::removeColumn(int acolumn, const QModelIndex &aparent)
{ return removeColumns(acolumn, 1, aparent); }
inline bool QAbstractItemModel::moveRow(const QModelIndex &sourceParent, int sourceRow,
                                        const QModelIndex &destinationParent, int destinationChild)
{ return moveRows(sourceParent, sourceRow, 1, destinationParent, destinationChild); }
inline bool QAbstractItemModel::moveColumn(const QModelIndex &sourceParent, int sourceColumn,
                                           const QModelIndex &destinationParent, int destinationChild)
{ return moveColumns(sourceParent, sourceColumn, 1, destinationParent, destinationChild); }
inline QModelIndex QAbstractItemModel::createIndex(int arow, int acolumn, void *adata) const
{ return QModelIndex(arow, acolumn, adata, this); }
inline QModelIndex QAbstractItemModel::createIndex(int arow, int acolumn, quintptr aid) const
{ return QModelIndex(arow, acolumn, aid, this); }

class __declspec(dllimport) QAbstractTableModel : public QAbstractItemModel
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

public:
    explicit QAbstractTableModel(QObject *parent = 0);
    ~QAbstractTableModel();

    QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
    bool dropMimeData(const QMimeData *data, Qt::DropAction action,
                      int row, int column, const QModelIndex &parent);

    Qt::ItemFlags flags(const QModelIndex &index) const override;






    using QObject::parent;


protected:
    QAbstractTableModel(QAbstractItemModelPrivate &dd, QObject *parent);

private:
    QAbstractTableModel(const QAbstractTableModel &) = delete; QAbstractTableModel &operator=(const QAbstractTableModel &) = delete;
    QModelIndex parent(const QModelIndex &child) const;
    bool hasChildren(const QModelIndex &parent) const;
};

class __declspec(dllimport) QAbstractListModel : public QAbstractItemModel
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

public:
    explicit QAbstractListModel(QObject *parent = 0);
    ~QAbstractListModel();

    QModelIndex index(int row, int column = 0, const QModelIndex &parent = QModelIndex()) const;
    bool dropMimeData(const QMimeData *data, Qt::DropAction action,
                      int row, int column, const QModelIndex &parent);

    Qt::ItemFlags flags(const QModelIndex &index) const override;






    using QObject::parent;


protected:
    QAbstractListModel(QAbstractItemModelPrivate &dd, QObject *parent);

private:
    QAbstractListModel(const QAbstractListModel &) = delete; QAbstractListModel &operator=(const QAbstractListModel &) = delete;
    QModelIndex parent(const QModelIndex &child) const;
    int columnCount(const QModelIndex &parent) const;
    bool hasChildren(const QModelIndex &parent) const;
};



inline QModelIndex QModelIndex::parent() const
{ return m ? m->parent(*this) : QModelIndex(); }

inline QModelIndex QModelIndex::sibling(int arow, int acolumn) const
{ return m ? (r == arow && c == acolumn) ? *this : m->sibling(arow, acolumn, *this) : QModelIndex(); }

inline QModelIndex QModelIndex::child(int arow, int acolumn) const
{ return m ? m->index(arow, acolumn, *this) : QModelIndex(); }

inline QVariant QModelIndex::data(int arole) const
{ return m ? m->data(*this, arole) : QVariant(); }

inline Qt::ItemFlags QModelIndex::flags() const
{ return m ? m->flags(*this) : Qt::ItemFlags(0); }

inline uint qHash(const QModelIndex &index)
{ return uint((index.row() << 4) + index.column() + index.internalId()); }
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractproxymodel.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractproxymodel.h"
class QAbstractProxyModelPrivate;
class QItemSelection;

class __declspec(dllimport) QAbstractProxyModel : public QAbstractItemModel
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};


public:
    explicit QAbstractProxyModel(QObject *parent = 0);
    ~QAbstractProxyModel();

    virtual void setSourceModel(QAbstractItemModel *sourceModel);
    QAbstractItemModel *sourceModel() const;

    virtual QModelIndex mapToSource(const QModelIndex &proxyIndex) const = 0;
    virtual QModelIndex mapFromSource(const QModelIndex &sourceIndex) const = 0;

    virtual QItemSelection mapSelectionToSource(const QItemSelection &selection) const;
    virtual QItemSelection mapSelectionFromSource(const QItemSelection &selection) const;

    bool submit();
    void revert();

    QVariant data(const QModelIndex &proxyIndex, int role = Qt::DisplayRole) const;
    QVariant headerData(int section, Qt::Orientation orientation, int role) const;
    QMap<int, QVariant> itemData(const QModelIndex &index) const;
    Qt::ItemFlags flags(const QModelIndex &index) const;

    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);
    bool setItemData(const QModelIndex& index, const QMap<int, QVariant> &roles);
    bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value, int role = Qt::EditRole);

    QModelIndex buddy(const QModelIndex &index) const;
    bool canFetchMore(const QModelIndex &parent) const;
    void fetchMore(const QModelIndex &parent);
    void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);
    QSize span(const QModelIndex &index) const;
    bool hasChildren(const QModelIndex &parent = QModelIndex()) const;
    QModelIndex sibling(int row, int column, const QModelIndex &idx) const;

    QMimeData* mimeData(const QModelIndexList &indexes) const;
    QStringList mimeTypes() const;
    Qt::DropActions supportedDropActions() const;

public:
    void sourceModelChanged(

        QPrivateSignal

    );

protected :
    void resetInternalData();

protected:
    QAbstractProxyModel(QAbstractProxyModelPrivate &, QObject *parent);

private:
    inline QAbstractProxyModelPrivate* d_func() { return reinterpret_cast<QAbstractProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractProxyModelPrivate* d_func() const { return reinterpret_cast<const QAbstractProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractProxyModelPrivate;
    QAbstractProxyModel(const QAbstractProxyModel &) = delete; QAbstractProxyModel &operator=(const QAbstractProxyModel &) = delete;

};
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qidentityproxymodel.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qidentityproxymodel.h"
class QIdentityProxyModelPrivate;

class __declspec(dllimport) QIdentityProxyModel : public QAbstractProxyModel
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    explicit QIdentityProxyModel(QObject* parent = 0);
    ~QIdentityProxyModel();

    int columnCount(const QModelIndex& parent = QModelIndex()) const;
    QModelIndex index(int row, int column, const QModelIndex& parent = QModelIndex()) const;
    QModelIndex mapFromSource(const QModelIndex& sourceIndex) const;
    QModelIndex mapToSource(const QModelIndex& proxyIndex) const;
    QModelIndex parent(const QModelIndex& child) const;
    int rowCount(const QModelIndex& parent = QModelIndex()) const;
    QVariant headerData(int section, Qt::Orientation orientation, int role) const;
    bool dropMimeData(const QMimeData* data, Qt::DropAction action, int row, int column, const QModelIndex& parent);
    QModelIndex sibling(int row, int column, const QModelIndex &idx) const;

    QItemSelection mapSelectionFromSource(const QItemSelection& selection) const;
    QItemSelection mapSelectionToSource(const QItemSelection& selection) const;
    QModelIndexList match(const QModelIndex& start, int role, const QVariant& value, int hits = 1, Qt::MatchFlags flags = Qt::MatchFlags(Qt::MatchStartsWith|Qt::MatchWrap)) const;
    void setSourceModel(QAbstractItemModel* sourceModel);

    bool insertColumns(int column, int count, const QModelIndex& parent = QModelIndex());
    bool insertRows(int row, int count, const QModelIndex& parent = QModelIndex());
    bool removeColumns(int column, int count, const QModelIndex& parent = QModelIndex());
    bool removeRows(int row, int count, const QModelIndex& parent = QModelIndex());

protected:
    QIdentityProxyModel(QIdentityProxyModelPrivate &dd, QObject* parent);

private:
    inline QIdentityProxyModelPrivate* d_func() { return reinterpret_cast<QIdentityProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QIdentityProxyModelPrivate* d_func() const { return reinterpret_cast<const QIdentityProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QIdentityProxyModelPrivate;
    QIdentityProxyModel(const QIdentityProxyModel &) = delete; QIdentityProxyModel &operator=(const QIdentityProxyModel &) = delete;
#line 110 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qidentityproxymodel.h"
};
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qitemselectionmodel.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qitemselectionmodel.h"
class __declspec(dllimport) QItemSelectionRange
{

public:
    inline QItemSelectionRange() {}
    inline QItemSelectionRange(const QItemSelectionRange &other)
        : tl(other.tl), br(other.br) {}
    inline QItemSelectionRange(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    explicit inline QItemSelectionRange(const QModelIndex &index)
        { tl = index; br = tl; }

    inline int top() const { return tl.row(); }
    inline int left() const { return tl.column(); }
    inline int bottom() const { return br.row(); }
    inline int right() const { return br.column(); }
    inline int width() const { return br.column() - tl.column() + 1; }
    inline int height() const { return br.row() - tl.row() + 1; }

    inline const QPersistentModelIndex &topLeft() const { return tl; }
    inline const QPersistentModelIndex &bottomRight() const { return br; }
    inline QModelIndex parent() const { return tl.parent(); }
    inline const QAbstractItemModel *model() const { return tl.model(); }

    inline bool contains(const QModelIndex &index) const
    {
        return (parent() == index.parent()
                && tl.row() <= index.row() && tl.column() <= index.column()
                && br.row() >= index.row() && br.column() >= index.column());
    }

    inline bool contains(int row, int column, const QModelIndex &parentIndex) const
    {
        return (parent() == parentIndex
                && tl.row() <= row && tl.column() <= column
                && br.row() >= row && br.column() >= column);
    }

    bool intersects(const QItemSelectionRange &other) const;




    QItemSelectionRange intersected(const QItemSelectionRange &other) const;


    inline bool operator==(const QItemSelectionRange &other) const
        { return (tl == other.tl && br == other.br); }
    inline bool operator!=(const QItemSelectionRange &other) const
        { return !operator==(other); }
    inline bool operator<(const QItemSelectionRange &other) const
        {


            if (other.tl.model() == tl.model()) {

                const QModelIndex topLeftParent = tl.parent();
                const QModelIndex otherTopLeftParent = other.tl.parent();
                if (topLeftParent == otherTopLeftParent) {
                    if (other.tl.row() == tl.row()) {
                        if (other.tl.column() == tl.column()) {
                            if (other.br.row() == br.row()) {
                                return br.column() < other.br.column();
                            }
                            return br.row() < other.br.row();
                        }
                        return tl.column() < other.tl.column();
                    }
                    return tl.row() < other.tl.row();
                }
                return topLeftParent < otherTopLeftParent;
            }
            return tl.model() < other.tl.model();
        }

    inline bool isValid() const
    {
        return (tl.isValid() && br.isValid() && tl.parent() == br.parent()
                && top() <= bottom() && left() <= right());
    }

    bool isEmpty() const;

    QModelIndexList indexes() const;

private:
    QPersistentModelIndex tl, br;
};
template<> class QTypeInfo<QItemSelectionRange > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QItemSelectionRange)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QItemSelectionRange >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QItemSelectionRange) }; static inline const char *name() { return "QItemSelectionRange"; } };

inline QItemSelectionRange::QItemSelectionRange(const QModelIndex &atopLeft,
                                                const QModelIndex &abottomRight)
{ tl = atopLeft; br = abottomRight; }

class QItemSelection;
class QItemSelectionModelPrivate;

class __declspec(dllimport) QItemSelectionModel : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QItemSelectionModelPrivate* d_func() { return reinterpret_cast<QItemSelectionModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QItemSelectionModelPrivate* d_func() const { return reinterpret_cast<const QItemSelectionModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QItemSelectionModelPrivate;


public:

    enum SelectionFlag {
        NoUpdate = 0x0000,
        Clear = 0x0001,
        Select = 0x0002,
        Deselect = 0x0004,
        Toggle = 0x0008,
        Current = 0x0010,
        Rows = 0x0020,
        Columns = 0x0040,
        SelectCurrent = Select | Current,
        ToggleCurrent = Toggle | Current,
        ClearAndSelect = Clear | Select
    };

    typedef QFlags<SelectionFlag> SelectionFlags;

    explicit QItemSelectionModel(QAbstractItemModel *model);
    explicit QItemSelectionModel(QAbstractItemModel *model, QObject *parent);
    virtual ~QItemSelectionModel();

    QModelIndex currentIndex() const;

    bool isSelected(const QModelIndex &index) const;
    bool isRowSelected(int row, const QModelIndex &parent) const;
    bool isColumnSelected(int column, const QModelIndex &parent) const;

    bool rowIntersectsSelection(int row, const QModelIndex &parent) const;
    bool columnIntersectsSelection(int column, const QModelIndex &parent) const;

    bool hasSelection() const;

    QModelIndexList selectedIndexes() const;
    QModelIndexList selectedRows(int column = 0) const;
    QModelIndexList selectedColumns(int row = 0) const;
    const QItemSelection selection() const;

    const QAbstractItemModel *model() const;

public :
    virtual void setCurrentIndex(const QModelIndex &index, QItemSelectionModel::SelectionFlags command);
    virtual void select(const QModelIndex &index, QItemSelectionModel::SelectionFlags command);
    virtual void select(const QItemSelection &selection, QItemSelectionModel::SelectionFlags command);
    virtual void clear();
    virtual void reset();

    void clearSelection();
    virtual void clearCurrentIndex();

public:
    void selectionChanged(const QItemSelection &selected, const QItemSelection &deselected);
    void currentChanged(const QModelIndex &current, const QModelIndex &previous);
    void currentRowChanged(const QModelIndex &current, const QModelIndex &previous);
    void currentColumnChanged(const QModelIndex &current, const QModelIndex &previous);

protected:
    QItemSelectionModel(QItemSelectionModelPrivate &dd, QAbstractItemModel *model);
    void emitSelectionChanged(const QItemSelection &newSelection, const QItemSelection &oldSelection);

private:
    QItemSelectionModel(const QItemSelectionModel &) = delete; QItemSelectionModel &operator=(const QItemSelectionModel &) = delete;






};

 inline QFlags<QItemSelectionModel::SelectionFlags::enum_type> operator|(QItemSelectionModel::SelectionFlags::enum_type f1, QItemSelectionModel::SelectionFlags::enum_type f2) { return QFlags<QItemSelectionModel::SelectionFlags::enum_type>(f1) | f2; } inline QFlags<QItemSelectionModel::SelectionFlags::enum_type> operator|(QItemSelectionModel::SelectionFlags::enum_type f1, QFlags<QItemSelectionModel::SelectionFlags::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QItemSelectionModel::SelectionFlags::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


inline uint qHash(const QItemSelectionRange &) { return 0; }

class __declspec(dllimport) QItemSelection : public QList<QItemSelectionRange>
{
public:
    QItemSelection() {}
    QItemSelection(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    void select(const QModelIndex &topLeft, const QModelIndex &bottomRight);
    bool contains(const QModelIndex &index) const;
    QModelIndexList indexes() const;
    void merge(const QItemSelection &other, QItemSelectionModel::SelectionFlags command);
    static void split(const QItemSelectionRange &range,
                      const QItemSelectionRange &other,
                      QItemSelection *result);
};


__declspec(dllimport) QDebug operator<<(QDebug, const QItemSelectionRange &);
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsortfilterproxymodel.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsortfilterproxymodel.h"
class QSortFilterProxyModelPrivate;
class QSortFilterProxyModelLessThan;
class QSortFilterProxyModelGreaterThan;

class __declspec(dllimport) QSortFilterProxyModel : public QAbstractProxyModel
{
    friend class QSortFilterProxyModelLessThan;
    friend class QSortFilterProxyModelGreaterThan;

    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
#line 73 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsortfilterproxymodel.h"
public:
    explicit QSortFilterProxyModel(QObject *parent = 0);
    ~QSortFilterProxyModel();

    void setSourceModel(QAbstractItemModel *sourceModel);

    QModelIndex mapToSource(const QModelIndex &proxyIndex) const;
    QModelIndex mapFromSource(const QModelIndex &sourceIndex) const;

    QItemSelection mapSelectionToSource(const QItemSelection &proxySelection) const;
    QItemSelection mapSelectionFromSource(const QItemSelection &sourceSelection) const;

    QRegExp filterRegExp() const;
    void setFilterRegExp(const QRegExp &regExp);

    int filterKeyColumn() const;
    void setFilterKeyColumn(int column);

    Qt::CaseSensitivity filterCaseSensitivity() const;
    void setFilterCaseSensitivity(Qt::CaseSensitivity cs);

    Qt::CaseSensitivity sortCaseSensitivity() const;
    void setSortCaseSensitivity(Qt::CaseSensitivity cs);

    bool isSortLocaleAware() const;
    void setSortLocaleAware(bool on);

    int sortColumn() const;
    Qt::SortOrder sortOrder() const;

    bool dynamicSortFilter() const;
    void setDynamicSortFilter(bool enable);

    int sortRole() const;
    void setSortRole(int role);

    int filterRole() const;
    void setFilterRole(int role);

public :
    void setFilterRegExp(const QString &pattern);
    void setFilterWildcard(const QString &pattern);
    void setFilterFixedString(const QString &pattern);
    void clear();
    void invalidate();

protected:
    virtual bool filterAcceptsRow(int source_row, const QModelIndex &source_parent) const;
    virtual bool filterAcceptsColumn(int source_column, const QModelIndex &source_parent) const;
    virtual bool lessThan(const QModelIndex &left, const QModelIndex &right) const;

    void filterChanged();
    void invalidateFilter();

public:



    using QObject::parent;


    QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
    QModelIndex parent(const QModelIndex &child) const;
    QModelIndex sibling(int row, int column, const QModelIndex &idx) const;

    int rowCount(const QModelIndex &parent = QModelIndex()) const;
    int columnCount(const QModelIndex &parent = QModelIndex()) const;
    bool hasChildren(const QModelIndex &parent = QModelIndex()) const;

    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const;
    bool setHeaderData(int section, Qt::Orientation orientation,
            const QVariant &value, int role = Qt::EditRole);

    QMimeData *mimeData(const QModelIndexList &indexes) const;
    bool dropMimeData(const QMimeData *data, Qt::DropAction action,
                      int row, int column, const QModelIndex &parent);

    bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
    bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
    bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
    bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());

    void fetchMore(const QModelIndex &parent);
    bool canFetchMore(const QModelIndex &parent) const;
    Qt::ItemFlags flags(const QModelIndex &index) const;

    QModelIndex buddy(const QModelIndex &index) const;
    QModelIndexList match(const QModelIndex &start, int role,
                          const QVariant &value, int hits = 1,
                          Qt::MatchFlags flags =
                          Qt::MatchFlags(Qt::MatchStartsWith|Qt::MatchWrap)) const;
    QSize span(const QModelIndex &index) const;
    void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);

    QStringList mimeTypes() const;
    Qt::DropActions supportedDropActions() const;
private:
    inline QSortFilterProxyModelPrivate* d_func() { return reinterpret_cast<QSortFilterProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSortFilterProxyModelPrivate* d_func() const { return reinterpret_cast<const QSortFilterProxyModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSortFilterProxyModelPrivate;
    QSortFilterProxyModel(const QSortFilterProxyModel &) = delete; QSortFilterProxyModel &operator=(const QSortFilterProxyModel &) = delete;
#line 195 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsortfilterproxymodel.h"
};
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstringlistmodel.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstringlistmodel.h"
class __declspec(dllimport) QStringListModel : public QAbstractListModel
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    explicit QStringListModel(QObject *parent = 0);
    explicit QStringListModel(const QStringList &strings, QObject *parent = 0);

    int rowCount(const QModelIndex &parent = QModelIndex()) const;
    QModelIndex sibling(int row, int column, const QModelIndex &idx) const;

    QVariant data(const QModelIndex &index, int role) const;
    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

    Qt::ItemFlags flags(const QModelIndex &index) const;

    bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
    bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());

    void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);

    QStringList stringList() const;
    void setStringList(const QStringList &strings);

    Qt::DropActions supportedDropActions() const;

private:
    QStringListModel(const QStringListModel &) = delete; QStringListModel &operator=(const QStringListModel &) = delete;
    QStringList lst;
};
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qjsonarray.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qjsonarray.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qjsonvalue.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qjsonvalue.h"
class QDebug;
class QVariant;
class QJsonArray;
class QJsonObject;

namespace QJsonPrivate {
    class Data;
    class Base;
    class Object;
    class Header;
    class Array;
    class Value;
    class Entry;
}

class __declspec(dllimport) QJsonValue
{
public:
    enum Type {
        Null = 0x0,
        Bool = 0x1,
        Double = 0x2,
        String = 0x3,
        Array = 0x4,
        Object = 0x5,
        Undefined = 0x80
    };

    QJsonValue(Type = Null);
    QJsonValue(bool b);
    QJsonValue(double n);
    QJsonValue(int n);
    QJsonValue(qint64 n);
    QJsonValue(const QString &s);
    QJsonValue(QLatin1String s);

    inline QJsonValue(const char *s)
        : d(0), t(String) { stringDataFromQStringHelper(QString::fromUtf8(s)); }

    QJsonValue(const QJsonArray &a);
    QJsonValue(const QJsonObject &o);

    ~QJsonValue();

    QJsonValue(const QJsonValue &other);
    QJsonValue &operator =(const QJsonValue &other);

    static QJsonValue fromVariant(const QVariant &variant);
    QVariant toVariant() const;

    Type type() const;
    inline bool isNull() const { return type() == Null; }
    inline bool isBool() const { return type() == Bool; }
    inline bool isDouble() const { return type() == Double; }
    inline bool isString() const { return type() == String; }
    inline bool isArray() const { return type() == Array; }
    inline bool isObject() const { return type() == Object; }
    inline bool isUndefined() const { return type() == Undefined; }

    bool toBool(bool defaultValue = false) const;
    int toInt(int defaultValue = 0) const;
    double toDouble(double defaultValue = 0) const;
    QString toString(const QString &defaultValue = QString()) const;
    QJsonArray toArray() const;
    QJsonArray toArray(const QJsonArray &defaultValue) const;
    QJsonObject toObject() const;
    QJsonObject toObject(const QJsonObject &defaultValue) const;

    bool operator==(const QJsonValue &other) const;
    bool operator!=(const QJsonValue &other) const;

private:

    inline QJsonValue(const void *) {}
    friend class QJsonPrivate::Value;
    friend class QJsonArray;
    friend class QJsonObject;
    friend __declspec(dllimport) QDebug operator<<(QDebug, const QJsonValue &);

    QJsonValue(QJsonPrivate::Data *d, QJsonPrivate::Base *b, const QJsonPrivate::Value& v);
    void stringDataFromQStringHelper(const QString &string);

    void detach();

    union {
        quint64 ui;
        bool b;
        double dbl;
        QStringData *stringData;
        QJsonPrivate::Base *base;
    };
    QJsonPrivate::Data *d;
    Type t;
};

class __declspec(dllimport) QJsonValueRef
{
public:
    QJsonValueRef(QJsonArray *array, int idx)
        : a(array), is_object(false), index(idx) {}
    QJsonValueRef(QJsonObject *object, int idx)
        : o(object), is_object(true), index(idx) {}

    inline operator QJsonValue() const { return toValue(); }
    QJsonValueRef &operator = (const QJsonValue &val);
    QJsonValueRef &operator = (const QJsonValueRef &val);

    inline QJsonValue::Type type() const { return toValue().type(); }
    inline bool isNull() const { return type() == QJsonValue::Null; }
    inline bool isBool() const { return type() == QJsonValue::Bool; }
    inline bool isDouble() const { return type() == QJsonValue::Double; }
    inline bool isString() const { return type() == QJsonValue::String; }
    inline bool isArray() const { return type() == QJsonValue::Array; }
    inline bool isObject() const { return type() == QJsonValue::Object; }
    inline bool isUndefined() const { return type() == QJsonValue::Undefined; }

    inline bool toBool() const { return toValue().toBool(); }
    inline int toInt() const { return toValue().toInt(); }
    inline double toDouble() const { return toValue().toDouble(); }
    inline QString toString() const { return toValue().toString(); }
    QJsonArray toArray() const;
    QJsonObject toObject() const;

    inline bool operator==(const QJsonValue &other) const { return toValue() == other; }
    inline bool operator!=(const QJsonValue &other) const { return toValue() != other; }

private:
    QJsonValue toValue() const;

    union {
        QJsonArray *a;
        QJsonObject *o;
    };
    uint is_object : 1;
    uint index : 31;
};


__declspec(dllimport) QDebug operator<<(QDebug, const QJsonValue &);
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qjsonarray.h"





class QDebug;
class QStringList;
template <typename T> class QList;
typedef QList<QVariant> QVariantList;

class __declspec(dllimport) QJsonArray
{
public:
    QJsonArray();
    ~QJsonArray();

    QJsonArray(const QJsonArray &other);
    QJsonArray &operator =(const QJsonArray &other);

    static QJsonArray fromStringList(const QStringList &list);
    static QJsonArray fromVariantList(const QVariantList &list);
    QVariantList toVariantList() const;

    int size() const;
    inline int count() const { return size(); }

    bool isEmpty() const;
    QJsonValue at(int i) const;
    QJsonValue first() const;
    QJsonValue last() const;

    void prepend(const QJsonValue &value);
    void append(const QJsonValue &value);
    void removeAt(int i);
    QJsonValue takeAt(int i);
    inline void removeFirst() { removeAt(0); }
    inline void removeLast() { removeAt(size() - 1); }

    void insert(int i, const QJsonValue &value);
    void replace(int i, const QJsonValue &value);

    bool contains(const QJsonValue &element) const;
    QJsonValueRef operator[](int i);
    QJsonValue operator[](int i) const;

    bool operator==(const QJsonArray &other) const;
    bool operator!=(const QJsonArray &other) const;

    class const_iterator;

    class iterator {
    public:
        QJsonArray *a;
        int i;
        typedef std::random_access_iterator_tag iterator_category;
        typedef int difference_type;
        typedef QJsonValue value_type;

        typedef QJsonValueRef reference;

        inline iterator() : a(0), i(0) { }
        explicit inline iterator(QJsonArray *array, int index) : a(array), i(index) { }

        inline QJsonValueRef operator*() const { return QJsonValueRef(a, i); }

        inline QJsonValueRef operator[](int j) const { return QJsonValueRef(a, i + j); }

        inline bool operator==(const iterator &o) const { return i == o.i; }
        inline bool operator!=(const iterator &o) const { return i != o.i; }
        inline bool operator<(const iterator& other) const { return i < other.i; }
        inline bool operator<=(const iterator& other) const { return i <= other.i; }
        inline bool operator>(const iterator& other) const { return i > other.i; }
        inline bool operator>=(const iterator& other) const { return i >= other.i; }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }
        inline bool operator<(const const_iterator& other) const { return i < other.i; }
        inline bool operator<=(const const_iterator& other) const { return i <= other.i; }
        inline bool operator>(const const_iterator& other) const { return i > other.i; }
        inline bool operator>=(const const_iterator& other) const { return i >= other.i; }
        inline iterator &operator++() { ++i; return *this; }
        inline iterator operator++(int) { iterator n = *this; ++i; return n; }
        inline iterator &operator--() { i--; return *this; }
        inline iterator operator--(int) { iterator n = *this; i--; return n; }
        inline iterator &operator+=(int j) { i+=j; return *this; }
        inline iterator &operator-=(int j) { i-=j; return *this; }
        inline iterator operator+(int j) const { return iterator(a, i+j); }
        inline iterator operator-(int j) const { return iterator(a, i-j); }
        inline int operator-(iterator j) const { return i - j.i; }
    };
    friend class iterator;

    class const_iterator {
    public:
        const QJsonArray *a;
        int i;
        typedef std::random_access_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef QJsonValue value_type;

        typedef QJsonValue reference;

        inline const_iterator() : a(0), i(0) { }
        explicit inline const_iterator(const QJsonArray *array, int index) : a(array), i(index) { }
        inline const_iterator(const const_iterator &o) : a(o.a), i(o.i) {}
        inline const_iterator(const iterator &o) : a(o.a), i(o.i) {}

        inline QJsonValue operator*() const { return a->at(i); }

        inline QJsonValue operator[](int j) const { return a->at(i+j); }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }
        inline bool operator<(const const_iterator& other) const { return i < other.i; }
        inline bool operator<=(const const_iterator& other) const { return i <= other.i; }
        inline bool operator>(const const_iterator& other) const { return i > other.i; }
        inline bool operator>=(const const_iterator& other) const { return i >= other.i; }
        inline const_iterator &operator++() { ++i; return *this; }
        inline const_iterator operator++(int) { const_iterator n = *this; ++i; return n; }
        inline const_iterator &operator--() { i--; return *this; }
        inline const_iterator operator--(int) { const_iterator n = *this; i--; return n; }
        inline const_iterator &operator+=(int j) { i+=j; return *this; }
        inline const_iterator &operator-=(int j) { i-=j; return *this; }
        inline const_iterator operator+(int j) const { return const_iterator(a, i+j); }
        inline const_iterator operator-(int j) const { return const_iterator(a, i-j); }
        inline int operator-(const_iterator j) const { return i - j.i; }
    };
    friend class const_iterator;


    inline iterator begin() { detach(); return iterator(this, 0); }
    inline const_iterator begin() const { return const_iterator(this, 0); }
    inline const_iterator constBegin() const { return const_iterator(this, 0); }
    inline iterator end() { detach(); return iterator(this, size()); }
    inline const_iterator end() const { return const_iterator(this, size()); }
    inline const_iterator constEnd() const { return const_iterator(this, size()); }
    iterator insert(iterator before, const QJsonValue &value) { insert(before.i, value); return before; }
    iterator erase(iterator it) { removeAt(it.i); return it; }


    typedef iterator Iterator;
    typedef const_iterator ConstIterator;


    inline QJsonArray operator+(const QJsonValue &v) const
    { QJsonArray n = *this; n += v; return n; }
    inline QJsonArray &operator+=(const QJsonValue &v)
    { append(v); return *this; }
    inline QJsonArray &operator<< (const QJsonValue &v)
    { append(v); return *this; }


    inline void push_back(const QJsonValue &t) { append(t); }
    inline void push_front(const QJsonValue &t) { prepend(t); }
    inline void pop_front() { removeFirst(); }
    inline void pop_back() { removeLast(); }
    inline bool empty() const { return isEmpty(); }
    typedef int size_type;
    typedef QJsonValue value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef QJsonValueRef reference;
    typedef QJsonValue const_reference;
    typedef int difference_type;

private:
    friend class QJsonPrivate::Data;
    friend class QJsonValue;
    friend class QJsonDocument;
    friend __declspec(dllimport) QDebug operator<<(QDebug, const QJsonArray &);

    QJsonArray(QJsonPrivate::Data *data, QJsonPrivate::Array *array);
    void compact();
    void detach(uint reserve = 0);

    QJsonPrivate::Data *d;
    QJsonPrivate::Array *a;
};


__declspec(dllimport) QDebug operator<<(QDebug, const QJsonArray &);
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qjsondocument.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qjsondocument.h"
class QDebug;

namespace QJsonPrivate {
    class Parser;
}

struct __declspec(dllimport) QJsonParseError
{
    enum ParseError {
        NoError = 0,
        UnterminatedObject,
        MissingNameSeparator,
        UnterminatedArray,
        MissingValueSeparator,
        IllegalValue,
        TerminationByNumber,
        IllegalNumber,
        IllegalEscapeSequence,
        IllegalUTF8String,
        UnterminatedString,
        MissingObject,
        DeepNesting,
        DocumentTooLarge
    };

    QString errorString() const;

    int offset;
    ParseError error;
};

class __declspec(dllimport) QJsonDocument
{
public:

    static const uint BinaryFormatTag = ('q') | ('b' << 8) | ('j' << 16) | ('s' << 24);




    QJsonDocument();
    explicit QJsonDocument(const QJsonObject &object);
    explicit QJsonDocument(const QJsonArray &array);
    ~QJsonDocument();

    QJsonDocument(const QJsonDocument &other);
    QJsonDocument &operator =(const QJsonDocument &other);

    enum DataValidation {
        Validate,
        BypassValidation
    };

    static QJsonDocument fromRawData(const char *data, int size, DataValidation validation = Validate);
    const char *rawData(int *size) const;

    static QJsonDocument fromBinaryData(const QByteArray &data, DataValidation validation = Validate);
    QByteArray toBinaryData() const;

    static QJsonDocument fromVariant(const QVariant &variant);
    QVariant toVariant() const;

    enum JsonFormat {
        Indented,
        Compact
    };

    static QJsonDocument fromJson(const QByteArray &json, QJsonParseError *error = 0);




    QByteArray toJson() const;
    QByteArray toJson(JsonFormat format) const;


    bool isEmpty() const;
    bool isArray() const;
    bool isObject() const;

    QJsonObject object() const;
    QJsonArray array() const;

    void setObject(const QJsonObject &object);
    void setArray(const QJsonArray &array);

    bool operator==(const QJsonDocument &other) const;
    bool operator!=(const QJsonDocument &other) const { return !(*this == other); }

    bool isNull() const;

private:
    friend class QJsonValue;
    friend class QJsonPrivate::Data;
    friend class QJsonPrivate::Parser;
    friend __declspec(dllimport) QDebug operator<<(QDebug, const QJsonDocument &);

    QJsonDocument(QJsonPrivate::Data *data);

    QJsonPrivate::Data *d;
};


__declspec(dllimport) QDebug operator<<(QDebug, const QJsonDocument &);
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qjsonobject.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qjsonobject.h"
class QDebug;
template <class Key, class T> class QMap;
typedef QMap<QString, QVariant> QVariantMap;

class __declspec(dllimport) QJsonObject
{
public:
    QJsonObject();
    ~QJsonObject();

    QJsonObject(const QJsonObject &other);
    QJsonObject &operator =(const QJsonObject &other);

    static QJsonObject fromVariantMap(const QVariantMap &map);
    QVariantMap toVariantMap() const;

    QStringList keys() const;
    int size() const;
    inline int count() const { return size(); }
    inline int length() const { return size(); }
    bool isEmpty() const;

    QJsonValue value(const QString &key) const;
    QJsonValue operator[] (const QString &key) const;
    QJsonValueRef operator[] (const QString &key);

    void remove(const QString &key);
    QJsonValue take(const QString &key);
    bool contains(const QString &key) const;

    bool operator==(const QJsonObject &other) const;
    bool operator!=(const QJsonObject &other) const;

    class const_iterator;

    class iterator
    {
        friend class const_iterator;
        friend class QJsonObject;
        QJsonObject *o;
        int i;

    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef int difference_type;
        typedef QJsonValue value_type;

        typedef QJsonValueRef reference;

                         inline iterator() : o(0), i(0) {}
                         inline iterator(QJsonObject *obj, int index) : o(obj), i(index) {}

        inline QString key() const { return o->keyAt(i); }
        inline QJsonValueRef value() const { return QJsonValueRef(o, i); }
        inline QJsonValueRef operator*() const { return QJsonValueRef(o, i); }

        inline bool operator==(const iterator &other) const { return i == other.i; }
        inline bool operator!=(const iterator &other) const { return i != other.i; }

        inline iterator &operator++() { ++i; return *this; }
        inline iterator operator++(int) { iterator r = *this; ++i; return r; }
        inline iterator &operator--() { --i; return *this; }
        inline iterator operator--(int) { iterator r = *this; --i; return r; }
        inline iterator operator+(int j) const
        { iterator r = *this; r.i += j; return r; }
        inline iterator operator-(int j) const { return operator+(-j); }
        inline iterator &operator+=(int j) { i += j; return *this; }
        inline iterator &operator-=(int j) { i -= j; return *this; }

    public:
        inline bool operator==(const const_iterator &other) const { return i == other.i; }
        inline bool operator!=(const const_iterator &other) const { return i != other.i; }
    };
    friend class iterator;

    class const_iterator
    {
        friend class iterator;
        const QJsonObject *o;
        int i;

    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef int difference_type;
        typedef QJsonValue value_type;
        typedef QJsonValue reference;

                         inline const_iterator() : o(0), i(0) {}
                         inline const_iterator(const QJsonObject *obj, int index)
            : o(obj), i(index) {}
        inline const_iterator(const iterator &other)
            : o(other.o), i(other.i) {}

        inline QString key() const { return o->keyAt(i); }
        inline QJsonValue value() const { return o->valueAt(i); }
        inline QJsonValue operator*() const { return o->valueAt(i); }

        inline bool operator==(const const_iterator &other) const { return i == other.i; }
        inline bool operator!=(const const_iterator &other) const { return i != other.i; }

        inline const_iterator &operator++() { ++i; return *this; }
        inline const_iterator operator++(int) { const_iterator r = *this; ++i; return r; }
        inline const_iterator &operator--() { --i; return *this; }
        inline const_iterator operator--(int) { const_iterator r = *this; --i; return r; }
        inline const_iterator operator+(int j) const
        { const_iterator r = *this; r.i += j; return r; }
        inline const_iterator operator-(int j) const { return operator+(-j); }
        inline const_iterator &operator+=(int j) { i += j; return *this; }
        inline const_iterator &operator-=(int j) { i -= j; return *this; }

        inline bool operator==(const iterator &other) const { return i == other.i; }
        inline bool operator!=(const iterator &other) const { return i != other.i; }
    };
    friend class const_iterator;


    inline iterator begin() { detach(); return iterator(this, 0); }
    inline const_iterator begin() const { return const_iterator(this, 0); }
    inline const_iterator constBegin() const { return const_iterator(this, 0); }
    inline iterator end() { detach(); return iterator(this, size()); }
    inline const_iterator end() const { return const_iterator(this, size()); }
    inline const_iterator constEnd() const { return const_iterator(this, size()); }
    iterator erase(iterator it);


    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    iterator find(const QString &key);
    const_iterator find(const QString &key) const { return constFind(key); }
    const_iterator constFind(const QString &key) const;
    iterator insert(const QString &key, const QJsonValue &value);


    typedef QJsonValue mapped_type;
    typedef QString key_type;
    typedef int size_type;

    inline bool empty() const { return isEmpty(); }

private:
    friend class QJsonPrivate::Data;
    friend class QJsonValue;
    friend class QJsonDocument;
    friend class QJsonValueRef;

    friend __declspec(dllimport) QDebug operator<<(QDebug, const QJsonObject &);

    QJsonObject(QJsonPrivate::Data *data, QJsonPrivate::Object *object);
    void detach(uint reserve = 0);
    void compact();

    QString keyAt(int i) const;
    QJsonValue valueAt(int i) const;
    void setValueAt(int i, const QJsonValue &val);

    QJsonPrivate::Data *d;
    QJsonPrivate::Object *o;
};


__declspec(dllimport) QDebug operator<<(QDebug, const QJsonObject &);
#line 57 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstracteventdispatcher.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstracteventdispatcher.h"
class QAbstractNativeEventFilter;
class QAbstractEventDispatcherPrivate;
class QSocketNotifier;


class QWinEventNotifier;


class __declspec(dllimport) QAbstractEventDispatcher : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QAbstractEventDispatcherPrivate* d_func() { return reinterpret_cast<QAbstractEventDispatcherPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractEventDispatcherPrivate* d_func() const { return reinterpret_cast<const QAbstractEventDispatcherPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractEventDispatcherPrivate;

public:
    struct TimerInfo
    {
        int timerId;
        int interval;
        Qt::TimerType timerType;

        inline TimerInfo(int id, int i, Qt::TimerType t)
            : timerId(id), interval(i), timerType(t)
        { }
    };

    explicit QAbstractEventDispatcher(QObject *parent = 0);
    ~QAbstractEventDispatcher();

    static QAbstractEventDispatcher *instance(QThread *thread = 0);

    virtual bool processEvents(QEventLoop::ProcessEventsFlags flags) = 0;
    virtual bool hasPendingEvents() = 0;

    virtual void registerSocketNotifier(QSocketNotifier *notifier) = 0;
    virtual void unregisterSocketNotifier(QSocketNotifier *notifier) = 0;







    int registerTimer(int interval, Qt::TimerType timerType, QObject *object);
    virtual void registerTimer(int timerId, int interval, Qt::TimerType timerType, QObject *object) = 0;
    virtual bool unregisterTimer(int timerId) = 0;
    virtual bool unregisterTimers(QObject *object) = 0;
    virtual QList<TimerInfo> registeredTimers(QObject *object) const = 0;

    virtual int remainingTime(int timerId) = 0;


    virtual bool registerEventNotifier(QWinEventNotifier *notifier) = 0;
    virtual void unregisterEventNotifier(QWinEventNotifier *notifier) = 0;


    virtual void wakeUp() = 0;
    virtual void interrupt() = 0;
    virtual void flush() = 0;

    virtual void startingUp();
    virtual void closingDown();

    void installNativeEventFilter(QAbstractNativeEventFilter *filterObj);
    void removeNativeEventFilter(QAbstractNativeEventFilter *filterObj);
    bool filterNativeEvent(const QByteArray &eventType, void *message, long *result);




public:
    void aboutToBlock();
    void awake();

protected:
    QAbstractEventDispatcher(QAbstractEventDispatcherPrivate &,
                             QObject *parent);
};
#line 59 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractnativeeventfilter.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractnativeeventfilter.h"
class QAbstractNativeEventFilterPrivate;

class __declspec(dllimport) QAbstractNativeEventFilter
{
public:
    QAbstractNativeEventFilter();
    virtual ~QAbstractNativeEventFilter();

    virtual bool nativeEventFilter(const QByteArray &eventType, void *message, long *result) = 0;

private:
    QAbstractNativeEventFilter(const QAbstractNativeEventFilter &) = delete; QAbstractNativeEventFilter &operator=(const QAbstractNativeEventFilter &) = delete;
    QAbstractNativeEventFilterPrivate *d;
};
#line 60 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"






#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qmetaobject.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qmetaobject.h"
template <typename T> class QList;



class __declspec(dllimport) QMetaMethod
{
public:
    inline QMetaMethod() : mobj(0),handle(0) {}

    QByteArray methodSignature() const;
    QByteArray name() const;
    const char *typeName() const;
    int returnType() const;
    int parameterCount() const;
    int parameterType(int index) const;
    void getParameterTypes(int *types) const;
    QList<QByteArray> parameterTypes() const;
    QList<QByteArray> parameterNames() const;
    const char *tag() const;
    enum Access { Private, Protected, Public };
    Access access() const;
    enum MethodType { Method, Signal, Slot, Constructor };
    MethodType methodType() const;
    enum Attributes { Compatibility = 0x1, Cloned = 0x2, Scriptable = 0x4 };
    int attributes() const;
    int methodIndex() const;
    int revision() const;

    inline const QMetaObject *enclosingMetaObject() const { return mobj; }

    bool invoke(QObject *object,
                Qt::ConnectionType connectionType,
                QGenericReturnArgument returnValue,
                QGenericArgument val0 = QGenericArgument(0),
                QGenericArgument val1 = QGenericArgument(),
                QGenericArgument val2 = QGenericArgument(),
                QGenericArgument val3 = QGenericArgument(),
                QGenericArgument val4 = QGenericArgument(),
                QGenericArgument val5 = QGenericArgument(),
                QGenericArgument val6 = QGenericArgument(),
                QGenericArgument val7 = QGenericArgument(),
                QGenericArgument val8 = QGenericArgument(),
                QGenericArgument val9 = QGenericArgument()) const;
    inline bool invoke(QObject *object,
                       QGenericReturnArgument returnValue,
                       QGenericArgument val0 = QGenericArgument(0),
                       QGenericArgument val1 = QGenericArgument(),
                       QGenericArgument val2 = QGenericArgument(),
                       QGenericArgument val3 = QGenericArgument(),
                       QGenericArgument val4 = QGenericArgument(),
                       QGenericArgument val5 = QGenericArgument(),
                       QGenericArgument val6 = QGenericArgument(),
                       QGenericArgument val7 = QGenericArgument(),
                       QGenericArgument val8 = QGenericArgument(),
                       QGenericArgument val9 = QGenericArgument()) const
    {
        return invoke(object, Qt::AutoConnection, returnValue,
                      val0, val1, val2, val3, val4, val5, val6, val7, val8, val9);
    }
    inline bool invoke(QObject *object,
                       Qt::ConnectionType connectionType,
                       QGenericArgument val0 = QGenericArgument(0),
                       QGenericArgument val1 = QGenericArgument(),
                       QGenericArgument val2 = QGenericArgument(),
                       QGenericArgument val3 = QGenericArgument(),
                       QGenericArgument val4 = QGenericArgument(),
                       QGenericArgument val5 = QGenericArgument(),
                       QGenericArgument val6 = QGenericArgument(),
                       QGenericArgument val7 = QGenericArgument(),
                       QGenericArgument val8 = QGenericArgument(),
                       QGenericArgument val9 = QGenericArgument()) const
    {
        return invoke(object, connectionType, QGenericReturnArgument(),
                      val0, val1, val2, val3, val4, val5, val6, val7, val8, val9);
    }
    inline bool invoke(QObject *object,
                       QGenericArgument val0 = QGenericArgument(0),
                       QGenericArgument val1 = QGenericArgument(),
                       QGenericArgument val2 = QGenericArgument(),
                       QGenericArgument val3 = QGenericArgument(),
                       QGenericArgument val4 = QGenericArgument(),
                       QGenericArgument val5 = QGenericArgument(),
                       QGenericArgument val6 = QGenericArgument(),
                       QGenericArgument val7 = QGenericArgument(),
                       QGenericArgument val8 = QGenericArgument(),
                       QGenericArgument val9 = QGenericArgument()) const
    {
        return invoke(object, Qt::AutoConnection, QGenericReturnArgument(),
                      val0, val1, val2, val3, val4, val5, val6, val7, val8, val9);
    }

    inline bool isValid() const { return mobj != 0; }




    template <typename Func>
    static inline QMetaMethod fromSignal(Func signal)
    {
        typedef QtPrivate::FunctionPointer<Func> SignalType;
        static_assert(bool(QtPrivate::HasQ_OBJECT_Macro<typename SignalType::Object>::Value), "No Q_OBJECT in the class with the signal");

        return fromSignalImpl(&SignalType::Object::staticMetaObject,
                              reinterpret_cast<void **>(&signal));
    }


private:






    static QMetaMethod fromSignalImpl(const QMetaObject *, void **);

    const QMetaObject *mobj;
    uint handle;
    friend class QMetaMethodPrivate;
    friend struct QMetaObject;
    friend struct QMetaObjectPrivate;
    friend class QObject;
    friend bool operator==(const QMetaMethod &m1, const QMetaMethod &m2);
    friend bool operator!=(const QMetaMethod &m1, const QMetaMethod &m2);
};
template<> class QTypeInfo<QMetaMethod > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMetaMethod)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QMetaMethod >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QMetaMethod) }; static inline const char *name() { return "QMetaMethod"; } };

inline bool operator==(const QMetaMethod &m1, const QMetaMethod &m2)
{ return m1.mobj == m2.mobj && m1.handle == m2.handle; }
inline bool operator!=(const QMetaMethod &m1, const QMetaMethod &m2)
{ return !(m1 == m2); }

class __declspec(dllimport) QMetaEnum
{
public:
    inline QMetaEnum() : mobj(0),handle(0) {}

    const char *name() const;
    bool isFlag() const;

    int keyCount() const;
    const char *key(int index) const;
    int value(int index) const;

    const char *scope() const;

    int keyToValue(const char *key, bool *ok = 0) const;
    const char* valueToKey(int value) const;
    int keysToValue(const char * keys, bool *ok = 0) const;
    QByteArray valueToKeys(int value) const;

    inline const QMetaObject *enclosingMetaObject() const { return mobj; }

    inline bool isValid() const { return name() != 0; }
private:
    const QMetaObject *mobj;
    uint handle;
    friend struct QMetaObject;
};
template<> class QTypeInfo<QMetaEnum > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMetaEnum)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QMetaEnum >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QMetaEnum) }; static inline const char *name() { return "QMetaEnum"; } };

class __declspec(dllimport) QMetaProperty
{
public:
    QMetaProperty();

    const char *name() const;
    const char *typeName() const;
    QVariant::Type type() const;
    int userType() const;
    int propertyIndex() const;

    bool isReadable() const;
    bool isWritable() const;
    bool isResettable() const;
    bool isDesignable(const QObject *obj = 0) const;
    bool isScriptable(const QObject *obj = 0) const;
    bool isStored(const QObject *obj = 0) const;
    bool isEditable(const QObject *obj = 0) const;
    bool isUser(const QObject *obj = 0) const;
    bool isConstant() const;
    bool isFinal() const;

    bool isFlagType() const;
    bool isEnumType() const;
    QMetaEnum enumerator() const;

    bool hasNotifySignal() const;
    QMetaMethod notifySignal() const;
    int notifySignalIndex() const;

    int revision() const;

    QVariant read(const QObject *obj) const;
    bool write(QObject *obj, const QVariant &value) const;
    bool reset(QObject *obj) const;

    bool hasStdCppSet() const;
    inline bool isValid() const { return isReadable(); }
    inline const QMetaObject *enclosingMetaObject() const { return mobj; }

private:
    const QMetaObject *mobj;
    uint handle;
    int idx;
    QMetaEnum menum;
    friend struct QMetaObject;
    friend struct QMetaObjectPrivate;
};

class __declspec(dllimport) QMetaClassInfo
{
public:
    inline QMetaClassInfo() : mobj(0),handle(0) {}
    const char *name() const;
    const char *value() const;
    inline const QMetaObject *enclosingMetaObject() const { return mobj; }
private:
    const QMetaObject *mobj;
    uint handle;
    friend struct QMetaObject;
};
template<> class QTypeInfo<QMetaClassInfo > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMetaClassInfo)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QMetaClassInfo >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QMetaClassInfo) }; static inline const char *name() { return "QMetaClassInfo"; } };
#line 66 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qmimedata.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qmimedata.h"
class QUrl;
class QMimeDataPrivate;

class __declspec(dllimport) QMimeData : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    QMimeData();
    ~QMimeData();

    QList<QUrl> urls() const;
    void setUrls(const QList<QUrl> &urls);
    bool hasUrls() const;

    QString text() const;
    void setText(const QString &text);
    bool hasText() const;

    QString html() const;
    void setHtml(const QString &html);
    bool hasHtml() const;

    QVariant imageData() const;
    void setImageData(const QVariant &image);
    bool hasImage() const;

    QVariant colorData() const;
    void setColorData(const QVariant &color);
    bool hasColor() const;

    QByteArray data(const QString &mimetype) const;
    void setData(const QString &mimetype, const QByteArray &data);
    void removeFormat(const QString &mimetype);

    virtual bool hasFormat(const QString &mimetype) const;
    virtual QStringList formats() const;

    void clear();
protected:
    virtual QVariant retrieveData(const QString &mimetype,
                                      QVariant::Type preferredType) const;
private:
    QMimeData(const QMimeData &) = delete; QMimeData &operator=(const QMimeData &) = delete;
    inline QMimeDataPrivate* d_func() { return reinterpret_cast<QMimeDataPrivate *>(qGetPtrHelper(d_ptr)); } inline const QMimeDataPrivate* d_func() const { return reinterpret_cast<const QMimeDataPrivate *>(qGetPtrHelper(d_ptr)); } friend class QMimeDataPrivate;
};
#line 68 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qobjectcleanuphandler.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qobjectcleanuphandler.h"
class __declspec(dllimport) QObjectCleanupHandler : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};

public:
    QObjectCleanupHandler();
    ~QObjectCleanupHandler();

    QObject* add(QObject* object);
    void remove(QObject *object);
    bool isEmpty() const;
    void clear();

private:

    QObjectList cleanupObjects;

private :
    void objectDestroyed(QObject *);
};
#line 70 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qpointer.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qpointer.h"
class QVariant;

template <class T>
class QPointer
{
    template<typename U>
    struct TypeSelector
    {
        typedef QObject Type;
    };
    template<typename U>
    struct TypeSelector<const U>
    {
        typedef const QObject Type;
    };
    typedef typename TypeSelector<T>::Type QObjectType;
    QWeakPointer<QObjectType> wp;
public:
    inline QPointer() { }
    inline QPointer(T *p) : wp(p, true) { }

    inline ~QPointer() { }

    inline QPointer<T> &operator=(T* p)
    { wp.assign(static_cast<QObjectType*>(p)); return *this; }

    inline T* data() const
    { return static_cast<T*>( wp.data()); }
    inline T* operator->() const
    { return data(); }
    inline T& operator*() const
    { return *data(); }
    inline operator T*() const
    { return data(); }

    inline bool isNull() const
    { return wp.isNull(); }

    inline void clear()
    { wp.clear(); }
};
template <class T> class QTypeInfo<QPointer<T> > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPointer<T>)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QPointer<T> >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QPointer<T>) }; static inline const char *name() { return "QPointer<T>"; } };

template <class T>
inline bool operator==(const T *o, const QPointer<T> &p)
{ return o == p.operator->(); }

template<class T>
inline bool operator==(const QPointer<T> &p, const T *o)
{ return p.operator->() == o; }

template <class T>
inline bool operator==(T *o, const QPointer<T> &p)
{ return o == p.operator->(); }

template<class T>
inline bool operator==(const QPointer<T> &p, T *o)
{ return p.operator->() == o; }

template<class T>
inline bool operator==(const QPointer<T> &p1, const QPointer<T> &p2)
{ return p1.operator->() == p2.operator->(); }

template <class T>
inline bool operator!=(const T *o, const QPointer<T> &p)
{ return o != p.operator->(); }

template<class T>
inline bool operator!= (const QPointer<T> &p, const T *o)
{ return p.operator->() != o; }

template <class T>
inline bool operator!=(T *o, const QPointer<T> &p)
{ return o != p.operator->(); }

template<class T>
inline bool operator!= (const QPointer<T> &p, T *o)
{ return p.operator->() != o; }

template<class T>
inline bool operator!= (const QPointer<T> &p1, const QPointer<T> &p2)
{ return p1.operator->() != p2.operator->() ; }

template<typename T>
QPointer<T>
qPointerFromVariant(const QVariant &variant)
{
    return QPointer<T>(qobject_cast<T*>(QtSharedPointer::weakPointerFromVariant_internal(variant).data()));
}
#line 72 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsharedmemory.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsharedmemory.h"
class QSharedMemoryPrivate;

class __declspec(dllimport) QSharedMemory : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QSharedMemoryPrivate* d_func() { return reinterpret_cast<QSharedMemoryPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSharedMemoryPrivate* d_func() const { return reinterpret_cast<const QSharedMemoryPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSharedMemoryPrivate;

public:
    enum AccessMode
    {
        ReadOnly,
        ReadWrite
    };

    enum SharedMemoryError
    {
        NoError,
        PermissionDenied,
        InvalidSize,
        KeyError,
        AlreadyExists,
        NotFound,
        LockError,
        OutOfResources,
        UnknownError
    };

    QSharedMemory(QObject *parent = 0);
    QSharedMemory(const QString &key, QObject *parent = 0);
    ~QSharedMemory();

    void setKey(const QString &key);
    QString key() const;
    void setNativeKey(const QString &key);
    QString nativeKey() const;

    bool create(int size, AccessMode mode = ReadWrite);
    int size() const;

    bool attach(AccessMode mode = ReadWrite);
    bool isAttached() const;
    bool detach();

    void *data();
    const void* constData() const;
    const void *data() const;


    bool lock();
    bool unlock();


    SharedMemoryError error() const;
    QString errorString() const;

private:
    QSharedMemory(const QSharedMemory &) = delete; QSharedMemory &operator=(const QSharedMemory &) = delete;
};
#line 73 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsignalmapper.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsignalmapper.h"
class QSignalMapperPrivate;

class __declspec(dllimport) QSignalMapper : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QSignalMapperPrivate* d_func() { return reinterpret_cast<QSignalMapperPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSignalMapperPrivate* d_func() const { return reinterpret_cast<const QSignalMapperPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSignalMapperPrivate;
public:
    explicit QSignalMapper(QObject *parent = 0);
    ~QSignalMapper();

    void setMapping(QObject *sender, int id);
    void setMapping(QObject *sender, const QString &text);
    void setMapping(QObject *sender, QWidget *widget);
    void setMapping(QObject *sender, QObject *object);
    void removeMappings(QObject *sender);

    QObject *mapping(int id) const;
    QObject *mapping(const QString &text) const;
    QObject *mapping(QWidget *widget) const;
    QObject *mapping(QObject *object) const;

public:
    void mapped(int);
    void mapped(const QString &);
    void mapped(QWidget *);
    void mapped(QObject *);

public :
    void map();
    void map(QObject *sender);

private:
    QSignalMapper(const QSignalMapper &) = delete; QSignalMapper &operator=(const QSignalMapper &) = delete;

};
#line 74 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsocketnotifier.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsocketnotifier.h"
class QSocketNotifierPrivate;
class __declspec(dllimport) QSocketNotifier : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QSocketNotifierPrivate* d_func() { return reinterpret_cast<QSocketNotifierPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSocketNotifierPrivate* d_func() const { return reinterpret_cast<const QSocketNotifierPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSocketNotifierPrivate;

public:
    enum Type { Read, Write, Exception };

    QSocketNotifier(qintptr socket, Type, QObject *parent = 0);
    ~QSocketNotifier();

    qintptr socket() const;
    Type type() const;

    bool isEnabled() const;

public :
    void setEnabled(bool);

public:
    void activated(int socket

    , QPrivateSignal

    );

protected:
    bool event(QEvent *);

private:
    QSocketNotifier(const QSocketNotifier &) = delete; QSocketNotifier &operator=(const QSocketNotifier &) = delete;
};
#line 75 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsystemsemaphore.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsystemsemaphore.h"
class QSystemSemaphorePrivate;

class __declspec(dllimport) QSystemSemaphore
{

public:
    enum AccessMode
    {
        Open,
        Create
    };

    enum SystemSemaphoreError
    {
        NoError,
        PermissionDenied,
        KeyError,
        AlreadyExists,
        NotFound,
        OutOfResources,
        UnknownError
    };

    QSystemSemaphore(const QString &key, int initialValue = 0, AccessMode mode = Open);
    ~QSystemSemaphore();

    void setKey(const QString &key, int initialValue = 0, AccessMode mode = Open);
    QString key() const;

    bool acquire();
    bool release(int n = 1);

    SystemSemaphoreError error() const;
    QString errorString() const;

private:
    QSystemSemaphore(const QSystemSemaphore &) = delete; QSystemSemaphore &operator=(const QSystemSemaphore &) = delete;
    QScopedPointer<QSystemSemaphorePrivate> d;
};
#line 76 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"




#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qwineventnotifier.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qwineventnotifier.h"
class QWinEventNotifierPrivate;
class __declspec(dllimport) QWinEventNotifier : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QWinEventNotifierPrivate* d_func() { return reinterpret_cast<QWinEventNotifierPrivate *>(qGetPtrHelper(d_ptr)); } inline const QWinEventNotifierPrivate* d_func() const { return reinterpret_cast<const QWinEventNotifierPrivate *>(qGetPtrHelper(d_ptr)); } friend class QWinEventNotifierPrivate;
    typedef Qt::HANDLE HANDLE;

public:
    explicit QWinEventNotifier(QObject *parent = 0);
    explicit QWinEventNotifier(HANDLE hEvent, QObject *parent = 0);
    ~QWinEventNotifier();

    void setHandle(HANDLE hEvent);
    HANDLE handle() const;

    bool isEnabled() const;

public :
    void setEnabled(bool enable);

public:
    void activated(HANDLE hEvent

    , QPrivateSignal

    );

protected:
    bool event(QEvent * e);
};
#line 80 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qmimedatabase.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qmimedatabase.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmimetype.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qmimetype.h"
class QMimeTypePrivate;
class QFileinfo;
class QStringList;

class __declspec(dllimport) QMimeType
{
public:
    QMimeType();
    QMimeType(const QMimeType &other);
    QMimeType &operator=(const QMimeType &other);

    QMimeType &operator=(QMimeType &&other)
    {
        qSwap(d, other.d);
        return *this;
    }

    void swap(QMimeType &other)
    {
        qSwap(d, other.d);
    }
    explicit QMimeType(const QMimeTypePrivate &dd);
    ~QMimeType();

    bool operator==(const QMimeType &other) const;

    inline bool operator!=(const QMimeType &other) const
    {
        return !operator==(other);
    }

    bool isValid() const;

    bool isDefault() const;

    QString name() const;
    QString comment() const;
    QString genericIconName() const;
    QString iconName() const;
    QStringList globPatterns() const;
    QStringList parentMimeTypes() const;
    QStringList allAncestors() const;
    QStringList aliases() const;
    QStringList suffixes() const;
    QString preferredSuffix() const;

    bool inherits(const QString &mimeTypeName) const;

    QString filterString() const;

protected:
    friend class QMimeTypeParserBase;
    friend class MimeTypeMapEntry;
    friend class QMimeDatabasePrivate;
    friend class QMimeXMLProvider;
    friend class QMimeBinaryProvider;
    friend class QMimeTypePrivate;

    QExplicitlySharedDataPointer<QMimeTypePrivate> d;
};

template<> class QTypeInfo<QMimeType > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QMimeType)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QMimeType >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QMimeType) }; static inline const char *name() { return "QMimeType"; } }; template <> inline void qSwap<QMimeType>(QMimeType &value1, QMimeType &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QMimeType >(::QMimeType &value1, ::QMimeType &value2) { value1.swap(value2); } }
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qmimedatabase.h"





class QByteArray;
class QFileInfo;
class QIODevice;
class QUrl;

class QMimeDatabasePrivate;
class __declspec(dllimport) QMimeDatabase
{
    QMimeDatabase(const QMimeDatabase &) = delete; QMimeDatabase &operator=(const QMimeDatabase &) = delete;

public:
    QMimeDatabase();
    ~QMimeDatabase();

    QMimeType mimeTypeForName(const QString &nameOrAlias) const;

    enum MatchMode {
        MatchDefault = 0x0,
        MatchExtension = 0x1,
        MatchContent = 0x2
    };

    QMimeType mimeTypeForFile(const QString &fileName, MatchMode mode = MatchDefault) const;
    QMimeType mimeTypeForFile(const QFileInfo &fileInfo, MatchMode mode = MatchDefault) const;
    QList<QMimeType> mimeTypesForFileName(const QString &fileName) const;

    QMimeType mimeTypeForData(const QByteArray &data) const;
    QMimeType mimeTypeForData(QIODevice *device) const;

    QMimeType mimeTypeForUrl(const QUrl &url) const;
    QMimeType mimeTypeForFileNameAndData(const QString &fileName, QIODevice *device) const;
    QMimeType mimeTypeForFileNameAndData(const QString &fileName, const QByteArray &data) const;

    QString suffixForFileName(const QString &fileName) const;

    QList<QMimeType> allMimeTypes() const;

private:
    QMimeDatabasePrivate *d;
};
#line 81 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfactoryinterface.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfactoryinterface.h"
struct __declspec(dllimport) QFactoryInterface
{
    virtual ~QFactoryInterface() {}
    virtual QStringList keys() const = 0;
};


template <> inline const char *qobject_interface_iid<QFactoryInterface *>() { return "org.qt-project.Qt.QFactoryInterface"; } template <> inline QFactoryInterface *qobject_cast<QFactoryInterface *>(QObject *object) { return reinterpret_cast<QFactoryInterface *>((object ? object->qt_metacast("org.qt-project.Qt.QFactoryInterface") : 0)); } template <> inline QFactoryInterface *qobject_cast<QFactoryInterface *>(const QObject *object) { return reinterpret_cast<QFactoryInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("org.qt-project.Qt.QFactoryInterface") : 0)); }
#line 83 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlibrary.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlibrary.h"
class QLibraryPrivate;

class __declspec(dllimport) QLibrary : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};



public:
    enum LoadHint {
        ResolveAllSymbolsHint = 0x01,
        ExportExternalSymbolsHint = 0x02,
        LoadArchiveMemberHint = 0x04,
        PreventUnloadHint = 0x08
    };
    typedef QFlags<LoadHint> LoadHints;

    explicit QLibrary(QObject *parent = 0);
    explicit QLibrary(const QString& fileName, QObject *parent = 0);
    explicit QLibrary(const QString& fileName, int verNum, QObject *parent = 0);
    explicit QLibrary(const QString& fileName, const QString &version, QObject *parent = 0);
    ~QLibrary();

    QFunctionPointer resolve(const char *symbol);
    static QFunctionPointer resolve(const QString &fileName, const char *symbol);
    static QFunctionPointer resolve(const QString &fileName, int verNum, const char *symbol);
    static QFunctionPointer resolve(const QString &fileName, const QString &version, const char *symbol);

    bool load();
    bool unload();
    bool isLoaded() const;

    static bool isLibrary(const QString &fileName);

    void setFileName(const QString &fileName);
    QString fileName() const;

    void setFileNameAndVersion(const QString &fileName, int verNum);
    void setFileNameAndVersion(const QString &fileName, const QString &version);
    QString errorString() const;

    void setLoadHints(LoadHints hints);
    LoadHints loadHints() const;
private:
    QLibraryPrivate *d;
    bool did_load;
    QLibrary(const QLibrary &) = delete; QLibrary &operator=(const QLibrary &) = delete;
};

 inline QFlags<QLibrary::LoadHints::enum_type> operator|(QLibrary::LoadHints::enum_type f1, QLibrary::LoadHints::enum_type f2) { return QFlags<QLibrary::LoadHints::enum_type>(f1) | f2; } inline QFlags<QLibrary::LoadHints::enum_type> operator|(QLibrary::LoadHints::enum_type f1, QFlags<QLibrary::LoadHints::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QLibrary::LoadHints::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
#line 84 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qplugin.h"
#line 60 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qplugin.h"
typedef QObject *(*QtPluginInstanceFunction)();
typedef const char *(*QtPluginMetaDataFunction)();

struct __declspec(dllimport) QStaticPlugin
{



    QtPluginInstanceFunction instance;
    QtPluginMetaDataFunction rawMetaData;






    QJsonObject metaData() const;
};
template<> class QTypeInfo<QStaticPlugin > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QStaticPlugin)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QStaticPlugin >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QStaticPlugin) }; static inline const char *name() { return "QStaticPlugin"; } };

void __declspec(dllimport) qRegisterStaticPluginFunction(QStaticPlugin staticPlugin);
#line 91 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qplugin.h"
#pragma section(".qtmetadata",read,shared)
#line 85 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qpluginloader.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qpluginloader.h"
class QLibraryPrivate;
class QJsonObject;

class __declspec(dllimport) QPluginLoader : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};


public:
    explicit QPluginLoader(QObject *parent = 0);
    explicit QPluginLoader(const QString &fileName, QObject *parent = 0);
    ~QPluginLoader();

    QObject *instance();
    QJsonObject metaData() const;

    static QObjectList staticInstances();
    static QVector<QStaticPlugin> staticPlugins();

    bool load();
    bool unload();
    bool isLoaded() const;

    void setFileName(const QString &fileName);
    QString fileName() const;

    QString errorString() const;

    void setLoadHints(QLibrary::LoadHints loadHints);
    QLibrary::LoadHints loadHints() const;

private:
    QLibraryPrivate *d;
    bool did_load;
    QPluginLoader(const QPluginLoader &) = delete; QPluginLoader &operator=(const QPluginLoader &) = delete;
};
#line 86 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/quuid.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/quuid.h"
typedef struct _GUID
{
    ulong Data1;
    ushort Data2;
    ushort Data3;
    uchar Data4[8];
} GUID, *REFGUID, *LPGUID;







class __declspec(dllimport) QUuid
{
public:
    enum Variant {
        VarUnknown =-1,
        NCS = 0,
        DCE = 2,
        Microsoft = 6,
        Reserved = 7
    };

    enum Version {
        VerUnknown =-1,
        Time = 1,
        EmbeddedPOSIX = 2,
        Md5 = 3,
        Name = Md5,
        Random = 4,
        Sha1 = 5
    };
#line 92 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/quuid.h"
    QUuid()
    {
        data1 = 0;
        data2 = 0;
        data3 = 0;
        for(int i = 0; i < 8; i++)
            data4[i] = 0;
    }
    QUuid(uint l, ushort w1, ushort w2, uchar b1, uchar b2, uchar b3, uchar b4, uchar b5, uchar b6, uchar b7, uchar b8)
    {
        data1 = l;
        data2 = w1;
        data3 = w2;
        data4[0] = b1;
        data4[1] = b2;
        data4[2] = b3;
        data4[3] = b4;
        data4[4] = b5;
        data4[5] = b6;
        data4[6] = b7;
        data4[7] = b8;
    }


    QUuid(const QString &);
    QUuid(const char *);
    QString toString() const;
    QUuid(const QByteArray &);
    QByteArray toByteArray() const;
    QByteArray toRfc4122() const;
    static QUuid fromRfc4122(const QByteArray &);
    bool isNull() const;

    bool operator==(const QUuid &orig) const
    {
        uint i;
        if (data1 != orig.data1 || data2 != orig.data2 ||
             data3 != orig.data3)
            return false;

        for(i = 0; i < 8; i++)
            if (data4[i] != orig.data4[i])
                return false;

        return true;
    }

    bool operator!=(const QUuid &orig) const
    {
        return !(*this == orig);
    }

    bool operator<(const QUuid &other) const;
    bool operator>(const QUuid &other) const;
#line 156 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/quuid.h"
    QUuid(const GUID &guid)
    {
        data1 = guid.Data1;
        data2 = guid.Data2;
        data3 = guid.Data3;
        for(int i = 0; i < 8; i++)
            data4[i] = guid.Data4[i];
    }


    QUuid &operator=(const GUID &guid)
    {
        *this = QUuid(guid);
        return *this;
    }

    operator GUID() const
    {
        GUID guid = { data1, data2, data3, { data4[0], data4[1], data4[2], data4[3], data4[4], data4[5], data4[6], data4[7] } };
        return guid;
    }

    bool operator==(const GUID &guid) const
    {
        return *this == QUuid(guid);
    }

    bool operator!=(const GUID &guid) const
    {
        return !(*this == guid);
    }

    static QUuid createUuid();

    static QUuid createUuidV3(const QUuid &ns, const QByteArray &baseData);
    static QUuid createUuidV5(const QUuid &ns, const QByteArray &baseData);
    static inline QUuid createUuidV3(const QUuid &ns, const QString &baseData)
    {
        return QUuid::createUuidV3(ns, baseData.toUtf8());
    }

    static inline QUuid createUuidV5(const QUuid &ns, const QString &baseData)
    {
        return QUuid::createUuidV5(ns, baseData.toUtf8());
    }



    QUuid::Variant variant() const;
    QUuid::Version version() const;

    uint data1;
    ushort data2;
    ushort data3;
    uchar data4[8];
};

template<> class QTypeInfo<QUuid > { public: enum { isComplex = (((Q_PRIMITIVE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_PRIMITIVE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QUuid)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QUuid >::value, isDummy = (((Q_PRIMITIVE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QUuid) }; static inline const char *name() { return "QUuid"; } };


__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QUuid &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QUuid &);



__declspec(dllimport) QDebug operator<<(QDebug, const QUuid &);


__declspec(dllimport) uint qHash(const QUuid &uuid, uint seed = 0) throw();
#line 87 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractstate.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstractstate.h"
class QState;
class QStateMachine;

class QAbstractStatePrivate;
class __declspec(dllimport) QAbstractState : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    ~QAbstractState();

    QState *parentState() const;
    QStateMachine *machine() const;

public:
    void entered(

      QPrivateSignal

    );
    void exited(

      QPrivateSignal

    );

protected:
    QAbstractState(QState *parent = 0);

    virtual void onEntry(QEvent *event) = 0;
    virtual void onExit(QEvent *event) = 0;

    bool event(QEvent *e);

protected:
    QAbstractState(QAbstractStatePrivate &dd, QState *parent);

private:
    QAbstractState(const QAbstractState &) = delete; QAbstractState &operator=(const QAbstractState &) = delete;
    inline QAbstractStatePrivate* d_func() { return reinterpret_cast<QAbstractStatePrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractStatePrivate* d_func() const { return reinterpret_cast<const QAbstractStatePrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractStatePrivate;
};
#line 88 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstracttransition.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qabstracttransition.h"
class QEvent;
class QAbstractState;
class QState;
class QStateMachine;


class QAbstractAnimation;


class QAbstractTransitionPrivate;
class __declspec(dllimport) QAbstractTransition : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};



public:
    QAbstractTransition(QState *sourceState = 0);
    virtual ~QAbstractTransition();

    QState *sourceState() const;
    QAbstractState *targetState() const;
    void setTargetState(QAbstractState* target);
    QList<QAbstractState*> targetStates() const;
    void setTargetStates(const QList<QAbstractState*> &targets);

    QStateMachine *machine() const;


    void addAnimation(QAbstractAnimation *animation);
    void removeAnimation(QAbstractAnimation *animation);
    QList<QAbstractAnimation*> animations() const;


public:
    void triggered(

      QPrivateSignal

    );

protected:
    virtual bool eventTest(QEvent *event) = 0;

    virtual void onTransition(QEvent *event) = 0;

    bool event(QEvent *e);

protected:
    QAbstractTransition(QAbstractTransitionPrivate &dd, QState *parent);

private:
    QAbstractTransition(const QAbstractTransition &) = delete; QAbstractTransition &operator=(const QAbstractTransition &) = delete;
    inline QAbstractTransitionPrivate* d_func() { return reinterpret_cast<QAbstractTransitionPrivate *>(qGetPtrHelper(d_ptr)); } inline const QAbstractTransitionPrivate* d_func() const { return reinterpret_cast<const QAbstractTransitionPrivate *>(qGetPtrHelper(d_ptr)); } friend class QAbstractTransitionPrivate;
};
#line 89 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qeventtransition.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qeventtransition.h"
class QEventTransitionPrivate;
class __declspec(dllimport) QEventTransition : public QAbstractTransition
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};


public:
    QEventTransition(QState *sourceState = 0);
    QEventTransition(QObject *object, QEvent::Type type, QState *sourceState = 0);
    ~QEventTransition();

    QObject *eventSource() const;
    void setEventSource(QObject *object);

    QEvent::Type eventType() const;
    void setEventType(QEvent::Type type);

protected:
    bool eventTest(QEvent *event);
    void onTransition(QEvent *event);

    bool event(QEvent *e);

protected:
    QEventTransition(QEventTransitionPrivate &dd, QState *parent);
    QEventTransition(QEventTransitionPrivate &dd, QObject *object,
                     QEvent::Type type, QState *parent);

private:
    QEventTransition(const QEventTransition &) = delete; QEventTransition &operator=(const QEventTransition &) = delete;
    inline QEventTransitionPrivate* d_func() { return reinterpret_cast<QEventTransitionPrivate *>(qGetPtrHelper(d_ptr)); } inline const QEventTransitionPrivate* d_func() const { return reinterpret_cast<const QEventTransitionPrivate *>(qGetPtrHelper(d_ptr)); } friend class QEventTransitionPrivate;
};
#line 90 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfinalstate.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfinalstate.h"
class QFinalStatePrivate;
class __declspec(dllimport) QFinalState : public QAbstractState
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    QFinalState(QState *parent = 0);
    ~QFinalState();

protected:
    void onEntry(QEvent *event);
    void onExit(QEvent *event);

    bool event(QEvent *e);

private:
    QFinalState(const QFinalState &) = delete; QFinalState &operator=(const QFinalState &) = delete;
    inline QFinalStatePrivate* d_func() { return reinterpret_cast<QFinalStatePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFinalStatePrivate* d_func() const { return reinterpret_cast<const QFinalStatePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFinalStatePrivate;
};
#line 91 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qhistorystate.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qhistorystate.h"
class QHistoryStatePrivate;
class __declspec(dllimport) QHistoryState : public QAbstractState
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};



public:
    enum HistoryType {
        ShallowHistory,
        DeepHistory
    };

    QHistoryState(QState *parent = 0);
    QHistoryState(HistoryType type, QState *parent = 0);
    ~QHistoryState();

    QAbstractState *defaultState() const;
    void setDefaultState(QAbstractState *state);

    HistoryType historyType() const;
    void setHistoryType(HistoryType type);

protected:
    void onEntry(QEvent *event);
    void onExit(QEvent *event);

    bool event(QEvent *e);

private:
    QHistoryState(const QHistoryState &) = delete; QHistoryState &operator=(const QHistoryState &) = delete;
    inline QHistoryStatePrivate* d_func() { return reinterpret_cast<QHistoryStatePrivate *>(qGetPtrHelper(d_ptr)); } inline const QHistoryStatePrivate* d_func() const { return reinterpret_cast<const QHistoryStatePrivate *>(qGetPtrHelper(d_ptr)); } friend class QHistoryStatePrivate;
};
#line 92 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsignaltransition.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsignaltransition.h"
class QSignalTransitionPrivate;
class __declspec(dllimport) QSignalTransition : public QAbstractTransition
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};


public:
    QSignalTransition(QState *sourceState = 0);
    QSignalTransition(const QObject *sender, const char *signal,
                      QState *sourceState = 0);
    ~QSignalTransition();

    QObject *senderObject() const;
    void setSenderObject(const QObject *sender);

    QByteArray signal() const;
    void setSignal(const QByteArray &signal);

protected:
    bool eventTest(QEvent *event);
    void onTransition(QEvent *event);

    bool event(QEvent *e);

private:
    QSignalTransition(const QSignalTransition &) = delete; QSignalTransition &operator=(const QSignalTransition &) = delete;
    inline QSignalTransitionPrivate* d_func() { return reinterpret_cast<QSignalTransitionPrivate *>(qGetPtrHelper(d_ptr)); } inline const QSignalTransitionPrivate* d_func() const { return reinterpret_cast<const QSignalTransitionPrivate *>(qGetPtrHelper(d_ptr)); } friend class QSignalTransitionPrivate;
};
#line 93 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstate.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstate.h"
class QAbstractTransition;
class QSignalTransition;

class QStatePrivate;
class __declspec(dllimport) QState : public QAbstractState
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};




public:
    enum ChildMode {
        ExclusiveStates,
        ParallelStates
    };

    enum RestorePolicy {
        DontRestoreProperties,
        RestoreProperties
    };

    QState(QState *parent = 0);
    QState(ChildMode childMode, QState *parent = 0);
    ~QState();

    QAbstractState *errorState() const;
    void setErrorState(QAbstractState *state);

    void addTransition(QAbstractTransition *transition);
    QSignalTransition *addTransition(const QObject *sender, const char *signal, QAbstractState *target);
    QAbstractTransition *addTransition(QAbstractState *target);
    void removeTransition(QAbstractTransition *transition);
    QList<QAbstractTransition*> transitions() const;

    QAbstractState *initialState() const;
    void setInitialState(QAbstractState *state);

    ChildMode childMode() const;
    void setChildMode(ChildMode mode);


    void assignProperty(QObject *object, const char *name,
                        const QVariant &value);


public:
    void finished(

      QPrivateSignal

    );
    void propertiesAssigned(

      QPrivateSignal

    );

protected:
    void onEntry(QEvent *event);
    void onExit(QEvent *event);

    bool event(QEvent *e);

protected:
    QState(QStatePrivate &dd, QState *parent);

private:
    QState(const QState &) = delete; QState &operator=(const QState &) = delete;
    inline QStatePrivate* d_func() { return reinterpret_cast<QStatePrivate *>(qGetPtrHelper(d_ptr)); } inline const QStatePrivate* d_func() const { return reinterpret_cast<const QStatePrivate *>(qGetPtrHelper(d_ptr)); } friend class QStatePrivate;
};
#line 94 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstatemachine.h"
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstatemachine.h"
class QStateMachinePrivate;
class QAbstractAnimation;
class __declspec(dllimport) QStateMachine : public QState
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};





public:
    class __declspec(dllimport) SignalEvent : public QEvent
    {
    public:
        SignalEvent(QObject *sender, int signalIndex,
                     const QList<QVariant> &arguments);
        ~SignalEvent();

        inline QObject *sender() const { return m_sender; }
        inline int signalIndex() const { return m_signalIndex; }
        inline QList<QVariant> arguments() const { return m_arguments; }

    private:
        QObject *m_sender;
        int m_signalIndex;
        QList<QVariant> m_arguments;

        friend class QSignalTransitionPrivate;
    };

    class __declspec(dllimport) WrappedEvent : public QEvent
    {
    public:
        WrappedEvent(QObject *object, QEvent *event);
        ~WrappedEvent();

        inline QObject *object() const { return m_object; }
        inline QEvent *event() const { return m_event; }

    private:
        QObject *m_object;
        QEvent *m_event;
    };

    enum EventPriority {
        NormalPriority,
        HighPriority
    };

    enum Error {
        NoError,
        NoInitialStateError,
        NoDefaultStateInHistoryStateError,
        NoCommonAncestorForTransitionError
    };

    explicit QStateMachine(QObject *parent = 0);
    explicit QStateMachine(QState::ChildMode childMode, QObject *parent = 0);
    ~QStateMachine();

    void addState(QAbstractState *state);
    void removeState(QAbstractState *state);

    Error error() const;
    QString errorString() const;
    void clearError();

    bool isRunning() const;


    bool isAnimated() const;
    void setAnimated(bool enabled);

    void addDefaultAnimation(QAbstractAnimation *animation);
    QList<QAbstractAnimation *> defaultAnimations() const;
    void removeDefaultAnimation(QAbstractAnimation *animation);


    QState::RestorePolicy globalRestorePolicy() const;
    void setGlobalRestorePolicy(QState::RestorePolicy restorePolicy);

    void postEvent(QEvent *event, EventPriority priority = NormalPriority);
    int postDelayedEvent(QEvent *event, int delay);
    bool cancelDelayedEvent(int id);

    QSet<QAbstractState*> configuration() const;


    bool eventFilter(QObject *watched, QEvent *event);


public :
    void start();
    void stop();

public:
    void started(

      QPrivateSignal

    );
    void stopped(

      QPrivateSignal

    );

protected:
    void onEntry(QEvent *event);
    void onExit(QEvent *event);

    virtual void beginSelectTransitions(QEvent *event);
    virtual void endSelectTransitions(QEvent *event);

    virtual void beginMicrostep(QEvent *event);
    virtual void endMicrostep(QEvent *event);

    bool event(QEvent *e);

protected:
    QStateMachine(QStateMachinePrivate &dd, QObject *parent);

private:
    QStateMachine(const QStateMachine &) = delete; QStateMachine &operator=(const QStateMachine &) = delete;
    inline QStateMachinePrivate* d_func() { return reinterpret_cast<QStateMachinePrivate *>(qGetPtrHelper(d_ptr)); } inline const QStateMachinePrivate* d_func() const { return reinterpret_cast<const QStateMachinePrivate *>(qGetPtrHelper(d_ptr)); } friend class QStateMachinePrivate;







};
#line 95 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 96 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qexception.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qexception.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qatomic.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qexception.h"
#line 61 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qexception.h"
class __declspec(dllimport) QException : public std::exception
{
public:
    virtual void raise() const;
    virtual QException *clone() const;
};

class __declspec(dllimport) QUnhandledException : public QException
{
public:
    void raise() const;
    QUnhandledException *clone() const;
};

namespace QtPrivate {

class Base;
class __declspec(dllimport) ExceptionHolder
{
public:
    ExceptionHolder(QException *exception = 0);
    ExceptionHolder(const ExceptionHolder &other);
    void operator=(const ExceptionHolder &other);
    ~ExceptionHolder();
    QException *exception() const;
    QExplicitlySharedDataPointer<Base> base;
};

class __declspec(dllimport) ExceptionStore
{
public:
    void setException(const QException &e);
    bool hasException() const;
    ExceptionHolder exception();
    void throwPossibleException();
    bool hasThrown() const;
    ExceptionHolder exceptionHolder;
};

}
#line 97 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfuture.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfuture.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfutureinterface.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfutureinterface.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qrunnable.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qrunnable.h"
class QRunnable
{
    int ref;

    friend class QThreadPool;
    friend class QThreadPoolPrivate;
    friend class QThreadPoolThread;

public:
    virtual void run() = 0;

    QRunnable() : ref(0) { }
    virtual ~QRunnable() { }

    bool autoDelete() const { return ref != -1; }
    void setAutoDelete(bool _autoDelete) { ref = _autoDelete ? 0 : -1; }
};
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfutureinterface.h"






#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qresultstore.h"
#line 65 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qresultstore.h"
namespace QtPrivate {

class ResultItem
{
public:
    ResultItem(const void *_result, int _count) : m_count(_count), result(_result) { }
    ResultItem(const void *_result) : m_count(0), result(_result) { }
    ResultItem() : m_count(0), result(0) { }
    bool isValid() const { return result != 0; }
    bool isVector() const { return m_count != 0; }
    int count() const { return (m_count == 0) ? 1 : m_count; }
    int m_count;
    const void *result;
};

class __declspec(dllimport) ResultIteratorBase
{
public:
    ResultIteratorBase();
    ResultIteratorBase(QMap<int, ResultItem>::const_iterator _mapIterator, int _vectorIndex = 0);
    int vectorIndex() const;
    int resultIndex() const;

    ResultIteratorBase operator++();
    int batchSize() const;
    void batchedAdvance();
    bool operator==(const ResultIteratorBase &other) const;
    bool operator!=(const ResultIteratorBase &other) const;
    bool isVector() const;
    bool canIncrementVectorIndex() const;
protected:
    QMap<int, ResultItem>::const_iterator mapIterator;
    int m_vectorIndex;
};

template <typename T>
class ResultIterator : public ResultIteratorBase
{
public:
    ResultIterator(const ResultIteratorBase &base)
    : ResultIteratorBase(base) { }

    const T &value() const
    {
        return *pointer();
    }

    const T *pointer() const
    {
        if (mapIterator.value().isVector())
            return &(reinterpret_cast<const QVector<T> *>(mapIterator.value().result)->at(m_vectorIndex));
        else
            return reinterpret_cast<const T *>(mapIterator.value().result);
    }
};

class __declspec(dllimport) ResultStoreBase
{
public:
    ResultStoreBase();
    void setFilterMode(bool enable);
    bool filterMode() const;
    int addResult(int index, const void *result);
    int addResults(int index, const void *results, int vectorSize, int logicalCount);
    ResultIteratorBase begin() const;
    ResultIteratorBase end() const;
    bool hasNextResult() const;
    ResultIteratorBase resultAt(int index) const;
    bool contains(int index) const;
    int count() const;
    virtual ~ResultStoreBase() { }

protected:
    int insertResultItem(int index, ResultItem &resultItem);
    void insertResultItemIfValid(int index, ResultItem &resultItem);
    void syncPendingResults();
    void syncResultCount();
    int updateInsertIndex(int index, int _count);

    QMap<int, ResultItem> m_results;
    int insertIndex;
    int resultCount;

    bool m_filterMode;
    QMap<int, ResultItem> pendingResults;
    int filteredResults;

};

template <typename T>
class ResultStore : public ResultStoreBase
{
public:
    ResultStore() { }

    ResultStore(const ResultStoreBase &base)
    : ResultStoreBase(base) { }

    int addResult(int index, const T *result)
    {
        if (result == 0)
            return ResultStoreBase::addResult(index, result);
        else
            return ResultStoreBase::addResult(index, new T(*result));
    }

    int addResults(int index, const QVector<T> *results)
    {
        return ResultStoreBase::addResults(index, new QVector<T>(*results), results->count(), results->count());
    }

    int addResults(int index, const QVector<T> *results, int totalCount)
    {
        if (m_filterMode == true && results->count() != totalCount && 0 == results->count())
            return ResultStoreBase::addResults(index, 0, 0, totalCount);
        else
            return ResultStoreBase::addResults(index, new QVector<T>(*results), results->count(), totalCount);
    }

    int addCanceledResult(int index)
    {
        return addResult(index, 0);
    }

    int addCanceledResults(int index, int _count)
    {
        QVector<T> empty;
        return addResults(index, &empty, _count);
    }

    ResultIterator<T> begin() const
    {
        return static_cast<ResultIterator<T> >(ResultStoreBase::begin());
    }

    ResultIterator<T> end() const
    {
        return static_cast<ResultIterator<T> >(ResultStoreBase::end());
    }

    ResultIterator<T> resultAt(int index) const
    {
        return static_cast<ResultIterator<T> >(ResultStoreBase::resultAt(index));
    }

    void clear()
    {
        QMap<int, ResultItem>::const_iterator mapIterator = m_results.constBegin();
        while (mapIterator != m_results.constEnd()) {
            if (mapIterator.value().isVector())
                delete reinterpret_cast<const QVector<T> *>(mapIterator.value().result);
            else
                delete reinterpret_cast<const T *>(mapIterator.value().result);
            ++mapIterator;
        }
        resultCount = 0;
        m_results.clear();
    }

    ~ResultStore()
    {
        clear();
    }

};

}
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qfutureinterface.h"





template <typename T> class QFuture;
class QFutureInterfaceBasePrivate;
class QFutureWatcherBase;
class QFutureWatcherBasePrivate;

class __declspec(dllimport) QFutureInterfaceBase
{
public:
    enum State {
        NoState = 0x00,
        Running = 0x01,
        Started = 0x02,
        Finished = 0x04,
        Canceled = 0x08,
        Paused = 0x10,
        Throttled = 0x20
    };

    QFutureInterfaceBase(State initialState = NoState);
    QFutureInterfaceBase(const QFutureInterfaceBase &other);
    virtual ~QFutureInterfaceBase();


    void reportStarted();
    void reportFinished();
    void reportCanceled();

    void reportException(const QException &e);

    void reportResultsReady(int beginIndex, int endIndex);

    void setRunnable(QRunnable *runnable);
    void setFilterMode(bool enable);
    void setProgressRange(int minimum, int maximum);
    int progressMinimum() const;
    int progressMaximum() const;
    bool isProgressUpdateNeeded() const;
    void setProgressValue(int progressValue);
    int progressValue() const;
    void setProgressValueAndText(int progressValue, const QString &progressText);
    QString progressText() const;

    void setExpectedResultCount(int resultCount);
    int expectedResultCount();
    int resultCount() const;

    bool queryState(State state) const;
    bool isRunning() const;
    bool isStarted() const;
    bool isCanceled() const;
    bool isFinished() const;
    bool isPaused() const;
    bool isThrottled() const;
    bool isResultReadyAt(int index) const;

    void cancel();
    void setPaused(bool paused);
    void togglePaused();
    void setThrottled(bool enable);

    void waitForFinished();
    bool waitForNextResult();
    void waitForResult(int resultIndex);
    void waitForResume();

    QMutex *mutex() const;
    QtPrivate::ExceptionStore &exceptionStore();
    QtPrivate::ResultStoreBase &resultStoreBase();
    const QtPrivate::ResultStoreBase &resultStoreBase() const;

    inline bool operator==(const QFutureInterfaceBase &other) const { return d == other.d; }
    inline bool operator!=(const QFutureInterfaceBase &other) const { return d != other.d; }
    QFutureInterfaceBase &operator=(const QFutureInterfaceBase &other);

protected:
    bool refT() const;
    bool derefT() const;
public:


private:

    QFutureInterfaceBasePrivate *d;

private:
    friend class QFutureWatcherBase;
    friend class QFutureWatcherBasePrivate;
};

template <typename T>
class QFutureInterface : public QFutureInterfaceBase
{
public:
    QFutureInterface(State initialState = NoState)
        : QFutureInterfaceBase(initialState)
    {
        refT();
    }
    QFutureInterface(const QFutureInterface &other)
        : QFutureInterfaceBase(other)
    {
        refT();
    }
    ~QFutureInterface()
    {
        if (!derefT())
            resultStore().clear();
    }

    static QFutureInterface canceledResult()
    { return QFutureInterface(State(Started | Finished | Canceled)); }

    QFutureInterface &operator=(const QFutureInterface &other)
    {
        other.refT();
        if (!derefT())
            resultStore().clear();
        QFutureInterfaceBase::operator=(other);
        return *this;
    }

    inline QFuture<T> future();

    inline void reportResult(const T *result, int index = -1);
    inline void reportResult(const T &result, int index = -1);
    inline void reportResults(const QVector<T> &results, int beginIndex = -1, int count = -1);
    inline void reportFinished(const T *result = 0);

    inline const T &resultReference(int index) const;
    inline const T *resultPointer(int index) const;
    inline QList<T> results();
private:
    QtPrivate::ResultStore<T> &resultStore()
    { return static_cast<QtPrivate::ResultStore<T> &>(resultStoreBase()); }
    const QtPrivate::ResultStore<T> &resultStore() const
    { return static_cast<const QtPrivate::ResultStore<T> &>(resultStoreBase()); }
};

template <typename T>
inline void QFutureInterface<T>::reportResult(const T *result, int index)
{
    QMutexLocker locker(mutex());
    if (this->queryState(Canceled) || this->queryState(Finished)) {
        return;
    }

    QtPrivate::ResultStore<T> &store = resultStore();


    if (store.filterMode()) {
        const int resultCountBefore = store.count();
        store.addResult(index, result);
        this->reportResultsReady(resultCountBefore, resultCountBefore + store.count());
    } else {
        const int insertIndex = store.addResult(index, result);
        this->reportResultsReady(insertIndex, insertIndex + 1);
    }
}

template <typename T>
inline void QFutureInterface<T>::reportResult(const T &result, int index)
{
    reportResult(&result, index);
}

template <typename T>
inline void QFutureInterface<T>::reportResults(const QVector<T> &_results, int beginIndex, int count)
{
    QMutexLocker locker(mutex());
    if (this->queryState(Canceled) || this->queryState(Finished)) {
        return;
    }

    QtPrivate::ResultStore<T> &store = resultStore();

    if (store.filterMode()) {
        const int resultCountBefore = store.count();
        store.addResults(beginIndex, &_results, count);
        this->reportResultsReady(resultCountBefore, store.count());
    } else {
        const int insertIndex = store.addResults(beginIndex, &_results, count);
        this->reportResultsReady(insertIndex, insertIndex + _results.count());
    }
}

template <typename T>
inline void QFutureInterface<T>::reportFinished(const T *result)
{
    if (result)
        reportResult(result);
    QFutureInterfaceBase::reportFinished();
}

template <typename T>
inline const T &QFutureInterface<T>::resultReference(int index) const
{
    QMutexLocker lock(mutex());
    return resultStore().resultAt(index).value();
}

template <typename T>
inline const T *QFutureInterface<T>::resultPointer(int index) const
{
    QMutexLocker lock(mutex());
    return resultStore().resultAt(index).pointer();
}

template <typename T>
inline QList<T> QFutureInterface<T>::results()
{
    if (this->isCanceled()) {
        exceptionStore().throwPossibleException();
        return QList<T>();
    }
    QFutureInterfaceBase::waitForResult(-1);

    QList<T> res;
    QMutexLocker lock(mutex());

    QtPrivate::ResultIterator<T> it = resultStore().begin();
    while (it != resultStore().end()) {
        res.append(it.value());
        ++it;
    }

    return res;
}

template <>
class QFutureInterface<void> : public QFutureInterfaceBase
{
public:
    QFutureInterface<void>(State initialState = NoState)
        : QFutureInterfaceBase(initialState)
    { }
    QFutureInterface<void>(const QFutureInterface<void> &other)
        : QFutureInterfaceBase(other)
    { }

    static QFutureInterface<void> canceledResult()
    { return QFutureInterface(State(Started | Finished | Canceled)); }

    QFutureInterface<void> &operator=(const QFutureInterface<void> &other)
    {
        QFutureInterfaceBase::operator=(other);
        return *this;
    }

    inline QFuture<void> future();

    void reportResult(const void *, int) { }
    void reportResults(const QVector<void> &, int) { }
    void reportFinished(const void * = 0) { QFutureInterfaceBase::reportFinished(); }
};
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfuture.h"






template <typename T>
class QFutureWatcher;
template <>
class QFutureWatcher<void>;

template <typename T>
class QFuture
{
public:
    QFuture()
        : d(QFutureInterface<T>::canceledResult())
    { }
    explicit QFuture(QFutureInterface<T> *p)
        : d(*p)
    { }
    QFuture(const QFuture &other)
        : d(other.d)
    { }
    ~QFuture()
    { }

    inline QFuture &operator=(const QFuture &other);
    bool operator==(const QFuture &other) const { return (d == other.d); }
    bool operator!=(const QFuture &other) const { return (d != other.d); }

    void cancel() { d.cancel(); }
    bool isCanceled() const { return d.isCanceled(); }

    void setPaused(bool paused) { d.setPaused(paused); }
    bool isPaused() const { return d.isPaused(); }
    void pause() { setPaused(true); }
    void resume() { setPaused(false); }
    void togglePaused() { d.togglePaused(); }

    bool isStarted() const { return d.isStarted(); }
    bool isFinished() const { return d.isFinished(); }
    bool isRunning() const { return d.isRunning(); }

    int resultCount() const { return d.resultCount(); }
    int progressValue() const { return d.progressValue(); }
    int progressMinimum() const { return d.progressMinimum(); }
    int progressMaximum() const { return d.progressMaximum(); }
    QString progressText() const { return d.progressText(); }
    void waitForFinished() { d.waitForFinished(); }

    inline T result() const;
    inline T resultAt(int index) const;
    bool isResultReadyAt(int resultIndex) const { return d.isResultReadyAt(resultIndex); }

    operator T() const { return result(); }
    QList<T> results() const { return d.results(); }

    class const_iterator
    {
    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef const T *pointer;
        typedef const T &reference;

        inline const_iterator() {}
        inline const_iterator(QFuture const * const _future, int _index) : future(_future), index(_index) {}
        inline const_iterator(const const_iterator &o) : future(o.future), index(o.index) {}
        inline const_iterator &operator=(const const_iterator &o)
        { future = o.future; index = o.index; return *this; }
        inline const T &operator*() const { return future->d.resultReference(index); }
        inline const T *operator->() const { return future->d.resultPointer(index); }

        inline bool operator!=(const const_iterator &other) const
        {
            if (index == -1 && other.index == -1)
                return false;
            if (other.index == -1)
                return (future->isRunning() || (index < future->resultCount()));
            return (index != other.index);
        }

        inline bool operator==(const const_iterator &o) const { return !operator!=(o); }
        inline const_iterator &operator++() { ++index; return *this; }
        inline const_iterator operator++(int) { const_iterator r = *this; ++index; return r; }
        inline const_iterator &operator--() { --index; return *this; }
        inline const_iterator operator--(int) { const_iterator r = *this; --index; return r; }
        inline const_iterator operator+(int j) const { return const_iterator(future, index + j); }
        inline const_iterator operator-(int j) const { return const_iterator(future, index - j); }
        inline const_iterator &operator+=(int j) { index += j; return *this; }
        inline const_iterator &operator-=(int j) { index -= j; return *this; }
    private:
        QFuture const * future;
        int index;
    };
    friend class const_iterator;
    typedef const_iterator ConstIterator;

    const_iterator begin() const { return const_iterator(this, 0); }
    const_iterator constBegin() const { return const_iterator(this, 0); }
    const_iterator end() const { return const_iterator(this, -1); }
    const_iterator constEnd() const { return const_iterator(this, -1); }

private:
    friend class QFutureWatcher<T>;

public:
    mutable QFutureInterface<T> d;
};

template <typename T>
inline QFuture<T> &QFuture<T>::operator=(const QFuture<T> &other)
{
    d = other.d;
    return *this;
}

template <typename T>
inline T QFuture<T>::result() const
{
    d.waitForResult(0);
    return d.resultReference(0);
}

template <typename T>
inline T QFuture<T>::resultAt(int index) const
{
    d.waitForResult(index);
    return d.resultReference(index);
}

template <typename T>
inline QFuture<T> QFutureInterface<T>::future()
{
    return QFuture<T>(this);
}

template <class T> class QFutureIterator { typedef typename QFuture<T>::const_iterator const_iterator; QFuture<T> c; const_iterator i; public: inline QFutureIterator(const QFuture<T> &container) : c(container), i(c.constBegin()) {} inline QFutureIterator &operator=(const QFuture<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };

template <>
class QFuture<void>
{
public:
    QFuture()
        : d(QFutureInterface<void>::canceledResult())
    { }
    explicit QFuture(QFutureInterfaceBase *p)
        : d(*p)
    { }
    QFuture(const QFuture &other)
        : d(other.d)
    { }
    ~QFuture()
    { }

    QFuture &operator=(const QFuture &other);
    bool operator==(const QFuture &other) const { return (d == other.d); }
    bool operator!=(const QFuture &other) const { return (d != other.d); }


    template <typename T>
    QFuture(const QFuture<T> &other)
        : d(other.d)
    { }

    template <typename T>
    QFuture<void> &operator=(const QFuture<T> &other)
    {
        d = other.d;
        return *this;
    }


    void cancel() { d.cancel(); }
    bool isCanceled() const { return d.isCanceled(); }

    void setPaused(bool paused) { d.setPaused(paused); }
    bool isPaused() const { return d.isPaused(); }
    void pause() { setPaused(true); }
    void resume() { setPaused(false); }
    void togglePaused() { d.togglePaused(); }

    bool isStarted() const { return d.isStarted(); }
    bool isFinished() const { return d.isFinished(); }
    bool isRunning() const { return d.isRunning(); }

    int resultCount() const { return d.resultCount(); }
    int progressValue() const { return d.progressValue(); }
    int progressMinimum() const { return d.progressMinimum(); }
    int progressMaximum() const { return d.progressMaximum(); }
    QString progressText() const { return d.progressText(); }
    void waitForFinished() { d.waitForFinished(); }

private:
    friend class QFutureWatcher<void>;




    mutable QFutureInterfaceBase d;
};

inline QFuture<void> &QFuture<void>::operator=(const QFuture<void> &other)
{
    d = other.d;
    return *this;
}

inline QFuture<void> QFutureInterface<void>::future()
{
    return QFuture<void>(this);
}

template <typename T>
QFuture<void> qToVoidFuture(const QFuture<T> &future)
{
    return QFuture<void>(future.d);
}
#line 98 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfuturesynchronizer.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfuturesynchronizer.h"
template <typename T>
class QFutureSynchronizer
{
    QFutureSynchronizer(const QFutureSynchronizer &) = delete; QFutureSynchronizer &operator=(const QFutureSynchronizer &) = delete;

public:
    QFutureSynchronizer() : m_cancelOnWait(false) { }
    explicit QFutureSynchronizer(const QFuture<T> &future)
        : m_cancelOnWait(false)
    { addFuture(future); }
    ~QFutureSynchronizer() { waitForFinished(); }

    void setFuture(const QFuture<T> &future)
    {
        waitForFinished();
        m_futures.clear();
        addFuture(future);
    }

    void addFuture(const QFuture<T> &future)
    {
        m_futures.append(future);
    }

    void waitForFinished()
    {
        if (m_cancelOnWait) {
            for (int i = 0; i < m_futures.count(); ++i) {
                 m_futures[i].cancel();
            }
        }

        for (int i = 0; i < m_futures.count(); ++i) {
             m_futures[i].waitForFinished();
         }
    }

    void clearFutures()
    {
        m_futures.clear();
    }

    QList<QFuture<T> > futures() const
    {
        return m_futures;
    }

    void setCancelOnWait(bool enabled)
    {
        m_cancelOnWait = enabled;
    }

    bool cancelOnWait() const
    {
        return m_cancelOnWait;
    }

protected:
    QList<QFuture<T> > m_futures;
    bool m_cancelOnWait;
};
#line 100 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfuturewatcher.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfuturewatcher.h"
class QEvent;

class QFutureWatcherBasePrivate;
class __declspec(dllimport) QFutureWatcherBase : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QFutureWatcherBasePrivate* d_func() { return reinterpret_cast<QFutureWatcherBasePrivate *>(qGetPtrHelper(d_ptr)); } inline const QFutureWatcherBasePrivate* d_func() const { return reinterpret_cast<const QFutureWatcherBasePrivate *>(qGetPtrHelper(d_ptr)); } friend class QFutureWatcherBasePrivate;

public:
    explicit QFutureWatcherBase(QObject *parent = 0);


    int progressValue() const;
    int progressMinimum() const;
    int progressMaximum() const;
    QString progressText() const;

    bool isStarted() const;
    bool isFinished() const;
    bool isRunning() const;
    bool isCanceled() const;
    bool isPaused() const;

    void waitForFinished();

    void setPendingResultsLimit(int limit);

    bool event(QEvent *event);

public:
    void started();
    void finished();
    void canceled();
    void paused();
    void resumed();
    void resultReadyAt(int resultIndex);
    void resultsReadyAt(int beginIndex, int endIndex);
    void progressRangeChanged(int minimum, int maximum);
    void progressValueChanged(int progressValue);
    void progressTextChanged(const QString &progressText);

public :
    void cancel();
    void setPaused(bool paused);
    void pause();
    void resume();
    void togglePaused();

protected:
    void connectNotify (const QMetaMethod &signal);
    void disconnectNotify (const QMetaMethod &signal);


    void connectOutputInterface();
    void disconnectOutputInterface(bool pendingAssignment = false);

private:

    virtual const QFutureInterfaceBase &futureInterface() const = 0;
    virtual QFutureInterfaceBase &futureInterface() = 0;
};

template <typename T>
class QFutureWatcher : public QFutureWatcherBase
{
public:
    explicit QFutureWatcher(QObject *_parent = 0)
        : QFutureWatcherBase(_parent)
    { }
    ~QFutureWatcher()
    { disconnectOutputInterface(); }

    void setFuture(const QFuture<T> &future);
    QFuture<T> future() const
    { return m_future; }

    T result() const { return m_future.result(); }
    T resultAt(int index) const { return m_future.resultAt(index); }
#line 169 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qfuturewatcher.h"
private:
    QFuture<T> m_future;
    const QFutureInterfaceBase &futureInterface() const { return m_future.d; }
    QFutureInterfaceBase &futureInterface() { return m_future.d; }
};

template <typename T>
inline void QFutureWatcher<T>::setFuture(const QFuture<T> &_future)
{
    if (_future == m_future)
        return;

    disconnectOutputInterface(true);
    m_future = _future;
    connectOutputInterface();
}

template <>
class QFutureWatcher<void> : public QFutureWatcherBase
{
public:
    explicit QFutureWatcher(QObject *_parent = 0)
        : QFutureWatcherBase(_parent)
    { }
    ~QFutureWatcher()
    { disconnectOutputInterface(); }

    void setFuture(const QFuture<void> &future);
    QFuture<void> future() const
    { return m_future; }

private:
    QFuture<void> m_future;
    const QFutureInterfaceBase &futureInterface() const { return m_future.d; }
    QFutureInterfaceBase &futureInterface() { return m_future.d; }
};

inline void QFutureWatcher<void>::setFuture(const QFuture<void> &_future)
{
    if (_future == m_future)
        return;

    disconnectOutputInterface(true);
    m_future = _future;
    connectOutputInterface();
}
#line 101 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qreadwritelock.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qreadwritelock.h"
struct QReadWriteLockPrivate;

class __declspec(dllimport) QReadWriteLock
{
public:
    enum RecursionMode { NonRecursive, Recursive };

    explicit QReadWriteLock(RecursionMode recursionMode = NonRecursive);
    ~QReadWriteLock();

    void lockForRead();
    bool tryLockForRead();
    bool tryLockForRead(int timeout);

    void lockForWrite();
    bool tryLockForWrite();
    bool tryLockForWrite(int timeout);

    void unlock();

private:
    QReadWriteLock(const QReadWriteLock &) = delete; QReadWriteLock &operator=(const QReadWriteLock &) = delete;
    QReadWriteLockPrivate *d;

    friend class QWaitCondition;
};


#pragma warning(push)
#pragma warning(disable: 4312)


class __declspec(dllimport) QReadLocker
{
public:
    inline QReadLocker(QReadWriteLock *readWriteLock);

    inline ~QReadLocker()
    { unlock(); }

    inline void unlock()
    {
        if (q_val) {
            if ((q_val & quintptr(1u)) == quintptr(1u)) {
                q_val &= ~quintptr(1u);
                readWriteLock()->unlock();
            }
        }
    }

    inline void relock()
    {
        if (q_val) {
            if ((q_val & quintptr(1u)) == quintptr(0u)) {
                readWriteLock()->lockForRead();
                q_val |= quintptr(1u);
            }
        }
    }

    inline QReadWriteLock *readWriteLock() const
    { return reinterpret_cast<QReadWriteLock *>(q_val & ~quintptr(1u)); }

private:
    QReadLocker(const QReadLocker &) = delete; QReadLocker &operator=(const QReadLocker &) = delete;
    quintptr q_val;
};

inline QReadLocker::QReadLocker(QReadWriteLock *areadWriteLock)
    : q_val(reinterpret_cast<quintptr>(areadWriteLock))
{
    ((!((q_val & quintptr(1u)) == quintptr(0))) ? qt_assert_x("QReadLocker", "QReadWriteLock pointer is misaligned","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qreadwritelock.h",124) : qt_noop());

    relock();
}

class __declspec(dllimport) QWriteLocker
{
public:
    inline QWriteLocker(QReadWriteLock *readWriteLock);

    inline ~QWriteLocker()
    { unlock(); }

    inline void unlock()
    {
        if (q_val) {
            if ((q_val & quintptr(1u)) == quintptr(1u)) {
                q_val &= ~quintptr(1u);
                readWriteLock()->unlock();
            }
        }
    }

    inline void relock()
    {
        if (q_val) {
            if ((q_val & quintptr(1u)) == quintptr(0u)) {
                readWriteLock()->lockForWrite();
                q_val |= quintptr(1u);
            }
        }
    }

    inline QReadWriteLock *readWriteLock() const
    { return reinterpret_cast<QReadWriteLock *>(q_val & ~quintptr(1u)); }


private:
    QWriteLocker(const QWriteLocker &) = delete; QWriteLocker &operator=(const QWriteLocker &) = delete;
    quintptr q_val;
};

inline QWriteLocker::QWriteLocker(QReadWriteLock *areadWriteLock)
    : q_val(reinterpret_cast<quintptr>(areadWriteLock))
{
    ((!((q_val & quintptr(1u)) == quintptr(0))) ? qt_assert_x("QWriteLocker", "QReadWriteLock pointer is misaligned","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qreadwritelock.h",169) : qt_noop());

    relock();
}


#pragma warning(pop)
#line 104 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsemaphore.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qsemaphore.h"
class QSemaphorePrivate;

class __declspec(dllimport) QSemaphore
{
public:
    explicit QSemaphore(int n = 0);
    ~QSemaphore();

    void acquire(int n = 1);
    bool tryAcquire(int n = 1);
    bool tryAcquire(int n, int timeout);

    void release(int n = 1);

    int available() const;

private:
    QSemaphore(const QSemaphore &) = delete; QSemaphore &operator=(const QSemaphore &) = delete;

    QSemaphorePrivate *d;
};
#line 107 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qthread.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qthread.h"
class QThreadData;
class QThreadPrivate;
class QAbstractEventDispatcher;


class __declspec(dllimport) QThread : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    static Qt::HANDLE currentThreadId() throw();
    static QThread *currentThread();
    static int idealThreadCount() throw();
    static void yieldCurrentThread();

    explicit QThread(QObject *parent = 0);
    ~QThread();

    enum Priority {
        IdlePriority,

        LowestPriority,
        LowPriority,
        NormalPriority,
        HighPriority,
        HighestPriority,

        TimeCriticalPriority,

        InheritPriority
    };

    void setPriority(Priority priority);
    Priority priority() const;

    bool isFinished() const;
    bool isRunning() const;

    void requestInterruption();
    bool isInterruptionRequested() const;

    void setStackSize(uint stackSize);
    uint stackSize() const;

    void exit(int retcode = 0);

    QAbstractEventDispatcher *eventDispatcher() const;
    void setEventDispatcher(QAbstractEventDispatcher *eventDispatcher);

    bool event(QEvent *event);

public :
    void start(Priority = InheritPriority);
    void terminate();
    void quit();

public:

    bool wait(unsigned long time = 0xffffffffUL);

    static void sleep(unsigned long);
    static void msleep(unsigned long);
    static void usleep(unsigned long);

public:
    void started(

      QPrivateSignal

    );
    void finished(

      QPrivateSignal

    );

protected:
    virtual void run();
    int exec();

    static void setTerminationEnabled(bool enabled = true);

protected:
    QThread(QThreadPrivate &dd, QObject *parent = 0);

private:
    inline QThreadPrivate* d_func() { return reinterpret_cast<QThreadPrivate *>(qGetPtrHelper(d_ptr)); } inline const QThreadPrivate* d_func() const { return reinterpret_cast<const QThreadPrivate *>(qGetPtrHelper(d_ptr)); } friend class QThreadPrivate;

    friend class QCoreApplication;
    friend class QThreadData;
};
#line 108 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qthreadpool.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qthreadpool.h"
class QThreadPoolPrivate;
class __declspec(dllimport) QThreadPool : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QThreadPoolPrivate* d_func() { return reinterpret_cast<QThreadPoolPrivate *>(qGetPtrHelper(d_ptr)); } inline const QThreadPoolPrivate* d_func() const { return reinterpret_cast<const QThreadPoolPrivate *>(qGetPtrHelper(d_ptr)); } friend class QThreadPoolPrivate;



    friend class QFutureInterfaceBase;

public:
    QThreadPool(QObject *parent = 0);
    ~QThreadPool();

    static QThreadPool *globalInstance();

    void start(QRunnable *runnable, int priority = 0);
    bool tryStart(QRunnable *runnable);

    int expiryTimeout() const;
    void setExpiryTimeout(int expiryTimeout);

    int maxThreadCount() const;
    void setMaxThreadCount(int maxThreadCount);

    int activeThreadCount() const;

    void reserveThread();
    void releaseThread();

    bool waitForDone(int msecs = -1);

    void clear();
};
#line 109 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qthreadstorage.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qthreadstorage.h"
class __declspec(dllimport) QThreadStorageData
{
public:
    explicit QThreadStorageData(void (*func)(void *));
    ~QThreadStorageData();

    void** get() const;
    void** set(void* p);

    static void finish(void**);
    int id;
};





template <typename T>
inline
T *&qThreadStorage_localData(QThreadStorageData &d, T **)
{
    void **v = d.get();
    if (!v) v = d.set(0);
    return *(reinterpret_cast<T**>(v));
}

template <typename T>
inline
T *qThreadStorage_localData_const(const QThreadStorageData &d, T **)
{
    void **v = d.get();
    return v ? *(reinterpret_cast<T**>(v)) : 0;
}

template <typename T>
inline
void qThreadStorage_setLocalData(QThreadStorageData &d, T **t)
{ (void) d.set(*t); }

template <typename T>
inline
void qThreadStorage_deleteData(void *d, T **)
{ delete static_cast<T *>(d); }


template <typename T>
inline
T &qThreadStorage_localData(QThreadStorageData &d, T *)
{
    void **v = d.get();
    if (!v) v = d.set(new T());
    return *(reinterpret_cast<T*>(*v));
}

template <typename T>
inline
T qThreadStorage_localData_const(const QThreadStorageData &d, T *)
{
    void **v = d.get();
    return v ? *(reinterpret_cast<T*>(*v)) : T();
}

template <typename T>
inline
void qThreadStorage_setLocalData(QThreadStorageData &d, T *t)
{ (void) d.set(new T(*t)); }

template <typename T>
inline
void qThreadStorage_deleteData(void *d, T *)
{ delete static_cast<T *>(d); }





template <class T>
class QThreadStorage
{
private:
    QThreadStorageData d;

    QThreadStorage(const QThreadStorage &) = delete; QThreadStorage &operator=(const QThreadStorage &) = delete;

    static inline void deleteData(void *x)
    { qThreadStorage_deleteData(x, reinterpret_cast<T*>(0)); }

public:
    inline QThreadStorage() : d(deleteData) { }
    inline ~QThreadStorage() { }

    inline bool hasLocalData() const
    { return d.get() != 0; }

    inline T& localData()
    { return qThreadStorage_localData(d, reinterpret_cast<T*>(0)); }
    inline T localData() const
    { return qThreadStorage_localData_const(d, reinterpret_cast<T*>(0)); }

    inline void setLocalData(T t)
    { qThreadStorage_setLocalData(d, &t); }
};
#line 110 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qwaitcondition.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qwaitcondition.h"
class QWaitConditionPrivate;
class QMutex;
class QReadWriteLock;

class __declspec(dllimport) QWaitCondition
{
public:
    QWaitCondition();
    ~QWaitCondition();

    bool wait(QMutex *lockedMutex, unsigned long time = 0xffffffffUL);
    bool wait(QReadWriteLock *lockedReadWriteLock, unsigned long time = 0xffffffffUL);

    void wakeOne();
    void wakeAll();

private:
    QWaitCondition(const QWaitCondition &) = delete; QWaitCondition &operator=(const QWaitCondition &) = delete;

    QWaitConditionPrivate * d;
};
#line 111 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h"
namespace QtPrivate {

template <class T>
struct QPodArrayOps
    : QTypedArrayData<T>
{
    void appendInitialize(size_t newSize)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",60) : qt_noop());
        ((!(newSize > uint(this->size))) ? qt_assert("newSize > uint(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",61) : qt_noop());
        ((!(newSize <= this->alloc)) ? qt_assert("newSize <= this->alloc","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",62) : qt_noop());

        ::memset(this->end(), 0, (newSize - this->size) * sizeof(T));
        this->size = int(newSize);
    }

    void copyAppend(const T *b, const T *e)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",70) : qt_noop());
        ((!(b < e)) ? qt_assert("b < e","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",71) : qt_noop());
        ((!(size_t(e - b) <= this->alloc - uint(this->size))) ? qt_assert("size_t(e - b) <= this->alloc - uint(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",72) : qt_noop());

        ::memcpy(this->end(), b, (e - b) * sizeof(T));
        this->size += e - b;
    }

    void copyAppend(size_t n, const T &t)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",80) : qt_noop());
        ((!(n <= this->alloc - uint(this->size))) ? qt_assert("n <= this->alloc - uint(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",81) : qt_noop());

        T *iter = this->end();
        const T *const end = iter + n;
        for (; iter != end; ++iter)
            ::memcpy(iter, &t, sizeof(T));
        this->size += int(n);
    }

    void truncate(size_t newSize)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",92) : qt_noop());
        ((!(newSize < size_t(this->size))) ? qt_assert("newSize < size_t(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",93) : qt_noop());

        this->size = int(newSize);
    }

    void destroyAll()
    {
        ((!(this->ref.atomic.load() == 0)) ? qt_assert("this->ref.atomic.load() == 0","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",100) : qt_noop());



    }

    void insert(T *where, const T *b, const T *e)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",108) : qt_noop());
        ((!(where >= this->begin() && where < this->end())) ? qt_assert("where >= this->begin() && where < this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",109) : qt_noop());
        ((!(b < e)) ? qt_assert("b < e","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",110) : qt_noop());
        ((!(e <= where || b > this->end())) ? qt_assert("e <= where || b > this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",111) : qt_noop());
        ((!(size_t(e - b) <= this->alloc - uint(this->size))) ? qt_assert("size_t(e - b) <= this->alloc - uint(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",112) : qt_noop());

        ::memmove(where + (e - b), where, (static_cast<const T*>(this->end()) - where) * sizeof(T));
        ::memcpy(where, b, (e - b) * sizeof(T));
        this->size += (e - b);
    }

    void erase(T *b, T *e)
    {
        ((!(b < e)) ? qt_assert("b < e","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",121) : qt_noop());
        ((!(b >= this->begin() && b < this->end())) ? qt_assert("b >= this->begin() && b < this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",122) : qt_noop());
        ((!(e > this->begin() && e < this->end())) ? qt_assert("e > this->begin() && e < this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",123) : qt_noop());

        ::memmove(b, e, (static_cast<T *>(this->end()) - e) * sizeof(T));
        this->size -= (e - b);
    }
};

template <class T>
struct QGenericArrayOps
    : QTypedArrayData<T>
{
    void appendInitialize(size_t newSize)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",136) : qt_noop());
        ((!(newSize > uint(this->size))) ? qt_assert("newSize > uint(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",137) : qt_noop());
        ((!(newSize <= this->alloc)) ? qt_assert("newSize <= this->alloc","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",138) : qt_noop());

        T *const begin = this->begin();
        do {
            new (begin + this->size) T();
        } while (uint(++this->size) != newSize);
    }

    void copyAppend(const T *b, const T *e)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",148) : qt_noop());
        ((!(b < e)) ? qt_assert("b < e","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",149) : qt_noop());
        ((!(size_t(e - b) <= this->alloc - uint(this->size))) ? qt_assert("size_t(e - b) <= this->alloc - uint(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",150) : qt_noop());

        T *iter = this->end();
        for (; b != e; ++iter, ++b) {
            new (iter) T(*b);
            ++this->size;
        }
    }

    void copyAppend(size_t n, const T &t)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",161) : qt_noop());
        ((!(n <= this->alloc - uint(this->size))) ? qt_assert("n <= this->alloc - uint(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",162) : qt_noop());

        T *iter = this->end();
        const T *const end = iter + n;
        for (; iter != end; ++iter) {
            new (iter) T(t);
            ++this->size;
        }
    }

    void truncate(size_t newSize)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",174) : qt_noop());
        ((!(newSize < size_t(this->size))) ? qt_assert("newSize < size_t(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",175) : qt_noop());

        const T *const b = this->begin();
        do {
            (b + --this->size)->~T();
        } while (uint(this->size) != newSize);
    }

    void destroyAll()
    {



        ((!(this->ref.atomic.load() == 0)) ? qt_assert("this->ref.atomic.load() == 0","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",188) : qt_noop());

        const T *const b = this->begin();
        const T *i = this->end();

        while (i != b)
            (--i)->~T();
    }

    void insert(T *where, const T *b, const T *e)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",199) : qt_noop());
        ((!(where >= this->begin() && where < this->end())) ? qt_assert("where >= this->begin() && where < this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",200) : qt_noop());
        ((!(b < e)) ? qt_assert("b < e","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",201) : qt_noop());
        ((!(e <= where || b > this->end())) ? qt_assert("e <= where || b > this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",202) : qt_noop());
        ((!(size_t(e - b) <= this->alloc - uint(this->size))) ? qt_assert("size_t(e - b) <= this->alloc - uint(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",203) : qt_noop());



        T *const end = this->end();
        const T *readIter = end;
        T *writeIter = end + (e - b);

        const T *const step1End = where + qMax(e - b, end - where);

        struct Destructor
        {
            Destructor(T *&it)
                : iter(&it)
                , end(it)
            {
            }

            void commit()
            {
                iter = &end;
            }

            ~Destructor()
            {
                for (; *iter != end; --*iter)
                    (*iter)->~T();
            }

            T **iter;
            T *end;
        } destroyer(writeIter);


        do {
            --readIter, --writeIter;
            new (writeIter) T(*readIter);
        } while (writeIter != step1End);

        while (writeIter != end) {
            --e, --writeIter;
            new (writeIter) T(*e);
        }

        destroyer.commit();
        this->size += destroyer.end - end;


        while (readIter != where) {
            --readIter, --writeIter;
            *writeIter = *readIter;
        }

        while (writeIter != where) {
            --e, --writeIter;
            *writeIter = *e;
        }
    }

    void erase(T *b, T *e)
    {
        ((!(b < e)) ? qt_assert("b < e","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",264) : qt_noop());
        ((!(b >= this->begin() && b < this->end())) ? qt_assert("b >= this->begin() && b < this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",265) : qt_noop());
        ((!(e > this->begin() && e < this->end())) ? qt_assert("e > this->begin() && e < this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",266) : qt_noop());

        const T *const end = this->end();

        do {
            *b = *e;
            ++b, ++e;
        } while (e != end);

        do {
            (--e)->~T();
            --this->size;
        } while (e != b);
    }
};

template <class T>
struct QMovableArrayOps
    : QGenericArrayOps<T>
{





    void insert(T *where, const T *b, const T *e)
    {
        ((!(!this->ref.isShared())) ? qt_assert("!this->ref.isShared()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",293) : qt_noop());
        ((!(where >= this->begin() && where < this->end())) ? qt_assert("where >= this->begin() && where < this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",294) : qt_noop());
        ((!(b < e)) ? qt_assert("b < e","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",295) : qt_noop());
        ((!(e <= where || b > this->end())) ? qt_assert("e <= where || b > this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",296) : qt_noop());
        ((!(size_t(e - b) <= this->alloc - uint(this->size))) ? qt_assert("size_t(e - b) <= this->alloc - uint(this->size)","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",297) : qt_noop());




        struct ReversibleDisplace
        {
            ReversibleDisplace(T *start, T *finish, size_t diff)
                : begin(start)
                , end(finish)
                , displace(diff)
            {
                ::memmove(begin + displace, begin, (end - begin) * sizeof(T));
            }

            void commit() { displace = 0; }

            ~ReversibleDisplace()
            {
                if (displace)
                    ::memmove(begin, begin + displace, (end - begin) * sizeof(T));
            }

            T *const begin;
            T *const end;
            size_t displace;

        } displace(where, this->end(), size_t(e - b));

        struct CopyConstructor
        {
            CopyConstructor(T *w) : where(w) {}

            void copy(const T *src, const T *const srcEnd)
            {
                n = 0;
                for (; src != srcEnd; ++src) {
                    new (where + n) T(*src);
                    ++n;
                }
                n = 0;
            }

            ~CopyConstructor()
            {
                while (n)
                    where[--n].~T();
            }

            T *const where;
            size_t n;
        } copier(where);

        copier.copy(b, e);
        displace.commit();
        this->size += (e - b);
    }

    void erase(T *b, T *e)
    {
        ((!(b < e)) ? qt_assert("b < e","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",357) : qt_noop());
        ((!(b >= this->begin() && b < this->end())) ? qt_assert("b >= this->begin() && b < this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",358) : qt_noop());
        ((!(e > this->begin() && e < this->end())) ? qt_assert("e > this->begin() && e < this->end()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydataops.h",359) : qt_noop());

        struct Mover
        {
            Mover(T *&start, const T *finish, int &sz)
                : destination(start)
                , source(start)
                , n(finish - start)
                , size(sz)
            {
            }

            ~Mover()
            {
                ::memmove(destination, source, n * sizeof(T));
                size -= (source - destination);
            }

            T *&destination;
            const T *const source;
            size_t n;
            int &size;
        } mover(e, this->end(), this->size);

        do {

            (--e)->~T();
        } while (e != b);
    }
};

template <class T, class = void>
struct QArrayOpsSelector
{
    typedef QGenericArrayOps<T> Type;
};

template <class T>
struct QArrayOpsSelector<T,
    typename QEnableIf<
        !QTypeInfo<T>::isComplex && !QTypeInfo<T>::isStatic
    >::Type>
{
    typedef QPodArrayOps<T> Type;
};

template <class T>
struct QArrayOpsSelector<T,
    typename QEnableIf<
        QTypeInfo<T>::isComplex && !QTypeInfo<T>::isStatic
    >::Type>
{
    typedef QMovableArrayOps<T> Type;
};

}

template <class T>
struct QArrayDataOps
    : QtPrivate::QArrayOpsSelector<T>::Type
{
};
#line 114 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydatapointer.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydatapointer.h"
template <class T>
struct QArrayDataPointer
{
private:
    typedef QTypedArrayData<T> Data;
    typedef QArrayDataOps<T> DataOps;

public:
    QArrayDataPointer()
        : d(Data::sharedNull())
    {
    }

    QArrayDataPointer(const QArrayDataPointer &other)
        : d(other.d->ref.ref()
            ? other.d
            : other.clone(other.d->cloneFlags()))
    {
    }

    explicit QArrayDataPointer(QTypedArrayData<T> *ptr)
        : d(ptr)
    {
        do { if (!(ptr)) qBadAlloc(); } while (0);
    }

    QArrayDataPointer(QArrayDataPointerRef<T> ref)
        : d(ref.ptr)
    {
    }

    QArrayDataPointer &operator=(const QArrayDataPointer &other)
    {
        QArrayDataPointer tmp(other);
        this->swap(tmp);
        return *this;
    }


    QArrayDataPointer(QArrayDataPointer &&other)
        : d(other.d)
    {
        other.d = Data::sharedNull();
    }

    QArrayDataPointer &operator=(QArrayDataPointer &&other)
    {
        this->swap(other);
        return *this;
    }


    DataOps &operator*() const
    {
        ((!(d)) ? qt_assert("d","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydatapointer.h",103) : qt_noop());
        return *static_cast<DataOps *>(d);
    }

    DataOps *operator->() const
    {
        ((!(d)) ? qt_assert("d","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qarraydatapointer.h",109) : qt_noop());
        return static_cast<DataOps *>(d);
    }

    ~QArrayDataPointer()
    {
        if (!d->ref.deref()) {
            if (d->isMutable())
                (*this)->destroyAll();
            Data::deallocate(d);
        }
    }

    bool isNull() const
    {
        return d == Data::sharedNull();
    }

    Data *data() const
    {
        return d;
    }

    bool needsDetach() const
    {
        return (!d->isMutable() || d->ref.isShared());
    }


    void setSharable(bool sharable)
    {
        if (needsDetach()) {
            Data *detached = clone(sharable
                    ? d->detachFlags() & ~QArrayData::Unsharable
                    : d->detachFlags() | QArrayData::Unsharable);
            QArrayDataPointer old(d);
            d = detached;
        } else {
            d->ref.setSharable(sharable);
        }
    }

    bool isSharable() const { return d->isSharable(); }


    void swap(QArrayDataPointer &other)
    {
        qSwap(d, other.d);
    }

    void clear()
    {
        QArrayDataPointer tmp(d);
        d = Data::sharedNull();
    }

    bool detach()
    {
        if (needsDetach()) {
            Data *copy = clone(d->detachFlags());
            QArrayDataPointer old(d);
            d = copy;
            return true;
        }

        return false;
    }

private:
    Data *clone(QArrayData::AllocationOptions options) const
    {
        QArrayDataPointer copy(Data::allocate(d->detachCapacity(d->size),
                    options));
        if (d->size)
            copy->copyAppend(d->begin(), d->end());

        Data *result = copy.d;
        copy.d = Data::sharedNull();
        return result;
    }

    Data *d;
};

template <class T>
inline bool operator==(const QArrayDataPointer<T> &lhs, const QArrayDataPointer<T> &rhs)
{
    return lhs.data() == rhs.data();
}

template <class T>
inline bool operator!=(const QArrayDataPointer<T> &lhs, const QArrayDataPointer<T> &rhs)
{
    return lhs.data() != rhs.data();
}

template <class T>
inline void qSwap(QArrayDataPointer<T> &p1, QArrayDataPointer<T> &p2)
{
    p1.swap(p2);
}



namespace std
{
    template <class T>
    inline void swap(
            ::QArrayDataPointer<T> &p1,
            ::QArrayDataPointer<T> &p2)
    {
        p1.swap(p2);
    }
}
#line 115 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbitarray.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbitarray.h"
class QBitRef;
class __declspec(dllimport) QBitArray
{
    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &, const QBitArray &);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &, QBitArray &);
    friend __declspec(dllimport) uint qHash(const QBitArray &key, uint seed) throw();
    QByteArray d;

public:
    inline QBitArray() {}
    explicit QBitArray(int size, bool val = false);
    QBitArray(const QBitArray &other) : d(other.d) {}
    inline QBitArray &operator=(const QBitArray &other) { d = other.d; return *this; }

    inline QBitArray(QBitArray &&other) : d(std::move(other.d)) {}
    inline QBitArray &operator=(QBitArray &&other)
    { qSwap(d, other.d); return *this; }


    inline void swap(QBitArray &other) { qSwap(d, other.d); }

    inline int size() const { return (d.size() << 3) - *d.constData(); }
    inline int count() const { return (d.size() << 3) - *d.constData(); }
    int count(bool on) const;

    inline bool isEmpty() const { return d.isEmpty(); }
    inline bool isNull() const { return d.isNull(); }

    void resize(int size);

    inline void detach() { d.detach(); }
    inline bool isDetached() const { return d.isDetached(); }
    inline void clear() { d.clear(); }

    bool testBit(int i) const;
    void setBit(int i);
    void setBit(int i, bool val);
    void clearBit(int i);
    bool toggleBit(int i);

    bool at(int i) const;
    QBitRef operator[](int i);
    bool operator[](int i) const;
    QBitRef operator[](uint i);
    bool operator[](uint i) const;

    QBitArray& operator&=(const QBitArray &);
    QBitArray& operator|=(const QBitArray &);
    QBitArray& operator^=(const QBitArray &);
    QBitArray operator~() const;

    inline bool operator==(const QBitArray& other) const { return d == other.d; }
    inline bool operator!=(const QBitArray& other) const { return d != other.d; }

    inline bool fill(bool val, int size = -1);
    void fill(bool val, int first, int last);

    inline void truncate(int pos) { if (pos < size()) resize(pos); }

public:
    typedef QByteArray::DataPtr DataPtr;
    inline DataPtr &data_ptr() { return d.data_ptr(); }
};

inline bool QBitArray::fill(bool aval, int asize)
{ *this = QBitArray((asize < 0 ? this->size() : asize), aval); return true; }

__declspec(dllimport) QBitArray operator&(const QBitArray &, const QBitArray &);
__declspec(dllimport) QBitArray operator|(const QBitArray &, const QBitArray &);
__declspec(dllimport) QBitArray operator^(const QBitArray &, const QBitArray &);

inline bool QBitArray::testBit(int i) const
{ ((!(uint(i) < uint(size()))) ? qt_assert("uint(i) < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbitarray.h",122) : qt_noop());
 return (*(reinterpret_cast<const uchar*>(d.constData())+1+(i>>3)) & (1 << (i & 7))) != 0; }

inline void QBitArray::setBit(int i)
{ ((!(uint(i) < uint(size()))) ? qt_assert("uint(i) < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbitarray.h",126) : qt_noop());
 *(reinterpret_cast<uchar*>(d.data())+1+(i>>3)) |= uchar(1 << (i & 7)); }

inline void QBitArray::clearBit(int i)
{ ((!(uint(i) < uint(size()))) ? qt_assert("uint(i) < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbitarray.h",130) : qt_noop());
 *(reinterpret_cast<uchar*>(d.data())+1+(i>>3)) &= ~uchar(1 << (i & 7)); }

inline void QBitArray::setBit(int i, bool val)
{ if (val) setBit(i); else clearBit(i); }

inline bool QBitArray::toggleBit(int i)
{ ((!(uint(i) < uint(size()))) ? qt_assert("uint(i) < uint(size())","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbitarray.h",137) : qt_noop());
 uchar b = uchar(1<<(i&7)); uchar* p = reinterpret_cast<uchar*>(d.data())+1+(i>>3);
 uchar c = uchar(*p&b); *p^=b; return c!=0; }

inline bool QBitArray::operator[](int i) const { return testBit(i); }
inline bool QBitArray::operator[](uint i) const { return testBit(i); }
inline bool QBitArray::at(int i) const { return testBit(i); }

class __declspec(dllimport) QBitRef
{
private:
    QBitArray& a;
    int i;
    inline QBitRef(QBitArray& array, int idx) : a(array), i(idx) {}
    friend class QBitArray;
public:
    inline operator bool() const { return a.testBit(i); }
    inline bool operator!() const { return !a.testBit(i); }
    QBitRef& operator=(const QBitRef& val) { a.setBit(i, val); return *this; }
    QBitRef& operator=(bool val) { a.setBit(i, val); return *this; }
};

inline QBitRef QBitArray::operator[](int i)
{ ((!(i >= 0)) ? qt_assert("i >= 0","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbitarray.h",160) : qt_noop()); return QBitRef(*this, i); }
inline QBitRef QBitArray::operator[](uint i)
{ return QBitRef(*this, i); }



__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QBitArray &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QBitArray &);



__declspec(dllimport) QDebug operator<<(QDebug, const QBitArray &);


template<> class QTypeInfo<QBitArray > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QBitArray)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QBitArray >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QBitArray) }; static inline const char *name() { return "QBitArray"; } }; template <> inline void qSwap<QBitArray>(QBitArray &value1, QBitArray &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QBitArray >(::QBitArray &value1, ::QBitArray &value2) { value1.swap(value2); } }
#line 116 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbytearraymatcher.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qbytearraymatcher.h"
class QByteArrayMatcherPrivate;

class __declspec(dllimport) QByteArrayMatcher
{
public:
    QByteArrayMatcher();
    explicit QByteArrayMatcher(const QByteArray &pattern);
    explicit QByteArrayMatcher(const char *pattern, int length);
    QByteArrayMatcher(const QByteArrayMatcher &other);
    ~QByteArrayMatcher();

    QByteArrayMatcher &operator=(const QByteArrayMatcher &other);

    void setPattern(const QByteArray &pattern);

    int indexIn(const QByteArray &ba, int from = 0) const;
    int indexIn(const char *str, int len, int from = 0) const;
    inline QByteArray pattern() const
    {
        if (q_pattern.isNull())
            return QByteArray(reinterpret_cast<const char*>(p.p), p.l);
        return q_pattern;
    }

private:
    QByteArrayMatcherPrivate *d;
    QByteArray q_pattern;





    struct Data {
        uchar q_skiptable[256];
        const uchar *p;
        int l;
    };
    union {
        uint dummy[256];
        Data p;
    };



};
#line 118 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcache.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcache.h"
template <class Key, class T>
class QCache
{
    struct Node {
        inline Node() : keyPtr(0) {}
        inline Node(T *data, int cost)
            : keyPtr(0), t(data), c(cost), p(0), n(0) {}
        const Key *keyPtr; T *t; int c; Node *p,*n;
    };
    Node *f, *l;
    QHash<Key, Node> hash;
    int mx, total;

    inline void unlink(Node &n) {
        if (n.p) n.p->n = n.n;
        if (n.n) n.n->p = n.p;
        if (l == &n) l = n.p;
        if (f == &n) f = n.n;
        total -= n.c;
        T *obj = n.t;
        hash.remove(*n.keyPtr);
        delete obj;
    }
    inline T *relink(const Key &key) {
        typename QHash<Key, Node>::iterator i = hash.find(key);
        if (typename QHash<Key, Node>::const_iterator(i) == hash.constEnd())
            return 0;

        Node &n = *i;
        if (f != &n) {
            if (n.p) n.p->n = n.n;
            if (n.n) n.n->p = n.p;
            if (l == &n) l = n.p;
            n.p = 0;
            n.n = f;
            f->p = &n;
            f = &n;
        }
        return n.t;
    }

    QCache(const QCache &) = delete; QCache &operator=(const QCache &) = delete;

public:
    inline explicit QCache(int maxCost = 100);
    inline ~QCache() { clear(); }

    inline int maxCost() const { return mx; }
    void setMaxCost(int m);
    inline int totalCost() const { return total; }

    inline int size() const { return hash.size(); }
    inline int count() const { return hash.size(); }
    inline bool isEmpty() const { return hash.isEmpty(); }
    inline QList<Key> keys() const { return hash.keys(); }

    void clear();

    bool insert(const Key &key, T *object, int cost = 1);
    T *object(const Key &key) const;
    inline bool contains(const Key &key) const { return hash.contains(key); }
    T *operator[](const Key &key) const;

    bool remove(const Key &key);
    T *take(const Key &key);

private:
    void trim(int m);
};

template <class Key, class T>
inline QCache<Key, T>::QCache(int amaxCost)
    : f(0), l(0), mx(amaxCost), total(0) {}

template <class Key, class T>
inline void QCache<Key,T>::clear()
{ while (f) { delete f->t; f = f->n; }
 hash.clear(); l = 0; total = 0; }

template <class Key, class T>
inline void QCache<Key,T>::setMaxCost(int m)
{ mx = m; trim(mx); }

template <class Key, class T>
inline T *QCache<Key,T>::object(const Key &key) const
{ return const_cast<QCache<Key,T>*>(this)->relink(key); }

template <class Key, class T>
inline T *QCache<Key,T>::operator[](const Key &key) const
{ return object(key); }

template <class Key, class T>
inline bool QCache<Key,T>::remove(const Key &key)
{
    typename QHash<Key, Node>::iterator i = hash.find(key);
    if (typename QHash<Key, Node>::const_iterator(i) == hash.constEnd()) {
        return false;
    } else {
        unlink(*i);
        return true;
    }
}

template <class Key, class T>
inline T *QCache<Key,T>::take(const Key &key)
{
    typename QHash<Key, Node>::iterator i = hash.find(key);
    if (i == hash.end())
        return 0;

    Node &n = *i;
    T *t = n.t;
    n.t = 0;
    unlink(n);
    return t;
}

template <class Key, class T>
bool QCache<Key,T>::insert(const Key &akey, T *aobject, int acost)
{
    remove(akey);
    if (acost > mx) {
        delete aobject;
        return false;
    }
    trim(mx - acost);
    Node sn(aobject, acost);
    typename QHash<Key, Node>::iterator i = hash.insert(akey, sn);
    total += acost;
    Node *n = &i.value();
    n->keyPtr = &i.key();
    if (f) f->p = n;
    n->n = f;
    f = n;
    if (!l) l = f;
    return true;
}

template <class Key, class T>
void QCache<Key,T>::trim(int m)
{
    Node *n = l;
    while (n && total > m) {
        Node *u = n;
        n = n->p;
        unlink(*u);
    }
}
#line 119 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcollator.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcollator.h"
class QCollatorPrivate;
class QCollatorSortKeyPrivate;

class __declspec(dllimport) QCollatorSortKey
{
    friend class QCollator;
public:
    QCollatorSortKey(const QCollatorSortKey &other);
    ~QCollatorSortKey();
    QCollatorSortKey &operator=(const QCollatorSortKey &other);

    inline QCollatorSortKey &operator=(QCollatorSortKey &&other)
    { swap(other); return *this; }

    void swap(QCollatorSortKey &other)
    { d.swap(other.d); }

    int compare(const QCollatorSortKey &key) const;

protected:
    QCollatorSortKey(QCollatorSortKeyPrivate*);

    QSharedDataPointer<QCollatorSortKeyPrivate> d;

private:
    QCollatorSortKey();
};

inline bool operator<(const QCollatorSortKey &lhs, const QCollatorSortKey &rhs)
{
    return lhs.compare(rhs) < 0;
}

class __declspec(dllimport) QCollator
{
public:
    explicit QCollator(const QLocale &locale = QLocale());
    QCollator(const QCollator &);
    ~QCollator();
    QCollator &operator=(const QCollator &);

    QCollator(QCollator &&other)
        : d(other.d) { other.d = 0; }
    QCollator &operator=(QCollator &&other)
    { swap(other); return *this; }


    void swap(QCollator &other)
    { qSwap(d, other.d); }

    void setLocale(const QLocale &locale);
    QLocale locale() const;

    Qt::CaseSensitivity caseSensitivity() const;
    void setCaseSensitivity(Qt::CaseSensitivity cs);

    void setNumericMode(bool on);
    bool numericMode() const;

    void setIgnorePunctuation(bool on);
    bool ignorePunctuation() const;

    int compare(const QString &s1, const QString &s2) const;
    int compare(const QStringRef &s1, const QStringRef &s2) const;
    int compare(const QChar *s1, int len1, const QChar *s2, int len2) const;

    bool operator()(const QString &s1, const QString &s2) const
    { return compare(s1, s2) < 0; }

    QCollatorSortKey sortKey(const QString &string) const;

private:
    QCollatorPrivate *d;

    void detach();
};

template<> class QTypeInfo<QCollatorSortKey > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QCollatorSortKey)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QCollatorSortKey >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QCollatorSortKey) }; static inline const char *name() { return "QCollatorSortKey"; } }; template <> inline void qSwap<QCollatorSortKey>(QCollatorSortKey &value1, QCollatorSortKey &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QCollatorSortKey >(::QCollatorSortKey &value1, ::QCollatorSortKey &value2) { value1.swap(value2); } }
template<> class QTypeInfo<QCollator > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QCollator)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QCollator >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QCollator) }; static inline const char *name() { return "QCollator"; } }; template <> inline void qSwap<QCollator>(QCollator &value1, QCollator &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QCollator >(::QCollator &value1, ::QCollator &value2) { value1.swap(value2); } }
#line 121 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcommandlineoption.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcommandlineoption.h"
class QCommandLineOptionPrivate;

class __declspec(dllimport) QCommandLineOption
{
public:
    explicit QCommandLineOption(const QString &name, const QString &description = QString(),
                                const QString &valueName = QString(),
                                const QString &defaultValue = QString());
    explicit QCommandLineOption(const QStringList &names, const QString &description = QString(),
                                const QString &valueName = QString(),
                                const QString &defaultValue = QString());
    QCommandLineOption(const QCommandLineOption &other);

    ~QCommandLineOption();

    QCommandLineOption &operator=(const QCommandLineOption &other);

    inline QCommandLineOption &operator=(QCommandLineOption &&other)
    { qSwap(d, other.d); return *this; }


    inline void swap(QCommandLineOption &other)
    { qSwap(d, other.d); }

    QStringList names() const;

    void setValueName(const QString &name);
    QString valueName() const;

    void setDescription(const QString &description);
    QString description() const;

    void setDefaultValue(const QString &defaultValue);
    void setDefaultValues(const QStringList &defaultValues);
    QStringList defaultValues() const;

private:
    QSharedDataPointer<QCommandLineOptionPrivate> d;
};

template<> class QTypeInfo<QCommandLineOption > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QCommandLineOption)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QCommandLineOption >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QCommandLineOption) }; static inline const char *name() { return "QCommandLineOption"; } }; template <> inline void qSwap<QCommandLineOption>(QCommandLineOption &value1, QCommandLineOption &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QCommandLineOption >(::QCommandLineOption &value1, ::QCommandLineOption &value2) { value1.swap(value2); } }
#line 122 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcommandlineparser.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcommandlineparser.h"
class QCommandLineParserPrivate;
class QCoreApplication;

class __declspec(dllimport) QCommandLineParser
{
    public: static inline QString tr(const char *sourceText, const char *disambiguation = 0, int n = -1) { return QCoreApplication::translate("QCommandLineParser", sourceText, disambiguation, n); } static inline QString trUtf8(const char *sourceText, const char *disambiguation = 0, int n = -1) { return QCoreApplication::translate("QCommandLineParser", sourceText, disambiguation, n); } private:
public:
    QCommandLineParser();
    ~QCommandLineParser();

    enum SingleDashWordOptionMode {
        ParseAsCompactedShortOptions,
        ParseAsLongOptions
    };
    void setSingleDashWordOptionMode(SingleDashWordOptionMode parsingMode);

    bool addOption(const QCommandLineOption &commandLineOption);

    QCommandLineOption addVersionOption();
    QCommandLineOption addHelpOption();
    void setApplicationDescription(const QString &description);
    QString applicationDescription() const;
    void addPositionalArgument(const QString &name, const QString &description, const QString &syntax = QString());
    void clearPositionalArguments();

    void process(const QStringList &arguments);
    void process(const QCoreApplication &app);

    bool parse(const QStringList &arguments);
    QString errorText() const;

    bool isSet(const QString &name) const;
    QString value(const QString &name) const;
    QStringList values(const QString &name) const;

    bool isSet(const QCommandLineOption &option) const;
    QString value(const QCommandLineOption &option) const;
    QStringList values(const QCommandLineOption &option) const;

    QStringList positionalArguments() const;
    QStringList optionNames() const;
    QStringList unknownOptionNames() const;

    __declspec(noreturn) void showHelp(int exitCode = 0);
    QString helpText() const;

private:
    QCommandLineParser(const QCommandLineParser &) = delete; QCommandLineParser &operator=(const QCommandLineParser &) = delete;

    QCommandLineParserPrivate * const d;
};
#line 123 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcryptographichash.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qcryptographichash.h"
class QCryptographicHashPrivate;
class QIODevice;

class __declspec(dllimport) QCryptographicHash
{
public:
    enum Algorithm {

        Md4,
        Md5,

        Sha1 = 2,

        Sha224,
        Sha256,
        Sha384,
        Sha512,
        Sha3_224,
        Sha3_256,
        Sha3_384,
        Sha3_512

    };

    explicit QCryptographicHash(Algorithm method);
    ~QCryptographicHash();

    void reset();

    void addData(const char *data, int length);
    void addData(const QByteArray &data);
    bool addData(QIODevice* device);

    QByteArray result() const;

    static QByteArray hash(const QByteArray &data, Algorithm method);
private:
    QCryptographicHash(const QCryptographicHash &) = delete; QCryptographicHash &operator=(const QCryptographicHash &) = delete;
    QCryptographicHashPrivate *d;
};
#line 126 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qelapsedtimer.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qelapsedtimer.h"
class __declspec(dllimport) QElapsedTimer
{
public:
    enum ClockType {
        SystemTime,
        MonotonicClock,
        TickCounter,
        MachAbsoluteTime,
        PerformanceCounter
    };
    static ClockType clockType() throw();
    static bool isMonotonic() throw();

    void start() throw();
    qint64 restart() throw();
    void invalidate() throw();
    bool isValid() const throw();

    qint64 nsecsElapsed() const throw();
    qint64 elapsed() const throw();
    bool hasExpired(qint64 timeout) const throw();

    qint64 msecsSinceReference() const throw();
    qint64 msecsTo(const QElapsedTimer &other) const throw();
    qint64 secsTo(const QElapsedTimer &other) const throw();

    bool operator==(const QElapsedTimer &other) const throw()
    { return t1 == other.t1 && t2 == other.t2; }
    bool operator!=(const QElapsedTimer &other) const throw()
    { return !(*this == other); }

    friend bool __declspec(dllimport) operator<(const QElapsedTimer &v1, const QElapsedTimer &v2) throw();

private:
    qint64 t1;
    qint64 t2;
};
#line 129 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"




#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h"
#line 60 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h"
struct __declspec(dllimport) QLinkedListData
{
    QLinkedListData *n, *p;
    QtPrivate::RefCount ref;
    int size;
    uint sharable : 1;

    static const QLinkedListData shared_null;
};

template <typename T>
struct QLinkedListNode
{
    inline QLinkedListNode(const T &arg): t(arg) { }
    QLinkedListNode *n, *p;
    T t;
};

template <class T>
class QLinkedList
{
    typedef QLinkedListNode<T> Node;
    union { QLinkedListData *d; QLinkedListNode<T> *e; };

public:
    inline QLinkedList() : d(const_cast<QLinkedListData *>(&QLinkedListData::shared_null)) { }
    inline QLinkedList(const QLinkedList<T> &l) : d(l.d) { d->ref.ref(); if (!d->sharable) detach(); }







    ~QLinkedList();
    QLinkedList<T> &operator=(const QLinkedList<T> &);

    inline QLinkedList(QLinkedList<T> &&other) : d(other.d) { other.d = const_cast<QLinkedListData *>(&QLinkedListData::shared_null); }
    inline QLinkedList<T> &operator=(QLinkedList<T> &&other)
    { qSwap(d, other.d); return *this; }

    inline void swap(QLinkedList<T> &other) { qSwap(d, other.d); }
    bool operator==(const QLinkedList<T> &l) const;
    inline bool operator!=(const QLinkedList<T> &l) const { return !(*this == l); }

    inline int size() const { return d->size; }
    inline void detach()
    { if (d->ref.isShared()) detach_helper2(this->e); }
    inline bool isDetached() const { return !d->ref.isShared(); }

    inline void setSharable(bool sharable) { if (!sharable) detach(); if (d != &QLinkedListData::shared_null) d->sharable = sharable; }

    inline bool isSharedWith(const QLinkedList<T> &other) const { return d == other.d; }

    inline bool isEmpty() const { return d->size == 0; }

    void clear();

    void append(const T &);
    void prepend(const T &);
    T takeFirst();
    T takeLast();
    int removeAll(const T &t);
    bool removeOne(const T &t);
    bool contains(const T &t) const;
    int count(const T &t) const;

    class const_iterator;

    class iterator
    {
    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef T *pointer;
        typedef T &reference;
        Node *i;
        inline iterator() : i(0) {}
        inline iterator(Node *n) : i(n) {}
        inline iterator(const iterator &o) : i(o.i) {}
        inline iterator &operator=(const iterator &o) { i = o.i; return *this; }
        inline T &operator*() const { return i->t; }
        inline T *operator->() const { return &i->t; }
        inline bool operator==(const iterator &o) const { return i == o.i; }
        inline bool operator!=(const iterator &o) const { return i != o.i; }
        inline bool operator==(const const_iterator &o) const
            { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const
            { return i != o.i; }
        inline iterator &operator++() { i = i->n; return *this; }
        inline iterator operator++(int) { Node *n = i; i = i->n; return n; }
        inline iterator &operator--() { i = i->p; return *this; }
        inline iterator operator--(int) { Node *n = i; i = i->p; return n; }
        inline iterator operator+(int j) const
        { Node *n = i; if (j > 0) while (j--) n = n->n; else while (j++) n = n->p; return n; }
        inline iterator operator-(int j) const { return operator+(-j); }
        inline iterator &operator+=(int j) { return *this = *this + j; }
        inline iterator &operator-=(int j) { return *this = *this - j; }
    };
    friend class iterator;

    class const_iterator
    {
    public:
        typedef std::bidirectional_iterator_tag iterator_category;
        typedef qptrdiff difference_type;
        typedef T value_type;
        typedef const T *pointer;
        typedef const T &reference;
        Node *i;
        inline const_iterator() : i(0) {}
        inline const_iterator(Node *n) : i(n) {}
        inline const_iterator(const const_iterator &o) : i(o.i){}
        inline const_iterator(iterator ci) : i(ci.i){}
        inline const_iterator &operator=(const const_iterator &o) { i = o.i; return *this; }
        inline const T &operator*() const { return i->t; }
        inline const T *operator->() const { return &i->t; }
        inline bool operator==(const const_iterator &o) const { return i == o.i; }
        inline bool operator!=(const const_iterator &o) const { return i != o.i; }
        inline const_iterator &operator++() { i = i->n; return *this; }
        inline const_iterator operator++(int) { Node *n = i; i = i->n; return n; }
        inline const_iterator &operator--() { i = i->p; return *this; }
        inline const_iterator operator--(int) { Node *n = i; i = i->p; return n; }
        inline const_iterator operator+(int j) const
        { Node *n = i; if (j > 0) while (j--) n = n->n; else while (j++) n = n->p; return n; }
        inline const_iterator operator-(int j) const { return operator+(-j); }
        inline const_iterator &operator+=(int j) { return *this = *this + j; }
        inline const_iterator &operator-=(int j) { return *this = *this - j; }
    };
    friend class const_iterator;


    inline iterator begin() { detach(); return e->n; }
    inline const_iterator begin() const { return e->n; }
    inline const_iterator cbegin() const { return e->n; }
    inline const_iterator constBegin() const { return e->n; }
    inline iterator end() { detach(); return e; }
    inline const_iterator end() const { return e; }
    inline const_iterator cend() const { return e; }
    inline const_iterator constEnd() const { return e; }
    iterator insert(iterator before, const T &t);
    iterator erase(iterator pos);
    iterator erase(iterator first, iterator last);


    typedef iterator Iterator;
    typedef const_iterator ConstIterator;
    inline int count() const { return d->size; }
    inline T& first() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",209) : qt_noop()); return *begin(); }
    inline const T& first() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",210) : qt_noop()); return *begin(); }
    T& last() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",211) : qt_noop()); return *(--end()); }
    const T& last() const { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",212) : qt_noop()); return *(--end()); }
    inline void removeFirst() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",213) : qt_noop()); erase(begin()); }
    inline void removeLast() { ((!(!isEmpty())) ? qt_assert("!isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",214) : qt_noop()); erase(--end()); }
    inline bool startsWith(const T &t) const { return !isEmpty() && first() == t; }
    inline bool endsWith(const T &t) const { return !isEmpty() && last() == t; }


    inline void push_back(const T &t) { append(t); }
    inline void push_front(const T &t) { prepend(t); }
    inline T& front() { return first(); }
    inline const T& front() const { return first(); }
    inline T& back() { return last(); }
    inline const T& back() const { return last(); }
    inline void pop_front() { removeFirst(); }
    inline void pop_back() { removeLast(); }
    inline bool empty() const { return isEmpty(); }
    typedef int size_type;
    typedef T value_type;
    typedef value_type *pointer;
    typedef const value_type *const_pointer;
    typedef value_type &reference;
    typedef const value_type &const_reference;
    typedef qptrdiff difference_type;

    static inline QLinkedList<T> fromStdList(const std::list<T> &list)
    { QLinkedList<T> tmp; std::copy(list.begin(), list.end(), std::back_inserter(tmp)); return tmp; }
    inline std::list<T> toStdList() const
    { std::list<T> tmp; std::copy(constBegin(), constEnd(), std::back_inserter(tmp)); return tmp; }


    QLinkedList<T> &operator+=(const QLinkedList<T> &l);
    QLinkedList<T> operator+(const QLinkedList<T> &l) const;
    inline QLinkedList<T> &operator+=(const T &t) { append(t); return *this; }
    inline QLinkedList<T> &operator<< (const T &t) { append(t); return *this; }
    inline QLinkedList<T> &operator<<(const QLinkedList<T> &l) { *this += l; return *this; }

private:
    void detach_helper();
    iterator detach_helper2(iterator);
    void freeData(QLinkedListData*);
};

template <typename T>
inline QLinkedList<T>::~QLinkedList()
{
    if (!d->ref.deref())
        freeData(d);
}

template <typename T>
void QLinkedList<T>::detach_helper()
{
    detach_helper2(this->e);
}

template <typename T>
typename QLinkedList<T>::iterator QLinkedList<T>::detach_helper2(iterator orgite)
{

    bool isEndIterator = (orgite.i == this->e);
    union { QLinkedListData *d; Node *e; } x;
    x.d = new QLinkedListData;
    x.d->ref.initializeOwned();
    x.d->size = d->size;
    x.d->sharable = true;
    Node *original = e->n;
    Node *copy = x.e;
    Node *org = orgite.i;

    while (original != org) {
        try {
            copy->n = new Node(original->t);
            copy->n->p = copy;
            original = original->n;
            copy = copy->n;
        } catch (...) {
            copy->n = x.e;
            ((!(!x.d->ref.deref())) ? qt_assert("!x.d->ref.deref()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",289) : qt_noop());
            freeData(x.d);
            throw;
        }
    }
    iterator r(copy);
    while (original != e) {
        try {
            copy->n = new Node(original->t);
            copy->n->p = copy;
            original = original->n;
            copy = copy->n;
        } catch (...) {
            copy->n = x.e;
            ((!(!x.d->ref.deref())) ? qt_assert("!x.d->ref.deref()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",303) : qt_noop());
            freeData(x.d);
            throw;
        }
    }
    copy->n = x.e;
    x.e->p = copy;
    if (!d->ref.deref())
        freeData(d);
    d = x.d;
    if (!isEndIterator)
        ++r;
    return r;
}

template <typename T>
void QLinkedList<T>::freeData(QLinkedListData *x)
{
    Node *y = reinterpret_cast<Node*>(x);
    Node *i = y->n;
    ((!(x->ref.atomic.load() == 0)) ? qt_assert("x->ref.atomic.load() == 0","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",323) : qt_noop());
    while (i != y) {
        Node *n = i;
        i = i->n;
        delete n;
    }
    delete x;
}

template <typename T>
void QLinkedList<T>::clear()
{
    *this = QLinkedList<T>();
}

template <typename T>
QLinkedList<T> &QLinkedList<T>::operator=(const QLinkedList<T> &l)
{
    if (d != l.d) {
        QLinkedListData *o = l.d;
        o->ref.ref();
        if (!d->ref.deref())
            freeData(d);
        d = o;
        if (!d->sharable)
            detach_helper();
    }
    return *this;
}

template <typename T>
bool QLinkedList<T>::operator== (const QLinkedList<T> &l) const
{
    if (d->size != l.d->size)
        return false;
    if (e == l.e)
        return true;
    Node *i = e->n;
    Node *il = l.e->n;
    while (i != e) {
        if (! (i->t == il->t))
            return false;
        i = i->n;
        il = il->n;
    }
    return true;
}

template <typename T>
void QLinkedList<T>::append(const T &t)
{
    detach();
    Node *i = new Node(t);
    i->n = e;
    i->p = e->p;
    i->p->n = i;
    e->p = i;
    d->size++;
}

template <typename T>
void QLinkedList<T>::prepend(const T &t)
{
    detach();
    Node *i = new Node(t);
    i->n = e->n;
    i->p = e;
    i->n->p = i;
    e->n = i;
    d->size++;
}

template <typename T>
int QLinkedList<T>::removeAll(const T &_t)
{
    detach();
    const T t = _t;
    Node *i = e->n;
    int c = 0;
    while (i != e) {
        if (i->t == t) {
            Node *n = i;
            i->n->p = i->p;
            i->p->n = i->n;
            i = i->n;
            delete n;
            c++;
        } else {
            i = i->n;
        }
    }
    d->size-=c;
    return c;
}

template <typename T>
bool QLinkedList<T>::removeOne(const T &_t)
{
    detach();
    iterator it = std::find(begin(), end(), _t);
    if (it != end()) {
        erase(it);
        return true;
    }
    return false;
}

template <typename T>
inline T QLinkedList<T>::takeFirst()
{
    T t = first();
    removeFirst();
    return t;
}

template <typename T>
inline T QLinkedList<T>::takeLast()
{
    T t = last();
    removeLast();
    return t;
}

template <typename T>
bool QLinkedList<T>::contains(const T &t) const
{
    Node *i = e;
    while ((i = i->n) != e)
        if (i->t == t)
            return true;
    return false;
}

template <typename T>
int QLinkedList<T>::count(const T &t) const
{
    Node *i = e;
    int c = 0;
    while ((i = i->n) != e)
        if (i->t == t)
            c++;
    return c;
}


template <typename T>
typename QLinkedList<T>::iterator QLinkedList<T>::insert(iterator before, const T &t)
{
    if (d->ref.isShared())
        before = detach_helper2(before);

    Node *i = before.i;
    Node *m = new Node(t);
    m->n = i;
    m->p = i->p;
    m->p->n = m;
    i->p = m;
    d->size++;
    return m;
}

template <typename T>
typename QLinkedList<T>::iterator QLinkedList<T>::erase(typename QLinkedList<T>::iterator afirst,
                                                         typename QLinkedList<T>::iterator alast)
{
    while (afirst != alast)
        erase(afirst++);
    return alast;
}


template <typename T>
typename QLinkedList<T>::iterator QLinkedList<T>::erase(iterator pos)
{
    if (d->ref.isShared())
        pos = detach_helper2(pos);

    Node *i = pos.i;
    if (i != e) {
        Node *n = i;
        i->n->p = i->p;
        i->p->n = i->n;
        i = i->n;
        delete n;
        d->size--;
    }
    return i;
}

template <typename T>
QLinkedList<T> &QLinkedList<T>::operator+=(const QLinkedList<T> &l)
{
    detach();
    int n = l.d->size;
    d->size += n;
    Node *original = l.e->n;
    while (n--) {
        try {
            Node *copy = new Node(original->t);
            original = original->n;
            copy->n = e;
            copy->p = e->p;
            copy->p->n = copy;
            e->p = copy;
        } catch (...) {

            while (n++<d->size)
                removeLast();
            throw;
        }
    }
    return *this;
}

template <typename T>
QLinkedList<T> QLinkedList<T>::operator+(const QLinkedList<T> &l) const
{
    QLinkedList<T> n = *this;
    n += l;
    return n;
}

template <class T> class QLinkedListIterator { typedef typename QLinkedList<T>::const_iterator const_iterator; QLinkedList<T> c; const_iterator i; public: inline QLinkedListIterator(const QLinkedList<T> &container) : c(container), i(c.constBegin()) {} inline QLinkedListIterator &operator=(const QLinkedList<T> &container) { c = container; i = c.constBegin(); return *this; } inline void toFront() { i = c.constBegin(); } inline void toBack() { i = c.constEnd(); } inline bool hasNext() const { return i != c.constEnd(); } inline const T &next() { return *i++; } inline const T &peekNext() const { return *i; } inline bool hasPrevious() const { return i != c.constBegin(); } inline const T &previous() { return *--i; } inline const T &peekPrevious() const { const_iterator p = i; return *--p; } inline bool findNext(const T &t) { while (i != c.constEnd()) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (i != c.constBegin()) if (*(--i) == t) return true; return false; } };
template <class T> class QMutableLinkedListIterator { typedef typename QLinkedList<T>::iterator iterator; typedef typename QLinkedList<T>::const_iterator const_iterator; QLinkedList<T> *c; iterator i, n; inline bool item_exists() const { return const_iterator(n) != c->constEnd(); } public: inline QMutableLinkedListIterator(QLinkedList<T> &container) : c(&container) { c->setSharable(false); i = c->begin(); n = c->end(); } inline ~QMutableLinkedListIterator() { c->setSharable(true); } inline QMutableLinkedListIterator &operator=(QLinkedList<T> &container) { c->setSharable(true); c = &container; c->setSharable(false); i = c->begin(); n = c->end(); return *this; } inline void toFront() { i = c->begin(); n = c->end(); } inline void toBack() { i = c->end(); n = i; } inline bool hasNext() const { return c->constEnd() != const_iterator(i); } inline T &next() { n = i++; return *n; } inline T &peekNext() const { return *i; } inline bool hasPrevious() const { return c->constBegin() != const_iterator(i); } inline T &previous() { n = --i; return *n; } inline T &peekPrevious() const { iterator p = i; return *--p; } inline void remove() { if (c->constEnd() != const_iterator(n)) { i = c->erase(n); n = c->end(); } } inline void setValue(const T &t) const { if (c->constEnd() != const_iterator(n)) *n = t; } inline T &value() { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",546) : qt_noop()); return *n; } inline const T &value() const { ((!(item_exists())) ? qt_assert("item_exists()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qlinkedlist.h",546) : qt_noop()); return *n; } inline void insert(const T &t) { n = i = c->insert(i, t); ++i; } inline bool findNext(const T &t) { while (c->constEnd() != const_iterator(n = i)) if (*i++ == t) return true; return false; } inline bool findPrevious(const T &t) { while (c->constBegin() != const_iterator(i)) if (*(n = --i) == t) return true; n = c->end(); return false; } };
#line 133 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"





#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qmessageauthenticationcode.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qmessageauthenticationcode.h"
class QMessageAuthenticationCodePrivate;
class QIODevice;

class __declspec(dllimport) QMessageAuthenticationCode
{
public:
    explicit QMessageAuthenticationCode(QCryptographicHash::Algorithm method,
                                        const QByteArray &key = QByteArray());
    ~QMessageAuthenticationCode();

    void reset();

    void setKey(const QByteArray &key);

    void addData(const char *data, int length);
    void addData(const QByteArray &data);
    bool addData(QIODevice *device);

    QByteArray result() const;

    static QByteArray hash(const QByteArray &message, const QByteArray &key,
                           QCryptographicHash::Algorithm method);

private:
    QMessageAuthenticationCode(const QMessageAuthenticationCode &) = delete; QMessageAuthenticationCode &operator=(const QMessageAuthenticationCode &) = delete;
    QMessageAuthenticationCodePrivate *d;
};
#line 138 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qqueue.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qqueue.h"
template <class T>
class QQueue : public QList<T>
{
public:
    inline QQueue() {}
    inline ~QQueue() {}
    inline void swap(QQueue<T> &other) { QList<T>::swap(other); }
    inline void enqueue(const T &t) { QList<T>::append(t); }
    inline T dequeue() { return QList<T>::takeFirst(); }
    inline T &head() { return QList<T>::first(); }
    inline const T &head() const { return QList<T>::first(); }
};
#line 141 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"




#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qregularexpression.h"
#line 57 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qregularexpression.h"
class QRegularExpressionMatch;
class QRegularExpressionMatchIterator;
struct QRegularExpressionPrivate;

class __declspec(dllimport) QRegularExpression
{
public:
    enum PatternOption {
        NoPatternOption = 0x0000,
        CaseInsensitiveOption = 0x0001,
        DotMatchesEverythingOption = 0x0002,
        MultilineOption = 0x0004,
        ExtendedPatternSyntaxOption = 0x0008,
        InvertedGreedinessOption = 0x0010,
        DontCaptureOption = 0x0020,
        UseUnicodePropertiesOption = 0x0040
    };
    typedef QFlags<PatternOption> PatternOptions;

    PatternOptions patternOptions() const;
    void setPatternOptions(PatternOptions options);

    QRegularExpression();
    explicit QRegularExpression(const QString &pattern, PatternOptions options = NoPatternOption);
    QRegularExpression(const QRegularExpression &re);
    ~QRegularExpression();
    QRegularExpression &operator=(const QRegularExpression &re);


    inline QRegularExpression &operator=(QRegularExpression &&re)
    { d.swap(re.d); return *this; }


    inline void swap(QRegularExpression &re) { d.swap(re.d); }

    QString pattern() const;
    void setPattern(const QString &pattern);

    bool isValid() const;
    int patternErrorOffset() const;
    QString errorString() const;

    int captureCount() const;
    QStringList namedCaptureGroups() const;

    enum MatchType {
        NormalMatch = 0,
        PartialPreferCompleteMatch,
        PartialPreferFirstMatch,
        NoMatch
    };

    enum MatchOption {
        NoMatchOption = 0x0000,
        AnchoredMatchOption = 0x0001
    };
    typedef QFlags<MatchOption> MatchOptions;

    QRegularExpressionMatch match(const QString &subject,
                                  int offset = 0,
                                  MatchType matchType = NormalMatch,
                                  MatchOptions matchOptions = NoMatchOption) const;

    QRegularExpressionMatchIterator globalMatch(const QString &subject,
                                                int offset = 0,
                                                MatchType matchType = NormalMatch,
                                                MatchOptions matchOptions = NoMatchOption) const;

    static QString escape(const QString &str);

    bool operator==(const QRegularExpression &re) const;
    inline bool operator!=(const QRegularExpression &re) const { return !operator==(re); }

private:
    friend struct QRegularExpressionPrivate;
    friend class QRegularExpressionMatch;
    friend struct QRegularExpressionMatchPrivate;
    friend class QRegularExpressionMatchIterator;

    QRegularExpression(QRegularExpressionPrivate &dd);
    QExplicitlySharedDataPointer<QRegularExpressionPrivate> d;
};

template<> class QTypeInfo<QRegularExpression > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRegularExpression)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QRegularExpression >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QRegularExpression) }; static inline const char *name() { return "QRegularExpression"; } }; template <> inline void qSwap<QRegularExpression>(QRegularExpression &value1, QRegularExpression &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QRegularExpression >(::QRegularExpression &value1, ::QRegularExpression &value2) { value1.swap(value2); } }
 inline QFlags<QRegularExpression::PatternOptions::enum_type> operator|(QRegularExpression::PatternOptions::enum_type f1, QRegularExpression::PatternOptions::enum_type f2) { return QFlags<QRegularExpression::PatternOptions::enum_type>(f1) | f2; } inline QFlags<QRegularExpression::PatternOptions::enum_type> operator|(QRegularExpression::PatternOptions::enum_type f1, QFlags<QRegularExpression::PatternOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QRegularExpression::PatternOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
 inline QFlags<QRegularExpression::MatchOptions::enum_type> operator|(QRegularExpression::MatchOptions::enum_type f1, QRegularExpression::MatchOptions::enum_type f2) { return QFlags<QRegularExpression::MatchOptions::enum_type>(f1) | f2; } inline QFlags<QRegularExpression::MatchOptions::enum_type> operator|(QRegularExpression::MatchOptions::enum_type f1, QFlags<QRegularExpression::MatchOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QRegularExpression::MatchOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }


__declspec(dllimport) QDataStream &operator<<(QDataStream &out, const QRegularExpression &re);
__declspec(dllimport) QDataStream &operator>>(QDataStream &in, QRegularExpression &re);



__declspec(dllimport) QDebug operator<<(QDebug debug, const QRegularExpression &re);
__declspec(dllimport) QDebug operator<<(QDebug debug, QRegularExpression::PatternOptions patternOptions);


struct QRegularExpressionMatchPrivate;

class __declspec(dllimport) QRegularExpressionMatch
{
public:
    QRegularExpressionMatch();
    ~QRegularExpressionMatch();
    QRegularExpressionMatch(const QRegularExpressionMatch &match);
    QRegularExpressionMatch &operator=(const QRegularExpressionMatch &match);


    inline QRegularExpressionMatch &operator=(QRegularExpressionMatch &&match)
    { d.swap(match.d); return *this; }

    inline void swap(QRegularExpressionMatch &match) { d.swap(match.d); }

    QRegularExpression regularExpression() const;
    QRegularExpression::MatchType matchType() const;
    QRegularExpression::MatchOptions matchOptions() const;

    bool hasMatch() const;
    bool hasPartialMatch() const;

    bool isValid() const;

    int lastCapturedIndex() const;

    QString captured(int nth = 0) const;
    QStringRef capturedRef(int nth = 0) const;

    QString captured(const QString &name) const;
    QStringRef capturedRef(const QString &name) const;

    QStringList capturedTexts() const;

    int capturedStart(int nth = 0) const;
    int capturedLength(int nth = 0) const;
    int capturedEnd(int nth = 0) const;

    int capturedStart(const QString &name) const;
    int capturedLength(const QString &name) const;
    int capturedEnd(const QString &name) const;

private:
    friend class QRegularExpression;
    friend struct QRegularExpressionMatchPrivate;
    friend class QRegularExpressionMatchIterator;

    QRegularExpressionMatch(QRegularExpressionMatchPrivate &dd);
    QSharedDataPointer<QRegularExpressionMatchPrivate> d;
};

template<> class QTypeInfo<QRegularExpressionMatch > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRegularExpressionMatch)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QRegularExpressionMatch >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QRegularExpressionMatch) }; static inline const char *name() { return "QRegularExpressionMatch"; } }; template <> inline void qSwap<QRegularExpressionMatch>(QRegularExpressionMatch &value1, QRegularExpressionMatch &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QRegularExpressionMatch >(::QRegularExpressionMatch &value1, ::QRegularExpressionMatch &value2) { value1.swap(value2); } }


__declspec(dllimport) QDebug operator<<(QDebug debug, const QRegularExpressionMatch &match);


struct QRegularExpressionMatchIteratorPrivate;

class __declspec(dllimport) QRegularExpressionMatchIterator
{
public:
    QRegularExpressionMatchIterator();
    ~QRegularExpressionMatchIterator();
    QRegularExpressionMatchIterator(const QRegularExpressionMatchIterator &iterator);
    QRegularExpressionMatchIterator &operator=(const QRegularExpressionMatchIterator &iterator);

    inline QRegularExpressionMatchIterator &operator=(QRegularExpressionMatchIterator &&iterator)
    { d.swap(iterator.d); return *this; }

    void swap(QRegularExpressionMatchIterator &iterator) { d.swap(iterator.d); }

    bool isValid() const;

    bool hasNext() const;
    QRegularExpressionMatch next();
    QRegularExpressionMatch peekNext() const;

    QRegularExpression regularExpression() const;
    QRegularExpression::MatchType matchType() const;
    QRegularExpression::MatchOptions matchOptions() const;

private:
    friend class QRegularExpression;

    QRegularExpressionMatchIterator(QRegularExpressionMatchIteratorPrivate &dd);
    QSharedDataPointer<QRegularExpressionMatchIteratorPrivate> d;
};

template<> class QTypeInfo<QRegularExpressionMatchIterator > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QRegularExpressionMatchIterator)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QRegularExpressionMatchIterator >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QRegularExpressionMatchIterator) }; static inline const char *name() { return "QRegularExpressionMatchIterator"; } }; template <> inline void qSwap<QRegularExpressionMatchIterator>(QRegularExpressionMatchIterator &value1, QRegularExpressionMatchIterator &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QRegularExpressionMatchIterator >(::QRegularExpressionMatchIterator &value1, ::QRegularExpressionMatchIterator &value2) { value1.swap(value2); } }
#line 145 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qscopedvaluerollback.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qscopedvaluerollback.h"
template <typename T>
class QScopedValueRollback
{
public:
    explicit QScopedValueRollback(T &var) :
        varRef(var)
    {
        oldValue = varRef;
    }

    ~QScopedValueRollback()
    {
        varRef = oldValue;
    }

    void commit()
    {
        oldValue = varRef;
    }

private:
    T& varRef;
    T oldValue;

    QScopedValueRollback(const QScopedValueRollback &) = delete; QScopedValueRollback &operator=(const QScopedValueRollback &) = delete;
};
#line 147 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"





#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstack.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstack.h"
template<class T>
class QStack : public QVector<T>
{
public:
    inline QStack() {}
    inline ~QStack() {}
    inline void swap(QStack<T> &other) { QVector<T>::swap(other); }
    inline void push(const T &t) { QVector<T>::append(t); }
    T pop();
    T &top();
    const T &top() const;
};

template<class T>
inline T QStack<T>::pop()
{ ((!(!this->isEmpty())) ? qt_assert("!this->isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstack.h",65) : qt_noop()); T t = this->data()[this->size() -1];
  this->resize(this->size()-1); return t; }

template<class T>
inline T &QStack<T>::top()
{ ((!(!this->isEmpty())) ? qt_assert("!this->isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstack.h",70) : qt_noop()); this->detach(); return this->data()[this->size()-1]; }

template<class T>
inline const T &QStack<T>::top() const
{ ((!(!this->isEmpty())) ? qt_assert("!this->isEmpty()","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstack.h",74) : qt_noop()); return this->data()[this->size()-1]; }
#line 152 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstringbuilder.h"
#line 60 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstringbuilder.h"
struct __declspec(dllimport) QAbstractConcatenable
{
protected:
    static void convertFromAscii(const char *a, int len, QChar *&out);
    static inline void convertFromAscii(char a, QChar *&out)
    {
        *out++ = QLatin1Char(a);
    }
    static void appendLatin1To(const char *a, int len, QChar *out);
};

template <typename T> struct QConcatenable {};

namespace QtStringBuilder {
    template <typename A, typename B> struct ConvertToTypeHelper
    { typedef A ConvertTo; };
    template <typename T> struct ConvertToTypeHelper<T, QString>
    { typedef QString ConvertTo; };
}

template<typename Builder, typename T>
struct QStringBuilderCommon
{
    T toUpper() const { return resolved().toUpper(); }
    T toLower() const { return resolved().toLower(); }

protected:
    const T resolved() const { return *static_cast<const Builder*>(this); }
};

template<typename Builder, typename T>
struct QStringBuilderBase : public QStringBuilderCommon<Builder, T>
{
};

template<typename Builder>
struct QStringBuilderBase<Builder, QString> : public QStringBuilderCommon<Builder, QString>
{
    QByteArray toLatin1() const { return this->resolved().toLatin1(); }
    QByteArray toUtf8() const { return this->resolved().toUtf8(); }
    QByteArray toLocal8Bit() const { return this->resolved().toLocal8Bit(); }
};

template <typename A, typename B>
class QStringBuilder : public QStringBuilderBase<QStringBuilder<A, B>, typename QtStringBuilder::ConvertToTypeHelper<typename QConcatenable<A>::ConvertTo, typename QConcatenable<B>::ConvertTo>::ConvertTo>
{
public:
    QStringBuilder(const A &a_, const B &b_) : a(a_), b(b_) {}
private:
    friend class QByteArray;
    friend class QString;
    template <typename T> T convertTo() const
    {
        const uint len = QConcatenable< QStringBuilder<A, B> >::size(*this);
        T s(len, Qt::Uninitialized);



        typename T::iterator d = const_cast<typename T::iterator>(s.constData());
        typename T::const_iterator const start = d;
        QConcatenable< QStringBuilder<A, B> >::appendTo(*this, d);

        if (!QConcatenable< QStringBuilder<A, B> >::ExactSize && int(len) != d - start) {


            s.resize(d - start);
        }
        return s;
    }

    typedef QConcatenable<QStringBuilder<A, B> > Concatenable;
    typedef typename Concatenable::ConvertTo ConvertTo;
public:
    operator ConvertTo() const { return convertTo<ConvertTo>(); }

    int size() const { return Concatenable::size(*this); }

    const A &a;
    const B &b;
};

template <>
class QStringBuilder <QString, QString> : public QStringBuilderBase<QStringBuilder<QString, QString>, QString>
{
    public:
        QStringBuilder(const QString &a_, const QString &b_) : a(a_), b(b_) {}
        QStringBuilder(const QStringBuilder &other) : a(other.a), b(other.b) {}

        operator QString() const
        { QString r(a); r += b; return r; }

        const QString &a;
        const QString &b;

    private:
        QStringBuilder &operator=(const QStringBuilder &) = delete;
};

template <>
class QStringBuilder <QByteArray, QByteArray> : public QStringBuilderBase<QStringBuilder<QByteArray, QByteArray>, QByteArray>
{
    public:
        QStringBuilder(const QByteArray &a_, const QByteArray &b_) : a(a_), b(b_) {}
        QStringBuilder(const QStringBuilder &other) : a(other.a), b(other.b) {}

        operator QByteArray() const
        { QByteArray r(a); r += b; return r; }

        const QByteArray &a;
        const QByteArray &b;

    private:
        QStringBuilder &operator=(const QStringBuilder &) = delete;
};


template <> struct QConcatenable<char> : private QAbstractConcatenable
{
    typedef char type;
    typedef QByteArray ConvertTo;
    enum { ExactSize = true };
    static int size(const char) { return 1; }

    static inline void appendTo(const char c, QChar *&out)
    {
        QAbstractConcatenable::convertFromAscii(c, out);
    }

    static inline void appendTo(const char c, char *&out)
    { *out++ = c; }
};

template <> struct QConcatenable<QLatin1Char>
{
    typedef QLatin1Char type;
    typedef QString ConvertTo;
    enum { ExactSize = true };
    static int size(const QLatin1Char) { return 1; }
    static inline void appendTo(const QLatin1Char c, QChar *&out)
    { *out++ = c; }
    static inline void appendTo(const QLatin1Char c, char *&out)
    { *out++ = c.toLatin1(); }
};

template <> struct QConcatenable<QChar> : private QAbstractConcatenable
{
    typedef QChar type;
    typedef QString ConvertTo;
    enum { ExactSize = true };
    static int size(const QChar) { return 1; }
    static inline void appendTo(const QChar c, QChar *&out)
    { *out++ = c; }
};

template <> struct QConcatenable<QChar::SpecialCharacter> : private QAbstractConcatenable
{
    typedef QChar::SpecialCharacter type;
    typedef QString ConvertTo;
    enum { ExactSize = true };
    static int size(const QChar::SpecialCharacter) { return 1; }
    static inline void appendTo(const QChar::SpecialCharacter c, QChar *&out)
    { *out++ = c; }
};

template <> struct QConcatenable<QCharRef> : private QAbstractConcatenable
{
    typedef QCharRef type;
    typedef QString ConvertTo;
    enum { ExactSize = true };
    static int size(QCharRef) { return 1; }
    static inline void appendTo(QCharRef c, QChar *&out)
    { *out++ = QChar(c); }
};

template <> struct QConcatenable<QLatin1String> : private QAbstractConcatenable
{
    typedef QLatin1String type;
    typedef QString ConvertTo;
    enum { ExactSize = true };
    static int size(const QLatin1String a) { return a.size(); }
    static inline void appendTo(const QLatin1String a, QChar *&out)
    {
        appendLatin1To(a.latin1(), a.size(), out);
        out += a.size();
    }
    static inline void appendTo(const QLatin1String a, char *&out)
    {
        if (a.data()) {
            for (const char *s = a.data(); *s; )
                *out++ = *s++;
        }
    }
};

template <> struct QConcatenable<QString> : private QAbstractConcatenable
{
    typedef QString type;
    typedef QString ConvertTo;
    enum { ExactSize = true };
    static int size(const QString &a) { return a.size(); }
    static inline void appendTo(const QString &a, QChar *&out)
    {
        const int n = a.size();
        memcpy(out, reinterpret_cast<const char*>(a.constData()), sizeof(QChar) * n);
        out += n;
    }
};

template <> struct QConcatenable<QStringRef> : private QAbstractConcatenable
{
    typedef QStringRef type;
    typedef QString ConvertTo;
    enum { ExactSize = true };
    static int size(const QStringRef &a) { return a.size(); }
    static inline void appendTo(const QStringRef &a, QChar *&out)
    {
        const int n = a.size();
        memcpy(out, reinterpret_cast<const char*>(a.constData()), sizeof(QChar) * n);
        out += n;
    }
};

template <int N> struct QConcatenable<char[N]> : private QAbstractConcatenable
{
    typedef char type[N];
    typedef QByteArray ConvertTo;
    enum { ExactSize = false };
    static int size(const char[N]) { return N - 1; }

    static inline void appendTo(const char a[N], QChar *&out)
    {
        QAbstractConcatenable::convertFromAscii(a, N - 1, out);
    }

    static inline void appendTo(const char a[N], char *&out)
    {
        while (*a)
            *out++ = *a++;
    }
};

template <int N> struct QConcatenable<const char[N]> : private QAbstractConcatenable
{
    typedef const char type[N];
    typedef QByteArray ConvertTo;
    enum { ExactSize = false };
    static int size(const char[N]) { return N - 1; }

    static inline void appendTo(const char a[N], QChar *&out)
    {
        QAbstractConcatenable::convertFromAscii(a, N - 1, out);
    }

    static inline void appendTo(const char a[N], char *&out)
    {
        while (*a)
            *out++ = *a++;
    }
};

template <> struct QConcatenable<const char *> : private QAbstractConcatenable
{
    typedef char const *type;
    typedef QByteArray ConvertTo;
    enum { ExactSize = false };
    static int size(const char *a) { return qstrlen(a); }

    static inline void appendTo(const char *a, QChar *&out)
    { QAbstractConcatenable::convertFromAscii(a, -1, out); }

    static inline void appendTo(const char *a, char *&out)
    {
        if (!a)
            return;
        while (*a)
            *out++ = *a++;
    }
};

template <> struct QConcatenable<QByteArray> : private QAbstractConcatenable
{
    typedef QByteArray type;
    typedef QByteArray ConvertTo;
    enum { ExactSize = false };
    static int size(const QByteArray &ba) { return ba.size(); }

    static inline void appendTo(const QByteArray &ba, QChar *&out)
    {
        QAbstractConcatenable::convertFromAscii(ba.constData(), ba.size(), out);
    }

    static inline void appendTo(const QByteArray &ba, char *&out)
    {
        const char *a = ba.constData();
        const char * const end = ba.end();
        while (a != end)
            *out++ = *a++;
    }
};


template <typename A, typename B>
struct QConcatenable< QStringBuilder<A, B> >
{
    typedef QStringBuilder<A, B> type;
    typedef typename QtStringBuilder::ConvertToTypeHelper<typename QConcatenable<A>::ConvertTo, typename QConcatenable<B>::ConvertTo>::ConvertTo ConvertTo;
    enum { ExactSize = QConcatenable<A>::ExactSize && QConcatenable<B>::ExactSize };
    static int size(const type &p)
    {
        return QConcatenable<A>::size(p.a) + QConcatenable<B>::size(p.b);
    }
    template<typename T> static inline void appendTo(const type &p, T *&out)
    {
        QConcatenable<A>::appendTo(p.a, out);
        QConcatenable<B>::appendTo(p.b, out);
    }
};

template <typename A, typename B>
QStringBuilder<typename QConcatenable<A>::type, typename QConcatenable<B>::type>
operator%(const A &a, const B &b)
{
   return QStringBuilder<typename QConcatenable<A>::type, typename QConcatenable<B>::type>(a, b);
}
#line 396 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qstringbuilder.h"
namespace QtStringBuilder {
template <typename A, typename B>
QByteArray &appendToByteArray(QByteArray &a, const QStringBuilder<A, B> &b, char)
{

    int len = a.size() + QConcatenable< QStringBuilder<A, B> >::size(b);
    a.reserve(len);
    char *it = a.data() + a.size();
    QConcatenable< QStringBuilder<A, B> >::appendTo(b, it);
    a.resize(len);
    return a;
}


template <typename A, typename B>
QByteArray &appendToByteArray(QByteArray &a, const QStringBuilder<A, B> &b, QChar)
{
    return a += QString(b).toUtf8();
}

}

template <typename A, typename B>
QByteArray &operator+=(QByteArray &a, const QStringBuilder<A, B> &b)
{
    return QtStringBuilder::appendToByteArray(a, b,
                                              typename QConcatenable< QStringBuilder<A, B> >::ConvertTo::value_type());
}

template <typename A, typename B>
QString &operator+=(QString &a, const QStringBuilder<A, B> &b)
{
    int len = a.size() + QConcatenable< QStringBuilder<A, B> >::size(b);
    a.reserve(len);
    QChar *it = a.data() + a.size();
    QConcatenable< QStringBuilder<A, B> >::appendTo(b, it);
    a.resize(it - a.constData());
    return a;
}
#line 154 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtextboundaryfinder.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtextboundaryfinder.h"
class QTextBoundaryFinderPrivate;

class __declspec(dllimport) QTextBoundaryFinder
{
public:
    QTextBoundaryFinder();
    QTextBoundaryFinder(const QTextBoundaryFinder &other);
    QTextBoundaryFinder &operator=(const QTextBoundaryFinder &other);
    ~QTextBoundaryFinder();

    enum BoundaryType {
        Grapheme,
        Word,
        Sentence,
        Line
    };

    enum BoundaryReason {
        NotAtBoundary = 0,
        BreakOpportunity = 0x1f,
        StartOfItem = 0x20,
        EndOfItem = 0x40,
        MandatoryBreak = 0x80,
        SoftHyphen = 0x100
    };
    typedef QFlags<BoundaryReason> BoundaryReasons;

    QTextBoundaryFinder(BoundaryType type, const QString &string);
    QTextBoundaryFinder(BoundaryType type, const QChar *chars, int length, unsigned char *buffer = 0, int bufferSize = 0);

    inline bool isValid() const { return d; }

    inline BoundaryType type() const { return t; }
    QString string() const;

    void toStart();
    void toEnd();
    int position() const;
    void setPosition(int position);

    int toNextBoundary();
    int toPreviousBoundary();

    bool isAtBoundary() const;
    BoundaryReasons boundaryReasons() const;

private:
    BoundaryType t;
    QString s;
    const QChar *chars;
    int length;
    int pos;
    uint freePrivate : 1;
    uint unused : 31;
    QTextBoundaryFinderPrivate *d;
};

 inline QFlags<QTextBoundaryFinder::BoundaryReasons::enum_type> operator|(QTextBoundaryFinder::BoundaryReasons::enum_type f1, QTextBoundaryFinder::BoundaryReasons::enum_type f2) { return QFlags<QTextBoundaryFinder::BoundaryReasons::enum_type>(f1) | f2; } inline QFlags<QTextBoundaryFinder::BoundaryReasons::enum_type> operator|(QTextBoundaryFinder::BoundaryReasons::enum_type f1, QFlags<QTextBoundaryFinder::BoundaryReasons::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QTextBoundaryFinder::BoundaryReasons::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
#line 157 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtimeline.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtimeline.h"
class QTimeLinePrivate;
class __declspec(dllimport) QTimeLine : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};







public:
    enum State {
        NotRunning,
        Paused,
        Running
    };
    enum Direction {
        Forward,
        Backward
    };
    enum CurveShape {
        EaseInCurve,
        EaseOutCurve,
        EaseInOutCurve,
        LinearCurve,
        SineCurve,
        CosineCurve
    };

    explicit QTimeLine(int duration = 1000, QObject *parent = 0);
    virtual ~QTimeLine();

    State state() const;

    int loopCount() const;
    void setLoopCount(int count);

    Direction direction() const;
    void setDirection(Direction direction);

    int duration() const;
    void setDuration(int duration);

    int startFrame() const;
    void setStartFrame(int frame);
    int endFrame() const;
    void setEndFrame(int frame);
    void setFrameRange(int startFrame, int endFrame);

    int updateInterval() const;
    void setUpdateInterval(int interval);

    CurveShape curveShape() const;
    void setCurveShape(CurveShape shape);

    QEasingCurve easingCurve() const;
    void setEasingCurve(const QEasingCurve &curve);

    int currentTime() const;
    int currentFrame() const;
    qreal currentValue() const;

    int frameForTime(int msec) const;
    virtual qreal valueForTime(int msec) const;

public :
    void start();
    void resume();
    void stop();
    void setPaused(bool paused);
    void setCurrentTime(int msec);
    void toggleDirection();

public:
    void valueChanged(qreal x

      , QPrivateSignal

    );
    void frameChanged(int

      , QPrivateSignal

    );
    void stateChanged(QTimeLine::State newState

      , QPrivateSignal

    );
    void finished(

      QPrivateSignal

    );

protected:
    void timerEvent(QTimerEvent *event);

private:
    QTimeLine(const QTimeLine &) = delete; QTimeLine &operator=(const QTimeLine &) = delete;
    inline QTimeLinePrivate* d_func() { return reinterpret_cast<QTimeLinePrivate *>(qGetPtrHelper(d_ptr)); } inline const QTimeLinePrivate* d_func() const { return reinterpret_cast<const QTimeLinePrivate *>(qGetPtrHelper(d_ptr)); } friend class QTimeLinePrivate;
};
#line 158 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtimezone.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtimezone.h"
class QTimeZonePrivate;

class __declspec(dllimport) QTimeZone
{
public:
    enum TimeType {
        StandardTime = 0,
        DaylightTime = 1,
        GenericTime = 2
    };

    enum NameType {
        DefaultName = 0,
        LongName = 1,
        ShortName = 2,
        OffsetName = 3
    };

    struct OffsetData {
        QString abbreviation;
        QDateTime atUtc;
        int offsetFromUtc;
        int standardTimeOffset;
        int daylightTimeOffset;
    };
    typedef QVector<OffsetData> OffsetDataList;

    QTimeZone();
    explicit QTimeZone(const QByteArray &ianaId);
    explicit QTimeZone(int offsetSeconds);
                 QTimeZone(const QByteArray &zoneId, int offsetSeconds, const QString &name,
              const QString &abbreviation, QLocale::Country country = QLocale::AnyCountry,
              const QString &comment = QString());
    QTimeZone(const QTimeZone &other);
    ~QTimeZone();

    QTimeZone &operator=(const QTimeZone &other);

    QTimeZone &operator=(QTimeZone &&other) { swap(other); return *this; }


    void swap(QTimeZone &other)
    { d.swap(other.d); }

    bool operator==(const QTimeZone &other) const;
    bool operator!=(const QTimeZone &other) const;

    bool isValid() const;

    QByteArray id() const;
    QLocale::Country country() const;
    QString comment() const;

    QString displayName(const QDateTime &atDateTime,
                        QTimeZone::NameType nameType = QTimeZone::DefaultName,
                        const QLocale &locale = QLocale()) const;
    QString displayName(QTimeZone::TimeType timeType,
                        QTimeZone::NameType nameType = QTimeZone::DefaultName,
                        const QLocale &locale = QLocale()) const;
    QString abbreviation(const QDateTime &atDateTime) const;

    int offsetFromUtc(const QDateTime &atDateTime) const;
    int standardTimeOffset(const QDateTime &atDateTime) const;
    int daylightTimeOffset(const QDateTime &atDateTime) const;

    bool hasDaylightTime() const;
    bool isDaylightTime(const QDateTime &atDateTime) const;

    OffsetData offsetData(const QDateTime &forDateTime) const;

    bool hasTransitions() const;
    OffsetData nextTransition(const QDateTime &afterDateTime) const;
    OffsetData previousTransition(const QDateTime &beforeDateTime) const;
    OffsetDataList transitions(const QDateTime &fromDateTime, const QDateTime &toDateTime) const;

    static QByteArray systemTimeZoneId();

    static bool isTimeZoneIdAvailable(const QByteArray &ianaId);

    static QList<QByteArray> availableTimeZoneIds();
    static QList<QByteArray> availableTimeZoneIds(QLocale::Country country);
    static QList<QByteArray> availableTimeZoneIds(int offsetSeconds);

    static QByteArray ianaIdToWindowsId(const QByteArray &ianaId);
    static QByteArray windowsIdToDefaultIanaId(const QByteArray &windowsId);
    static QByteArray windowsIdToDefaultIanaId(const QByteArray &windowsId,
                                                QLocale::Country country);
    static QList<QByteArray> windowsIdToIanaIds(const QByteArray &windowsId);
    static QList<QByteArray> windowsIdToIanaIds(const QByteArray &windowsId,
                                                 QLocale::Country country);

private:
    QTimeZone(QTimeZonePrivate &dd);

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &ds, const QTimeZone &tz);

    friend class QTimeZonePrivate;
    friend class QDateTime;
    friend class QDateTimePrivate;
    QSharedDataPointer<QTimeZonePrivate> d;
};

template<> class QTypeInfo<QTimeZone::OffsetData > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTimeZone::OffsetData)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTimeZone::OffsetData >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTimeZone::OffsetData) }; static inline const char *name() { return "QTimeZone::OffsetData"; } };
template<> class QTypeInfo<QTimeZone > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QTimeZone)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QTimeZone >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QTimeZone) }; static inline const char *name() { return "QTimeZone"; } }; template <> inline void qSwap<QTimeZone>(QTimeZone &value1, QTimeZone &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QTimeZone >(::QTimeZone &value1, ::QTimeZone &value2) { value1.swap(value2); } }


__declspec(dllimport) QDataStream &operator<<(QDataStream &ds, const QTimeZone &tz);
__declspec(dllimport) QDataStream &operator>>(QDataStream &ds, QTimeZone &tz);



__declspec(dllimport) QDebug operator<<(QDebug dbg, const QTimeZone &tz);
#line 159 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qxmlstream.h"
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qxmlstream.h"
class __declspec(dllimport) QXmlStreamStringRef {
    QString m_string;
    int m_position, m_size;
public:
    inline QXmlStreamStringRef():m_position(0), m_size(0){}
    inline QXmlStreamStringRef(const QStringRef &aString)
        :m_string(aString.string()?*aString.string():QString()), m_position(aString.position()), m_size(aString.size()){}
    inline QXmlStreamStringRef(const QString &aString):m_string(aString), m_position(0), m_size(aString.size()){}
    inline ~QXmlStreamStringRef(){}
    inline void clear() { m_string.clear(); m_position = m_size = 0; }
    inline operator QStringRef() const { return QStringRef(&m_string, m_position, m_size); }
    inline const QString *string() const { return &m_string; }
    inline int position() const { return m_position; }
    inline int size() const { return m_size; }
};


class QXmlStreamReaderPrivate;
class QXmlStreamAttributes;
class __declspec(dllimport) QXmlStreamAttribute {
    QXmlStreamStringRef m_name, m_namespaceUri, m_qualifiedName, m_value;
    void *reserved;
    uint m_isDefault : 1;
    friend class QXmlStreamReaderPrivate;
    friend class QXmlStreamAttributes;
public:
    QXmlStreamAttribute();
    QXmlStreamAttribute(const QString &qualifiedName, const QString &value);
    QXmlStreamAttribute(const QString &namespaceUri, const QString &name, const QString &value);
    QXmlStreamAttribute(const QXmlStreamAttribute &);
    QXmlStreamAttribute& operator=(const QXmlStreamAttribute &);
    ~QXmlStreamAttribute();
    inline QStringRef namespaceUri() const { return m_namespaceUri; }
    inline QStringRef name() const { return m_name; }
    inline QStringRef qualifiedName() const { return m_qualifiedName; }
    inline QStringRef prefix() const {
        return QStringRef(m_qualifiedName.string(),
                          m_qualifiedName.position(),
                          qMax(0, m_qualifiedName.size() - m_name.size() - 1));
    }
    inline QStringRef value() const { return m_value; }
    inline bool isDefault() const { return m_isDefault; }
    inline bool operator==(const QXmlStreamAttribute &other) const {
        return (value() == other.value()
                && (namespaceUri().isNull() ? (qualifiedName() == other.qualifiedName())
                    : (namespaceUri() == other.namespaceUri() && name() == other.name())));
    }
    inline bool operator!=(const QXmlStreamAttribute &other) const
        { return !operator==(other); }
};

template<> class QTypeInfo<QXmlStreamAttribute > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QXmlStreamAttribute)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QXmlStreamAttribute >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QXmlStreamAttribute) }; static inline const char *name() { return "QXmlStreamAttribute"; } };

class __declspec(dllimport) QXmlStreamAttributes : public QVector<QXmlStreamAttribute>
{
public:
    inline QXmlStreamAttributes() {}
    QStringRef value(const QString &namespaceUri, const QString &name) const;
    QStringRef value(const QString &namespaceUri, QLatin1String name) const;
    QStringRef value(QLatin1String namespaceUri, QLatin1String name) const;
    QStringRef value(const QString &qualifiedName) const;
    QStringRef value(QLatin1String qualifiedName) const;
    void append(const QString &namespaceUri, const QString &name, const QString &value);
    void append(const QString &qualifiedName, const QString &value);

    inline bool hasAttribute(const QString &qualifiedName) const
    {
        return !value(qualifiedName).isNull();
    }

    inline bool hasAttribute(QLatin1String qualifiedName) const
    {
        return !value(qualifiedName).isNull();
    }

    inline bool hasAttribute(const QString &namespaceUri, const QString &name) const
    {
        return !value(namespaceUri, name).isNull();
    }


    using QVector<QXmlStreamAttribute>::append;




};

class __declspec(dllimport) QXmlStreamNamespaceDeclaration {
    QXmlStreamStringRef m_prefix, m_namespaceUri;
    void *reserved;

    friend class QXmlStreamReaderPrivate;
public:
    QXmlStreamNamespaceDeclaration();
    QXmlStreamNamespaceDeclaration(const QXmlStreamNamespaceDeclaration &);
    QXmlStreamNamespaceDeclaration(const QString &prefix, const QString &namespaceUri);
    ~QXmlStreamNamespaceDeclaration();
    QXmlStreamNamespaceDeclaration& operator=(const QXmlStreamNamespaceDeclaration &);
    inline QStringRef prefix() const { return m_prefix; }
    inline QStringRef namespaceUri() const { return m_namespaceUri; }
    inline bool operator==(const QXmlStreamNamespaceDeclaration &other) const {
        return (prefix() == other.prefix() && namespaceUri() == other.namespaceUri());
    }
    inline bool operator!=(const QXmlStreamNamespaceDeclaration &other) const
        { return !operator==(other); }
};

template<> class QTypeInfo<QXmlStreamNamespaceDeclaration > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QXmlStreamNamespaceDeclaration)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QXmlStreamNamespaceDeclaration >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QXmlStreamNamespaceDeclaration) }; static inline const char *name() { return "QXmlStreamNamespaceDeclaration"; } };
typedef QVector<QXmlStreamNamespaceDeclaration> QXmlStreamNamespaceDeclarations;

class __declspec(dllimport) QXmlStreamNotationDeclaration {
    QXmlStreamStringRef m_name, m_systemId, m_publicId;
    void *reserved;

    friend class QXmlStreamReaderPrivate;
public:
    QXmlStreamNotationDeclaration();
    ~QXmlStreamNotationDeclaration();
    QXmlStreamNotationDeclaration(const QXmlStreamNotationDeclaration &);
    QXmlStreamNotationDeclaration& operator=(const QXmlStreamNotationDeclaration &);
    inline QStringRef name() const { return m_name; }
    inline QStringRef systemId() const { return m_systemId; }
    inline QStringRef publicId() const { return m_publicId; }
    inline bool operator==(const QXmlStreamNotationDeclaration &other) const {
        return (name() == other.name() && systemId() == other.systemId()
                && publicId() == other.publicId());
    }
    inline bool operator!=(const QXmlStreamNotationDeclaration &other) const
        { return !operator==(other); }
};

template<> class QTypeInfo<QXmlStreamNotationDeclaration > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QXmlStreamNotationDeclaration)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QXmlStreamNotationDeclaration >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QXmlStreamNotationDeclaration) }; static inline const char *name() { return "QXmlStreamNotationDeclaration"; } };
typedef QVector<QXmlStreamNotationDeclaration> QXmlStreamNotationDeclarations;

class __declspec(dllimport) QXmlStreamEntityDeclaration {
    QXmlStreamStringRef m_name, m_notationName, m_systemId, m_publicId, m_value;
    void *reserved;

    friend class QXmlStreamReaderPrivate;
public:
    QXmlStreamEntityDeclaration();
    ~QXmlStreamEntityDeclaration();
    QXmlStreamEntityDeclaration(const QXmlStreamEntityDeclaration &);
    QXmlStreamEntityDeclaration& operator=(const QXmlStreamEntityDeclaration &);
    inline QStringRef name() const { return m_name; }
    inline QStringRef notationName() const { return m_notationName; }
    inline QStringRef systemId() const { return m_systemId; }
    inline QStringRef publicId() const { return m_publicId; }
    inline QStringRef value() const { return m_value; }
    inline bool operator==(const QXmlStreamEntityDeclaration &other) const {
        return (name() == other.name()
                && notationName() == other.notationName()
                && systemId() == other.systemId()
                && publicId() == other.publicId()
                && value() == other.value());
    }
    inline bool operator!=(const QXmlStreamEntityDeclaration &other) const
        { return !operator==(other); }
};

template<> class QTypeInfo<QXmlStreamEntityDeclaration > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QXmlStreamEntityDeclaration)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QXmlStreamEntityDeclaration >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QXmlStreamEntityDeclaration) }; static inline const char *name() { return "QXmlStreamEntityDeclaration"; } };
typedef QVector<QXmlStreamEntityDeclaration> QXmlStreamEntityDeclarations;


class __declspec(dllimport) QXmlStreamEntityResolver
{
public:
    virtual ~QXmlStreamEntityResolver();
    virtual QString resolveEntity(const QString& publicId, const QString& systemId);
    virtual QString resolveUndeclaredEntity(const QString &name);
};


class __declspec(dllimport) QXmlStreamReader {

public:
    enum TokenType {
        NoToken = 0,
        Invalid,
        StartDocument,
        EndDocument,
        StartElement,
        EndElement,
        Characters,
        Comment,
        DTD,
        EntityReference,
        ProcessingInstruction
    };


    QXmlStreamReader();
    explicit QXmlStreamReader(QIODevice *device);
    explicit QXmlStreamReader(const QByteArray &data);
    explicit QXmlStreamReader(const QString &data);
    explicit QXmlStreamReader(const char * data);
    ~QXmlStreamReader();

    void setDevice(QIODevice *device);
    QIODevice *device() const;
    void addData(const QByteArray &data);
    void addData(const QString &data);
    void addData(const char *data);
    void clear();


    bool atEnd() const;
    TokenType readNext();

    bool readNextStartElement();
    void skipCurrentElement();

    TokenType tokenType() const;
    QString tokenString() const;

    void setNamespaceProcessing(bool);
    bool namespaceProcessing() const;

    inline bool isStartDocument() const { return tokenType() == StartDocument; }
    inline bool isEndDocument() const { return tokenType() == EndDocument; }
    inline bool isStartElement() const { return tokenType() == StartElement; }
    inline bool isEndElement() const { return tokenType() == EndElement; }
    inline bool isCharacters() const { return tokenType() == Characters; }
    bool isWhitespace() const;
    bool isCDATA() const;
    inline bool isComment() const { return tokenType() == Comment; }
    inline bool isDTD() const { return tokenType() == DTD; }
    inline bool isEntityReference() const { return tokenType() == EntityReference; }
    inline bool isProcessingInstruction() const { return tokenType() == ProcessingInstruction; }

    bool isStandaloneDocument() const;
    QStringRef documentVersion() const;
    QStringRef documentEncoding() const;

    qint64 lineNumber() const;
    qint64 columnNumber() const;
    qint64 characterOffset() const;

    QXmlStreamAttributes attributes() const;

    enum ReadElementTextBehaviour {
        ErrorOnUnexpectedElement,
        IncludeChildElements,
        SkipChildElements
    };
    QString readElementText(ReadElementTextBehaviour behaviour = ErrorOnUnexpectedElement);

    QStringRef name() const;
    QStringRef namespaceUri() const;
    QStringRef qualifiedName() const;
    QStringRef prefix() const;

    QStringRef processingInstructionTarget() const;
    QStringRef processingInstructionData() const;

    QStringRef text() const;

    QXmlStreamNamespaceDeclarations namespaceDeclarations() const;
    void addExtraNamespaceDeclaration(const QXmlStreamNamespaceDeclaration &extraNamespaceDeclaraction);
    void addExtraNamespaceDeclarations(const QXmlStreamNamespaceDeclarations &extraNamespaceDeclaractions);
    QXmlStreamNotationDeclarations notationDeclarations() const;
    QXmlStreamEntityDeclarations entityDeclarations() const;
    QStringRef dtdName() const;
    QStringRef dtdPublicId() const;
    QStringRef dtdSystemId() const;


    enum Error {
        NoError,
        UnexpectedElementError,
        CustomError,
        NotWellFormedError,
        PrematureEndOfDocumentError
    };
    void raiseError(const QString& message = QString());
    QString errorString() const;
    Error error() const;

    inline bool hasError() const
    {
        return error() != NoError;
    }

    void setEntityResolver(QXmlStreamEntityResolver *resolver);
    QXmlStreamEntityResolver *entityResolver() const;

private:
    QXmlStreamReader(const QXmlStreamReader &) = delete; QXmlStreamReader &operator=(const QXmlStreamReader &) = delete;
    inline QXmlStreamReaderPrivate* d_func() { return reinterpret_cast<QXmlStreamReaderPrivate *>(qGetPtrHelper(d_ptr)); } inline const QXmlStreamReaderPrivate* d_func() const { return reinterpret_cast<const QXmlStreamReaderPrivate *>(qGetPtrHelper(d_ptr)); } friend class QXmlStreamReaderPrivate;
    QScopedPointer<QXmlStreamReaderPrivate> d_ptr;

};




class QXmlStreamWriterPrivate;

class __declspec(dllimport) QXmlStreamWriter
{


public:
    QXmlStreamWriter();
    explicit QXmlStreamWriter(QIODevice *device);
    explicit QXmlStreamWriter(QByteArray *array);
    explicit QXmlStreamWriter(QString *string);
    ~QXmlStreamWriter();

    void setDevice(QIODevice *device);
    QIODevice *device() const;


    void setCodec(QTextCodec *codec);
    void setCodec(const char *codecName);
    QTextCodec *codec() const;


    void setAutoFormatting(bool);
    bool autoFormatting() const;

    void setAutoFormattingIndent(int spacesOrTabs);
    int autoFormattingIndent() const;

    void writeAttribute(const QString &qualifiedName, const QString &value);
    void writeAttribute(const QString &namespaceUri, const QString &name, const QString &value);
    void writeAttribute(const QXmlStreamAttribute& attribute);
    void writeAttributes(const QXmlStreamAttributes& attributes);

    void writeCDATA(const QString &text);
    void writeCharacters(const QString &text);
    void writeComment(const QString &text);

    void writeDTD(const QString &dtd);

    void writeEmptyElement(const QString &qualifiedName);
    void writeEmptyElement(const QString &namespaceUri, const QString &name);

    void writeTextElement(const QString &qualifiedName, const QString &text);
    void writeTextElement(const QString &namespaceUri, const QString &name, const QString &text);

    void writeEndDocument();
    void writeEndElement();

    void writeEntityReference(const QString &name);
    void writeNamespace(const QString &namespaceUri, const QString &prefix = QString());
    void writeDefaultNamespace(const QString &namespaceUri);
    void writeProcessingInstruction(const QString &target, const QString &data = QString());

    void writeStartDocument();
    void writeStartDocument(const QString &version);
    void writeStartDocument(const QString &version, bool standalone);
    void writeStartElement(const QString &qualifiedName);
    void writeStartElement(const QString &namespaceUri, const QString &name);


    void writeCurrentToken(const QXmlStreamReader &reader);


    bool hasError() const;

private:
    QXmlStreamWriter(const QXmlStreamWriter &) = delete; QXmlStreamWriter &operator=(const QXmlStreamWriter &) = delete;
    inline QXmlStreamWriterPrivate* d_func() { return reinterpret_cast<QXmlStreamWriterPrivate *>(qGetPtrHelper(d_ptr)); } inline const QXmlStreamWriterPrivate* d_func() const { return reinterpret_cast<const QXmlStreamWriterPrivate *>(qGetPtrHelper(d_ptr)); } friend class QXmlStreamWriterPrivate;
    QScopedPointer<QXmlStreamWriterPrivate> d_ptr;
};
#line 162 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtCore/qtcoreversion.h"
#line 163 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QtCore"
#line 2 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/QtGuiDepends"
#line 3 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h"
#line 63 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h"
class QAccessibleInterface;
class QAccessibleEvent;
class QWindow;
class QTextCursor;


class __declspec(dllimport) QAccessible
{
    public: static const QMetaObject staticMetaObject; private:

public:

    enum Event {
        SoundPlayed = 0x0001,
        Alert = 0x0002,
        ForegroundChanged = 0x0003,
        MenuStart = 0x0004,
        MenuEnd = 0x0005,
        PopupMenuStart = 0x0006,
        PopupMenuEnd = 0x0007,
        ContextHelpStart = 0x000C,
        ContextHelpEnd = 0x000D,
        DragDropStart = 0x000E,
        DragDropEnd = 0x000F,
        DialogStart = 0x0010,
        DialogEnd = 0x0011,
        ScrollingStart = 0x0012,
        ScrollingEnd = 0x0013,

        MenuCommand = 0x0018,


        ActionChanged = 0x0101,
        ActiveDescendantChanged = 0x0102,
        AttributeChanged = 0x0103,
        DocumentContentChanged = 0x0104,
        DocumentLoadComplete = 0x0105,
        DocumentLoadStopped = 0x0106,
        DocumentReload = 0x0107,
        HyperlinkEndIndexChanged = 0x0108,
        HyperlinkNumberOfAnchorsChanged = 0x0109,
        HyperlinkSelectedLinkChanged = 0x010A,
        HypertextLinkActivated = 0x010B,
        HypertextLinkSelected = 0x010C,
        HyperlinkStartIndexChanged = 0x010D,
        HypertextChanged = 0x010E,
        HypertextNLinksChanged = 0x010F,
        ObjectAttributeChanged = 0x0110,
        PageChanged = 0x0111,
        SectionChanged = 0x0112,
        TableCaptionChanged = 0x0113,
        TableColumnDescriptionChanged = 0x0114,
        TableColumnHeaderChanged = 0x0115,
        TableModelChanged = 0x0116,
        TableRowDescriptionChanged = 0x0117,
        TableRowHeaderChanged = 0x0118,
        TableSummaryChanged = 0x0119,
        TextAttributeChanged = 0x011A,
        TextCaretMoved = 0x011B,

        TextColumnChanged = 0x011D,
        TextInserted = 0x011E,
        TextRemoved = 0x011F,
        TextUpdated = 0x0120,
        TextSelectionChanged = 0x0121,
        VisibleDataChanged = 0x0122,

        ObjectCreated = 0x8000,
        ObjectDestroyed = 0x8001,
        ObjectShow = 0x8002,
        ObjectHide = 0x8003,
        ObjectReorder = 0x8004,
        Focus = 0x8005,
        Selection = 0x8006,
        SelectionAdd = 0x8007,
        SelectionRemove = 0x8008,
        SelectionWithin = 0x8009,
        StateChanged = 0x800A,
        LocationChanged = 0x800B,
        NameChanged = 0x800C,
        DescriptionChanged = 0x800D,
        ValueChanged = 0x800E,
        ParentChanged = 0x800F,
        HelpChanged = 0x80A0,
        DefaultActionChanged = 0x80B0,
        AcceleratorChanged = 0x80C0,

        InvalidEvent
    };



    struct State {

        quint64 disabled : 1;
        quint64 selected : 1;
        quint64 focusable : 1;
        quint64 focused : 1;
        quint64 pressed : 1;
        quint64 checkable : 1;
        quint64 checked : 1;
        quint64 checkStateMixed : 1;
        quint64 readOnly : 1;
        quint64 hotTracked : 1;
        quint64 defaultButton : 1;
        quint64 expanded : 1;
        quint64 collapsed : 1;
        quint64 busy : 1;
        quint64 expandable : 1;
        quint64 marqueed : 1;
        quint64 animated : 1;
        quint64 invisible : 1;
        quint64 offscreen : 1;
        quint64 sizeable : 1;
        quint64 movable : 1;
        quint64 selfVoicing : 1;
        quint64 selectable : 1;
        quint64 linked : 1;
        quint64 traversed : 1;
        quint64 multiSelectable : 1;
        quint64 extSelectable : 1;
        quint64 passwordEdit : 1;
        quint64 hasPopup : 1;
        quint64 modal : 1;



        quint64 active : 1;
        quint64 invalid : 1;
        quint64 editable : 1;
        quint64 multiLine : 1;
        quint64 selectableText : 1;
        quint64 supportsAutoCompletion : 1;
#line 218 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h"
        State() {
            memset(this, 0, sizeof(State));
        }
    };





    enum Role {
        NoRole = 0x00000000,
        TitleBar = 0x00000001,
        MenuBar = 0x00000002,
        ScrollBar = 0x00000003,
        Grip = 0x00000004,
        Sound = 0x00000005,
        Cursor = 0x00000006,
        Caret = 0x00000007,
        AlertMessage = 0x00000008,
        Window = 0x00000009,
        Client = 0x0000000A,
        PopupMenu = 0x0000000B,
        MenuItem = 0x0000000C,
        ToolTip = 0x0000000D,
        Application = 0x0000000E,
        Document = 0x0000000F,
        Pane = 0x00000010,
        Chart = 0x00000011,
        Dialog = 0x00000012,
        Border = 0x00000013,
        Grouping = 0x00000014,
        Separator = 0x00000015,
        ToolBar = 0x00000016,
        StatusBar = 0x00000017,
        Table = 0x00000018,
        ColumnHeader = 0x00000019,
        RowHeader = 0x0000001A,
        Column = 0x0000001B,
        Row = 0x0000001C,
        Cell = 0x0000001D,
        Link = 0x0000001E,
        HelpBalloon = 0x0000001F,
        Assistant = 0x00000020,
        List = 0x00000021,
        ListItem = 0x00000022,
        Tree = 0x00000023,
        TreeItem = 0x00000024,
        PageTab = 0x00000025,
        PropertyPage = 0x00000026,
        Indicator = 0x00000027,
        Graphic = 0x00000028,
        StaticText = 0x00000029,
        EditableText = 0x0000002A,
        Button = 0x0000002B,

        PushButton = Button,

        CheckBox = 0x0000002C,
        RadioButton = 0x0000002D,
        ComboBox = 0x0000002E,

        ProgressBar = 0x00000030,
        Dial = 0x00000031,
        HotkeyField = 0x00000032,
        Slider = 0x00000033,
        SpinBox = 0x00000034,
        Canvas = 0x00000035,
        Animation = 0x00000036,
        Equation = 0x00000037,
        ButtonDropDown = 0x00000038,
        ButtonMenu = 0x00000039,
        ButtonDropGrid = 0x0000003A,
        Whitespace = 0x0000003B,
        PageTabList = 0x0000003C,
        Clock = 0x0000003D,
        Splitter = 0x0000003E,



        LayeredPane = 0x00000080,
        Terminal = 0x00000081,
        Desktop = 0x00000082,
        UserRole = 0x0000ffff
    };

    enum Text {
        Name = 0,
        Description,
        Value,
        Help,
        Accelerator,
        DebugDescription,
        UserText = 0x0000ffff
    };

    enum RelationFlag {
        Label = 0x00000001,
        Labelled = 0x00000002,
        Controller = 0x00000004,
        Controlled = 0x00000008,
        AllRelations = 0xffffffff
    };
    typedef QFlags<RelationFlag> Relation;

    enum InterfaceType
    {
        TextInterface,
        EditableTextInterface,
        ValueInterface,
        ActionInterface,
        ImageInterface,
        TableInterface,
        TableCellInterface
    };

    enum TextBoundaryType {
        CharBoundary,
        WordBoundary,
        SentenceBoundary,
        ParagraphBoundary,
        LineBoundary,
        NoBoundary
    };

    typedef QAccessibleInterface*(*InterfaceFactory)(const QString &key, QObject*);
    typedef void(*UpdateHandler)(QAccessibleEvent *event);
    typedef void(*RootObjectHandler)(QObject*);

    typedef unsigned Id;

    static void installFactory(InterfaceFactory);
    static void removeFactory(InterfaceFactory);
    static UpdateHandler installUpdateHandler(UpdateHandler);
    static RootObjectHandler installRootObjectHandler(RootObjectHandler);

    static QAccessibleInterface *queryAccessibleInterface(QObject *);
    static Id uniqueId(QAccessibleInterface *iface);
    static QAccessibleInterface *accessibleInterface(Id uniqueId);
    static Id registerAccessibleInterface(QAccessibleInterface *iface);
    static void deleteAccessibleInterface(Id uniqueId);





    static void updateAccessibility(QAccessibleEvent *event);

    static bool isActive();
    static void setRootObject(QObject *object);

    static void cleanup();

    static QPair< int, int > qAccessibleTextBoundaryHelper(const QTextCursor &cursor, TextBoundaryType boundaryType);

private:
    static UpdateHandler updateHandler;
    static RootObjectHandler rootObjectHandler;

    QAccessible() {}

    friend class QAccessibleCache;
};

__declspec(dllimport) bool operator==(const QAccessible::State &first, const QAccessible::State &second);

 inline QFlags<QAccessible::Relation::enum_type> operator|(QAccessible::Relation::enum_type f1, QAccessible::Relation::enum_type f2) { return QFlags<QAccessible::Relation::enum_type>(f1) | f2; } inline QFlags<QAccessible::Relation::enum_type> operator|(QAccessible::Relation::enum_type f1, QFlags<QAccessible::Relation::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QAccessible::Relation::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

class QAccessible2Interface;
class QAccessibleTextInterface;
class QAccessibleEditableTextInterface;
class QAccessibleValueInterface;
class QAccessibleActionInterface;
class QAccessibleImageInterface;
class QAccessibleTableInterface;
class QAccessibleTableCellInterface;
class QAccessibleTableModelChangeEvent;

class __declspec(dllimport) QAccessibleInterface
{
protected:
    virtual ~QAccessibleInterface();

public:

    virtual bool isValid() const = 0;
    virtual QObject *object() const = 0;
    virtual QWindow *window() const;


    virtual QVector<QPair<QAccessibleInterface*, QAccessible::Relation> > relations(QAccessible::Relation match = QAccessible::AllRelations) const;
    virtual QAccessibleInterface *focusChild() const;

    virtual QAccessibleInterface *childAt(int x, int y) const = 0;


    virtual QAccessibleInterface *parent() const = 0;
    virtual QAccessibleInterface *child(int index) const = 0;
    virtual int childCount() const = 0;
    virtual int indexOfChild(const QAccessibleInterface *) const = 0;


    virtual QString text(QAccessible::Text t) const = 0;
    virtual void setText(QAccessible::Text t, const QString &text) = 0;
    virtual QRect rect() const = 0;
    virtual QAccessible::Role role() const = 0;
    virtual QAccessible::State state() const = 0;

    virtual QColor foregroundColor() const;
    virtual QColor backgroundColor() const;

    inline QAccessibleTextInterface *textInterface()
    { return reinterpret_cast<QAccessibleTextInterface *>(interface_cast(QAccessible::TextInterface)); }

    inline QAccessibleEditableTextInterface *editableTextInterface()
    { return reinterpret_cast<QAccessibleEditableTextInterface *>(interface_cast(QAccessible::EditableTextInterface)); }

    inline QAccessibleValueInterface *valueInterface()
    { return reinterpret_cast<QAccessibleValueInterface *>(interface_cast(QAccessible::ValueInterface)); }

    inline QAccessibleActionInterface *actionInterface()
    { return reinterpret_cast<QAccessibleActionInterface *>(interface_cast(QAccessible::ActionInterface)); }

    inline QAccessibleImageInterface *imageInterface()
    { return reinterpret_cast<QAccessibleImageInterface *>(interface_cast(QAccessible::ImageInterface)); }

    inline QAccessibleTableInterface *tableInterface()
    { return reinterpret_cast<QAccessibleTableInterface *>(interface_cast(QAccessible::TableInterface)); }

    inline QAccessibleTableCellInterface *tableCellInterface()
    { return reinterpret_cast<QAccessibleTableCellInterface *>(interface_cast(QAccessible::TableCellInterface)); }

    virtual void virtual_hook(int id, void *data);

    virtual void *interface_cast(QAccessible::InterfaceType)
    { return 0; }

protected:
    friend class QAccessibleCache;
};

class __declspec(dllimport) QAccessibleTextInterface
{
public:
    virtual ~QAccessibleTextInterface() {}

    virtual void selection(int selectionIndex, int *startOffset, int *endOffset) const = 0;
    virtual int selectionCount() const = 0;
    virtual void addSelection(int startOffset, int endOffset) = 0;
    virtual void removeSelection(int selectionIndex) = 0;
    virtual void setSelection(int selectionIndex, int startOffset, int endOffset) = 0;


    virtual int cursorPosition() const = 0;
    virtual void setCursorPosition(int position) = 0;


    virtual QString text(int startOffset, int endOffset) const = 0;
    virtual QString textBeforeOffset(int offset, QAccessible::TextBoundaryType boundaryType,
                                     int *startOffset, int *endOffset) const;
    virtual QString textAfterOffset(int offset, QAccessible::TextBoundaryType boundaryType,
                                    int *startOffset, int *endOffset) const;
    virtual QString textAtOffset(int offset, QAccessible::TextBoundaryType boundaryType,
                                 int *startOffset, int *endOffset) const;
    virtual int characterCount() const = 0;


    virtual QRect characterRect(int offset) const = 0;
    virtual int offsetAtPoint(const QPoint &point) const = 0;

    virtual void scrollToSubstring(int startIndex, int endIndex) = 0;
    virtual QString attributes(int offset, int *startOffset, int *endOffset) const = 0;
};

class __declspec(dllimport) QAccessibleEditableTextInterface
{
public:
    virtual ~QAccessibleEditableTextInterface() {}

    virtual void deleteText(int startOffset, int endOffset) = 0;
    virtual void insertText(int offset, const QString &text) = 0;
    virtual void replaceText(int startOffset, int endOffset, const QString &text) = 0;
};

class __declspec(dllimport) QAccessibleValueInterface
{
public:

    virtual ~QAccessibleValueInterface() {}

    virtual QVariant currentValue() const = 0;
    virtual void setCurrentValue(const QVariant &value) = 0;
    virtual QVariant maximumValue() const = 0;
    virtual QVariant minimumValue() const = 0;
    virtual QVariant minimumStepSize() const = 0;
};

class __declspec(dllimport) QAccessibleTableCellInterface
{
public:
    virtual ~QAccessibleTableCellInterface() {}

    virtual bool isSelected() const = 0;

    virtual QList<QAccessibleInterface*> columnHeaderCells() const = 0;
    virtual QList<QAccessibleInterface*> rowHeaderCells() const = 0;
    virtual int columnIndex() const = 0;
    virtual int rowIndex() const = 0;
    virtual int columnExtent() const = 0;
    virtual int rowExtent() const = 0;

    virtual QAccessibleInterface* table() const = 0;
};

class __declspec(dllimport) QAccessibleTableInterface
{
public:
    virtual ~QAccessibleTableInterface() {}

    virtual QAccessibleInterface *caption() const = 0;
    virtual QAccessibleInterface *summary() const = 0;

    virtual QAccessibleInterface *cellAt (int row, int column) const = 0;
    virtual int selectedCellCount() const = 0;
    virtual QList<QAccessibleInterface*> selectedCells() const = 0;

    virtual QString columnDescription(int column) const = 0;
    virtual QString rowDescription(int row) const = 0;
    virtual int selectedColumnCount() const = 0;
    virtual int selectedRowCount() const = 0;
    virtual int columnCount() const = 0;
    virtual int rowCount() const = 0;
    virtual QList<int> selectedColumns() const = 0;
    virtual QList<int> selectedRows() const = 0;
    virtual bool isColumnSelected(int column) const = 0;
    virtual bool isRowSelected(int row) const = 0;
    virtual bool selectRow(int row) = 0;
    virtual bool selectColumn(int column) = 0;
    virtual bool unselectRow(int row) = 0;
    virtual bool unselectColumn(int column) = 0;

    virtual void modelChange(QAccessibleTableModelChangeEvent *event) = 0;

protected:
friend class QAbstractItemView;
friend class QAbstractItemViewPrivate;
};

class __declspec(dllimport) QAccessibleActionInterface
{
    public: static inline QString tr(const char *sourceText, const char *disambiguation = 0, int n = -1) { return QCoreApplication::translate("QAccessibleActionInterface", sourceText, disambiguation, n); } static inline QString trUtf8(const char *sourceText, const char *disambiguation = 0, int n = -1) { return QCoreApplication::translate("QAccessibleActionInterface", sourceText, disambiguation, n); } private:
public:
    virtual ~QAccessibleActionInterface() {}

    virtual QStringList actionNames() const = 0;
    virtual QString localizedActionName(const QString &name) const;
    virtual QString localizedActionDescription(const QString &name) const;
    virtual void doAction(const QString &actionName) = 0;
    virtual QStringList keyBindingsForAction(const QString &actionName) const = 0;

    static const QString &pressAction();
    static const QString &increaseAction();
    static const QString &decreaseAction();
    static const QString &showMenuAction();
    static const QString &setFocusAction();
    static const QString &toggleAction();
};

class __declspec(dllimport) QAccessibleImageInterface
{
public:
    virtual ~QAccessibleImageInterface() {}

    virtual QString imageDescription() const = 0;
    virtual QSize imageSize() const = 0;
    virtual QPoint imagePosition() const = 0;
};


class __declspec(dllimport) QAccessibleEvent
{
    QAccessibleEvent(const QAccessibleEvent &) = delete; QAccessibleEvent &operator=(const QAccessibleEvent &) = delete;
public:

    inline QAccessibleEvent(QObject *obj, QAccessible::Event typ)
        : m_type(typ), m_object(obj), m_child(-1)
    {
        ((!(obj)) ? qt_assert("obj","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",604) : qt_noop());


        ((!(m_type != QAccessible::ValueChanged)) ? qt_assert("m_type != QAccessible::ValueChanged","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",607) : qt_noop());
        ((!(m_type != QAccessible::StateChanged)) ? qt_assert("m_type != QAccessible::StateChanged","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",608) : qt_noop());
        ((!(m_type != QAccessible::TextCaretMoved)) ? qt_assert("m_type != QAccessible::TextCaretMoved","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",609) : qt_noop());
        ((!(m_type != QAccessible::TextSelectionChanged)) ? qt_assert("m_type != QAccessible::TextSelectionChanged","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",610) : qt_noop());
        ((!(m_type != QAccessible::TextInserted)) ? qt_assert("m_type != QAccessible::TextInserted","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",611) : qt_noop());
        ((!(m_type != QAccessible::TextRemoved)) ? qt_assert("m_type != QAccessible::TextRemoved","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",612) : qt_noop());
        ((!(m_type != QAccessible::TextUpdated)) ? qt_assert("m_type != QAccessible::TextUpdated","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",613) : qt_noop());
        ((!(m_type != QAccessible::TableModelChanged)) ? qt_assert("m_type != QAccessible::TableModelChanged","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",614) : qt_noop());
    }

    inline QAccessibleEvent(QAccessibleInterface *iface, QAccessible::Event typ)
        : m_type(typ), m_object(0)
    {
        ((!(iface)) ? qt_assert("iface","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",620) : qt_noop());
        ((!(m_type != QAccessible::ValueChanged)) ? qt_assert("m_type != QAccessible::ValueChanged","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",621) : qt_noop());
        ((!(m_type != QAccessible::StateChanged)) ? qt_assert("m_type != QAccessible::StateChanged","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",622) : qt_noop());
        ((!(m_type != QAccessible::TextCaretMoved)) ? qt_assert("m_type != QAccessible::TextCaretMoved","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",623) : qt_noop());
        ((!(m_type != QAccessible::TextSelectionChanged)) ? qt_assert("m_type != QAccessible::TextSelectionChanged","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",624) : qt_noop());
        ((!(m_type != QAccessible::TextInserted)) ? qt_assert("m_type != QAccessible::TextInserted","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",625) : qt_noop());
        ((!(m_type != QAccessible::TextRemoved)) ? qt_assert("m_type != QAccessible::TextRemoved","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",626) : qt_noop());
        ((!(m_type != QAccessible::TextUpdated)) ? qt_assert("m_type != QAccessible::TextUpdated","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",627) : qt_noop());
        ((!(m_type != QAccessible::TableModelChanged)) ? qt_assert("m_type != QAccessible::TableModelChanged","C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h",628) : qt_noop());
        m_uniqueId = QAccessible::uniqueId(iface);
    }

    virtual ~QAccessibleEvent()
    {}

    QAccessible::Event type() const { return m_type; }
    QObject *object() const { return m_object; }
    QAccessible::Id uniqueId() const;

    void setChild(int chld) { m_child = chld; }
    int child() const { return m_child; }

    virtual QAccessibleInterface *accessibleInterface() const;

protected:
    QAccessible::Event m_type;
    QObject *m_object;
    union {
        int m_child;
        QAccessible::Id m_uniqueId;
    };

};

class __declspec(dllimport) QAccessibleStateChangeEvent :public QAccessibleEvent
{
public:
    inline QAccessibleStateChangeEvent(QObject *obj, QAccessible::State state)
        : QAccessibleEvent(obj, QAccessible::InvalidEvent), m_changedStates(state)
    {
        m_type = QAccessible::StateChanged;
    }
    inline QAccessibleStateChangeEvent(QAccessibleInterface *iface, QAccessible::State state)
        : QAccessibleEvent(iface, QAccessible::InvalidEvent), m_changedStates(state)
    {
        m_type = QAccessible::StateChanged;
    }

    QAccessible::State changedStates() const {
        return m_changedStates;
    }

protected:
    QAccessible::State m_changedStates;
};


class __declspec(dllimport) QAccessibleTextCursorEvent : public QAccessibleEvent
{
public:
    inline QAccessibleTextCursorEvent(QObject *obj, int cursorPos)
        : QAccessibleEvent(obj, QAccessible::InvalidEvent)
      , m_cursorPosition(cursorPos)
    {
        m_type = QAccessible::TextCaretMoved;
    }
    inline QAccessibleTextCursorEvent(QAccessibleInterface *iface, int cursorPos)
        : QAccessibleEvent(iface, QAccessible::InvalidEvent)
      , m_cursorPosition(cursorPos)
    {
        m_type = QAccessible::TextCaretMoved;
    }

    void setCursorPosition(int position) { m_cursorPosition = position; }
    int cursorPosition() const { return m_cursorPosition; }

protected:
    int m_cursorPosition;
};


class __declspec(dllimport) QAccessibleTextSelectionEvent : public QAccessibleTextCursorEvent
{
public:
    inline QAccessibleTextSelectionEvent(QObject *obj, int start, int end)
        : QAccessibleTextCursorEvent(obj, (start == -1) ? 0 : end)
        , m_selectionStart(start), m_selectionEnd(end)
    {
        m_type = QAccessible::TextSelectionChanged;
    }
    inline QAccessibleTextSelectionEvent(QAccessibleInterface *iface, int start, int end)
        : QAccessibleTextCursorEvent(iface, (start == -1) ? 0 : end)
        , m_selectionStart(start), m_selectionEnd(end)
    {
        m_type = QAccessible::TextSelectionChanged;
    }

    void setSelection(int start, int end) {
        m_selectionStart = start;
        m_selectionEnd = end;
    }

    int selectionStart() const { return m_selectionStart; }
    int selectionEnd() const { return m_selectionEnd; }

protected:
        int m_selectionStart;
        int m_selectionEnd;
};

class __declspec(dllimport) QAccessibleTextInsertEvent : public QAccessibleTextCursorEvent
{
public:
    inline QAccessibleTextInsertEvent(QObject *obj, int position, const QString &text)
        : QAccessibleTextCursorEvent(obj, position + text.length())
        , m_position(position), m_text(text)
    {
        m_type = QAccessible::TextInserted;
    }
    inline QAccessibleTextInsertEvent(QAccessibleInterface *iface, int position, const QString &text)
        : QAccessibleTextCursorEvent(iface, position + text.length())
        , m_position(position), m_text(text)
    {
        m_type = QAccessible::TextInserted;
    }

    QString textInserted() const {
        return m_text;
    }
    int changePosition() const {
        return m_position;
    }

protected:
    int m_position;
    QString m_text;
};

class __declspec(dllimport) QAccessibleTextRemoveEvent : public QAccessibleTextCursorEvent
{
public:
    inline QAccessibleTextRemoveEvent(QObject *obj, int position, const QString &text)
        : QAccessibleTextCursorEvent(obj, position)
        , m_position(position), m_text(text)
    {
        m_type = QAccessible::TextRemoved;
    }
    inline QAccessibleTextRemoveEvent(QAccessibleInterface *iface, int position, const QString &text)
        : QAccessibleTextCursorEvent(iface, position)
        , m_position(position), m_text(text)
    {
        m_type = QAccessible::TextRemoved;
    }

    QString textRemoved() const {
        return m_text;
    }
    int changePosition() const {
        return m_position;
    }

protected:
    int m_position;
    QString m_text;
};

class __declspec(dllimport) QAccessibleTextUpdateEvent : public QAccessibleTextCursorEvent
{
public:
    inline QAccessibleTextUpdateEvent(QObject *obj, int position, const QString &oldText, const QString &text)
        : QAccessibleTextCursorEvent(obj, position + text.length())
        , m_position(position), m_oldText(oldText), m_text(text)
    {
        m_type = QAccessible::TextUpdated;
    }
    inline QAccessibleTextUpdateEvent(QAccessibleInterface *iface, int position, const QString &oldText, const QString &text)
        : QAccessibleTextCursorEvent(iface, position + text.length())
        , m_position(position), m_oldText(oldText), m_text(text)
    {
        m_type = QAccessible::TextUpdated;
    }
    QString textRemoved() const {
        return m_oldText;
    }
    QString textInserted() const {
        return m_text;
    }
    int changePosition() const {
        return m_position;
    }

protected:
    int m_position;
    QString m_oldText;
    QString m_text;
};

class __declspec(dllimport) QAccessibleValueChangeEvent : public QAccessibleEvent
{
public:
    inline QAccessibleValueChangeEvent(QObject *obj, const QVariant &val)
        : QAccessibleEvent(obj, QAccessible::InvalidEvent)
      , m_value(val)
    {
        m_type = QAccessible::ValueChanged;
    }
    inline QAccessibleValueChangeEvent(QAccessibleInterface *iface, const QVariant &val)
        : QAccessibleEvent(iface, QAccessible::InvalidEvent)
      , m_value(val)
    {
        m_type = QAccessible::ValueChanged;
    }

    void setValue(const QVariant & val) { m_value= val; }
    QVariant value() const { return m_value; }

protected:
    QVariant m_value;
};

class __declspec(dllimport) QAccessibleTableModelChangeEvent : public QAccessibleEvent
{
public:
    enum ModelChangeType {
        ModelReset,
        DataChanged,
        RowsInserted,
        ColumnsInserted,
        RowsRemoved,
        ColumnsRemoved
    };

    inline QAccessibleTableModelChangeEvent(QObject *obj, ModelChangeType changeType)
        : QAccessibleEvent(obj, QAccessible::InvalidEvent)
        , m_modelChangeType(changeType)
        , m_firstRow(-1), m_firstColumn(-1), m_lastRow(-1), m_lastColumn(-1)
    {
        m_type = QAccessible::TableModelChanged;
    }
    inline QAccessibleTableModelChangeEvent(QAccessibleInterface *iface, ModelChangeType changeType)
        : QAccessibleEvent(iface, QAccessible::InvalidEvent)
        , m_modelChangeType(changeType)
        , m_firstRow(-1), m_firstColumn(-1), m_lastRow(-1), m_lastColumn(-1)
    {
        m_type = QAccessible::TableModelChanged;
    }

    void setModelChangeType(ModelChangeType changeType) { m_modelChangeType = changeType; }
    ModelChangeType modelChangeType() const { return m_modelChangeType; }

    void setFirstRow(int row) { m_firstRow = row; }
    void setFirstColumn(int col) { m_firstColumn = col; }
    void setLastRow(int row) { m_lastRow = row; }
    void setLastColumn(int col) { m_lastColumn = col; }
    int firstRow() const { return m_firstRow; }
    int firstColumn() const { return m_firstColumn; }
    int lastRow() const { return m_lastRow; }
    int lastColumn() const { return m_lastColumn; }

protected:
    ModelChangeType m_modelChangeType;
    int m_firstRow;
    int m_firstColumn;
    int m_lastRow;
    int m_lastColumn;
};


template <> inline const char *qobject_interface_iid<QAccessibleInterface *>() { return "org.qt-project.Qt.QAccessibleInterface"; } template <> inline QAccessibleInterface *qobject_cast<QAccessibleInterface *>(QObject *object) { return reinterpret_cast<QAccessibleInterface *>((object ? object->qt_metacast("org.qt-project.Qt.QAccessibleInterface") : 0)); } template <> inline QAccessibleInterface *qobject_cast<QAccessibleInterface *>(const QObject *object) { return reinterpret_cast<QAccessibleInterface *>((object ? const_cast<QObject *>(object)->qt_metacast("org.qt-project.Qt.QAccessibleInterface") : 0)); }

__declspec(dllimport) const char *qAccessibleRoleString(QAccessible::Role role);
__declspec(dllimport) const char *qAccessibleEventString(QAccessible::Event event);


__declspec(dllimport) QDebug operator<<(QDebug d, const QAccessibleInterface *iface);
__declspec(dllimport) QDebug operator<<(QDebug d, const QAccessibleEvent &ev);
#line 4 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessiblebridge.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessiblebridge.h"
class QAccessibleInterface;
class QAccessibleEvent;

class QAccessibleBridge
{
public:
    virtual ~QAccessibleBridge() {}
    virtual void setRootObject(QAccessibleInterface *) = 0;
    virtual void notifyAccessibilityUpdate(QAccessibleEvent *event) = 0;
};



class __declspec(dllimport) QAccessibleBridgePlugin : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    explicit QAccessibleBridgePlugin(QObject *parent = 0);
    ~QAccessibleBridgePlugin();

    virtual QAccessibleBridge *create(const QString &key) = 0;
};
#line 5 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessibleobject.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessibleobject.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessibleobject.h"







class QAccessibleObjectPrivate;
class QObject;

class __declspec(dllimport) QAccessibleObject : public QAccessibleInterface
{
public:
    explicit QAccessibleObject(QObject *object);

    bool isValid() const override;
    QObject *object() const override;


    QRect rect() const override;
    void setText(QAccessible::Text t, const QString &text) override;
    QAccessibleInterface *childAt(int x, int y) const override;

protected:
    virtual ~QAccessibleObject();

private:
    QAccessibleObjectPrivate *d;
    QAccessibleObject(const QAccessibleObject &) = delete; QAccessibleObject &operator=(const QAccessibleObject &) = delete;
};

class __declspec(dllimport) QAccessibleApplication : public QAccessibleObject
{
public:
    QAccessibleApplication();

    QWindow *window() const override;

    int childCount() const override;
    int indexOfChild(const QAccessibleInterface*) const override;
    QAccessibleInterface *focusChild() const override;


    QAccessibleInterface *parent() const override;
    QAccessibleInterface *child(int index) const override;


    QString text(QAccessible::Text t) const override;
    QAccessible::Role role() const override;
    QAccessible::State state() const override;
};
#line 6 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessibleplugin.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessibleplugin.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessible.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qaccessibleplugin.h"








class QStringList;
class QAccessibleInterface;



class QAccessiblePluginPrivate;

class __declspec(dllimport) QAccessiblePlugin : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    explicit QAccessiblePlugin(QObject *parent = 0);
    ~QAccessiblePlugin();

    virtual QAccessibleInterface *create(const QString &key, QObject *object) = 0;
};
#line 7 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qbitmap.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qbitmap.h"
class QVariant;

class __declspec(dllimport) QBitmap : public QPixmap
{
public:
    QBitmap();
    QBitmap(const QPixmap &);
    QBitmap(int w, int h);
    explicit QBitmap(const QSize &);
    explicit QBitmap(const QString &fileName, const char *format=0);
    ~QBitmap();

    QBitmap &operator=(const QPixmap &);
    inline void swap(QBitmap &other) { QPixmap::swap(other); }
    operator QVariant() const;

    inline void clear() { fill(Qt::color0); }

    static QBitmap fromImage(const QImage &image, Qt::ImageConversionFlags flags = Qt::AutoColor);
    static QBitmap fromData(const QSize &size, const uchar *bits,
                            QImage::Format monoFormat = QImage::Format_MonoLSB);

    QBitmap transformed(const QMatrix &) const;
    QBitmap transformed(const QTransform &matrix) const;

    typedef QExplicitlySharedDataPointer<QPlatformPixmap> DataPtr;
};
template<> class QTypeInfo<QBitmap > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QBitmap)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QBitmap >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QBitmap) }; static inline const char *name() { return "QBitmap"; } }; template <> inline void qSwap<QBitmap>(QBitmap &value1, QBitmap &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QBitmap >(::QBitmap &value1, ::QBitmap &value2) { value1.swap(value2); } }
#line 8 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qiconengine.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qiconengine.h"
class __declspec(dllimport) QIconEngine
{
public:
    virtual ~QIconEngine();
    virtual void paint(QPainter *painter, const QRect &rect, QIcon::Mode mode, QIcon::State state) = 0;
    virtual QSize actualSize(const QSize &size, QIcon::Mode mode, QIcon::State state);
    virtual QPixmap pixmap(const QSize &size, QIcon::Mode mode, QIcon::State state);

    virtual void addPixmap(const QPixmap &pixmap, QIcon::Mode mode, QIcon::State state);
    virtual void addFile(const QString &fileName, const QSize &size, QIcon::Mode mode, QIcon::State state);

    virtual QString key() const;
    virtual QIconEngine *clone() const = 0;
    virtual bool read(QDataStream &in);
    virtual bool write(QDataStream &out) const;

    enum IconEngineHook { AvailableSizesHook = 1, IconNameHook };

    struct AvailableSizesArgument
    {
        QIcon::Mode mode;
        QIcon::State state;
        QList<QSize> sizes;
    };

    virtual QList<QSize> availableSizes(QIcon::Mode mode = QIcon::Normal,
                                    QIcon::State state = QIcon::Off) const;

    virtual QString iconName() const;

    virtual void virtual_hook(int id, void *data);
};
#line 10 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qiconengineplugin.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qiconengineplugin.h"
class QIconEngine;



class __declspec(dllimport) QIconEnginePlugin : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    QIconEnginePlugin(QObject *parent = 0);
    ~QIconEnginePlugin();

    virtual QIconEngine *create(const QString &filename = QString()) = 0;
};
#line 11 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qimageiohandler.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qimageiohandler.h"
class QImage;
class QRect;
class QSize;
class QVariant;

class QImageIOHandlerPrivate;
class __declspec(dllimport) QImageIOHandler
{
    inline QImageIOHandlerPrivate* d_func() { return reinterpret_cast<QImageIOHandlerPrivate *>(qGetPtrHelper(d_ptr)); } inline const QImageIOHandlerPrivate* d_func() const { return reinterpret_cast<const QImageIOHandlerPrivate *>(qGetPtrHelper(d_ptr)); } friend class QImageIOHandlerPrivate;
public:
    QImageIOHandler();
    virtual ~QImageIOHandler();

    void setDevice(QIODevice *device);
    QIODevice *device() const;

    void setFormat(const QByteArray &format);
    void setFormat(const QByteArray &format) const;
    QByteArray format() const;

    virtual QByteArray name() const;

    virtual bool canRead() const = 0;
    virtual bool read(QImage *image) = 0;
    virtual bool write(const QImage &image);

    enum ImageOption {
        Size,
        ClipRect,
        Description,
        ScaledClipRect,
        ScaledSize,
        CompressionRatio,
        Gamma,
        Quality,
        Name,
        SubType,
        IncrementalReading,
        Endianness,
        Animation,
        BackgroundColor,
        ImageFormat
    };
    virtual QVariant option(ImageOption option) const;
    virtual void setOption(ImageOption option, const QVariant &value);
    virtual bool supportsOption(ImageOption option) const;


    virtual bool jumpToNextImage();
    virtual bool jumpToImage(int imageNumber);
    virtual int loopCount() const;
    virtual int imageCount() const;
    virtual int nextImageDelay() const;
    virtual int currentImageNumber() const;
    virtual QRect currentImageRect() const;

protected:
    QImageIOHandler(QImageIOHandlerPrivate &dd);
    QScopedPointer<QImageIOHandlerPrivate> d_ptr;
private:
    QImageIOHandler(const QImageIOHandler &) = delete; QImageIOHandler &operator=(const QImageIOHandler &) = delete;
};





class __declspec(dllimport) QImageIOPlugin : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    explicit QImageIOPlugin(QObject *parent = 0);
    virtual ~QImageIOPlugin();

    enum Capability {
        CanRead = 0x1,
        CanWrite = 0x2,
        CanReadIncremental = 0x4
    };
    typedef QFlags<Capability> Capabilities;

    virtual Capabilities capabilities(QIODevice *device, const QByteArray &format) const = 0;
    virtual QImageIOHandler *create(QIODevice *device, const QByteArray &format = QByteArray()) const = 0;
};

 inline QFlags<QImageIOPlugin::Capabilities::enum_type> operator|(QImageIOPlugin::Capabilities::enum_type f1, QImageIOPlugin::Capabilities::enum_type f2) { return QFlags<QImageIOPlugin::Capabilities::enum_type>(f1) | f2; } inline QFlags<QImageIOPlugin::Capabilities::enum_type> operator|(QImageIOPlugin::Capabilities::enum_type f1, QFlags<QImageIOPlugin::Capabilities::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QImageIOPlugin::Capabilities::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }
#line 13 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qimagereader.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qimagereader.h"
class QColor;
class QIODevice;
class QRect;
class QSize;
class QStringList;

class QImageReaderPrivate;
class __declspec(dllimport) QImageReader
{
public:
    enum ImageReaderError {
        UnknownError,
        FileNotFoundError,
        DeviceError,
        UnsupportedFormatError,
        InvalidDataError
    };

    QImageReader();
    explicit QImageReader(QIODevice *device, const QByteArray &format = QByteArray());
    explicit QImageReader(const QString &fileName, const QByteArray &format = QByteArray());
    ~QImageReader();

    void setFormat(const QByteArray &format);
    QByteArray format() const;

    void setAutoDetectImageFormat(bool enabled);
    bool autoDetectImageFormat() const;

    void setDecideFormatFromContent(bool ignored);
    bool decideFormatFromContent() const;

    void setDevice(QIODevice *device);
    QIODevice *device() const;

    void setFileName(const QString &fileName);
    QString fileName() const;

    QSize size() const;

    QImage::Format imageFormat() const;

    QStringList textKeys() const;
    QString text(const QString &key) const;

    void setClipRect(const QRect &rect);
    QRect clipRect() const;

    void setScaledSize(const QSize &size);
    QSize scaledSize() const;

    void setQuality(int quality);
    int quality() const;

    void setScaledClipRect(const QRect &rect);
    QRect scaledClipRect() const;

    void setBackgroundColor(const QColor &color);
    QColor backgroundColor() const;

    bool supportsAnimation() const;

    bool canRead() const;
    QImage read();
    bool read(QImage *image);

    bool jumpToNextImage();
    bool jumpToImage(int imageNumber);
    int loopCount() const;
    int imageCount() const;
    int nextImageDelay() const;
    int currentImageNumber() const;
    QRect currentImageRect() const;

    ImageReaderError error() const;
    QString errorString() const;

    bool supportsOption(QImageIOHandler::ImageOption option) const;

    static QByteArray imageFormat(const QString &fileName);
    static QByteArray imageFormat(QIODevice *device);
    static QList<QByteArray> supportedImageFormats();
    static QList<QByteArray> supportedMimeTypes();

private:
    QImageReader(const QImageReader &) = delete; QImageReader &operator=(const QImageReader &) = delete;
    QImageReaderPrivate *d;
};
#line 14 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qimagewriter.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qimagewriter.h"
class QIODevice;
class QImage;

class QImageWriterPrivate;
class __declspec(dllimport) QImageWriter
{
public:
    enum ImageWriterError {
        UnknownError,
        DeviceError,
        UnsupportedFormatError
    };

    QImageWriter();
    explicit QImageWriter(QIODevice *device, const QByteArray &format);
    explicit QImageWriter(const QString &fileName, const QByteArray &format = QByteArray());
    ~QImageWriter();

    void setFormat(const QByteArray &format);
    QByteArray format() const;

    void setDevice(QIODevice *device);
    QIODevice *device() const;

    void setFileName(const QString &fileName);
    QString fileName() const;

    void setQuality(int quality);
    int quality() const;

    void setCompression(int compression);
    int compression() const;

    void setGamma(float gamma);
    float gamma() const;


    void setDescription(const QString &description);
    QString description() const;

    void setText(const QString &key, const QString &text);

    bool canWrite() const;
    bool write(const QImage &image);

    ImageWriterError error() const;
    QString errorString() const;

    bool supportsOption(QImageIOHandler::ImageOption option) const;

    static QList<QByteArray> supportedImageFormats();
    static QList<QByteArray> supportedMimeTypes();

private:
    QImageWriter(const QImageWriter &) = delete; QImageWriter &operator=(const QImageWriter &) = delete;
    QImageWriterPrivate *d;
};
#line 15 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qmovie.h"
#line 56 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qmovie.h"
class QByteArray;
class QColor;
class QIODevice;
class QImage;
class QPixmap;
class QRect;
class QSize;

class QMoviePrivate;
class __declspec(dllimport) QMovie : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QMoviePrivate* d_func() { return reinterpret_cast<QMoviePrivate *>(qGetPtrHelper(d_ptr)); } inline const QMoviePrivate* d_func() const { return reinterpret_cast<const QMoviePrivate *>(qGetPtrHelper(d_ptr)); } friend class QMoviePrivate;



public:
    enum MovieState {
        NotRunning,
        Paused,
        Running
    };
    enum CacheMode {
        CacheNone,
        CacheAll
    };

    explicit QMovie(QObject *parent = 0);
    explicit QMovie(QIODevice *device, const QByteArray &format = QByteArray(), QObject *parent = 0);
    explicit QMovie(const QString &fileName, const QByteArray &format = QByteArray(), QObject *parent = 0);
    ~QMovie();

    static QList<QByteArray> supportedFormats();

    void setDevice(QIODevice *device);
    QIODevice *device() const;

    void setFileName(const QString &fileName);
    QString fileName() const;

    void setFormat(const QByteArray &format);
    QByteArray format() const;

    void setBackgroundColor(const QColor &color);
    QColor backgroundColor() const;

    MovieState state() const;

    QRect frameRect() const;
    QImage currentImage() const;
    QPixmap currentPixmap() const;

    bool isValid() const;

    bool jumpToFrame(int frameNumber);
    int loopCount() const;
    int frameCount() const;
    int nextFrameDelay() const;
    int currentFrameNumber() const;

    int speed() const;

    QSize scaledSize();
    void setScaledSize(const QSize &size);

    CacheMode cacheMode() const;
    void setCacheMode(CacheMode mode);

public:
    void started();
    void resized(const QSize &size);
    void updated(const QRect &rect);
    void stateChanged(QMovie::MovieState state);
    void error(QImageReader::ImageReaderError error);
    void finished();
    void frameChanged(int frameNumber);

public :
    void start();
    bool jumpToNextFrame();
    void setPaused(bool paused);
    void stop();
    void setSpeed(int percentSpeed);

private:
    QMovie(const QMovie &) = delete; QMovie &operator=(const QMovie &) = delete;

};
#line 16 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpicture.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpicture.h"
class QPicturePrivate;
class __declspec(dllimport) QPicture : public QPaintDevice
{
    inline QPicturePrivate* d_func() { return reinterpret_cast<QPicturePrivate *>(qGetPtrHelper(d_ptr)); } inline const QPicturePrivate* d_func() const { return reinterpret_cast<const QPicturePrivate *>(qGetPtrHelper(d_ptr)); } friend class QPicturePrivate;
public:
    explicit QPicture(int formatVersion = -1);
    QPicture(const QPicture &);
    ~QPicture();

    bool isNull() const;

    int devType() const;
    uint size() const;
    const char* data() const;
    virtual void setData(const char* data, uint size);

    bool play(QPainter *p);

    bool load(QIODevice *dev, const char *format = 0);
    bool load(const QString &fileName, const char *format = 0);
    bool save(QIODevice *dev, const char *format = 0);
    bool save(const QString &fileName, const char *format = 0);

    QRect boundingRect() const;
    void setBoundingRect(const QRect &r);

    QPicture& operator=(const QPicture &p);

    inline QPicture &operator=(QPicture &&other)
    { qSwap(d_ptr, other.d_ptr); return *this; }

    inline void swap(QPicture &other) { d_ptr.swap(other.d_ptr); }
    void detach();
    bool isDetached() const;

    friend __declspec(dllimport) QDataStream &operator<<(QDataStream &in, const QPicture &p);
    friend __declspec(dllimport) QDataStream &operator>>(QDataStream &in, QPicture &p);

    static const char* pictureFormat(const QString &fileName);
    static QList<QByteArray> inputFormats();
    static QList<QByteArray> outputFormats();
    static QStringList inputFormatList();
    static QStringList outputFormatList();

    QPaintEngine *paintEngine() const;

protected:
    QPicture(QPicturePrivate &data);

    int metric(PaintDeviceMetric m) const;

private:
    bool exec(QPainter *p, QDataStream &ds, int i);

    QExplicitlySharedDataPointer<QPicturePrivate> d_ptr;
    friend class QPicturePaintEngine;
    friend class QAlphaPaintEngine;
    friend class QPreviewPaintEngine;

public:
    typedef QExplicitlySharedDataPointer<QPicturePrivate> DataPtr;
    inline DataPtr &data_ptr() { return d_ptr; }
};

template<> class QTypeInfo<QPicture > { public: enum { isComplex = (((Q_MOVABLE_TYPE) & Q_PRIMITIVE_TYPE) == 0), isStatic = (((Q_MOVABLE_TYPE) & (Q_MOVABLE_TYPE | Q_PRIMITIVE_TYPE)) == 0), isLarge = (sizeof(QPicture)>sizeof(void*)), isPointer = false, isIntegral = QtPrivate::is_integral< QPicture >::value, isDummy = (((Q_MOVABLE_TYPE) & Q_DUMMY_TYPE) != 0), sizeOf = sizeof(QPicture) }; static inline const char *name() { return "QPicture"; } }; template <> inline void qSwap<QPicture>(QPicture &value1, QPicture &value2) { value1.swap(value2); } namespace std { template<> inline void swap< ::QPicture >(::QPicture &value1, ::QPicture &value2) { value1.swap(value2); } }



class QIODevice;
class QPictureIO;
typedef void (*picture_io_handler)(QPictureIO *);

struct QPictureIOData;

class __declspec(dllimport) QPictureIO
{
public:
    QPictureIO();
    QPictureIO(QIODevice *ioDevice, const char *format);
    QPictureIO(const QString &fileName, const char *format);
    ~QPictureIO();

    const QPicture &picture() const;
    int status() const;
    const char *format() const;
    QIODevice *ioDevice() const;
    QString fileName() const;
    int quality() const;
    QString description() const;
    const char *parameters() const;
    float gamma() const;

    void setPicture(const QPicture &);
    void setStatus(int);
    void setFormat(const char *);
    void setIODevice(QIODevice *);
    void setFileName(const QString &);
    void setQuality(int);
    void setDescription(const QString &);
    void setParameters(const char *);
    void setGamma(float);

    bool read();
    bool write();

    static QByteArray pictureFormat(const QString &fileName);
    static QByteArray pictureFormat(QIODevice *);
    static QList<QByteArray> inputFormats();
    static QList<QByteArray> outputFormats();

    static void defineIOHandler(const char *format,
                                const char *header,
                                const char *flags,
                                picture_io_handler read_picture,
                                picture_io_handler write_picture);

private:
    QPictureIO(const QPictureIO &) = delete; QPictureIO &operator=(const QPictureIO &) = delete;

    void init();

    QPictureIOData *d;
};
#line 186 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpicture.h"
__declspec(dllimport) QDataStream &operator<<(QDataStream &, const QPicture &);
__declspec(dllimport) QDataStream &operator>>(QDataStream &, QPicture &);
#line 17 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpictureformatplugin.h"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpictureformatplugin.h"
class QPicture;
class QImage;
class QString;
class QStringList;



class __declspec(dllimport) QPictureFormatPlugin : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    explicit QPictureFormatPlugin(QObject *parent = 0);
    ~QPictureFormatPlugin();

    virtual bool loadPicture(const QString &format, const QString &filename, QPicture *pic);
    virtual bool savePicture(const QString &format, const QString &filename, const QPicture &pic);
    virtual bool installIOHandler(const QString &format) = 0;

};
#line 18 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpixmapcache.h"
#line 54 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qpixmapcache.h"
class __declspec(dllimport) QPixmapCache
{
public:
    class KeyData;
    class __declspec(dllimport) Key
    {
    public:
        Key();
        Key(const Key &other);
        ~Key();
        bool operator ==(const Key &key) const;
        inline bool operator !=(const Key &key) const
        { return !operator==(key); }
        Key &operator =(const Key &other);

    private:
        KeyData *d;
        friend class QPMCache;
        friend class QPixmapCache;
    };

    static int cacheLimit();
    static void setCacheLimit(int);
    static QPixmap *find(const QString &key);
    static bool find(const QString &key, QPixmap &pixmap);
    static bool find(const QString &key, QPixmap *pixmap);
    static bool find(const Key &key, QPixmap *pixmap);
    static bool insert(const QString &key, const QPixmap &pixmap);
    static Key insert(const QPixmap &pixmap);
    static bool replace(const Key &key, const QPixmap &pixmap);
    static void remove(const QString &key);
    static void remove(const Key &key);
    static void clear();






};
#line 20 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qstandarditemmodel.h"
#line 58 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qstandarditemmodel.h"
template <class T> class QList;

class QStandardItemModel;

class QStandardItemPrivate;
class __declspec(dllimport) QStandardItem
{
public:
    QStandardItem();
    explicit QStandardItem(const QString &text);
    QStandardItem(const QIcon &icon, const QString &text);
    explicit QStandardItem(int rows, int columns = 1);
    virtual ~QStandardItem();

    virtual QVariant data(int role = Qt::UserRole + 1) const;
    virtual void setData(const QVariant &value, int role = Qt::UserRole + 1);

    inline QString text() const {
        return qvariant_cast<QString>(data(Qt::DisplayRole));
    }
    inline void setText(const QString &text);

    inline QIcon icon() const {
        return qvariant_cast<QIcon>(data(Qt::DecorationRole));
    }
    inline void setIcon(const QIcon &icon);


    inline QString toolTip() const {
        return qvariant_cast<QString>(data(Qt::ToolTipRole));
    }
    inline void setToolTip(const QString &toolTip);



    inline QString statusTip() const {
        return qvariant_cast<QString>(data(Qt::StatusTipRole));
    }
    inline void setStatusTip(const QString &statusTip);



    inline QString whatsThis() const {
        return qvariant_cast<QString>(data(Qt::WhatsThisRole));
    }
    inline void setWhatsThis(const QString &whatsThis);


    inline QSize sizeHint() const {
        return qvariant_cast<QSize>(data(Qt::SizeHintRole));
    }
    inline void setSizeHint(const QSize &sizeHint);

    inline QFont font() const {
        return qvariant_cast<QFont>(data(Qt::FontRole));
    }
    inline void setFont(const QFont &font);

    inline Qt::Alignment textAlignment() const {
        return Qt::Alignment(qvariant_cast<int>(data(Qt::TextAlignmentRole)));
    }
    inline void setTextAlignment(Qt::Alignment textAlignment);

    inline QBrush background() const {
        return qvariant_cast<QBrush>(data(Qt::BackgroundRole));
    }
    inline void setBackground(const QBrush &brush);

    inline QBrush foreground() const {
        return qvariant_cast<QBrush>(data(Qt::ForegroundRole));
    }
    inline void setForeground(const QBrush &brush);

    inline Qt::CheckState checkState() const {
        return Qt::CheckState(qvariant_cast<int>(data(Qt::CheckStateRole)));
    }
    inline void setCheckState(Qt::CheckState checkState);

    inline QString accessibleText() const {
        return qvariant_cast<QString>(data(Qt::AccessibleTextRole));
    }
    inline void setAccessibleText(const QString &accessibleText);

    inline QString accessibleDescription() const {
        return qvariant_cast<QString>(data(Qt::AccessibleDescriptionRole));
    }
    inline void setAccessibleDescription(const QString &accessibleDescription);

    Qt::ItemFlags flags() const;
    void setFlags(Qt::ItemFlags flags);

    inline bool isEnabled() const {
        return (flags() & Qt::ItemIsEnabled) != 0;
    }
    void setEnabled(bool enabled);

    inline bool isEditable() const {
        return (flags() & Qt::ItemIsEditable) != 0;
    }
    void setEditable(bool editable);

    inline bool isSelectable() const {
        return (flags() & Qt::ItemIsSelectable) != 0;
    }
    void setSelectable(bool selectable);

    inline bool isCheckable() const {
        return (flags() & Qt::ItemIsUserCheckable) != 0;
    }
    void setCheckable(bool checkable);

    inline bool isTristate() const {
        return (flags() & Qt::ItemIsTristate) != 0;
    }
    void setTristate(bool tristate);


    inline bool isDragEnabled() const {
        return (flags() & Qt::ItemIsDragEnabled) != 0;
    }
    void setDragEnabled(bool dragEnabled);

    inline bool isDropEnabled() const {
        return (flags() & Qt::ItemIsDropEnabled) != 0;
    }
    void setDropEnabled(bool dropEnabled);


    QStandardItem *parent() const;
    int row() const;
    int column() const;
    QModelIndex index() const;
    QStandardItemModel *model() const;

    int rowCount() const;
    void setRowCount(int rows);
    int columnCount() const;
    void setColumnCount(int columns);

    bool hasChildren() const;
    QStandardItem *child(int row, int column = 0) const;
    void setChild(int row, int column, QStandardItem *item);
    inline void setChild(int row, QStandardItem *item);

    void insertRow(int row, const QList<QStandardItem*> &items);
    void insertColumn(int column, const QList<QStandardItem*> &items);
    void insertRows(int row, const QList<QStandardItem*> &items);
    void insertRows(int row, int count);
    void insertColumns(int column, int count);

    void removeRow(int row);
    void removeColumn(int column);
    void removeRows(int row, int count);
    void removeColumns(int column, int count);

    inline void appendRow(const QList<QStandardItem*> &items);
    inline void appendRows(const QList<QStandardItem*> &items);
    inline void appendColumn(const QList<QStandardItem*> &items);
    inline void insertRow(int row, QStandardItem *item);
    inline void appendRow(QStandardItem *item);

    QStandardItem *takeChild(int row, int column = 0);
    QList<QStandardItem*> takeRow(int row);
    QList<QStandardItem*> takeColumn(int column);

    void sortChildren(int column, Qt::SortOrder order = Qt::AscendingOrder);

    virtual QStandardItem *clone() const;

    enum ItemType { Type = 0, UserType = 1000 };
    virtual int type() const;


    virtual void read(QDataStream &in);
    virtual void write(QDataStream &out) const;

    virtual bool operator<(const QStandardItem &other) const;

protected:
    QStandardItem(const QStandardItem &other);
    QStandardItem(QStandardItemPrivate &dd);
    QStandardItem &operator=(const QStandardItem &other);
    QScopedPointer<QStandardItemPrivate> d_ptr;

    void emitDataChanged();

private:
    inline QStandardItemPrivate* d_func() { return reinterpret_cast<QStandardItemPrivate *>(qGetPtrHelper(d_ptr)); } inline const QStandardItemPrivate* d_func() const { return reinterpret_cast<const QStandardItemPrivate *>(qGetPtrHelper(d_ptr)); } friend class QStandardItemPrivate;
    friend class QStandardItemModelPrivate;
    friend class QStandardItemModel;
};

inline void QStandardItem::setText(const QString &atext)
{ setData(atext, Qt::DisplayRole); }

inline void QStandardItem::setIcon(const QIcon &aicon)
{ setData(aicon, Qt::DecorationRole); }


inline void QStandardItem::setToolTip(const QString &atoolTip)
{ setData(atoolTip, Qt::ToolTipRole); }



inline void QStandardItem::setStatusTip(const QString &astatusTip)
{ setData(astatusTip, Qt::StatusTipRole); }



inline void QStandardItem::setWhatsThis(const QString &awhatsThis)
{ setData(awhatsThis, Qt::WhatsThisRole); }


inline void QStandardItem::setSizeHint(const QSize &asizeHint)
{ setData(asizeHint, Qt::SizeHintRole); }

inline void QStandardItem::setFont(const QFont &afont)
{ setData(afont, Qt::FontRole); }

inline void QStandardItem::setTextAlignment(Qt::Alignment atextAlignment)
{ setData(int(atextAlignment), Qt::TextAlignmentRole); }

inline void QStandardItem::setBackground(const QBrush &abrush)
{ setData(abrush, Qt::BackgroundRole); }

inline void QStandardItem::setForeground(const QBrush &abrush)
{ setData(abrush, Qt::ForegroundRole); }

inline void QStandardItem::setCheckState(Qt::CheckState acheckState)
{ setData(acheckState, Qt::CheckStateRole); }

inline void QStandardItem::setAccessibleText(const QString &aaccessibleText)
{ setData(aaccessibleText, Qt::AccessibleTextRole); }

inline void QStandardItem::setAccessibleDescription(const QString &aaccessibleDescription)
{ setData(aaccessibleDescription, Qt::AccessibleDescriptionRole); }

inline void QStandardItem::setChild(int arow, QStandardItem *aitem)
{ setChild(arow, 0, aitem); }

inline void QStandardItem::appendRow(const QList<QStandardItem*> &aitems)
{ insertRow(rowCount(), aitems); }

inline void QStandardItem::appendRows(const QList<QStandardItem*> &aitems)
{ insertRows(rowCount(), aitems); }

inline void QStandardItem::appendColumn(const QList<QStandardItem*> &aitems)
{ insertColumn(columnCount(), aitems); }

inline void QStandardItem::insertRow(int arow, QStandardItem *aitem)
{ insertRow(arow, QList<QStandardItem*>() << aitem); }

inline void QStandardItem::appendRow(QStandardItem *aitem)
{ insertRow(rowCount(), aitem); }

class QStandardItemModelPrivate;

class __declspec(dllimport) QStandardItemModel : public QAbstractItemModel
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};


public:
    explicit QStandardItemModel(QObject *parent = 0);
    QStandardItemModel(int rows, int columns, QObject *parent = 0);
    ~QStandardItemModel();

    void setItemRoleNames(const QHash<int,QByteArray> &roleNames);

    QModelIndex index(int row, int column, const QModelIndex &parent = QModelIndex()) const;
    QModelIndex parent(const QModelIndex &child) const;

    int rowCount(const QModelIndex &parent = QModelIndex()) const;
    int columnCount(const QModelIndex &parent = QModelIndex()) const;
    bool hasChildren(const QModelIndex &parent = QModelIndex()) const;

    QModelIndex sibling(int row, int column, const QModelIndex &idx) const;

    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
    bool setData(const QModelIndex &index, const QVariant &value, int role = Qt::EditRole);

    QVariant headerData(int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const;
    bool setHeaderData(int section, Qt::Orientation orientation, const QVariant &value,
                       int role = Qt::EditRole);

    bool insertRows(int row, int count, const QModelIndex &parent = QModelIndex());
    bool insertColumns(int column, int count, const QModelIndex &parent = QModelIndex());
    bool removeRows(int row, int count, const QModelIndex &parent = QModelIndex());
    bool removeColumns(int column, int count, const QModelIndex &parent = QModelIndex());

    Qt::ItemFlags flags(const QModelIndex &index) const;
    Qt::DropActions supportedDropActions() const;

    QMap<int, QVariant> itemData(const QModelIndex &index) const;
    bool setItemData(const QModelIndex &index, const QMap<int, QVariant> &roles);

    void clear();




    using QObject::parent;


    void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);

    QStandardItem *itemFromIndex(const QModelIndex &index) const;
    QModelIndex indexFromItem(const QStandardItem *item) const;

    QStandardItem *item(int row, int column = 0) const;
    void setItem(int row, int column, QStandardItem *item);
    inline void setItem(int row, QStandardItem *item);
    QStandardItem *invisibleRootItem() const;

    QStandardItem *horizontalHeaderItem(int column) const;
    void setHorizontalHeaderItem(int column, QStandardItem *item);
    QStandardItem *verticalHeaderItem(int row) const;
    void setVerticalHeaderItem(int row, QStandardItem *item);

    void setHorizontalHeaderLabels(const QStringList &labels);
    void setVerticalHeaderLabels(const QStringList &labels);

    void setRowCount(int rows);
    void setColumnCount(int columns);

    void appendRow(const QList<QStandardItem*> &items);
    void appendColumn(const QList<QStandardItem*> &items);
    inline void appendRow(QStandardItem *item);

    void insertRow(int row, const QList<QStandardItem*> &items);
    void insertColumn(int column, const QList<QStandardItem*> &items);
    inline void insertRow(int row, QStandardItem *item);

    inline bool insertRow(int row, const QModelIndex &parent = QModelIndex());
    inline bool insertColumn(int column, const QModelIndex &parent = QModelIndex());

    QStandardItem *takeItem(int row, int column = 0);
    QList<QStandardItem*> takeRow(int row);
    QList<QStandardItem*> takeColumn(int column);

    QStandardItem *takeHorizontalHeaderItem(int column);
    QStandardItem *takeVerticalHeaderItem(int row);

    const QStandardItem *itemPrototype() const;
    void setItemPrototype(const QStandardItem *item);

    QList<QStandardItem*> findItems(const QString &text,
                                    Qt::MatchFlags flags = Qt::MatchExactly,
                                    int column = 0) const;

    int sortRole() const;
    void setSortRole(int role);

    QStringList mimeTypes() const;
    QMimeData *mimeData(const QModelIndexList &indexes) const;
    bool dropMimeData (const QMimeData *data, Qt::DropAction action, int row, int column, const QModelIndex &parent);

public:
    void itemChanged(QStandardItem *item);

protected:
    QStandardItemModel(QStandardItemModelPrivate &dd, QObject *parent = 0);

private:
    friend class QStandardItemPrivate;
    friend class QStandardItem;
    QStandardItemModel(const QStandardItemModel &) = delete; QStandardItemModel &operator=(const QStandardItemModel &) = delete;
    inline QStandardItemModelPrivate* d_func() { return reinterpret_cast<QStandardItemModelPrivate *>(qGetPtrHelper(d_ptr)); } inline const QStandardItemModelPrivate* d_func() const { return reinterpret_cast<const QStandardItemModelPrivate *>(qGetPtrHelper(d_ptr)); } friend class QStandardItemModelPrivate;



};

inline void QStandardItemModel::setItem(int arow, QStandardItem *aitem)
{ setItem(arow, 0, aitem); }

inline void QStandardItemModel::appendRow(QStandardItem *aitem)
{ appendRow(QList<QStandardItem*>() << aitem); }

inline void QStandardItemModel::insertRow(int arow, QStandardItem *aitem)
{ insertRow(arow, QList<QStandardItem*>() << aitem); }

inline bool QStandardItemModel::insertRow(int arow, const QModelIndex &aparent)
{ return QAbstractItemModel::insertRow(arow, aparent); }
inline bool QStandardItemModel::insertColumn(int acolumn, const QModelIndex &aparent)
{ return QAbstractItemModel::insertColumn(acolumn, aparent); }


__declspec(dllimport) QDataStream &operator>>(QDataStream &in, QStandardItem &item);
__declspec(dllimport) QDataStream &operator<<(QDataStream &out, const QStandardItem &item);
#line 21 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qclipboard.h"
#line 52 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qclipboard.h"
class QMimeData;
class QImage;
class QPixmap;

class __declspec(dllimport) QClipboard : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
private:
    explicit QClipboard(QObject *parent);
    ~QClipboard();

public:
    enum Mode { Clipboard, Selection, FindBuffer, LastMode = FindBuffer };

    void clear(Mode mode = Clipboard);

    bool supportsSelection() const;
    bool supportsFindBuffer() const;

    bool ownsSelection() const;
    bool ownsClipboard() const;
    bool ownsFindBuffer() const;

    QString text(Mode mode = Clipboard) const;
    QString text(QString& subtype, Mode mode = Clipboard) const;
    void setText(const QString &, Mode mode = Clipboard);

    const QMimeData *mimeData(Mode mode = Clipboard ) const;
    void setMimeData(QMimeData *data, Mode mode = Clipboard);

    QImage image(Mode mode = Clipboard) const;
    QPixmap pixmap(Mode mode = Clipboard) const;
    void setImage(const QImage &, Mode mode = Clipboard);
    void setPixmap(const QPixmap &, Mode mode = Clipboard);

public:
    void changed(QClipboard::Mode mode);
    void selectionChanged();
    void findBufferChanged();
    void dataChanged();

protected:
    friend class QApplication;
    friend class QApplicationPrivate;
    friend class QGuiApplication;
    friend class QBaseApplication;
    friend class QDragManager;
    friend class QPlatformClipboard;

private:
    QClipboard(const QClipboard &) = delete; QClipboard &operator=(const QClipboard &) = delete;

    bool supportsMode(Mode mode) const;
    bool ownsMode(Mode mode) const;
    void emitChanged(Mode mode);
};
#line 22 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qdrag.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qdrag.h"
class QMimeData;
class QDragPrivate;
class QPixmap;
class QPoint;
class QDragManager;


class __declspec(dllimport) QDrag : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QDragPrivate* d_func() { return reinterpret_cast<QDragPrivate *>(qGetPtrHelper(d_ptr)); } inline const QDragPrivate* d_func() const { return reinterpret_cast<const QDragPrivate *>(qGetPtrHelper(d_ptr)); } friend class QDragPrivate;
public:
    explicit QDrag(QObject *dragSource);
    ~QDrag();

    void setMimeData(QMimeData *data);
    QMimeData *mimeData() const;

    void setPixmap(const QPixmap &);
    QPixmap pixmap() const;

    void setHotSpot(const QPoint &hotspot);
    QPoint hotSpot() const;

    QObject *source() const;
    QObject *target() const;

    Qt::DropAction start(Qt::DropActions supportedActions = Qt::CopyAction);
    Qt::DropAction exec(Qt::DropActions supportedActions = Qt::MoveAction);
    Qt::DropAction exec(Qt::DropActions supportedActions, Qt::DropAction defaultAction);

    void setDragCursor(const QPixmap &cursor, Qt::DropAction action);
    QPixmap dragCursor(Qt::DropAction action) const;

    Qt::DropActions supportedActions() const;
    Qt::DropAction defaultAction() const;

public:
    void actionChanged(Qt::DropAction action);
    void targetChanged(QObject *newTarget);

private:
    friend class QDragManager;
    QDrag(const QDrag &) = delete; QDrag &operator=(const QDrag &) = delete;
};
#line 24 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qgenericplugin.h"
#line 55 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qgenericplugin.h"
class __declspec(dllimport) QGenericPlugin : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
public:
    explicit QGenericPlugin(QObject *parent = 0);
    ~QGenericPlugin();

    virtual QObject* create(const QString& name, const QString &spec) = 0;
};
#line 26 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qgenericpluginfactory.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qgenericpluginfactory.h"
class QString;
class QObject;

class __declspec(dllimport) QGenericPluginFactory
{
public:
    static QStringList keys();
    static QObject *create(const QString&, const QString &);
};
#line 27 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qguiapplication.h"
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qguiapplication.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qinputmethod.h"
#line 49 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qinputmethod.h"
class QInputMethodPrivate;
class QWindow;
class QRectF;
class QTransform;
class QInputMethodQueryEvent;

class __declspec(dllimport) QInputMethod : public QObject
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QInputMethodPrivate* d_func() { return reinterpret_cast<QInputMethodPrivate *>(qGetPtrHelper(d_ptr)); } inline const QInputMethodPrivate* d_func() const { return reinterpret_cast<const QInputMethodPrivate *>(qGetPtrHelper(d_ptr)); } friend class QInputMethodPrivate;
#line 67 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qinputmethod.h"
public:
    QTransform inputItemTransform() const;
    void setInputItemTransform(const QTransform &transform);

    QRectF inputItemRectangle() const;
    void setInputItemRectangle(const QRectF &rect);


    QRectF cursorRectangle() const;


    QRectF keyboardRectangle() const;

    enum Action {
        Click,
        ContextMenu
    };

    bool isVisible() const;
    void setVisible(bool visible);

    bool isAnimating() const;

    QLocale locale() const;
    Qt::LayoutDirection inputDirection() const;

    static QVariant queryFocusObject(Qt::InputMethodQuery query, QVariant argument);

public :
    void show();
    void hide();

    void update(Qt::InputMethodQueries queries);
    void reset();
    void commit();

    void invokeAction(Action a, int cursorPosition);

public:
    void cursorRectangleChanged();
    void keyboardRectangleChanged();
    void visibleChanged();
    void animatingChanged();
    void localeChanged();
    void inputDirectionChanged(Qt::LayoutDirection newDirection);

private:
    friend class QGuiApplication;
    friend class QGuiApplicationPrivate;
    friend class QPlatformInputContext;
    QInputMethod();
    ~QInputMethod();
};
#line 47 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qguiapplication.h"








class QSessionManager;
class QGuiApplicationPrivate;
class QPlatformNativeInterface;
class QPlatformIntegration;
class QPalette;
class QScreen;
class QStyleHints;
#line 73 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qguiapplication.h"
class __declspec(dllimport) QGuiApplication : public QCoreApplication
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};






public:



    QGuiApplication(int &argc, char **argv, int = ApplicationFlags);

    virtual ~QGuiApplication();

    static void setApplicationDisplayName(const QString &name);
    static QString applicationDisplayName();

    static QWindowList allWindows();
    static QWindowList topLevelWindows();
    static QWindow *topLevelAt(const QPoint &pos);

    static void setWindowIcon(const QIcon &icon);
    static QIcon windowIcon();

    static QString platformName();

    static QWindow *modalWindow();

    static QWindow *focusWindow();
    static QObject *focusObject();

    static QScreen *primaryScreen();
    static QList<QScreen *> screens();
    qreal devicePixelRatio() const;


    static QCursor *overrideCursor();
    static void setOverrideCursor(const QCursor &);
    static void changeOverrideCursor(const QCursor &);
    static void restoreOverrideCursor();


    static QFont font();
    static void setFont(const QFont &);


    static QClipboard *clipboard();


    static QPalette palette();
    static void setPalette(const QPalette &pal);

    static Qt::KeyboardModifiers keyboardModifiers();
    static Qt::KeyboardModifiers queryKeyboardModifiers();
    static Qt::MouseButtons mouseButtons();

    static void setLayoutDirection(Qt::LayoutDirection direction);
    static Qt::LayoutDirection layoutDirection();

    static inline bool isRightToLeft() { return layoutDirection() == Qt::RightToLeft; }
    static inline bool isLeftToRight() { return layoutDirection() == Qt::LeftToRight; }

    static QStyleHints *styleHints();
    static void setDesktopSettingsAware(bool on);
    static bool desktopSettingsAware();

    static QInputMethod *inputMethod();

    static QPlatformNativeInterface *platformNativeInterface();

    static void setQuitOnLastWindowClosed(bool quit);
    static bool quitOnLastWindowClosed();

    static Qt::ApplicationState applicationState();

    static int exec();
    bool notify(QObject *, QEvent *);



    bool isSessionRestored() const;
    QString sessionId() const;
    QString sessionKey() const;
    bool isSavingSession() const;


    static void sync();
public:
    void fontDatabaseChanged();
    void screenAdded(QScreen *screen);
    void lastWindowClosed();
    void focusObjectChanged(QObject *focusObject);
    void focusWindowChanged(QWindow *focusWindow);
    void applicationStateChanged(Qt::ApplicationState state);

    void commitDataRequest(QSessionManager &sessionManager);
    void saveStateRequest(QSessionManager &sessionManager);


protected:
    bool event(QEvent *);
    bool compressEvent(QEvent *, QObject *receiver, QPostEventList *);

    QGuiApplication(QGuiApplicationPrivate &p);

private:
    QGuiApplication(const QGuiApplication &) = delete; QGuiApplication &operator=(const QGuiApplication &) = delete;
    inline QGuiApplicationPrivate* d_func() { return reinterpret_cast<QGuiApplicationPrivate *>(qGetPtrHelper(d_ptr)); } inline const QGuiApplicationPrivate* d_func() const { return reinterpret_cast<const QGuiApplicationPrivate *>(qGetPtrHelper(d_ptr)); } friend class QGuiApplicationPrivate;




    friend class QGestureManager;

    friend class QFontDatabasePrivate;
    friend class QPlatformIntegration;

    friend class QPlatformSessionManager;

};
#line 28 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"



#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qoffscreensurface.h"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qoffscreensurface.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QObject"
#line 45 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qoffscreensurface.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qsurface.h"
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qsurface.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qsurfaceformat.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qsurfaceformat.h"
class QOpenGLContext;
class QSurfaceFormatPrivate;

class __declspec(dllimport) QSurfaceFormat
{
public:
    enum FormatOption {
        StereoBuffers = 0x0001,
        DebugContext = 0x0002,
        DeprecatedFunctions = 0x0004
    };
    typedef QFlags<FormatOption> FormatOptions;

    enum SwapBehavior {
        DefaultSwapBehavior,
        SingleBuffer,
        DoubleBuffer,
        TripleBuffer
    };

    enum RenderableType {
        DefaultRenderableType = 0x0,
        OpenGL = 0x1,
        OpenGLES = 0x2,
        OpenVG = 0x4
    };

    enum OpenGLContextProfile {
        NoProfile,
        CoreProfile,
        CompatibilityProfile
    };

    QSurfaceFormat();
                 QSurfaceFormat(FormatOptions options);
    QSurfaceFormat(const QSurfaceFormat &other);
    QSurfaceFormat &operator=(const QSurfaceFormat &other);
    ~QSurfaceFormat();

    void setDepthBufferSize(int size);
    int depthBufferSize() const;

    void setStencilBufferSize(int size);
    int stencilBufferSize() const;

    void setRedBufferSize(int size);
    int redBufferSize() const;
    void setGreenBufferSize(int size);
    int greenBufferSize() const;
    void setBlueBufferSize(int size);
    int blueBufferSize() const;
    void setAlphaBufferSize(int size);
    int alphaBufferSize() const;

    void setSamples(int numSamples);
    int samples() const;

    void setSwapBehavior(SwapBehavior behavior);
    SwapBehavior swapBehavior() const;

    bool hasAlpha() const;

    void setProfile(OpenGLContextProfile profile);
    OpenGLContextProfile profile() const;

    void setRenderableType(RenderableType type);
    RenderableType renderableType() const;

    void setMajorVersion(int majorVersion);
    int majorVersion() const;

    void setMinorVersion(int minorVersion);
    int minorVersion() const;

    QPair<int, int> version() const;
    void setVersion(int major, int minor);

    bool stereo() const;
    void setStereo(bool enable);

                  void setOption(QSurfaceFormat::FormatOptions opt);
                  bool testOption(QSurfaceFormat::FormatOptions opt) const;

    void setOptions(QSurfaceFormat::FormatOptions options);
    void setOption(FormatOption option, bool on = true);
    bool testOption(FormatOption option) const;
    QSurfaceFormat::FormatOptions options() const;

    int swapInterval() const;
    void setSwapInterval(int interval);

private:
    QSurfaceFormatPrivate *d;

    void detach();

    friend __declspec(dllimport) bool operator==(const QSurfaceFormat&, const QSurfaceFormat&);
    friend __declspec(dllimport) bool operator!=(const QSurfaceFormat&, const QSurfaceFormat&);

    friend __declspec(dllimport) QDebug operator<<(QDebug, const QSurfaceFormat &);

};

__declspec(dllimport) bool operator==(const QSurfaceFormat&, const QSurfaceFormat&);
__declspec(dllimport) bool operator!=(const QSurfaceFormat&, const QSurfaceFormat&);


__declspec(dllimport) QDebug operator<<(QDebug, const QSurfaceFormat &);


 inline QFlags<QSurfaceFormat::FormatOptions::enum_type> operator|(QSurfaceFormat::FormatOptions::enum_type f1, QSurfaceFormat::FormatOptions::enum_type f2) { return QFlags<QSurfaceFormat::FormatOptions::enum_type>(f1) | f2; } inline QFlags<QSurfaceFormat::FormatOptions::enum_type> operator|(QSurfaceFormat::FormatOptions::enum_type f1, QFlags<QSurfaceFormat::FormatOptions::enum_type> f2) { return f2 | f1; } inline QIncompatibleFlag operator|(QSurfaceFormat::FormatOptions::enum_type f1, int f2) { return QIncompatibleFlag(int(f1) | f2); }

inline bool QSurfaceFormat::stereo() const
{
    return testOption(QSurfaceFormat::StereoBuffers);
}
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qsurface.h"







class QPlatformSurface;

class QSurfacePrivate;

class __declspec(dllimport) QSurface
{
public:
    enum SurfaceClass {
        Window,
        Offscreen
    };

    enum SurfaceType {
        RasterSurface,
        OpenGLSurface,
        RasterGLSurface
    };

    virtual ~QSurface();

    SurfaceClass surfaceClass() const;

    virtual QSurfaceFormat format() const = 0;
    virtual QPlatformSurface *surfaceHandle() const = 0;

    virtual SurfaceType surfaceType() const = 0;
    bool supportsOpenGL() const;

    virtual QSize size() const = 0;

protected:
    explicit QSurface(SurfaceClass type);

    SurfaceClass m_type;

    QSurfacePrivate *m_reserved;
};
#line 46 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qoffscreensurface.h"




class QOffscreenSurfacePrivate;

class QScreen;
class QPlatformOffscreenSurface;

class __declspec(dllimport) QOffscreenSurface : public QObject, public QSurface
{
    public: template <typename ThisObject> inline void qt_check_for_QOBJECT_macro(const ThisObject &_q_argument) const { int i = qYouForgotTheQ_OBJECT_Macro(this, &_q_argument); i = i + 1; } static const QMetaObject staticMetaObject; virtual const QMetaObject *metaObject() const; virtual void *qt_metacast(const char *); static inline QString tr(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } static inline QString trUtf8(const char *s, const char *c = 0, int n = -1) { return staticMetaObject.tr(s, c, n); } virtual int qt_metacall(QMetaObject::Call, int, void **); private: static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); struct QPrivateSignal {};
    inline QOffscreenSurfacePrivate* d_func() { return reinterpret_cast<QOffscreenSurfacePrivate *>(qGetPtrHelper(d_ptr)); } inline const QOffscreenSurfacePrivate* d_func() const { return reinterpret_cast<const QOffscreenSurfacePrivate *>(qGetPtrHelper(d_ptr)); } friend class QOffscreenSurfacePrivate;

public:

    explicit QOffscreenSurface(QScreen *screen = 0);
    virtual ~QOffscreenSurface();

    SurfaceType surfaceType() const;

    void create();
    void destroy();

    bool isValid() const;

    void setFormat(const QSurfaceFormat &format);
    QSurfaceFormat format() const;
    QSurfaceFormat requestedFormat() const;

    QSize size() const;

    QScreen *screen() const;
    void setScreen(QScreen *screen);

    QPlatformOffscreenSurface *handle() const;

public:
    void screenChanged(QScreen *screen);

private :
    void screenDestroyed(QObject *screen);

private:

    QPlatformSurface *surfaceHandle() const;

    QOffscreenSurface(const QOffscreenSurface &) = delete; QOffscreenSurface &operator=(const QOffscreenSurface &) = delete;
};
#line 31 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui\\QtGui"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qopenglcontext.h"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qopenglcontext.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QObject"
#line 50 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qopenglcontext.h"

#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/QScopedPointer"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qopenglcontext.h"


#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/QSurfaceFormat"
#line 53 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qopenglcontext.h"
#line 62 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include/QtGui/qopenglcontext.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qopengl.h"
#line 51 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtGui/qopengl.h"
#line 1 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qt_windows.h"
#line 71 "C:/Qt/Qt5.3.2/5.3/msvc2013_opengl/include\\QtCore/qt_windows.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\windows.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\winapifamily.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\windows.h"
#line 22 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\windows.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\sdkddkver.h"
#line 20 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\sdkddkver.h"
#pragma warning(push)

#pragma warning(disable: 4001)
#line 279 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\sdkddkver.h"
#pragma warning(pop)
#line 22 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\windows.h"
#line 149 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\windows.h"
#pragma warning(disable: 4514)

#pragma warning(disable: 4103)


#pragma warning(push)

#pragma warning(disable: 4001)
#pragma warning(disable: 4201)
#pragma warning(disable: 4214)


#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\excpt.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\excpt.h"
#line 1 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\crtdefs.h"
#line 20 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\excpt.h"






#pragma pack(push,8)


extern "C" {





typedef enum _EXCEPTION_DISPOSITION {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;
#line 52 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\excpt.h"
struct _EXCEPTION_RECORD;
struct _CONTEXT;

EXCEPTION_DISPOSITION __cdecl _except_handler (
         struct _EXCEPTION_RECORD *_ExceptionRecord,
         void * _EstablisherFrame,
            struct _CONTEXT *_ContextRecord,
            void * _DispatcherContext
    );
#line 96 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\excpt.h"
unsigned long __cdecl _exception_code(void);
void * __cdecl _exception_info(void);
int __cdecl _abnormal_termination(void);
#line 175 "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/include\\excpt.h"
}


#pragma pack(pop)
#line 160 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\windows.h"




#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\windef.h"
#line 17 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\windef.h"
extern "C" {







#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\minwindef.h"
#line 14 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\minwindef.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings.h"
#line 63 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings.h"
extern "C" {
#line 484 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings.h"
}
#line 513 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings_strict.h"
#line 188 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings_strict.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings_undef.h"
#line 188 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings_strict.h"
#line 513 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings.h"
#line 534 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\driverspecs.h"
#line 125 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\driverspecs.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/sdv_driverspecs.h"
#line 125 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\driverspecs.h"








extern "C" {
#line 863 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\driverspecs.h"
}
#line 534 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\specstrings.h"
#line 14 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\minwindef.h"
#line 42 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\minwindef.h"
extern "C" {
#line 51 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\minwindef.h"
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
#line 156 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\minwindef.h"
typedef unsigned long DWORD;
typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef float FLOAT;
typedef FLOAT *PFLOAT;
typedef BOOL *PBOOL;
typedef BOOL *LPBOOL;
typedef BYTE *PBYTE;
typedef BYTE *LPBYTE;
typedef int *PINT;
typedef int *LPINT;
typedef WORD *PWORD;
typedef WORD *LPWORD;
typedef long *LPLONG;
typedef DWORD *PDWORD;
typedef DWORD *LPDWORD;
typedef void *LPVOID;
typedef const void *LPCVOID;

typedef int INT;
typedef unsigned int UINT;
typedef unsigned int *PUINT;




#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 22 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#pragma warning(push)

#pragma warning(disable: 4201)
#pragma warning(disable: 4214)


extern "C" {
#line 81 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\kernelspecs.h"
#line 43 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\kernelspecs.h"
extern "C" {
#line 249 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\kernelspecs.h"
}
#line 81 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 169 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\basetsd.h"
#line 40 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\basetsd.h"
  typedef unsigned long POINTER_64_INT;
#line 67 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\basetsd.h"
extern "C" {


typedef signed char INT8, *PINT8;
typedef signed short INT16, *PINT16;
typedef signed int INT32, *PINT32;
typedef signed __int64 INT64, *PINT64;
typedef unsigned char UINT8, *PUINT8;
typedef unsigned short UINT16, *PUINT16;
typedef unsigned int UINT32, *PUINT32;
typedef unsigned __int64 UINT64, *PUINT64;





typedef signed int LONG32, *PLONG32;





typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;
#line 129 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\basetsd.h"
    typedef __w64 int INT_PTR, *PINT_PTR;
    typedef __w64 unsigned int UINT_PTR, *PUINT_PTR;

    typedef __w64 long LONG_PTR, *PLONG_PTR;
    typedef __w64 unsigned long ULONG_PTR, *PULONG_PTR;
#line 328 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\basetsd.h"
typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;
typedef __w64 long SHANDLE_PTR;
typedef __w64 unsigned long HANDLE_PTR;
#line 349 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\basetsd.h"
__inline
void * __ptr64
PtrToPtr64(
    const void *p
    )
{
    return((void * __ptr64) (unsigned __int64) (ULONG_PTR)p );
}

__inline
void *
Ptr64ToPtr(
    const void * __ptr64 p
    )
{
    return((void *) (ULONG_PTR) (unsigned __int64) p);
}

__inline
void * __ptr64
HandleToHandle64(
    const void *h
    )
{
    return((void * __ptr64)(__int64)(LONG_PTR)h );
}

__inline
void *
Handle64ToHandle(
    const void * __ptr64 h
    )
{
    return((void *) (ULONG_PTR) (unsigned __int64) h );
}
#line 415 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\basetsd.h"
typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;
#line 464 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\basetsd.h"
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;





typedef __int64 LONG64, *PLONG64;






typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;







typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;




}
#line 169 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 339 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef void *PVOID;
typedef void * __ptr64 PVOID64;
#line 381 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef char CHAR;
typedef short SHORT;
typedef long LONG;

typedef int INT;
#line 394 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef wchar_t WCHAR;





typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef const WCHAR *LPCWCH, *PCWCH;

typedef WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef PWSTR *PZPWSTR;
typedef const PWSTR *PCZPWSTR;
typedef WCHAR *LPUWSTR, *PUWSTR;
typedef const WCHAR *LPCWSTR, *PCWSTR;
typedef PCWSTR *PZPCWSTR;
typedef const PCWSTR *PCZPCWSTR;
typedef const WCHAR *LPCUWSTR, *PCUWSTR;

typedef WCHAR *PZZWSTR;
typedef const WCHAR *PCZZWSTR;
typedef WCHAR *PUZZWSTR;
typedef const WCHAR *PCUZZWSTR;

typedef WCHAR *PNZWCH;
typedef const WCHAR *PCNZWCH;
typedef WCHAR *PUNZWCH;
typedef const WCHAR *PCUNZWCH;



typedef const WCHAR *LPCWCHAR, *PCWCHAR;
typedef const WCHAR *LPCUWCHAR, *PCUWCHAR;





typedef unsigned long UCSCHAR;
#line 451 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR *PCUUCSSTR;

typedef UCSCHAR *PUUCSCHAR;
typedef const UCSCHAR *PCUUCSCHAR;







typedef CHAR *PCHAR, *LPCH, *PCH;
typedef const CHAR *LPCCH, *PCCH;

typedef CHAR *NPSTR, *LPSTR, *PSTR;
typedef PSTR *PZPSTR;
typedef const PSTR *PCZPSTR;
typedef const CHAR *LPCSTR, *PCSTR;
typedef PCSTR *PZPCSTR;
typedef const PCSTR *PCZPCSTR;

typedef CHAR *PZZSTR;
typedef const CHAR *PCZZSTR;

typedef CHAR *PNZCH;
typedef const CHAR *PCNZCH;







typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TBYTE , *PTBYTE ;



typedef LPWCH LPTCH, PTCH;
typedef LPCWCH LPCTCH, PCTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
typedef PZZWSTR PZZTSTR;
typedef PCZZWSTR PCZZTSTR;
typedef PUZZWSTR PUZZTSTR;
typedef PCUZZWSTR PCUZZTSTR;
typedef PZPWSTR PZPTSTR;
typedef PNZWCH PNZTCH;
typedef PCNZWCH PCNZTCH;
typedef PUNZWCH PUNZTCH;
typedef PCUNZWCH PCUNZTCH;
#line 537 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef SHORT *PSHORT;
typedef LONG *PLONG;
#line 547 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _PROCESSOR_NUMBER {
    WORD Group;
    BYTE Number;
    BYTE Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;






typedef struct _GROUP_AFFINITY {
    KAFFINITY Mask;
    WORD Group;
    WORD Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;
#line 571 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef void *HANDLE;
#line 581 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef HANDLE *PHANDLE;







typedef BYTE FCHAR;
typedef WORD FSHORT;
typedef DWORD FLONG;
#line 602 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef long HRESULT;
#line 665 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef char CCHAR;
typedef DWORD LCID;
typedef PDWORD PLCID;
typedef WORD LANGID;
#line 677 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum {
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID
} COMPARTMENT_ID, *PCOMPARTMENT_ID;
#line 708 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;
#line 723 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;
#line 745 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;



typedef LONGLONG USN;




typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    } ;
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;

    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;




typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } ;
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;

    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;





typedef LONG_PTR RTL_REFERENCE_COUNT, *PRTL_REFERENCE_COUNT;
#line 802 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;


typedef ULONGLONG DWORDLONG;
typedef DWORDLONG *PDWORDLONG;
#line 854 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
ULONGLONG
__stdcall
Int64ShllMod32 (
         ULONGLONG Value,
         DWORD ShiftCount
    );

LONGLONG
__stdcall
Int64ShraMod32 (
         LONGLONG Value,
         DWORD ShiftCount
    );

ULONGLONG
__stdcall
Int64ShrlMod32 (
         ULONGLONG Value,
         DWORD ShiftCount
    );


#pragma warning(push)

#pragma warning(disable: 4035 4793)

__inline ULONGLONG
__stdcall
Int64ShllMod32 (
         ULONGLONG Value,
         DWORD ShiftCount
    )
{
    __asm {
        mov ecx, ShiftCount
        mov eax, dword ptr [Value]
        mov edx, dword ptr [Value+4]
        shld edx, eax, cl
        shl eax, cl
    }
}

__inline LONGLONG
__stdcall
Int64ShraMod32 (
         LONGLONG Value,
         DWORD ShiftCount
    )
{
    __asm {
        mov ecx, ShiftCount
        mov eax, dword ptr [Value]
        mov edx, dword ptr [Value+4]
        shrd eax, edx, cl
        sar edx, cl
    }
}

__inline ULONGLONG
__stdcall
Int64ShrlMod32 (
         ULONGLONG Value,
         DWORD ShiftCount
    )
{
    __asm {
        mov ecx, ShiftCount
        mov eax, dword ptr [Value]
        mov edx, dword ptr [Value+4]
        shrd eax, edx, cl
        shr edx, cl
    }
}


#pragma warning(pop)
#line 945 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" {
#line 997 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
unsigned int
__cdecl
_rotl (
         unsigned int Value,
         int Shift
    );

unsigned __int64
__cdecl
_rotl64 (
         unsigned __int64 Value,
         int Shift
    );

unsigned int
__cdecl
_rotr (
         unsigned int Value,
         int Shift
    );

unsigned __int64
__cdecl
_rotr64 (
         unsigned __int64 Value,
         int Shift
    );

#pragma intrinsic(_rotl)
#pragma intrinsic(_rotl64)
#pragma intrinsic(_rotr)
#pragma intrinsic(_rotr64)




}






typedef BYTE BOOLEAN;
typedef BOOLEAN *PBOOLEAN;





typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, * PRLIST_ENTRY;






typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;
#line 1068 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;



#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\guiddef.h"
#line 75 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\guiddef.h"
typedef GUID *LPGUID;




typedef const GUID *LPCGUID;





typedef GUID IID;
typedef IID *LPIID;


typedef GUID CLSID;
typedef CLSID *LPCLSID;


typedef GUID FMTID;
typedef FMTID *LPFMTID;
#line 150 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\guiddef.h"
__inline int InlineIsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

__inline int IsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}
#line 192 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\guiddef.h"
__inline bool operator==(const GUID & guidOne, const GUID & guidOther)
{
    return !!IsEqualGUID(guidOne,guidOther);
}

__inline bool operator!=(const GUID & guidOne, const GUID & guidOther)
{
    return !(guidOne == guidOther);
}
#line 1081 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"





typedef struct _OBJECTID {
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;
#line 1176 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C++"
template <typename T, size_t N>
char (*RtlpNumberOf( T (&)[N] ))[N];
#line 1304 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef


EXCEPTION_DISPOSITION
__stdcall
EXCEPTION_ROUTINE (
            struct _EXCEPTION_RECORD *ExceptionRecord,
         PVOID EstablisherFrame,
            struct _CONTEXT *ContextRecord,
         PVOID DispatcherContext
    );

typedef EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;
#line 2141 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C++" {

    template <size_t S>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE;

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<1>
    {
        typedef INT8 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<2>
    {
        typedef INT16 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<4>
    {
        typedef INT32 type;
    };


    template <class T>
    struct _ENUM_FLAG_SIZED_INTEGER
    {
        typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type;
    };

}
#line 2269 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;







typedef struct __declspec(align(16)) _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;





typedef struct __declspec(align(16)) _XSAVE_FORMAT {
    WORD ControlWord;
    WORD StatusWord;
    BYTE TagWord;
    BYTE Reserved1;
    WORD ErrorOpcode;
    DWORD ErrorOffset;
    WORD ErrorSelector;
    WORD Reserved2;
    DWORD DataOffset;
    WORD DataSelector;
    WORD Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];
#line 2310 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
    M128A XmmRegisters[8];
    BYTE Reserved4[224];



} XSAVE_FORMAT, *PXSAVE_FORMAT;



typedef struct __declspec(align(8)) _XSAVE_AREA_HEADER {
    DWORD64 Mask;
    DWORD64 Reserved[7];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;

typedef struct __declspec(align(16)) _XSAVE_AREA {
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;

typedef struct _XSTATE_CONTEXT {
    DWORD64 Mask;
    DWORD Length;
    DWORD Reserved1;
                                   PXSAVE_AREA Area;


    DWORD Reserved2;


    PVOID Buffer;


    DWORD Reserved3;


} XSTATE_CONTEXT, *PXSTATE_CONTEXT;





typedef struct _SCOPE_TABLE_AMD64 {
    DWORD Count;
    struct {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_AMD64, *PSCOPE_TABLE_AMD64;
#line 3839 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _SCOPE_TABLE_ARM {
    DWORD Count;
    struct
    {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_ARM, *PSCOPE_TABLE_ARM;
#line 4799 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" {
#line 4846 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
void
__int2c (
    void
    );

#pragma intrinsic(__int2c)
#line 4930 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
}
#line 4962 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#pragma warning(push)





#pragma warning(pop)
#line 4983 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" {
#line 5006 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
BOOLEAN
_bittest (
                                   LONG const *Base,
         LONG Offset
    );

BOOLEAN
_bittestandcomplement (
                                        LONG *Base,
         LONG Offset
    );

BOOLEAN
_bittestandset (
                                        LONG *Base,
         LONG Offset
    );

BOOLEAN
_bittestandreset (
                                        LONG *Base,
         LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
                                                              LONG volatile *Base,
         LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
                                                              LONG volatile *Base,
         LONG Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)
#line 5057 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
BOOLEAN
_BitScanForward (
          DWORD *Index,
         DWORD Mask
    );


BOOLEAN
_BitScanReverse (
          DWORD *Index,
         DWORD Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#line 5102 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
SHORT
_InterlockedIncrement16 (
                                  SHORT volatile *Addend
    );

SHORT
_InterlockedDecrement16 (
                                  SHORT volatile *Addend
    );

SHORT
_InterlockedCompareExchange16 (
                                  SHORT volatile *Destination,
         SHORT ExChange,
         SHORT Comperand
    );

LONG64
_InterlockedCompareExchange64 (
                                  LONG64 volatile *Destination,
         LONG64 ExChange,
         LONG64 Comperand
    );

#pragma intrinsic(_InterlockedIncrement16)
#pragma intrinsic(_InterlockedDecrement16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedCompareExchange64)
#line 5180 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
LONG
_InterlockedAnd (
                                  LONG volatile *Destination,
         LONG Value
    );

LONG
_InterlockedOr (
                                  LONG volatile *Destination,
         LONG Value
    );

LONG
_InterlockedXor (
                                  LONG volatile *Destination,
         LONG Value
    );

LONG
__cdecl
_InterlockedIncrement (
                                  LONG volatile *Addend
    );

LONG
__cdecl
_InterlockedDecrement (
                                  LONG volatile *Addend
    );

LONG
__cdecl
_InterlockedExchange (
                                  LONG volatile *Target,
         LONG Value
    );

LONG
__cdecl
_InterlockedExchangeAdd (
                                  LONG volatile *Addend,
         LONG Value
    );

__forceinline
LONG
_InterlockedAdd (
                                  LONG volatile *Addend,
         LONG Value
    )

{

    return _InterlockedExchangeAdd(Addend, Value) + Value;
}

LONG
__cdecl
_InterlockedCompareExchange (
                                  LONG volatile * Destination,
         LONG ExChange,
         LONG Comperand
    );



__forceinline

PVOID
_InlineInterlockedExchangePointer(



                          PVOID volatile * Destination,
             PVOID Value
    )
{
    return (PVOID)_InterlockedExchange((LONG volatile *) Destination,
                                      (LONG) Value);
}






__forceinline

PVOID
_InlineInterlockedCompareExchangePointer (



                          PVOID volatile * Destination,
             PVOID ExChange,
             PVOID Comperand
    )
{
    return (PVOID)_InterlockedCompareExchange((LONG volatile *) Destination,
                                             (LONG) ExChange,
                                             (LONG) Comperand);
}
#line 5292 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)








CHAR
_InterlockedExchange8 (
                                  CHAR volatile *Target,
         CHAR Value
    );

SHORT
_InterlockedExchange16 (
                                  SHORT volatile *Destination,
         SHORT ExChange
    );

#pragma intrinsic(_InterlockedExchange8)
#pragma intrinsic(_InterlockedExchange16)
#line 5337 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
char
_InterlockedAnd8 (
                                  char volatile *Destination,
         char Value
    );

char
_InterlockedOr8 (
                                  char volatile *Destination,
         char Value
    );

char
_InterlockedXor8 (
                                  char volatile *Destination,
         char Value
    );

SHORT
_InterlockedAnd16 (
                                  SHORT volatile *Destination,
         SHORT Value
    );

SHORT
_InterlockedXor16(
                                  SHORT volatile *Destination,
         SHORT Value
    );

SHORT
_InterlockedCompareExchange16 (
                                  SHORT volatile *Destination,
         SHORT ExChange,
         SHORT Comperand
    );

SHORT
_InterlockedOr16 (
                                  SHORT volatile *Destination,
         SHORT Value
    );

SHORT
_InterlockedIncrement16 (
                                  SHORT volatile *Destination
    );

SHORT
_InterlockedDecrement16 (
                                  SHORT volatile *Destination
    );

#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedXor16)
#pragma intrinsic (_InterlockedCompareExchange16)
#pragma intrinsic (_InterlockedIncrement16)
#pragma intrinsic (_InterlockedDecrement16)
#line 5409 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__forceinline
LONG64
_InterlockedAnd64 (
                                  LONG64 volatile *Destination,
         LONG64 Value
    )
{
    LONG64 Old;

    do {
        Old = *Destination;
    } while (_InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}






__forceinline
LONG64
_InterlockedAdd64 (
                                  LONG64 volatile *Addend,
         LONG64 Value
    )
{
    LONG64 Old;

    do {
        Old = *Addend;
    } while (_InterlockedCompareExchange64(Addend,
                                          Old + Value,
                                          Old) != Old);

    return Old + Value;
}
#line 5470 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
LONG
_InterlockedXor (
                                  LONG volatile *Target,
         LONG Set
    );

#pragma intrinsic(_InterlockedXor)





LONGLONG
__forceinline
_InterlockedOr64 (
                                  LONGLONG volatile *Destination,
         LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (_InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}



__forceinline
LONG64
_InterlockedXor64 (
                                  LONG64 volatile *Destination,
         LONG64 Value
    )
{
    LONG64 Old;

    do {
        Old = *Destination;
    } while (_InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}



LONGLONG
__forceinline
_InterlockedIncrement64 (
                                  LONGLONG volatile *Addend
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (_InterlockedCompareExchange64(Addend,
                                          Old + 1,
                                          Old) != Old);

    return Old + 1;
}





__forceinline
LONGLONG
_InterlockedDecrement64 (
                                  LONGLONG volatile *Addend
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (_InterlockedCompareExchange64(Addend,
                                          Old - 1,
                                          Old) != Old);

    return Old - 1;
}



__forceinline
LONGLONG
_InterlockedExchange64 (
                                  LONGLONG volatile *Target,
         LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Target;
    } while (_InterlockedCompareExchange64(Target,
                                          Value,
                                          Old) != Old);

    return Old;
}






__forceinline
LONGLONG
_InterlockedExchangeAdd64 (
                                  LONGLONG volatile *Addend,
         LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (_InterlockedCompareExchange64(Addend,
                                          Old + Value,
                                          Old) != Old);

    return Old;
}
#line 5610 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
void
__incfsbyte (
         DWORD Offset
    );

void
__addfsbyte (
         DWORD Offset,
         BYTE Value
    );

void
__incfsword (
         DWORD Offset
    );

void
__addfsword (
         DWORD Offset,
         WORD Value
    );

void
__incfsdword (
         DWORD Offset
    );

void
__addfsdword (
         DWORD Offset,
         DWORD Value
    );

#pragma intrinsic(__incfsbyte)
#pragma intrinsic(__addfsbyte)
#pragma intrinsic(__incfsword)
#pragma intrinsic(__addfsword)
#pragma intrinsic(__incfsdword)
#pragma intrinsic(__addfsdword)
#line 5664 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
void
__cpuidex (
    int CPUInfo[4],
    int Function,
    int SubLeaf
    );

#pragma intrinsic(__cpuidex)
#line 5681 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
BYTE
__readfsbyte (
         DWORD Offset
    );

WORD
__readfsword (
         DWORD Offset
    );

DWORD
__readfsdword (
         DWORD Offset
    );

void
__writefsbyte (
         DWORD Offset,
         BYTE Data
    );

void
__writefsword (
         DWORD Offset,
         WORD Data
    );

void
__writefsdword (
         DWORD Offset,
         DWORD Data
    );

#pragma intrinsic(__readfsbyte)
#pragma intrinsic(__readfsword)
#pragma intrinsic(__readfsdword)
#pragma intrinsic(__writefsbyte)
#pragma intrinsic(__writefsword)
#pragma intrinsic(__writefsdword)





void
_mm_pause (
    void
    );

#pragma intrinsic(_mm_pause)






}
#line 5748 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#pragma prefast(push)
#pragma warning(push)
#pragma prefast(disable: 6001 28113, "The barrier variable is accessed only to create a side effect.")
#pragma warning(disable: 4793)
__forceinline
void
MemoryBarrier (
    void
    )
{
    LONG Barrier;

    _InterlockedOr(&Barrier, 0);
    return;
}

#pragma warning(pop)
#pragma prefast(pop)
#line 5778 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
void
_mm_prefetch (
         CHAR const *a,
         int sel
    );

#pragma intrinsic(_mm_prefetch)
#line 5807 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
DWORD64
__readpmc (
         DWORD Counter
    );

#pragma intrinsic(__readpmc)







DWORD64
__rdtsc (
    void
    );

#pragma intrinsic(__rdtsc)








__inline PVOID GetFiberData( void ) { return *(PVOID *) (ULONG_PTR) __readfsdword (0x10);}
__inline PVOID GetCurrentFiber( void ) { return (PVOID) (ULONG_PTR) __readfsdword (0x10);}
#line 5900 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Spare0;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;
#line 5922 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef char __C_ASSERT__[(sizeof(XSAVE_FORMAT) == 512)?1:-1];







#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack4.h"
#line 24 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack4.h"
#pragma warning(disable: 4103)

#pragma pack(push,4)
#line 5929 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 5941 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _CONTEXT {
#line 5961 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
    DWORD ContextFlags;







    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;






    FLOATING_SAVE_AREA FloatSave;






    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;






    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;






    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;







    BYTE ExtendedRegisters[512];

} CONTEXT;

typedef CONTEXT *PCONTEXT;


#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#line 27 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#pragma warning(disable: 4103)

#pragma pack(pop)
#line 6029 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 6039 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _LDT_ENTRY {
    WORD LimitLow;
    WORD BaseLow;
    union {
        struct {
            BYTE BaseMid;
            BYTE Flags1;
            BYTE Flags2;
            BYTE BaseHi;
        } Bytes;
        struct {
            DWORD BaseMid : 8;
            DWORD Type : 5;
            DWORD Dpl : 2;
            DWORD Pres : 1;
            DWORD LimitHi : 4;
            DWORD Sys : 1;
            DWORD Reserved_0 : 1;
            DWORD Default_Big : 1;
            DWORD Granularity : 1;
            DWORD BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;
#line 7934 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" {


__forceinline
CHAR
ReadAcquire8 (
                               CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *Source;
    return Value;
}

__forceinline
CHAR
ReadNoFence8 (
                               CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease8 (
                                CHAR volatile *Destination,
         CHAR Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence8 (
                                CHAR volatile *Destination,
         CHAR Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
SHORT
ReadAcquire16 (
                               SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *Source;
    return Value;
}

__forceinline
SHORT
ReadNoFence16 (
                               SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease16 (
                                SHORT volatile *Destination,
         SHORT Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence16 (
                                SHORT volatile *Destination,
         SHORT Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
LONG
ReadAcquire (
                               LONG const volatile *Source
    )

{

    LONG Value;

    Value = *Source;
    return Value;
}

__forceinline
LONG
ReadNoFence (
                               LONG const volatile *Source
    )

{

    LONG Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease (
                                LONG volatile *Destination,
         LONG Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence (
                                LONG volatile *Destination,
         LONG Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
LONG64
ReadAcquire64 (
                               LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *Source;
    return Value;
}

__forceinline
LONG64
ReadNoFence64 (
                               LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease64 (
                                LONG64 volatile *Destination,
         LONG64 Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence64 (
                                LONG64 volatile *Destination,
         LONG64 Value
    )

{

    *Destination = Value;
    return;
}


}
#line 8163 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__forceinline
CHAR
ReadRaw8 (
                               CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *(CHAR *)Source;
    return Value;
}

__forceinline
void
WriteRaw8 (
                                CHAR volatile *Destination,
         CHAR Value
    )

{

    *(CHAR *)Destination = Value;
    return;
}

__forceinline
SHORT
ReadRaw16 (
                               SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *(SHORT *)Source;
    return Value;
}

__forceinline
void
WriteRaw16 (
                                SHORT volatile *Destination,
         SHORT Value
    )

{

    *(SHORT *)Destination = Value;
    return;
}

__forceinline
LONG
ReadRaw (
                               LONG const volatile *Source
    )

{

    LONG Value;

    Value = *(LONG *)Source;
    return Value;
}

__forceinline
void
WriteRaw (
                                LONG volatile *Destination,
         LONG Value
    )

{

    *(LONG *)Destination = Value;
    return;
}

__forceinline
LONG64
ReadRaw64 (
                               LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *(LONG64 *)Source;
    return Value;
}

__forceinline
void
WriteRaw64 (
                                LONG64 volatile *Destination,
         LONG64 Value
    )

{

    *(LONG64 *)Destination = Value;
    return;
}





__forceinline
BYTE
ReadUCharAcquire (
                               BYTE const volatile *Source
    )

{

    return (BYTE )ReadAcquire8((PCHAR)Source);
}

__forceinline
BYTE
ReadUCharNoFence (
                               BYTE const volatile *Source
    )

{

    return (BYTE )ReadNoFence8((PCHAR)Source);
}

__forceinline
BYTE
ReadUCharRaw (
                               BYTE const volatile *Source
    )

{

    return (BYTE )ReadRaw8((PCHAR)Source);
}

__forceinline
void
WriteUCharRelease (
                                BYTE volatile *Destination,
         BYTE Value
    )

{

    WriteRelease8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteUCharNoFence (
                                BYTE volatile *Destination,
         BYTE Value
    )

{

    WriteNoFence8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteUCharRaw (
                                BYTE volatile *Destination,
         BYTE Value
    )

{

    WriteRaw8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
WORD
ReadUShortAcquire (
                               WORD const volatile *Source
    )

{

    return (WORD )ReadAcquire16((PSHORT)Source);
}

__forceinline
WORD
ReadUShortNoFence (
                               WORD const volatile *Source
    )

{

    return (WORD )ReadNoFence16((PSHORT)Source);
}

__forceinline
WORD
ReadUShortRaw (
                               WORD const volatile *Source
    )

{

    return (WORD )ReadRaw16((PSHORT)Source);
}

__forceinline
void
WriteUShortRelease (
                                WORD volatile *Destination,
         WORD Value
    )

{

    WriteRelease16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
void
WriteUShortNoFence (
                                WORD volatile *Destination,
         WORD Value
    )

{

    WriteNoFence16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
void
WriteUShortRaw (
                                WORD volatile *Destination,
         WORD Value
    )

{

    WriteRaw16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
DWORD
ReadULongAcquire (
                               DWORD const volatile *Source
    )

{

    return (DWORD)ReadAcquire((PLONG)Source);
}

__forceinline
DWORD
ReadULongNoFence (
                               DWORD const volatile *Source
    )

{

    return (DWORD)ReadNoFence((PLONG)Source);
}

__forceinline
DWORD
ReadULongRaw (
                               DWORD const volatile *Source
    )

{

    return (DWORD)ReadRaw((PLONG)Source);
}

__forceinline
void
WriteULongRelease (
                                DWORD volatile *Destination,
         DWORD Value
    )

{

    WriteRelease((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WriteULongNoFence (
                                DWORD volatile *Destination,
         DWORD Value
    )

{

    WriteNoFence((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WriteULongRaw (
                                DWORD volatile *Destination,
         DWORD Value
    )

{

    WriteRaw((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
DWORD64
ReadULong64Acquire (
                               DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadAcquire64((PLONG64)Source);
}

__forceinline
DWORD64
ReadULong64NoFence (
                               DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadNoFence64((PLONG64)Source);
}

__forceinline
DWORD64
ReadULong64Raw (
                               DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadRaw64((PLONG64)Source);
}

__forceinline
void
WriteULong64Release (
                                DWORD64 volatile *Destination,
         DWORD64 Value
    )

{

    WriteRelease64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WriteULong64NoFence (
                                DWORD64 volatile *Destination,
         DWORD64 Value
    )

{

    WriteNoFence64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WriteULong64Raw (
                                DWORD64 volatile *Destination,
         DWORD64 Value
    )

{

    WriteRaw64((PLONG64)Destination, (LONG64)Value);
    return;
}
#line 8577 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__forceinline
PVOID
ReadPointerAcquire (
                               PVOID const volatile *Source
    )

{

    return (PVOID)ReadAcquire((PLONG)Source);
}

__forceinline
PVOID
ReadPointerNoFence (
                               PVOID const volatile *Source
    )

{

    return (PVOID)ReadNoFence((PLONG)Source);
}

__forceinline
PVOID
ReadPointerRaw (
                               PVOID const volatile *Source
    )

{

    return (PVOID)ReadRaw((PLONG)Source);
}

__forceinline
void
WritePointerRelease (
                                PVOID volatile *Destination,
         PVOID Value
    )

{

    WriteRelease((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WritePointerNoFence (
                                PVOID volatile *Destination,
             PVOID Value
    )

{

    WriteNoFence((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WritePointerRaw (
                                PVOID volatile *Destination,
             PVOID Value
    )

{

    WriteRaw((PLONG)Destination, (LONG)Value);
    return;
}
#line 8813 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _WOW64_FLOATING_SAVE_AREA {
    DWORD ControlWord;
    DWORD StatusWord;
    DWORD TagWord;
    DWORD ErrorOffset;
    DWORD ErrorSelector;
    DWORD DataOffset;
    DWORD DataSelector;
    BYTE RegisterArea[80];
    DWORD Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;


#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack4.h"
#line 24 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack4.h"
#pragma warning(disable: 4103)

#pragma pack(push,4)
#line 8827 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 8839 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _WOW64_CONTEXT {
#line 8859 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
    DWORD ContextFlags;







    DWORD Dr0;
    DWORD Dr1;
    DWORD Dr2;
    DWORD Dr3;
    DWORD Dr6;
    DWORD Dr7;






    WOW64_FLOATING_SAVE_AREA FloatSave;






    DWORD SegGs;
    DWORD SegFs;
    DWORD SegEs;
    DWORD SegDs;






    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;






    DWORD Ebp;
    DWORD Eip;
    DWORD SegCs;
    DWORD EFlags;
    DWORD Esp;
    DWORD SegSs;







    BYTE ExtendedRegisters[512];

} WOW64_CONTEXT;

typedef WOW64_CONTEXT *PWOW64_CONTEXT;


#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#line 27 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#pragma warning(disable: 4103)

#pragma pack(pop)
#line 8927 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"



typedef struct _WOW64_LDT_ENTRY {
    WORD LimitLow;
    WORD BaseLow;
    union {
        struct {
            BYTE BaseMid;
            BYTE Flags1;
            BYTE Flags2;
            BYTE BaseHi;
        } Bytes;
        struct {
            DWORD BaseMid : 8;
            DWORD Type : 5;
            DWORD Dpl : 2;
            DWORD Pres : 1;
            DWORD LimitHi : 4;
            DWORD Sys : 1;
            DWORD Reserved_0 : 1;
            DWORD Default_Big : 1;
            DWORD Granularity : 1;
            DWORD BaseHi : 8;
        } Bits;
    } HighWord;
} WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;

typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    DWORD Selector;
    WOW64_LDT_ENTRY Descriptor;
} WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;
#line 8981 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[15];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[15];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;





typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
#line 9039 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef PVOID PACCESS_TOKEN;
typedef PVOID PSECURITY_DESCRIPTOR;
typedef PVOID PSID;
typedef PVOID PCLAIMS_BLOB;
#line 9083 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;
#line 9141 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;
#line 9160 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack4.h"
#line 24 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack4.h"
#pragma warning(disable: 4103)

#pragma pack(push,4)
#line 9160 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"


typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;


#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#line 27 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#pragma warning(disable: 4103)

#pragma pack(pop)
#line 9169 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 9204 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;





typedef struct _SID {
   BYTE Revision;
   BYTE SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;



   DWORD SubAuthority[1];

} SID, *PISID;
#line 9235 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel
} SID_NAME_USE, *PSID_NAME_USE;

typedef struct _SID_AND_ATTRIBUTES {



    PSID Sid;

    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;


typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;

typedef struct _SID_AND_ATTRIBUTES_HASH {
    DWORD SidCount;
    PSID_AND_ATTRIBUTES SidAttr;
    SID_HASH_ENTRY Hash[32];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;
#line 9630 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum {

    WinNullSid = 0,
    WinWorldSid = 1,
    WinLocalSid = 2,
    WinCreatorOwnerSid = 3,
    WinCreatorGroupSid = 4,
    WinCreatorOwnerServerSid = 5,
    WinCreatorGroupServerSid = 6,
    WinNtAuthoritySid = 7,
    WinDialupSid = 8,
    WinNetworkSid = 9,
    WinBatchSid = 10,
    WinInteractiveSid = 11,
    WinServiceSid = 12,
    WinAnonymousSid = 13,
    WinProxySid = 14,
    WinEnterpriseControllersSid = 15,
    WinSelfSid = 16,
    WinAuthenticatedUserSid = 17,
    WinRestrictedCodeSid = 18,
    WinTerminalServerSid = 19,
    WinRemoteLogonIdSid = 20,
    WinLogonIdsSid = 21,
    WinLocalSystemSid = 22,
    WinLocalServiceSid = 23,
    WinNetworkServiceSid = 24,
    WinBuiltinDomainSid = 25,
    WinBuiltinAdministratorsSid = 26,
    WinBuiltinUsersSid = 27,
    WinBuiltinGuestsSid = 28,
    WinBuiltinPowerUsersSid = 29,
    WinBuiltinAccountOperatorsSid = 30,
    WinBuiltinSystemOperatorsSid = 31,
    WinBuiltinPrintOperatorsSid = 32,
    WinBuiltinBackupOperatorsSid = 33,
    WinBuiltinReplicatorSid = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid = 36,
    WinBuiltinNetworkConfigurationOperatorsSid = 37,
    WinAccountAdministratorSid = 38,
    WinAccountGuestSid = 39,
    WinAccountKrbtgtSid = 40,
    WinAccountDomainAdminsSid = 41,
    WinAccountDomainUsersSid = 42,
    WinAccountDomainGuestsSid = 43,
    WinAccountComputersSid = 44,
    WinAccountControllersSid = 45,
    WinAccountCertAdminsSid = 46,
    WinAccountSchemaAdminsSid = 47,
    WinAccountEnterpriseAdminsSid = 48,
    WinAccountPolicyAdminsSid = 49,
    WinAccountRasAndIasServersSid = 50,
    WinNTLMAuthenticationSid = 51,
    WinDigestAuthenticationSid = 52,
    WinSChannelAuthenticationSid = 53,
    WinThisOrganizationSid = 54,
    WinOtherOrganizationSid = 55,
    WinBuiltinIncomingForestTrustBuildersSid = 56,
    WinBuiltinPerfMonitoringUsersSid = 57,
    WinBuiltinPerfLoggingUsersSid = 58,
    WinBuiltinAuthorizationAccessSid = 59,
    WinBuiltinTerminalServerLicenseServersSid = 60,
    WinBuiltinDCOMUsersSid = 61,
    WinBuiltinIUsersSid = 62,
    WinIUserSid = 63,
    WinBuiltinCryptoOperatorsSid = 64,
    WinUntrustedLabelSid = 65,
    WinLowLabelSid = 66,
    WinMediumLabelSid = 67,
    WinHighLabelSid = 68,
    WinSystemLabelSid = 69,
    WinWriteRestrictedCodeSid = 70,
    WinCreatorOwnerRightsSid = 71,
    WinCacheablePrincipalsGroupSid = 72,
    WinNonCacheablePrincipalsGroupSid = 73,
    WinEnterpriseReadonlyControllersSid = 74,
    WinAccountReadonlyControllersSid = 75,
    WinBuiltinEventLogReadersGroup = 76,
    WinNewEnterpriseReadonlyControllersSid = 77,
    WinBuiltinCertSvcDComAccessGroup = 78,
    WinMediumPlusLabelSid = 79,
    WinLocalLogonSid = 80,
    WinConsoleLogonSid = 81,
    WinThisOrganizationCertificateSid = 82,
    WinApplicationPackageAuthoritySid = 83,
    WinBuiltinAnyPackageSid = 84,
    WinCapabilityInternetClientSid = 85,
    WinCapabilityInternetClientServerSid = 86,
    WinCapabilityPrivateNetworkClientServerSid = 87,
    WinCapabilityPicturesLibrarySid = 88,
    WinCapabilityVideosLibrarySid = 89,
    WinCapabilityMusicLibrarySid = 90,
    WinCapabilityDocumentsLibrarySid = 91,
    WinCapabilitySharedUserCertificatesSid = 92,
    WinCapabilityEnterpriseAuthenticationSid = 93,
    WinCapabilityRemovableStorageSid = 94,
    WinBuiltinRDSRemoteAccessServersSid = 95,
    WinBuiltinRDSEndpointServersSid = 96,
    WinBuiltinRDSManagementServersSid = 97,
    WinUserModeDriversSid = 98,
    WinBuiltinHyperVAdminsSid = 99,
    WinAccountCloneableControllersSid = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid = 102,
    WinAuthenticationAuthorityAssertedSid = 103,
    WinAuthenticationServiceAssertedSid = 104,
    WinLocalAccountSid = 105,
    WinLocalAccountAndAdministratorSid = 106,
    WinAccountProtectedUsersSid = 107,
} WELL_KNOWN_SID_TYPE;
#line 9837 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _ACL {
    BYTE AclRevision;
    BYTE Sbz1;
    WORD AclSize;
    WORD AceCount;
    WORD Sbz2;
} ACL;
typedef ACL *PACL;
#line 9867 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _ACE_HEADER {
    BYTE AceType;
    BYTE AceFlags;
    WORD AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;
#line 9981 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;

typedef struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} SYSTEM_RESOURCE_ATTRIBUTE_ACE, *PSYSTEM_RESOURCE_ATTRIBUTE_ACE;

typedef struct _SYSTEM_SCOPED_POLICY_ID_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_SCOPED_POLICY_ID_ACE, *PSYSTEM_SCOPED_POLICY_ID_ACE;

typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;

typedef struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_PROCESS_TRUST_LABEL_ACE, *PSYSTEM_PROCESS_TRUST_LABEL_ACE;
#line 10049 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;

typedef struct _ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;






typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;

} SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;

typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;

} ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;

} ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;

} SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;

} SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;
#line 10172 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;






typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;





typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;
#line 10223 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;
#line 10313 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    BYTE Revision;
    BYTE Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
    } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

typedef struct _SECURITY_DESCRIPTOR {
   BYTE Revision;
   BYTE Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;

   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;


typedef struct _SECURITY_OBJECT_AI_PARAMS {
    DWORD Size;
    DWORD ConstraintMask;
} SECURITY_OBJECT_AI_PARAMS, *PSECURITY_OBJECT_AI_PARAMS;
#line 10390 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _OBJECT_TYPE_LIST {
    WORD Level;
    WORD Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;
#line 10410 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;
#line 10464 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[1];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;
#line 10485 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _ACCESS_REASON_TYPE{

    AccessReasonNone = 0x00000000,






    AccessReasonAllowedAce = 0x00010000,
    AccessReasonDeniedAce = 0x00020000,

    AccessReasonAllowedParentAce = 0x00030000,
    AccessReasonDeniedParentAce = 0x00040000,

    AccessReasonNotGrantedByCape = 0x00050000,
    AccessReasonNotGrantedByParentCape = 0x00060000,

    AccessReasonNotGrantedToAppContainer = 0x00070000,

    AccessReasonMissingPrivilege = 0x00100000,
    AccessReasonFromPrivilege = 0x00200000,


    AccessReasonIntegrityLevel = 0x00300000,

    AccessReasonOwnership = 0x00400000,

    AccessReasonNullDacl = 0x00500000,
    AccessReasonEmptyDacl = 0x00600000,

    AccessReasonNoSD = 0x00700000,
    AccessReasonNoGrant = 0x00800000,

    AccessReasonTrustLabel = 0x00900000
}
ACCESS_REASON_TYPE;
#line 10536 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef DWORD ACCESS_REASON;

typedef struct _ACCESS_REASONS{
        ACCESS_REASON Data[32];
} ACCESS_REASONS, *PACCESS_REASONS;
#line 10565 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _SE_SECURITY_DESCRIPTOR
{
    DWORD Size;
    DWORD Flags;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;

typedef struct _SE_ACCESS_REQUEST
{
    DWORD Size;
    PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    PSID PrincipalSelfSid;
    PGENERIC_MAPPING GenericMapping;
    DWORD ObjectTypeListCount;
    POBJECT_TYPE_LIST ObjectTypeList;
} SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;


typedef struct _SE_ACCESS_REPLY
{
    DWORD Size;
    DWORD ResultListCount;
    PACCESS_MASK GrantedAccess;
    PDWORD AccessStatus;
    PACCESS_REASONS AccessReason;
    PPRIVILEGE_SET* Privileges;
} SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;
#line 10656 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;
#line 10728 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;







typedef enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited,
} TOKEN_ELEVATION_TYPE, *PTOKEN_ELEVATION_TYPE;






typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    TokenIsAppContainer,
    TokenCapabilities,
    TokenAppContainerSid,
    TokenAppContainerNumber,
    TokenUserClaimAttributes,
    TokenDeviceClaimAttributes,
    TokenRestrictedUserClaimAttributes,
    TokenRestrictedDeviceClaimAttributes,
    TokenDeviceGroups,
    TokenRestrictedDeviceGroups,
    TokenSecurityAttributes,
    TokenIsRestricted,
    TokenProcessTrustLevel,
    MaxTokenInfoClass
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;






typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;

typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;



    SID_AND_ATTRIBUTES Groups[1];

} TOKEN_GROUPS, *PTOKEN_GROUPS;


typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[1];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;


typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;

typedef struct _TOKEN_USER_CLAIMS {
    PCLAIMS_BLOB UserClaims;
} TOKEN_USER_CLAIMS, *PTOKEN_USER_CLAIMS;

typedef struct _TOKEN_DEVICE_CLAIMS {
    PCLAIMS_BLOB DeviceClaims;
} TOKEN_DEVICE_CLAIMS, *PTOKEN_DEVICE_CLAIMS;

typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;

typedef struct _TOKEN_LINKED_TOKEN {
    HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;

typedef struct _TOKEN_ELEVATION {
    DWORD TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;

typedef struct _TOKEN_MANDATORY_LABEL {
    SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;
#line 10875 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _TOKEN_MANDATORY_POLICY {
    DWORD Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;

typedef struct _TOKEN_ACCESS_INFORMATION {
    PSID_AND_ATTRIBUTES_HASH SidHash;
    PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    PTOKEN_PRIVILEGES Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    DWORD Flags;
    DWORD AppContainerNumber;
    PSID PackageSid;
    PSID_AND_ATTRIBUTES_HASH CapabilitiesHash;
    PSID TrustLevelSid;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;







typedef struct _TOKEN_AUDIT_POLICY {
    BYTE PerUserPolicy[(((56)) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;



typedef struct _TOKEN_SOURCE {
    CHAR SourceName[8];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;


typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;



typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;

typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession ;
} TOKEN_ORIGIN, * PTOKEN_ORIGIN ;


typedef enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
} MANDATORY_LEVEL, *PMANDATORY_LEVEL;

typedef struct _TOKEN_APPCONTAINER_INFORMATION {
    PSID TokenAppContainer;
} TOKEN_APPCONTAINER_INFORMATION, *PTOKEN_APPCONTAINER_INFORMATION;

typedef struct _TOKEN_SID_INFORMATION {
    PSID Sid;
} TOKEN_SID_INFORMATION, *PTOKEN_SID_INFORMATION;
#line 10986 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    DWORD64 Version;
    PWSTR Name;
} CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE, *PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
#line 10998 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    PVOID pValue;
    DWORD ValueLength;
} CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
    *PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
#line 11070 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _CLAIM_SECURITY_ATTRIBUTE_V1 {






    PWSTR Name;





    WORD ValueType;






    WORD Reserved;





    DWORD Flags;





    DWORD ValueCount;





    union {
        PLONG64 pInt64;
        PDWORD64 pUint64;
        PWSTR *ppString;
        PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
        PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_V1, *PCLAIM_SECURITY_ATTRIBUTE_V1;






typedef struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {






    DWORD Name;





    WORD ValueType;






    WORD Reserved;





    DWORD Flags;





    DWORD ValueCount;





    union {
        DWORD pInt64[1];
        DWORD pUint64[1];
        DWORD ppString[1];
        DWORD pFqbn[1];
        DWORD pOctetString[1];
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1, *PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
#line 11189 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {





    WORD Version;





    WORD Reserved;

    DWORD AttributeCount;
    union {
        PCLAIM_SECURITY_ATTRIBUTE_V1 pAttributeV1;
    } Attribute;
} CLAIM_SECURITY_ATTRIBUTES_INFORMATION, *PCLAIM_SECURITY_ATTRIBUTES_INFORMATION;
#line 11216 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;







typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;






typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;






typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;
#line 11271 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _SE_LEARNING_MODE_DATA_TYPE {
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings,
    SeLearningModeMax
} SE_LEARNING_MODE_DATA_TYPE;



typedef struct _SECURITY_CAPABILITIES {
    PSID AppContainerSid;
    PSID_AND_ATTRIBUTES Capabilities;
    DWORD CapabilityCount;
    DWORD Reserved;
} SECURITY_CAPABILITIES, *PSECURITY_CAPABILITIES, *LPSECURITY_CAPABILITIES;
#line 11348 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle;
    DWORD MemberLevel;
    DWORD Flags;
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;




typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;

    union {
        PVOID FiberData;
        DWORD Version;
    };



    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;




typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;


    union {
        DWORD FiberData;
        DWORD Version;
    };




    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;


    union {
        DWORD64 FiberData;
        DWORD Version;
    };





    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
#line 11431 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {
    DWORD UmsVersion;
        PVOID UmsContext;
        PVOID UmsCompletionList;
} UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES;

typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;







typedef union _RATE_QUOTA_LIMIT {
    DWORD RateData;
    struct {
        DWORD RatePercent : 7;
        DWORD Reserved0 : 25;
    } ;
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;

typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
    SIZE_T WorkingSetLimit;
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    DWORD Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;

typedef struct _IO_COUNTERS {
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;




typedef enum _HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
} HARDWARE_COUNTER_TYPE, *PHARDWARE_COUNTER_TYPE;
typedef enum _PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessReserved1Policy,
    ProcessSignaturePolicy,
    MaxProcessMitigationPolicy
} PROCESS_MITIGATION_POLICY, *PPROCESS_MITIGATION_POLICY;






typedef struct _PROCESS_MITIGATION_ASLR_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableBottomUpRandomization : 1;
            DWORD EnableForceRelocateImages : 1;
            DWORD EnableHighEntropy : 1;
            DWORD DisallowStrippedImages : 1;
            DWORD ReservedFlags : 28;
        };
    };
} PROCESS_MITIGATION_ASLR_POLICY, *PPROCESS_MITIGATION_ASLR_POLICY;

typedef struct _PROCESS_MITIGATION_DEP_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD Enable : 1;
            DWORD DisableAtlThunkEmulation : 1;
            DWORD ReservedFlags : 30;
        };
    };
    BOOLEAN Permanent;
} PROCESS_MITIGATION_DEP_POLICY, *PPROCESS_MITIGATION_DEP_POLICY;

typedef struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD RaiseExceptionOnInvalidHandleReference : 1;
            DWORD HandleExceptionsPermanentlyEnabled : 1;
            DWORD ReservedFlags : 30;
        };
    };
} PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY, *PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;

typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisallowWin32kSystemCalls : 1;
            DWORD ReservedFlags : 31;
        };
    };
} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisableExtensionPoints : 1;
            DWORD ReservedFlags : 31;
        };
    };
} PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY, *PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD ReservedFlags : 31;
        };
    };
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY;


typedef struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD ReservedFlags : 31;
        };
    };
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;


typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD TotalPageFaultCount;
    DWORD TotalProcesses;
    DWORD ActiveProcesses;
    DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    DWORD ActiveProcessLimit;
    ULONG_PTR Affinity;
    DWORD PriorityClass;
    DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD NumberOfAssignedProcesses;
    DWORD NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;

typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;





typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD SecurityLimitFlags ;
    HANDLE JobToken ;
    PTOKEN_GROUPS SidsToDisable ;
    PTOKEN_PRIVILEGES PrivilegesToDelete ;
    PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;

typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID CompletionKey;
    HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;

typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE {
    ToleranceLow = 1,
    ToleranceMedium,
    ToleranceHigh
} JOBOBJECT_RATE_CONTROL_TOLERANCE;

typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium,
    ToleranceIntervalLong
} JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;

typedef struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
    DWORD LimitFlags;
} JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION, *PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    DWORD LimitFlags;
    DWORD ViolationLimitFlags;
    DWORD64 IoReadBytes;
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytes;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTime;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemory;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceLimit;
} JOBOBJECT_LIMIT_VIOLATION_INFORMATION, *PJOBOBJECT_LIMIT_VIOLATION_INFORMATION;

typedef struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    DWORD ControlFlags;
    union {
        DWORD CpuRate;
        DWORD Weight;
    };
} JOBOBJECT_CPU_RATE_CONTROL_INFORMATION, *PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
#line 11820 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    JobObjectNotificationLimitInformation,
    JobObjectLimitViolationInformation,
    JobObjectGroupInformationEx,
    JobObjectCpuRateControlInformation,
    JobObjectCompletionFilter,
    JobObjectCompletionCounter,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information,
    JobObjectReserved3Information,
    JobObjectReserved4Information,
    JobObjectReserved5Information,
    JobObjectReserved6Information,
    JobObjectReserved7Information,
    JobObjectReserved8Information,
    JobObjectReserved9Information,
    MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;


typedef enum _FIRMWARE_TYPE {
    FirmwareTypeUnknown,
    FirmwareTypeBios,
    FirmwareTypeUefi,
    FirmwareTypeMax
} FIRMWARE_TYPE, *PFIRMWARE_TYPE;
#line 11887 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;



typedef enum _PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;



typedef struct _CACHE_DESCRIPTOR {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    ULONG_PTR ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG Reserved[2];
    } ;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

typedef struct _PROCESSOR_RELATIONSHIP {
    BYTE Flags;
    BYTE Reserved[21];
    WORD GroupCount;
                             GROUP_AFFINITY GroupMask[1];
} PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;

typedef struct _NUMA_NODE_RELATIONSHIP {
    DWORD NodeNumber;
    BYTE Reserved[20];
    GROUP_AFFINITY GroupMask;
} NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;

typedef struct _CACHE_RELATIONSHIP {
    BYTE Level;
    BYTE Associativity;
    WORD LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE Reserved[20];
    GROUP_AFFINITY GroupMask;
} CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;

typedef struct _PROCESSOR_GROUP_INFO {
    BYTE MaximumProcessorCount;
    BYTE ActiveProcessorCount;
    BYTE Reserved[38];
    KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;

typedef struct _GROUP_RELATIONSHIP {
    WORD MaximumGroupCount;
    WORD ActiveGroupCount;
    BYTE Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo[1];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;

                          struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union {
        PROCESSOR_RELATIONSHIP Processor;
        NUMA_NODE_RELATIONSHIP NumaNode;
        CACHE_RELATIONSHIP Cache;
        GROUP_RELATIONSHIP Group;
    } ;
};

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;



typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    DWORD64 CycleTime;
} SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
#line 12077 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION {

    DWORD64 EnabledFeatures;


    DWORD64 EnabledVolatileFeatures;


    DWORD Size;

    DWORD OptimizedSave : 1;


    XSTATE_FEATURE Features[(64)];

} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;


typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;

typedef struct __declspec(align(16)) _MEMORY_BASIC_INFORMATION64 {
    ULONGLONG BaseAddress;
    ULONGLONG AllocationBase;
    DWORD AllocationProtect;
    DWORD __alignment1;
    ULONGLONG RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
    DWORD __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;
#line 12312 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _FILE_ID_128 {
    BYTE Identifier[16];
} FILE_ID_128, *PFILE_ID_128;





typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;






typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;
#line 12392 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _REPARSE_GUID_DATA_BUFFER {
    DWORD ReparseTag;
    WORD ReparseDataLength;
    WORD Reserved;
    GUID ReparseGuid;
    struct {
        BYTE DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;
#line 12495 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _SCRUB_DATA_INPUT {





    DWORD Size;
#line 12510 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
    DWORD Flags;







    DWORD MaximumIos;





    DWORD Reserved[17];







    BYTE ResumeContext[816];

} SCRUB_DATA_INPUT, *PSCRUB_DATA_INPUT;



typedef struct _SCRUB_PARITY_EXTENT {

    LONGLONG Offset;

    ULONGLONG Length;

} SCRUB_PARITY_EXTENT, *PSCRUB_PARITY_EXTENT;

typedef struct _SCRUB_PARITY_EXTENT_DATA {





    WORD Size;





    WORD Flags;





    WORD NumberOfParityExtents;





    WORD MaximumNumberOfParityExtents;





    SCRUB_PARITY_EXTENT ParityExtents[1];

} SCRUB_PARITY_EXTENT_DATA, *PSCRUB_PARITY_EXTENT_DATA;



typedef struct _SCRUB_DATA_OUTPUT {





    DWORD Size;
#line 12598 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
    DWORD Flags;





    DWORD Status;






    ULONGLONG ErrorFileOffset;






    ULONGLONG ErrorLength;





    ULONGLONG NumberOfBytesRepaired;





    ULONGLONG NumberOfBytesFailed;





    ULONGLONG InternalFileReference;
#line 12647 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
    WORD ResumeContextLength;







    WORD ParityExtentDataOffset;





    DWORD Reserved[5];
#line 12686 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
    BYTE ResumeContext[816];

} SCRUB_DATA_OUTPUT, *PSCRUB_DATA_OUTPUT;
#line 12703 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _SharedVirtualDiskSupportType
{



    SharedVirtualDisksUnsupported = 0,




    SharedVirtualDisksSupported = 1
} SharedVirtualDiskSupportType;

typedef enum _SharedVirtualDiskHandleState
{



    SharedVirtualDiskHandleStateNone = 0,





    SharedVirtualDiskHandleStateFileShared = 1,





    SharedVirtualDiskHandleStateHandleShared = 3
} SharedVirtualDiskHandleState;





typedef struct _SHARED_VIRTUAL_DISK_SUPPORT {




    SharedVirtualDiskSupportType SharedVirtualDiskSupport;





    SharedVirtualDiskHandleState HandleState;
} SHARED_VIRTUAL_DISK_SUPPORT, *PSHARED_VIRTUAL_DISK_SUPPORT;
#line 12793 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_MAX_POWER_SAVINGS;






extern "C" const GUID GUID_MIN_POWER_SAVINGS;






extern "C" const GUID GUID_TYPICAL_POWER_SAVINGS;







extern "C" const GUID NO_SUBGROUP_GUID;







extern "C" const GUID ALL_POWERSCHEMES_GUID;
#line 12860 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_POWERSCHEME_PERSONALITY;
#line 12869 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_ACTIVE_POWERSCHEME;
#line 12884 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_IDLE_RESILIENCY_SUBGROUP;





extern "C" const GUID GUID_IDLE_RESILIENCY_PERIOD;






extern "C" const GUID GUID_IDLE_RESILIENCY_PLATFORM_STATE;






extern "C" const GUID GUID_DISK_COALESCING_POWERDOWN_TIMEOUT;
#line 12917 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT;
#line 12926 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_VIDEO_SUBGROUP;





extern "C" const GUID GUID_VIDEO_POWERDOWN_TIMEOUT;





extern "C" const GUID GUID_VIDEO_ANNOYANCE_TIMEOUT;





extern "C" const GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE;





extern "C" const GUID GUID_VIDEO_DIM_TIMEOUT;





extern "C" const GUID GUID_VIDEO_ADAPTIVE_POWERDOWN;





extern "C" const GUID GUID_MONITOR_POWER_ON;




extern "C" const GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS;





extern "C" const GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS;




extern "C" const GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS;






extern "C" const GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS;





extern "C" const GUID GUID_CONSOLE_DISPLAY_STATE;







extern "C" const GUID GUID_ALLOW_DISPLAY_REQUIRED;







extern "C" const GUID GUID_VIDEO_CONSOLE_LOCK_TIMEOUT;






extern "C" const GUID GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP;






extern "C" const GUID GUID_NON_ADAPTIVE_INPUT_TIMEOUT;







extern "C" const GUID GUID_DISK_SUBGROUP;





extern "C" const GUID GUID_DISK_POWERDOWN_TIMEOUT;






extern "C" const GUID GUID_DISK_IDLE_TIMEOUT;
#line 13051 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_DISK_BURST_IGNORE_THRESHOLD;





extern "C" const GUID GUID_DISK_ADAPTIVE_POWERDOWN;
#line 13066 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_SLEEP_SUBGROUP;







extern "C" const GUID GUID_SLEEP_IDLE_THRESHOLD;





extern "C" const GUID GUID_STANDBY_TIMEOUT;
#line 13089 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_UNATTEND_SLEEP_TIMEOUT;





extern "C" const GUID GUID_HIBERNATE_TIMEOUT;





extern "C" const GUID GUID_HIBERNATE_FASTS4_POLICY;
#line 13110 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_CRITICAL_POWER_TRANSITION;





extern "C" const GUID GUID_SYSTEM_AWAYMODE;





extern "C" const GUID GUID_ALLOW_AWAYMODE;





extern "C" const GUID GUID_VIDEO_FULLSCREEN_PLAYBACK;






extern "C" const GUID GUID_AUDIO_PLAYBACK;







extern "C" const GUID GUID_ALLOW_STANDBY_STATES;






extern "C" const GUID GUID_ALLOW_RTC_WAKE;







extern "C" const GUID GUID_ALLOW_SYSTEM_REQUIRED;
#line 13167 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_SYSTEM_BUTTON_SUBGROUP;
#line 13186 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_POWERBUTTON_ACTION;





extern "C" const GUID GUID_SLEEPBUTTON_ACTION;






extern "C" const GUID GUID_USERINTERFACEBUTTON_ACTION;





extern "C" const GUID GUID_LIDCLOSE_ACTION;
extern "C" const GUID GUID_LIDOPEN_POWERSTATE;
#line 13215 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_BATTERY_SUBGROUP;
#line 13227 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_0;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_0;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_0;

extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_1;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_1;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_1;

extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_2;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_2;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_2;

extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_3;
extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_3;
extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_3;
#line 13250 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_SETTINGS_SUBGROUP;





extern "C" const GUID GUID_PROCESSOR_THROTTLE_POLICY;
#line 13272 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM;







extern "C" const GUID GUID_PROCESSOR_THROTTLE_MINIMUM;







extern "C" const GUID GUID_PROCESSOR_ALLOW_THROTTLING;





extern "C" const GUID GUID_PROCESSOR_IDLESTATE_POLICY;





extern "C" const GUID GUID_PROCESSOR_PERFSTATE_POLICY;







extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD;







extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD;







extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY;







extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY;
#line 13341 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_TIME;
#line 13350 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_TIME;







extern "C" const GUID GUID_PROCESSOR_PERF_TIME_CHECK;







extern "C" const GUID GUID_PROCESSOR_PERF_BOOST_POLICY;
#line 13378 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_PERF_BOOST_MODE;
#line 13394 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_IDLE_ALLOW_SCALING;






extern "C" const GUID GUID_PROCESSOR_IDLE_DISABLE;
#line 13410 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_IDLE_STATE_MAXIMUM;
#line 13419 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_IDLE_TIME_CHECK;
#line 13428 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD;







extern "C" const GUID GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY;
#line 13470 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING;






extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD;







extern "C" const GUID GUID_PROCESSOR_PARKING_CORE_OVERRIDE;







extern "C" const GUID GUID_PROCESSOR_PARKING_PERF_STATE;







extern "C" const GUID GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD;







extern "C" const GUID GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD;
#line 13588 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_PERF_HISTORY;







extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_HISTORY;







extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_HISTORY;







extern "C" const GUID GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY;
#line 13622 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT;






extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT_PERF;







extern "C" const GUID GUID_PROCESSOR_DISTRIBUTE_UTILITY;







extern "C" const GUID GUID_SYSTEM_COOLING_POLICY;
#line 13655 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_LOCK_CONSOLE_ON_WAKE;
#line 13665 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_DEVICE_IDLE_POLICY;
#line 13686 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_ACDC_POWER_SOURCE;
#line 13702 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_LIDSWITCH_STATE_CHANGE;
#line 13719 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_BATTERY_PERCENTAGE_REMAINING;






extern "C" const GUID GUID_GLOBAL_USER_PRESENCE;
#line 13737 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_SESSION_DISPLAY_STATUS;
#line 13747 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_SESSION_USER_PRESENCE;






extern "C" const GUID GUID_IDLE_BACKGROUND_TASK;






extern "C" const GUID GUID_BACKGROUND_TASK_NOTIFICATION;







extern "C" const GUID GUID_APPLAUNCH_BUTTON;
#line 13780 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_PCIEXPRESS_SETTINGS_SUBGROUP;





extern "C" const GUID GUID_PCIEXPRESS_ASPM_POLICY;
#line 13798 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID GUID_ENABLE_SWITCH_FORCED_SHUTDOWN;






extern "C" const GUID GUID_INTSTEER_SUBGROUP;



extern "C" const GUID GUID_INTSTEER_MODE;



extern "C" const GUID GUID_INTSTEER_LOAD_PER_PROC_TRIGGER;



extern "C" const GUID GUID_INTSTEER_TIME_UNPARK_TRIGGER;



typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;



typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
} MONITOR_DISPLAY_STATE, *PMONITOR_DISPLAY_STATE;

typedef enum _USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent,
    PowerUserInactive,
    PowerUserMaximum,
    PowerUserInvalid = PowerUserMaximum
} USER_ACTIVITY_PRESENCE, *PUSER_ACTIVITY_PRESENCE;
#line 13876 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef DWORD EXECUTION_STATE, *PEXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;
#line 13899 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired,
    PowerRequestExecutionRequired
} POWER_REQUEST_TYPE, *PPOWER_REQUEST_TYPE;
#line 13925 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct CM_Power_Data_s {
    DWORD PD_Size;
    DEVICE_POWER_STATE PD_MostRecentPowerState;
    DWORD PD_Capabilities;
    DWORD PD_D1Latency;
    DWORD PD_D2Latency;
    DWORD PD_D3Latency;
    DEVICE_POWER_STATE PD_PowerStateMapping[7];
    SYSTEM_POWER_STATE PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;





typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,
    LastSleepTime,
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    PowerInformationLevelUnused0,
    SystemMonitorHiberBootPowerOff,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorCap,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities,
    SessionPowerInit,
    SessionDisplayState,
    PowerRequestCreate,
    PowerRequestAction,
    GetPowerRequestList,
    ProcessorInformationEx,
    NotifyUserModeLegacyPowerEvent,
    GroupPark,
    ProcessorIdleDomains,
    WakeTimerList,
    SystemHiberFileSize,
    ProcessorIdleStatesHv,
    ProcessorPerfStatesHv,
    ProcessorPerfCapHv,
    ProcessorSetIdle,
    LogicalProcessorIdling,
    UserPresence,
    PowerSettingNotificationName,
    GetPowerSettingValue,
    IdleResiliency,
    SessionRITState,
    SessionConnectNotification,
    SessionPowerCleanup,
    SessionLockState,
    SystemHiberbootState,
    PlatformInformation,
    PdcInvocation,
    MonitorInvocation,
    FirmwareTableInformationRegistered,
    SetShutdownSelectedTime,
    SuspendResumeInvocation,
    PlmPowerRequestCreate,
    ScreenOff,
    CsDeviceNotification,
    PlatformRole,
    LastResumePerformance,
    DisplayBurst,
    ExitLatencySamplingPercentage,
    RegisterSpmPowerSettings,
    PlatformIdleStates,
    ProcessorIdleVeto,
    PlatformIdleVeto,
    SystemBatteryStatePrecise,
    ThermalEvent,
    PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;





typedef enum {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 0xff
} POWER_USER_PRESENCE_TYPE, *PPOWER_USER_PRESENCE_TYPE;

typedef struct _POWER_USER_PRESENCE {
 POWER_USER_PRESENCE_TYPE UserPresence;
} POWER_USER_PRESENCE, *PPOWER_USER_PRESENCE;




typedef struct _POWER_SESSION_CONNECT {
    BOOLEAN Connected;
    BOOLEAN Console;
} POWER_SESSION_CONNECT, *PPOWER_SESSION_CONNECT;

typedef struct _POWER_SESSION_TIMEOUTS {
    DWORD InputTimeout;
    DWORD DisplayTimeout;
} POWER_SESSION_TIMEOUTS, *PPOWER_SESSION_TIMEOUTS;




typedef struct _POWER_SESSION_RIT_STATE {
    BOOLEAN Active;
    DWORD LastInputTime;
} POWER_SESSION_RIT_STATE, *PPOWER_SESSION_RIT_STATE;




typedef struct _POWER_SESSION_WINLOGON {
    DWORD SessionId;
    BOOLEAN Console;
    BOOLEAN Locked;
} POWER_SESSION_WINLOGON, *PPOWER_SESSION_WINLOGON;




typedef struct _POWER_IDLE_RESILIENCY {
    DWORD CoalescingTimeout;
    DWORD IdleResiliencyPeriod;
} POWER_IDLE_RESILIENCY, *PPOWER_IDLE_RESILIENCY;




typedef enum {
    MonitorRequestReasonUnknown,
    MonitorRequestReasonPowerButton,
    MonitorRequestReasonRemoteConnection,
    MonitorRequestReasonScMonitorpower,
    MonitorRequestReasonUserInput,
    MonitorRequestReasonAcDcDisplayBurst,
    MonitorRequestReasonUserDisplayBurst,
    MonitorRequestReasonPoSetSystemState,
    MonitorRequestReasonSetThreadExecutionState,
    MonitorRequestReasonFullWake,
    MonitorRequestReasonSessionUnlock,
    MonitorRequestReasonScreenOffRequest,
    MonitorRequestReasonIdleTimeout,
    MonitorRequestReasonPolicyChange,
    MonitorRequestReasonSleepButton,
    MonitorRequestReasonLid,
    MonitorRequestReasonMax
} POWER_MONITOR_REQUEST_REASON;




typedef struct _POWER_MONITOR_INVOCATION {
    BOOLEAN On;
    BOOLEAN Console;
    POWER_MONITOR_REQUEST_REASON RequestReason;
} POWER_MONITOR_INVOCATION, *PPOWER_MONITOR_INVOCATION;





typedef struct _RESUME_PERFORMANCE {
    DWORD PostTimeMs;
    ULONGLONG TotalResumeTimeMs;
    ULONGLONG ResumeCompleteTimestamp;
} RESUME_PERFORMANCE, *PRESUME_PERFORMANCE;





typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;

typedef struct {





    DWORD Version;





    GUID Guid;






    SYSTEM_POWER_CONDITION PowerCondition;




    DWORD DataLength;




    BYTE Data[1];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;



typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;






typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {





    LARGE_INTEGER ActivationTime;




    DWORD Flags;




    DWORD ButtonInstanceID;


} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;





typedef enum _POWER_PLATFORM_ROLE {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer,
    PlatformRoleSlate,
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE, *PPOWER_PLATFORM_ROLE;
#line 14233 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _POWER_PLATFORM_INFORMATION {
    BOOLEAN AoAc;
} POWER_PLATFORM_INFORMATION, *PPOWER_PLATFORM_INFORMATION;






typedef struct {
    DWORD Granularity;
    DWORD Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;




typedef struct {
    DWORD Frequency;
    DWORD Flags;
    DWORD PercentFrequency;
} PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;

typedef struct {
    DWORD Latency;
    DWORD Power;
    DWORD TimeCheck;
    BYTE PromotePercent;
    BYTE DemotePercent;
    BYTE StateType;
    BYTE Reserved;
    DWORD StateFlags;
    DWORD Context;
    DWORD IdleHandler;
    DWORD Reserved1;
} PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;
    DWORD OldState;
    DWORD64 TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;
    DWORD OldState;
    PVOID TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES_EX, *PPPM_WMI_IDLE_STATES_EX;

typedef struct {
    DWORD Frequency;
    DWORD Power;
    BYTE PercentFrequency;
    BYTE IncreaseLevel;
    BYTE DecreaseLevel;
    BYTE Type;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD64 Control;
    DWORD64 Status;
    DWORD HitCount;
    DWORD Reserved1;
    DWORD64 Reserved2;
    DWORD64 Reserved3;
} PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;
    DWORD MaxPerfState;
    DWORD MinPerfState;
    DWORD LowestPerfState;
    DWORD ThermalConstraint;
    BYTE BusyAdjThreshold;
    BYTE PolicyType;
    BYTE Type;
    BYTE Reserved;
    DWORD TimerInterval;
    DWORD64 TargetProcessors;
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;
    DWORD MaxPerfState;
    DWORD MinPerfState;
    DWORD LowestPerfState;
    DWORD ThermalConstraint;
    BYTE BusyAdjThreshold;
    BYTE PolicyType;
    BYTE Type;
    BYTE Reserved;
    DWORD TimerInterval;
    PVOID TargetProcessors;
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES_EX, *PPPM_WMI_PERF_STATES_EX;







typedef struct {
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD64 TotalTime;
    DWORD IdleTimeBuckets[6];
} PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING State[1];
} PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;







typedef struct {
    DWORD64 TotalTimeUs;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD Count;
} PPM_IDLE_STATE_BUCKET_EX, *PPPM_IDLE_STATE_BUCKET_EX;

typedef struct {
    DWORD64 TotalTime;
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD CancelledTransitions;
    PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16];
} PPM_IDLE_STATE_ACCOUNTING_EX, *PPPM_IDLE_STATE_ACCOUNTING_EX;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD AbortCount;
    DWORD64 StartTime;
                             PPM_IDLE_STATE_ACCOUNTING_EX State[1];
} PPM_IDLE_ACCOUNTING_EX, *PPPM_IDLE_ACCOUNTING_EX;
#line 14467 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
extern "C" const GUID PPM_PERFSTATE_CHANGE_GUID;



extern "C" const GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID;



extern "C" const GUID PPM_IDLESTATE_CHANGE_GUID;



extern "C" const GUID PPM_PERFSTATES_DATA_GUID;



extern "C" const GUID PPM_IDLESTATES_DATA_GUID;



extern "C" const GUID PPM_IDLE_ACCOUNTING_GUID;



extern "C" const GUID PPM_IDLE_ACCOUNTING_EX_GUID;



extern "C" const GUID PPM_THERMALCONSTRAINT_GUID;



extern "C" const GUID PPM_PERFMON_PERFSTATE_GUID;



extern "C" const GUID PPM_THERMAL_POLICY_CHANGE_GUID;



typedef struct {
    DWORD State;
    DWORD Status;
    DWORD Latency;
    DWORD Speed;
    DWORD Processor;
} PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;

typedef struct {
    DWORD State;
    DWORD Latency;
    DWORD Speed;
    DWORD64 Processors;
} PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;

typedef struct {
    DWORD NewState;
    DWORD OldState;
    DWORD64 Processors;
} PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;

typedef struct {
    DWORD ThermalConstraint;
    DWORD64 Processors;
} PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;

#pragma warning(push)
#pragma warning(disable: 4121)

typedef struct {
    BYTE Mode;
    DWORD64 Processors;
} PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;

#pragma warning(pop)




typedef struct {
    POWER_ACTION Action;
    DWORD Flags;
    DWORD EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;
#line 14583 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct {
    BOOLEAN Enable;
    BYTE Spare[3];
    DWORD BatteryLevel;
    POWER_ACTION_POLICY PowerPolicy;
    SYSTEM_POWER_STATE MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;
#line 14598 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _SYSTEM_POWER_POLICY {
    DWORD Revision;


    POWER_ACTION_POLICY PowerButton;
    POWER_ACTION_POLICY SleepButton;
    POWER_ACTION_POLICY LidClose;
    SYSTEM_POWER_STATE LidOpenWake;
    DWORD Reserved;


    POWER_ACTION_POLICY Idle;
    DWORD IdleTimeout;
    BYTE IdleSensitivity;

    BYTE DynamicThrottle;
    BYTE Spare2[2];


    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    SYSTEM_POWER_STATE ReducedLatencySleep;
    DWORD WinLogonFlags;

    DWORD Spare3;



    DWORD DozeS4Timeout;


    DWORD BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL DischargePolicy[4];


    DWORD VideoTimeout;
    BOOLEAN VideoDimDisplay;
    DWORD VideoReserved[3];


    DWORD SpindownTimeout;


    BOOLEAN OptimizeForPower;
    BYTE FanThrottleTolerance;
    BYTE ForcedThrottle;
    BYTE MinThrottle;
    POWER_ACTION_POLICY OverThrottled;

} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;
#line 14658 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct {
    DWORD TimeCheck;
    BYTE DemotePercent;
    BYTE PromotePercent;
    BYTE Spare[2];
} PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;

typedef struct {
    WORD Revision;
    union {
        WORD AsWORD ;
        struct {
            WORD AllowScaling : 1;
            WORD Disabled : 1;
            WORD Reserved : 14;
        } ;
    } Flags;

    DWORD PolicyCount;
    PROCESSOR_IDLESTATE_INFO Policy[0x3];
} PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;
#line 14693 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _PROCESSOR_POWER_POLICY_INFO {


    DWORD TimeCheck;
    DWORD DemoteLimit;
    DWORD PromoteLimit;


    BYTE DemotePercent;
    BYTE PromotePercent;
    BYTE Spare[2];


    DWORD AllowDemotion:1;
    DWORD AllowPromotion:1;
    DWORD Reserved:30;

} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;


typedef struct _PROCESSOR_POWER_POLICY {
    DWORD Revision;


    BYTE DynamicThrottle;
    BYTE Spare[3];


    DWORD DisableCStates:1;
    DWORD Reserved:31;




    DWORD PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];

} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;





typedef struct {
    DWORD Revision;
    BYTE MaxThrottle;
    BYTE MinThrottle;
    BYTE BusyAdjThreshold;
    union {
        BYTE Spare;
        union {
            BYTE AsBYTE ;
            struct {
                BYTE NoDomainAccounting : 1;
                BYTE IncreasePolicy: 2;
                BYTE DecreasePolicy: 2;
                BYTE Reserved : 3;
            } ;
        } Flags;
    } ;

    DWORD TimeCheck;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD IncreasePercent;
    DWORD DecreasePercent;
} PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;


typedef struct _ADMINISTRATOR_POWER_POLICY {


    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;


    DWORD MinVideoTimeout;
    DWORD MaxVideoTimeout;


    DWORD MinSpindownTimeout;
    DWORD MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;


typedef struct {

    BOOLEAN PowerButtonPresent;
    BOOLEAN SleepButtonPresent;
    BOOLEAN LidPresent;
    BOOLEAN SystemS1;
    BOOLEAN SystemS2;
    BOOLEAN SystemS3;
    BOOLEAN SystemS4;
    BOOLEAN SystemS5;
    BOOLEAN HiberFilePresent;
    BOOLEAN FullWake;
    BOOLEAN VideoDimPresent;
    BOOLEAN ApmPresent;
    BOOLEAN UpsPresent;


    BOOLEAN ThermalControl;
    BOOLEAN ProcessorThrottle;
    BYTE ProcessorMinThrottle;





    BYTE ProcessorMaxThrottle;
    BOOLEAN FastSystemS4;
    BOOLEAN Hiberboot;
    BOOLEAN WakeAlarmPresent;
    BOOLEAN AoAc;



    BOOLEAN DiskSpinDown;
    BYTE spare3[8];


    BOOLEAN SystemBatteriesPresent;
    BOOLEAN BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];


    SYSTEM_POWER_STATE AcOnLineWake;
    SYSTEM_POWER_STATE SoftLidWake;
    SYSTEM_POWER_STATE RtcWake;
    SYSTEM_POWER_STATE MinDeviceWakeState;
    SYSTEM_POWER_STATE DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct {
    BOOLEAN AcOnLine;
    BOOLEAN BatteryPresent;
    BOOLEAN Charging;
    BOOLEAN Discharging;
    BOOLEAN Spare1[3];

    BYTE Tag;

    DWORD MaxCapacity;
    DWORD RemainingCapacity;
    DWORD Rate;
    DWORD EstimatedTime;

    DWORD DefaultAlert1;
    DWORD DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;
#line 14854 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack4.h"
#line 24 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack4.h"
#pragma warning(disable: 4103)

#pragma pack(push,4)
#line 14854 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"








#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack2.h"
#line 24 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack2.h"
#pragma warning(disable: 4103)

#pragma pack(push,2)
#line 14862 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 14874 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_DOS_HEADER {
    WORD e_magic;
    WORD e_cblp;
    WORD e_cp;
    WORD e_crlc;
    WORD e_cparhdr;
    WORD e_minalloc;
    WORD e_maxalloc;
    WORD e_ss;
    WORD e_sp;
    WORD e_csum;
    WORD e_ip;
    WORD e_cs;
    WORD e_lfarlc;
    WORD e_ovno;
    WORD e_res[4];
    WORD e_oemid;
    WORD e_oeminfo;
    WORD e_res2[10];
    LONG e_lfanew;
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {
    WORD ne_magic;
    CHAR ne_ver;
    CHAR ne_rev;
    WORD ne_enttab;
    WORD ne_cbenttab;
    LONG ne_crc;
    WORD ne_flags;
    WORD ne_autodata;
    WORD ne_heap;
    WORD ne_stack;
    LONG ne_csip;
    LONG ne_sssp;
    WORD ne_cseg;
    WORD ne_cmod;
    WORD ne_cbnrestab;
    WORD ne_segtab;
    WORD ne_rsrctab;
    WORD ne_restab;
    WORD ne_modtab;
    WORD ne_imptab;
    LONG ne_nrestab;
    WORD ne_cmovent;
    WORD ne_align;
    WORD ne_cres;
    BYTE ne_exetyp;
    BYTE ne_flagsothers;
    WORD ne_pretthunks;
    WORD ne_psegrefbytes;
    WORD ne_swaparea;
    WORD ne_expver;
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER {
    WORD e32_magic;
    BYTE e32_border;
    BYTE e32_worder;
    DWORD e32_level;
    WORD e32_cpu;
    WORD e32_os;
    DWORD e32_ver;
    DWORD e32_mflags;
    DWORD e32_mpages;
    DWORD e32_startobj;
    DWORD e32_eip;
    DWORD e32_stackobj;
    DWORD e32_esp;
    DWORD e32_pagesize;
    DWORD e32_lastpagesize;
    DWORD e32_fixupsize;
    DWORD e32_fixupsum;
    DWORD e32_ldrsize;
    DWORD e32_ldrsum;
    DWORD e32_objtab;
    DWORD e32_objcnt;
    DWORD e32_objmap;
    DWORD e32_itermap;
    DWORD e32_rsrctab;
    DWORD e32_rsrccnt;
    DWORD e32_restab;
    DWORD e32_enttab;
    DWORD e32_dirtab;
    DWORD e32_dircnt;
    DWORD e32_fpagetab;
    DWORD e32_frectab;
    DWORD e32_impmod;
    DWORD e32_impmodcnt;
    DWORD e32_impproc;
    DWORD e32_pagesum;
    DWORD e32_datapage;
    DWORD e32_preload;
    DWORD e32_nrestab;
    DWORD e32_cbnrestab;
    DWORD e32_nressum;
    DWORD e32_autodata;
    DWORD e32_debuginfo;
    DWORD e32_debuglen;
    DWORD e32_instpreload;
    DWORD e32_instdemand;
    DWORD e32_heapsize;
    BYTE e32_res3[12];
    DWORD e32_winresoff;
    DWORD e32_winreslen;
    WORD e32_devid;
    WORD e32_ddkver;
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;



#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#line 27 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#pragma warning(disable: 4103)

#pragma pack(pop)
#line 14984 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"







typedef struct _IMAGE_FILE_HEADER {
    WORD Machine;
    WORD NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD SizeOfOptionalHeader;
    WORD Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
#line 15054 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;







typedef struct _IMAGE_OPTIONAL_HEADER {




    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;





    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD BaseOfBss;
    DWORD GprMask;
    DWORD CprMask[4];
    DWORD GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD Magic;
    BYTE MajorLinkerVersion;
    BYTE MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    ULONGLONG ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD MajorOperatingSystemVersion;
    WORD MinorOperatingSystemVersion;
    WORD MajorImageVersion;
    WORD MinorImageVersion;
    WORD MajorSubsystemVersion;
    WORD MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD Subsystem;
    WORD DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
#line 15166 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER32 PIMAGE_OPTIONAL_HEADER;



typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;





typedef IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS32 PIMAGE_NT_HEADERS;
#line 15262 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct ANON_OBJECT_HEADER {
    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID;
    DWORD SizeOfData;
} ANON_OBJECT_HEADER;

typedef struct ANON_OBJECT_HEADER_V2 {
    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID;
    DWORD SizeOfData;
    DWORD Flags;
    DWORD MetaDataSize;
    DWORD MetaDataOffset;
} ANON_OBJECT_HEADER_V2;

typedef struct ANON_OBJECT_HEADER_BIGOBJ {

    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    CLSID ClassID;
    DWORD SizeOfData;
    DWORD Flags;
    DWORD MetaDataSize;
    DWORD MetaDataOffset;


    DWORD NumberOfSections;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
} ANON_OBJECT_HEADER_BIGOBJ;







typedef struct _IMAGE_SECTION_HEADER {
    BYTE Name[8];
    union {
            DWORD PhysicalAddress;
            DWORD VirtualSize;
    } Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD NumberOfRelocations;
    WORD NumberOfLinenumbers;
    DWORD Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
#line 15390 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack2.h"
#line 24 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack2.h"
#pragma warning(disable: 4103)

#pragma pack(push,2)
#line 15390 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"







typedef struct _IMAGE_SYMBOL {
    union {
        BYTE ShortName[8];
        struct {
            DWORD Short;
            DWORD Long;
        } Name;
        DWORD LongName[2];
    } N;
    DWORD Value;
    SHORT SectionNumber;
    WORD Type;
    BYTE StorageClass;
    BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL *PIMAGE_SYMBOL;



typedef struct _IMAGE_SYMBOL_EX {
    union {
        BYTE ShortName[8];
        struct {
            DWORD Short;
            DWORD Long;
        } Name;
        DWORD LongName[2];
    } N;
    DWORD Value;
    LONG SectionNumber;
    WORD Type;
    BYTE StorageClass;
    BYTE NumberOfAuxSymbols;
} IMAGE_SYMBOL_EX;
typedef IMAGE_SYMBOL_EX *PIMAGE_SYMBOL_EX;
#line 15553 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack2.h"
#line 24 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack2.h"
#pragma warning(disable: 4103)

#pragma pack(push,2)
#line 15553 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"


typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    BYTE bAuxType;
    BYTE bReserved;
    DWORD SymbolTableIndex;
    BYTE rgbReserved[12];
} IMAGE_AUX_SYMBOL_TOKEN_DEF;

typedef IMAGE_AUX_SYMBOL_TOKEN_DEF *PIMAGE_AUX_SYMBOL_TOKEN_DEF;


#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#line 27 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#pragma warning(disable: 4103)

#pragma pack(pop)
#line 15564 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"






typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD TagIndex;
        union {
            struct {
                WORD Linenumber;
                WORD Size;
            } LnSz;
           DWORD TotalSize;
        } Misc;
        union {
            struct {
                DWORD PointerToLinenumber;
                DWORD PointerToNextFunction;
            } Function;
            struct {
                WORD Dimension[4];
            } Array;
        } FcnAry;
        WORD TvIndex;
    } Sym;
    struct {
        BYTE Name[18];
    } File;
    struct {
        DWORD Length;
        WORD NumberOfRelocations;
        WORD NumberOfLinenumbers;
        DWORD CheckSum;
        SHORT Number;
        BYTE Selection;
 BYTE bReserved;
 SHORT HighNumber;
    } Section;
    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
    struct {
        DWORD crc;
        BYTE rgbReserved[14];
    } CRC;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL *PIMAGE_AUX_SYMBOL;

typedef union _IMAGE_AUX_SYMBOL_EX {
    struct {
        DWORD WeakDefaultSymIndex;
        DWORD WeakSearchType;
        BYTE rgbReserved[12];
    } Sym;
    struct {
        BYTE Name[sizeof(IMAGE_SYMBOL_EX)];
    } File;
    struct {
        DWORD Length;
        WORD NumberOfRelocations;
        WORD NumberOfLinenumbers;
        DWORD CheckSum;
        SHORT Number;
        BYTE Selection;
        BYTE bReserved;
        SHORT HighNumber;
        BYTE rgbReserved[2];
    } Section;
    struct{
        IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
        BYTE rgbReserved[2];
    };
    struct {
        DWORD crc;
        BYTE rgbReserved[16];
    } CRC;
} IMAGE_AUX_SYMBOL_EX;
typedef IMAGE_AUX_SYMBOL_EX *PIMAGE_AUX_SYMBOL_EX;

typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;
#line 15668 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_RELOCATION {
    union {
        DWORD VirtualAddress;
        DWORD RelocCount;
    } ;
    DWORD SymbolTableIndex;
    WORD Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION *PIMAGE_RELOCATION;
#line 16049 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD SymbolTableIndex;
        DWORD VirtualAddress;
    } Type;
    WORD Linenumber;
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER *PIMAGE_LINENUMBER;



#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#line 27 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#pragma warning(disable: 4103)

#pragma pack(pop)
#line 16059 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"







typedef struct _IMAGE_BASE_RELOCATION {
    DWORD VirtualAddress;
    DWORD SizeOfBlock;

} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION * PIMAGE_BASE_RELOCATION;
#line 16113 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE Name[16];
    BYTE Date[12];
    BYTE UserID[6];
    BYTE GroupID[6];
    BYTE Mode[8];
    BYTE Size[10];
    BYTE EndHeader[2];
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;
#line 16133 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;





typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD Hint;
    CHAR Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;


#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack8.h"
#line 24 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/pshpack8.h"
#pragma warning(disable: 4103)

#pragma pack(push,8)
#line 16156 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"


typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;
        ULONGLONG Function;
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;


#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#line 27 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#pragma warning(disable: 4103)

#pragma pack(pop)
#line 16168 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"


typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;
        DWORD Function;
        DWORD Ordinal;
        DWORD AddressOfData;
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;
#line 16191 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef void
(__stdcall *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex;
    ULONGLONG AddressOfCallBacks;
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } ;
    } ;

} IMAGE_TLS_DIRECTORY64;

typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD StartAddressOfRawData;
    DWORD EndAddressOfRawData;
    DWORD AddressOfIndex;
    DWORD AddressOfCallBacks;
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } ;
    } ;

} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;
#line 16246 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef IMAGE_THUNK_DATA32 IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA32 PIMAGE_THUNK_DATA;

typedef IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY32 PIMAGE_TLS_DIRECTORY;


typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;
    } ;
    DWORD TimeDateStamp;




    DWORD ForwarderChain;
    DWORD Name;
    DWORD FirstThunk;
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR *PIMAGE_IMPORT_DESCRIPTOR;





typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD TimeDateStamp;
    WORD OffsetModuleName;
    WORD NumberOfModuleForwarderRefs;

} IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD TimeDateStamp;
    WORD OffsetModuleName;
    WORD Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;

typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR {
    union {
        DWORD AllAttributes;
        struct {
            DWORD RvaBased : 1;
            DWORD ReservedAttributes : 31;
        };
    } Attributes;

    DWORD DllNameRVA;
    DWORD ModuleHandleRVA;
    DWORD ImportAddressTableRVA;
    DWORD ImportNameTableRVA;
    DWORD BoundImportAddressTableRVA;
    DWORD UnloadInformationTableRVA;
    DWORD TimeDateStamp;


} IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;

typedef const IMAGE_DELAYLOAD_DESCRIPTOR *PCIMAGE_DELAYLOAD_DESCRIPTOR;
#line 16326 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    WORD NumberOfNamedEntries;
    WORD NumberOfIdEntries;

} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;
#line 16353 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        } ;
        DWORD Name;
        WORD Id;
    } ;
    union {
        DWORD OffsetToData;
        struct {
            DWORD OffsetToDirectory:31;
            DWORD DataIsDirectory:1;
        } ;
    } ;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;
#line 16380 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD Length;
    CHAR NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD Length;
    WCHAR NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;
#line 16401 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD OffsetToData;
    DWORD Size;
    DWORD CodePage;
    DWORD Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;





typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
    DWORD Size;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD GlobalFlagsClear;
    DWORD GlobalFlagsSet;
    DWORD CriticalSectionDefaultTimeout;
    DWORD DeCommitFreeBlockThreshold;
    DWORD DeCommitTotalFreeThreshold;
    DWORD LockPrefixTable;
    DWORD MaximumAllocationSize;
    DWORD VirtualMemoryThreshold;
    DWORD ProcessHeapFlags;
    DWORD ProcessAffinityMask;
    WORD CSDVersion;
    WORD Reserved1;
    DWORD EditList;
    DWORD SecurityCookie;
    DWORD SEHandlerTable;
    DWORD SEHandlerCount;
    DWORD GuardCFCheckFunctionPointer;
    DWORD Reserved2;
    DWORD GuardCFFunctionTable;
    DWORD GuardCFFunctionCount;
    DWORD GuardFlags;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
    DWORD Size;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD GlobalFlagsClear;
    DWORD GlobalFlagsSet;
    DWORD CriticalSectionDefaultTimeout;
    ULONGLONG DeCommitFreeBlockThreshold;
    ULONGLONG DeCommitTotalFreeThreshold;
    ULONGLONG LockPrefixTable;
    ULONGLONG MaximumAllocationSize;
    ULONGLONG VirtualMemoryThreshold;
    ULONGLONG ProcessAffinityMask;
    DWORD ProcessHeapFlags;
    WORD CSDVersion;
    WORD Reserved1;
    ULONGLONG EditList;
    ULONGLONG SecurityCookie;
    ULONGLONG SEHandlerTable;
    ULONGLONG SEHandlerCount;
    ULONGLONG GuardCFCheckFunctionPointer;
    ULONGLONG Reserved2;
    ULONGLONG GuardCFFunctionTable;
    ULONGLONG GuardCFFunctionCount;
    DWORD GuardFlags;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;





typedef IMAGE_LOAD_CONFIG_DIRECTORY32 IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY32 PIMAGE_LOAD_CONFIG_DIRECTORY;
#line 16492 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    union {
        DWORD UnwindData;
        struct {
            DWORD Flag : 2;
            DWORD FunctionLength : 11;
            DWORD Ret : 2;
            DWORD H : 1;
            DWORD Reg : 3;
            DWORD R : 1;
            DWORD L : 1;
            DWORD C : 1;
            DWORD StackAdjust : 10;
        } ;
    } ;
} IMAGE_ARM_RUNTIME_FUNCTION_ENTRY, * PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    union {
        DWORD UnwindInfoAddress;
        DWORD UnwindData;
    } ;
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
#line 16565 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;







typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD Type;
    DWORD SizeOfData;
    DWORD AddressOfRawData;
    DWORD PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;
#line 16599 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD NumberOfSymbols;
    DWORD LvaToFirstSymbol;
    DWORD NumberOfLinenumbers;
    DWORD LvaToFirstLinenumber;
    DWORD RvaToFirstByteOfCode;
    DWORD RvaToLastByteOfCode;
    DWORD RvaToFirstByteOfData;
    DWORD RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;






typedef struct _FPO_DATA {
    DWORD ulOffStart;
    DWORD cbProcSize;
    DWORD cdwLocals;
    WORD cdwParams;
    WORD cbProlog : 8;
    WORD cbRegs : 3;
    WORD fHasSEH : 1;
    WORD fUseBP : 1;
    WORD reserved : 1;
    WORD cbFrame : 2;
} FPO_DATA, *PFPO_DATA;





typedef struct _IMAGE_DEBUG_MISC {
    DWORD DataType;
    DWORD Length;

    BOOLEAN Unicode;
    BYTE Reserved[ 3 ];
    BYTE Data[ 1 ];
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;
#line 16648 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD StartingAddress;
    DWORD EndingAddress;
    DWORD EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG StartingAddress;
    ULONGLONG EndingAddress;
    union {
        ULONGLONG EndOfPrologue;
        ULONGLONG UnwindInfoAddress;
    } ;
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;
#line 16683 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD Signature;
    WORD Flags;
    WORD Machine;
    WORD Characteristics;
    DWORD TimeDateStamp;
    DWORD CheckSum;
    DWORD ImageBase;
    DWORD SizeOfImage;
    DWORD NumberOfSections;
    DWORD ExportedNamesSize;
    DWORD DebugDirectorySize;
    DWORD SectionAlignment;
    DWORD Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

typedef struct _NON_PAGED_DEBUG_INFO {
    WORD Signature;
    WORD Flags;
    DWORD Size;
    WORD Machine;
    WORD Characteristics;
    DWORD TimeDateStamp;
    DWORD CheckSum;
    DWORD SizeOfImage;
    ULONGLONG ImageBase;


} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;
#line 16733 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue: 1;

    int :7;
    unsigned int AmaskShift: 8;
    int :16;
    DWORD FirstEntryRVA;
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;

typedef struct _ImageArchitectureEntry {
    DWORD FixupInstRVA;
    DWORD NewInst;
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;


#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#line 27 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared/poppack.h"
#pragma warning(disable: 4103)

#pragma pack(pop)
#line 16747 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 16756 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct IMPORT_OBJECT_HEADER {
    WORD Sig1;
    WORD Sig2;
    WORD Version;
    WORD Machine;
    DWORD TimeDateStamp;
    DWORD SizeOfData;

    union {
        WORD Ordinal;
        WORD Hint;
    } ;

    WORD Type : 2;
    WORD NameType : 3;
    WORD Reserved : 11;
} IMPORT_OBJECT_HEADER;

typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;

typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0,
    IMPORT_OBJECT_NAME = 1,
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,
    IMPORT_OBJECT_NAME_UNDECORATE = 3,

} IMPORT_OBJECT_NAME_TYPE;





typedef enum ReplacesCorHdrNumericDefines
{

    COMIMAGE_FLAGS_ILONLY =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED =0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT =0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA =0x00010000,


    COR_VERSION_MAJOR_V2 =2,
    COR_VERSION_MAJOR =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR =5,
    COR_DELETED_NAME_LENGTH =8,
    COR_VTABLEGAP_NAME_LENGTH =8,


    NATIVE_TYPE_MAX_CB =1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,


    IMAGE_COR_MIH_METHODRVA =0x01,
    IMAGE_COR_MIH_EHRVA =0x02,
    IMAGE_COR_MIH_BASICBLOCK =0x08,


    COR_VTABLE_32BIT =0x01,
    COR_VTABLE_64BIT =0x02,
    COR_VTABLE_FROM_UNMANAGED =0x04,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN =0x08,
    COR_VTABLE_CALL_MOST_DERIVED =0x10,


    IMAGE_COR_EATJ_THUNK_SIZE =32,



    MAX_CLASS_NAME =1024,
    MAX_PACKAGE_NAME =1024,
} ReplacesCorHdrNumericDefines;


typedef struct IMAGE_COR20_HEADER
{

    DWORD cb;
    WORD MajorRuntimeVersion;
    WORD MinorRuntimeVersion;


    IMAGE_DATA_DIRECTORY MetaData;
    DWORD Flags;



    union {
        DWORD EntryPointToken;
        DWORD EntryPointRVA;
    } ;


    IMAGE_DATA_DIRECTORY Resources;
    IMAGE_DATA_DIRECTORY StrongNameSignature;


    IMAGE_DATA_DIRECTORY CodeManagerTable;
    IMAGE_DATA_DIRECTORY VTableFixups;
    IMAGE_DATA_DIRECTORY ExportAddressTableJumps;


    IMAGE_DATA_DIRECTORY ManagedNativeHeader;

} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;








#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\apiset.h"
#line 16875 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 16890 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__declspec(dllimport)

WORD
__stdcall
RtlCaptureStackBackTrace(
         DWORD FramesToSkip,
         DWORD FramesToCapture,
                                             PVOID * BackTrace,
              PDWORD BackTraceHash
    );
#line 16914 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__declspec(dllimport)
void
__stdcall
RtlCaptureContext(
          PCONTEXT ContextRecord
    );
#line 16933 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__declspec(dllimport)
void
__stdcall
RtlUnwind(
             PVOID TargetFrame,
             PVOID TargetIp,
             PEXCEPTION_RECORD ExceptionRecord,
         PVOID ReturnValue
    );
#line 17397 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__declspec(dllimport)
PVOID
__stdcall
RtlPcToFileHeader(
         PVOID PcValue,
          PVOID * BaseOfImage
    );
#line 17422 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__declspec(dllimport)
SIZE_T
__stdcall
RtlCompareMemory(
         const void * Source1,
         const void * Source2,
         SIZE_T Length
    );
#line 17476 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _SINGLE_LIST_ENTRY SLIST_ENTRY, *PSLIST_ENTRY;
#line 17497 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        WORD Depth;
        WORD CpuId;
    } ;
} SLIST_HEADER, *PSLIST_HEADER;
#line 17525 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__declspec(dllimport)
void
__stdcall
RtlInitializeSListHead (
          PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlFirstEntrySList (
         const SLIST_HEADER *ListHead
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPopEntrySList (
            PSLIST_HEADER ListHead
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPushEntrySList (
            PSLIST_HEADER ListHead,
                             PSLIST_ENTRY ListEntry
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPushListSListEx (
            PSLIST_HEADER ListHead,
                             PSLIST_ENTRY List,
            PSLIST_ENTRY ListEnd,
         DWORD Count
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedFlushSList (
            PSLIST_HEADER ListHead
    );

__declspec(dllimport)
WORD
__stdcall
RtlQueryDepthSList (
         PSLIST_HEADER ListHead
    );
#line 17607 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef union _RTL_RUN_ONCE {
    PVOID Ptr;
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;



typedef struct _RTL_BARRIER {
            DWORD Reserved1;
            DWORD Reserved2;
            ULONG_PTR Reserved3[2];
            DWORD Reserved4;
            DWORD Reserved5;
} RTL_BARRIER, *PRTL_BARRIER;
#line 17651 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__declspec(noreturn)
void
__fastfail(
         unsigned int Code
    );

#pragma intrinsic(__fastfail)
#line 17678 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__forceinline
DWORD
HEAP_MAKE_TAG_FLAGS (
         DWORD TagBase,
         DWORD Tag
    )

{
    return ((DWORD)((TagBase) + ((Tag) << 18)));
}
#line 17757 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__forceinline
PVOID
RtlSecureZeroMemory(
                                PVOID ptr,
         SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;







    while (cnt) {







        *vptr = 0;



        vptr++;
        cnt--;
    }



    return ptr;
}
#line 17814 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD Length;
    WORD Flags;
    BYTE Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;



typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[ 128 ];
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[ 128 ];
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;

typedef OSVERSIONINFOW OSVERSIONINFO;
typedef POSVERSIONINFOW POSVERSIONINFO;
typedef LPOSVERSIONINFOW LPOSVERSIONINFO;






typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR szCSDVersion[ 128 ];
    WORD wServicePackMajor;
    WORD wServicePackMinor;
    WORD wSuiteMask;
    BYTE wProductType;
    BYTE wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR szCSDVersion[ 128 ];
    WORD wServicePackMajor;
    WORD wServicePackMinor;
    WORD wSuiteMask;
    BYTE wProductType;
    BYTE wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;

typedef OSVERSIONINFOEXW OSVERSIONINFOEX;
typedef POSVERSIONINFOEXW POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXW LPOSVERSIONINFOEX;
#line 17959 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
         ULONGLONG ConditionMask,
         DWORD TypeMask,
         BYTE Condition
    );
#line 17984 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__declspec(dllimport)
BOOLEAN
__stdcall
RtlGetProductInfo(
          DWORD OSMajorVersion,
          DWORD OSMinorVersion,
          DWORD SpMajorVersion,
          DWORD SpMinorVersion,
          PDWORD ReturnedProductType
    );
#line 18004 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,
    UmsThreadAffinity,
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
} RTL_UMS_THREAD_INFO_CLASS, *PRTL_UMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield,
} RTL_UMS_SCHEDULER_REASON, *PRTL_UMS_SCHEDULER_REASON;

typedef

void
__stdcall
RTL_UMS_SCHEDULER_ENTRY_POINT(
         RTL_UMS_SCHEDULER_REASON Reason,
         ULONG_PTR ActivationPayload,
         PVOID SchedulerParam
    );

typedef RTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINT;
#line 18093 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__declspec(dllimport)
DWORD
__stdcall
RtlCrc32(
                           const void *Buffer,
         size_t Size,
         DWORD InitialCrc
    );

__declspec(dllimport)
ULONGLONG
__stdcall
RtlCrc64(
                           const void *Buffer,
         size_t Size,
         ULONGLONG InitialCrc
    );
#line 18121 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD Type;
    WORD CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD CreatorBackTraceIndexHigh;
    WORD SpareWORD ;
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;
#line 18152 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#pragma pack(push, 8)

typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;






    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

#pragma pack(pop)

typedef struct _RTL_SRWLOCK {
        PVOID Ptr;
} RTL_SRWLOCK, *PRTL_SRWLOCK;

typedef struct _RTL_CONDITION_VARIABLE {
        PVOID Ptr;
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;


typedef
void
(__stdcall *PAPCFUNC)(
         ULONG_PTR Parameter
    );
typedef LONG (__stdcall *PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef enum _HEAP_INFORMATION_CLASS {

    HeapCompatibilityInformation,
    HeapEnableTerminationOnCorruption


} HEAP_INFORMATION_CLASS;
#line 18209 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef void (__stdcall * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );
typedef void (__stdcall * WORKERCALLBACKFUNC) (PVOID );
typedef void (__stdcall * APC_CALLBACK_FUNCTION) (DWORD , PVOID, PVOID);
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK;
typedef
void
(__stdcall *PFLS_CALLBACK_FUNCTION) (
       PVOID lpFlsData
    );

typedef
BOOLEAN
(__stdcall *PSECURE_MEMORY_CACHE_CALLBACK) (
                            PVOID Addr,
         SIZE_T Range
    );




typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass,




    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4
} ACTIVATION_CONTEXT_INFO_CLASS;




typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    DWORD ulAssemblyIndex;
    DWORD ulFileIndexInAssembly;
} ACTIVATION_CONTEXT_QUERY_INDEX, * PACTIVATION_CONTEXT_QUERY_INDEX;

typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX * PCACTIVATION_CONTEXT_QUERY_INDEX;







typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulFilenameLength;
    DWORD ulPathLength;

    PCWSTR lpFileName;
    PCWSTR lpFilePath;
} ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION;
#line 18281 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulEncodedAssemblyIdentityLength;
    DWORD ulManifestPathType;
    DWORD ulManifestPathLength;
    LARGE_INTEGER liManifestLastWriteTime;
    DWORD ulPolicyPathType;
    DWORD ulPolicyPathLength;
    LARGE_INTEGER liPolicyLastWriteTime;
    DWORD ulMetadataSatelliteRosterIndex;

    DWORD ulManifestVersionMajor;
    DWORD ulManifestVersionMinor;
    DWORD ulPolicyVersionMajor;
    DWORD ulPolicyVersionMinor;
    DWORD ulAssemblyDirectoryNameLength;

    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;

    DWORD ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, * PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION * PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION ;

typedef enum
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;

typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, * PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION * PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION ;

typedef enum
{
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION
} ACTCTX_COMPATIBILITY_ELEMENT_TYPE;

typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
} COMPATIBILITY_CONTEXT_ELEMENT, *PCOMPATIBILITY_CONTEXT_ELEMENT;

typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT *PCCOMPATIBILITY_CONTEXT_ELEMENT;

#pragma warning(push)
#pragma warning(disable: 4200)

typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    DWORD ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements[];
} ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION, * PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;

#pragma warning(pop)

typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION * PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;




typedef struct _SUPPORTED_OS_INFO {
    WORD OsCount;
    WORD MitigationExist;
    WORD OsList[(4)];
} SUPPORTED_OS_INFO, *PSUPPORTED_OS_INFO;

typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    DWORD dwFlags;
    DWORD ulFormatVersion;
    DWORD ulAssemblyCount;
    DWORD ulRootManifestPathType;
    DWORD ulRootManifestPathChars;
    DWORD ulRootConfigurationPathType;
    DWORD ulRootConfigurationPathChars;
    DWORD ulAppDirPathType;
    DWORD ulAppDirPathChars;
    PCWSTR lpRootManifestPath;
    PCWSTR lpRootConfigurationPath;
    PCWSTR lpAppDirPath;
} ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_DETAILED_INFORMATION;




typedef struct _HARDWARE_COUNTER_DATA {
    HARDWARE_COUNTER_TYPE Type;
    DWORD Reserved;
    DWORD64 Value;
} HARDWARE_COUNTER_DATA, *PHARDWARE_COUNTER_DATA;



typedef struct _PERFORMANCE_DATA {
    WORD Size;
    BYTE Version;
    BYTE HwCountersCount;
    DWORD ContextSwitchCount;
    DWORD64 WaitReasonBitMap;
    DWORD64 CycleTime;
    DWORD RetryCount;
    DWORD Reserved;
    HARDWARE_COUNTER_DATA HwCounters[16];
} PERFORMANCE_DATA, *PPERFORMANCE_DATA;
#line 18445 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _EVENTLOGRECORD {
    DWORD Length;
    DWORD Reserved;
    DWORD RecordNumber;
    DWORD TimeGenerated;
    DWORD TimeWritten;
    DWORD EventID;
    WORD EventType;
    WORD NumStrings;
    WORD EventCategory;
    WORD ReservedFlags;
    DWORD ClosingRecordNumber;
    DWORD StringOffset;
    DWORD UserSidLength;
    DWORD UserSidOffset;
    DWORD DataLength;
    DWORD DataOffset;
#line 18473 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
} EVENTLOGRECORD, *PEVENTLOGRECORD;






#pragma warning(push)

#pragma warning(disable: 4200)

struct _EVENTSFORLOGFILE;
typedef struct _EVENTSFORLOGFILE EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;

struct _PACKEDEVENTINFO;
typedef struct _PACKEDEVENTINFO PACKEDEVENTINFO, *PPACKEDEVENTINFO;



struct _EVENTSFORLOGFILE
{
    DWORD ulSize;
    WCHAR szLogicalLogFile[256];
    DWORD ulNumRecords;
    EVENTLOGRECORD pEventLogRecords[];
};

struct _PACKEDEVENTINFO
{
    DWORD ulSize;
    DWORD ulNumEventsForLogFile;
    DWORD ulOffsets[];
};




#pragma warning(pop)
#line 18722 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType = 0x00000001,
    FileSystemType = 0x00000002,
    Win32ServiceOwnProcess = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType = 0x00000004,
    RecognizerType = 0x00000008
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad = 0x00000000,
    SystemLoad = 0x00000001,
    AutoLoad = 0x00000002,
    DemandLoad = 0x00000003,
    DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError = 0x00000000,
    NormalError = 0x00000001,
    SevereError = 0x00000002,
    CriticalError = 0x00000003
} SERVICE_ERROR_TYPE;
#line 18810 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;
#line 18826 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;
#line 18840 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;
#line 18854 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;
#line 18875 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;
#line 18968 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;





typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;





typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;





typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;
#line 19022 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;
#line 19038 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _TAPE_WMI_OPERATIONS {
   DWORD Method;
   DWORD DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;




typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;







extern "C" {




#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\ktmtypes.h"
#line 23 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\ktmtypes.h"
extern "C" {



typedef GUID UOW, *PUOW;
typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;
#line 78 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\ktmtypes.h"
typedef ULONG NOTIFICATION_MASK;
#line 133 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\ktmtypes.h"
typedef struct _TRANSACTION_NOTIFICATION {
    PVOID TransactionKey;
    ULONG TransactionNotification;
    LARGE_INTEGER TmVirtualClock;
    ULONG ArgumentLength;
} TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;

typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    GUID EnlistmentId;
    UOW UOW;
} TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;



typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    GUID TmIdentity;
    ULONG Flags;
} TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;

typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;

typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    SAVEPOINT_ID SavepointId;
} TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    ULONG PropagationCookie;
    GUID UOW;
    GUID TmIdentity;
    ULONG BufferLength;

} TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    ULONG MarshalCookie;
    GUID UOW;
} TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;

typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;







typedef struct _KCRM_MARSHAL_HEADER {
    ULONG VersionMajor;
    ULONG VersionMinor;
    ULONG NumProtocols;
    ULONG Unused;
} KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, * PRKCRM_MARSHAL_HEADER;

typedef struct _KCRM_TRANSACTION_BLOB {
    UOW UOW;
    GUID TmIdentity;
    ULONG IsolationLevel;
    ULONG IsolationFlags;
    ULONG Timeout;
    WCHAR Description[64];
} KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, * PRKCRM_TRANSACTION_BLOB;

typedef struct _KCRM_PROTOCOL_BLOB {
    CRM_PROTOCOL_ID ProtocolId;
                                  ULONG StaticInfoLength;
    ULONG TransactionIdInfoLength;
    ULONG Unused1;
    ULONG Unused2;
} KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, * PRKCRM_PROTOCOL_BLOB;


}
#line 19067 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
#line 19236 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;


typedef enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify,
} TRANSACTION_STATE;


typedef struct _TRANSACTION_BASIC_INFORMATION {
    GUID TransactionId;
    DWORD State;
    DWORD Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    GUID TmIdentity;
    LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    GUID LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    DWORD LogPathLength;
                                WCHAR LogPath[1];

} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;

typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;



typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    GUID OldestTransactionGuid;
} TRANSACTIONMANAGER_OLDEST_INFORMATION, *PTRANSACTIONMANAGER_OLDEST_INFORMATION;



typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
    DWORD IsolationLevel;
    DWORD IsolationFlags;
    LARGE_INTEGER Timeout;
    DWORD Outcome;
    DWORD DescriptionLength;
    WCHAR Description[1];

} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;



typedef struct _TRANSACTION_BIND_INFORMATION {
    HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;

typedef struct _TRANSACTION_ENLISTMENT_PAIR {
    GUID EnlistmentId;
    GUID ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;

typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    DWORD NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1];
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;

typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;


typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
    GUID ResourceManagerId;
    DWORD DescriptionLength;
    WCHAR Description[1];
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;

typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    HANDLE IoCompletionPortHandle;
    ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;




typedef enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation

    ,


    TransactionBindInformation,
    TransactionDTCPrivateInformation
    ,

} TRANSACTION_INFORMATION_CLASS;


typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4

    ,



    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5



} TRANSACTIONMANAGER_INFORMATION_CLASS;



typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;


typedef struct _ENLISTMENT_BASIC_INFORMATION {
    GUID EnlistmentId;
    GUID TransactionId;
    GUID ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;

typedef struct _ENLISTMENT_CRM_INFORMATION {
    GUID CrmTransactionManagerId;
    GUID CrmResourceManagerId;
    GUID CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;



typedef enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;

typedef struct _TRANSACTION_LIST_ENTRY {
    UOW UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;

typedef struct _TRANSACTION_LIST_INFORMATION {
    DWORD NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation[1];
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;






typedef enum _KTMOBJECT_TYPE {

    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID

} KTMOBJECT_TYPE, *PKTMOBJECT_TYPE;
#line 19421 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _KTMOBJECT_CURSOR {





    GUID LastQuery;





    DWORD ObjectIdCount;





    GUID ObjectIds[1];

} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;




}



typedef DWORD TP_VERSION, *PTP_VERSION;

typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;

typedef void (__stdcall *PTP_SIMPLE_CALLBACK)(
                PTP_CALLBACK_INSTANCE Instance,
                PVOID Context
    );

typedef struct _TP_POOL TP_POOL, *PTP_POOL;

typedef enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID,
    TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID
} TP_CALLBACK_PRIORITY;

typedef struct _TP_POOL_STACK_INFORMATION {
    SIZE_T StackReserve;
    SIZE_T StackCommit;
}TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;

typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;

typedef void (__stdcall *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(
                PVOID ObjectContext,
                PVOID CleanupContext
    );
#line 19488 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
typedef struct _TP_CALLBACK_ENVIRON_V3 {
    TP_VERSION Version;
    PTP_POOL Pool;
    PTP_CLEANUP_GROUP CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback;
    PVOID RaceDll;
    struct _ACTIVATION_CONTEXT *ActivationContext;
    PTP_SIMPLE_CALLBACK FinalizationCallback;
    union {
        DWORD Flags;
        struct {
            DWORD LongFunction : 1;
            DWORD Persistent : 1;
            DWORD Private : 30;
        } s;
    } u;
    TP_CALLBACK_PRIORITY CallbackPriority;
    DWORD Size;
} TP_CALLBACK_ENVIRON_V3;

typedef TP_CALLBACK_ENVIRON_V3 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;
#line 19536 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__forceinline
void
TpInitializeCallbackEnviron(
          PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{



    CallbackEnviron->Version = 3;







    CallbackEnviron->Pool = 0;
    CallbackEnviron->CleanupGroup = 0;
    CallbackEnviron->CleanupGroupCancelCallback = 0;
    CallbackEnviron->RaceDll = 0;
    CallbackEnviron->ActivationContext = 0;
    CallbackEnviron->FinalizationCallback = 0;
    CallbackEnviron->u.Flags = 0;



    CallbackEnviron->CallbackPriority = TP_CALLBACK_PRIORITY_NORMAL;
    CallbackEnviron->Size = sizeof(TP_CALLBACK_ENVIRON);



}

__forceinline
void
TpSetCallbackThreadpool(
            PTP_CALLBACK_ENVIRON CallbackEnviron,
            PTP_POOL Pool
    )
{
    CallbackEnviron->Pool = Pool;
}

__forceinline
void
TpSetCallbackCleanupGroup(
             PTP_CALLBACK_ENVIRON CallbackEnviron,
             PTP_CLEANUP_GROUP CleanupGroup,
             PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback
    )
{
    CallbackEnviron->CleanupGroup = CleanupGroup;
    CallbackEnviron->CleanupGroupCancelCallback = CleanupGroupCancelCallback;
}

__forceinline
void
TpSetCallbackActivationContext(
             PTP_CALLBACK_ENVIRON CallbackEnviron,
             struct _ACTIVATION_CONTEXT *ActivationContext
    )
{
    CallbackEnviron->ActivationContext = ActivationContext;
}

__forceinline
void
TpSetCallbackNoActivationContext(
            PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->ActivationContext = (struct _ACTIVATION_CONTEXT *)(LONG_PTR) -1;
}

__forceinline
void
TpSetCallbackLongFunction(
            PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.LongFunction = 1;
}

__forceinline
void
TpSetCallbackRaceWithDll(
            PTP_CALLBACK_ENVIRON CallbackEnviron,
            PVOID DllHandle
    )
{
    CallbackEnviron->RaceDll = DllHandle;
}

__forceinline
void
TpSetCallbackFinalizationCallback(
            PTP_CALLBACK_ENVIRON CallbackEnviron,
            PTP_SIMPLE_CALLBACK FinalizationCallback
    )
{
    CallbackEnviron->FinalizationCallback = FinalizationCallback;
}



__forceinline
void
TpSetCallbackPriority(
            PTP_CALLBACK_ENVIRON CallbackEnviron,
            TP_CALLBACK_PRIORITY Priority
    )
{
    CallbackEnviron->CallbackPriority = Priority;
}



__forceinline
void
TpSetCallbackPersistent(
            PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.Persistent = 1;
}


__forceinline
void
TpDestroyCallbackEnviron(
         PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{






    (CallbackEnviron);
}




typedef struct _TP_WORK TP_WORK, *PTP_WORK;

typedef void (__stdcall *PTP_WORK_CALLBACK)(
                PTP_CALLBACK_INSTANCE Instance,
                PVOID Context,
                PTP_WORK Work
    );

typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;

typedef void (__stdcall *PTP_TIMER_CALLBACK)(
                PTP_CALLBACK_INSTANCE Instance,
                PVOID Context,
                PTP_TIMER Timer
    );

typedef DWORD TP_WAIT_RESULT;

typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;

typedef void (__stdcall *PTP_WAIT_CALLBACK)(
                PTP_CALLBACK_INSTANCE Instance,
                PVOID Context,
                PTP_WAIT Wait,
                TP_WAIT_RESULT WaitResult
    );

typedef struct _TP_IO TP_IO, *PTP_IO;
#line 19787 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
__inline struct _TEB * NtCurrentTeb( void ) { return (struct _TEB *) (ULONG_PTR) __readfsdword (0x18); }
#line 19808 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winnt.h"
}



#pragma warning(pop)
#line 182 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\minwindef.h"




typedef UINT_PTR WPARAM;
typedef LONG_PTR LPARAM;
typedef LONG_PTR LRESULT;
#line 209 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\minwindef.h"
typedef HANDLE *SPHANDLE;
typedef HANDLE *LPHANDLE;
typedef HANDLE HGLOBAL;
typedef HANDLE HLOCAL;
typedef HANDLE GLOBALHANDLE;
typedef HANDLE LOCALHANDLE;







typedef int ( __stdcall *FARPROC)();
typedef int ( __stdcall *NEARPROC)();
typedef int (__stdcall *PROC)();
#line 237 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\minwindef.h"
typedef WORD ATOM;

struct HKEY__{int unused;}; typedef struct HKEY__ *HKEY;
typedef HKEY *PHKEY;
struct HMETAFILE__{int unused;}; typedef struct HMETAFILE__ *HMETAFILE;
struct HINSTANCE__{int unused;}; typedef struct HINSTANCE__ *HINSTANCE;
typedef HINSTANCE HMODULE;
struct HRGN__{int unused;}; typedef struct HRGN__ *HRGN;
struct HRSRC__{int unused;}; typedef struct HRSRC__ *HRSRC;
struct HSPRITE__{int unused;}; typedef struct HSPRITE__ *HSPRITE;
struct HLSURF__{int unused;}; typedef struct HLSURF__ *HLSURF;
struct HSTR__{int unused;}; typedef struct HSTR__ *HSTR;
struct HTASK__{int unused;}; typedef struct HTASK__ *HTASK;
struct HWINSTA__{int unused;}; typedef struct HWINSTA__ *HWINSTA;
struct HKL__{int unused;}; typedef struct HKL__ *HKL;


typedef int HFILE;
#line 263 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\minwindef.h"
typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;



}
#line 24 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\windef.h"
#line 39 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\windef.h"
struct HWND__{int unused;}; typedef struct HWND__ *HWND;
struct HHOOK__{int unused;}; typedef struct HHOOK__ *HHOOK;
#line 63 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\windef.h"
typedef void * HGDIOBJ;






struct HACCEL__{int unused;}; typedef struct HACCEL__ *HACCEL;


struct HBITMAP__{int unused;}; typedef struct HBITMAP__ *HBITMAP;
struct HBRUSH__{int unused;}; typedef struct HBRUSH__ *HBRUSH;


struct HCOLORSPACE__{int unused;}; typedef struct HCOLORSPACE__ *HCOLORSPACE;


struct HDC__{int unused;}; typedef struct HDC__ *HDC;

struct HGLRC__{int unused;}; typedef struct HGLRC__ *HGLRC;
struct HDESK__{int unused;}; typedef struct HDESK__ *HDESK;
struct HENHMETAFILE__{int unused;}; typedef struct HENHMETAFILE__ *HENHMETAFILE;

struct HFONT__{int unused;}; typedef struct HFONT__ *HFONT;

struct HICON__{int unused;}; typedef struct HICON__ *HICON;

struct HMENU__{int unused;}; typedef struct HMENU__ *HMENU;


struct HPALETTE__{int unused;}; typedef struct HPALETTE__ *HPALETTE;
struct HPEN__{int unused;}; typedef struct HPEN__ *HPEN;



struct HWINEVENTHOOK__{int unused;}; typedef struct HWINEVENTHOOK__ *HWINEVENTHOOK;
#line 110 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\windef.h"
struct HMONITOR__{int unused;}; typedef struct HMONITOR__ *HMONITOR;
#line 120 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\windef.h"
struct HUMPD__{int unused;}; typedef struct HUMPD__ *HUMPD;
#line 131 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\windef.h"
typedef HICON HCURSOR;




typedef DWORD COLORREF;







typedef DWORD *LPCOLORREF;
#line 154 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\windef.h"
typedef struct tagRECT
{
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECT, *PRECT, *NPRECT, *LPRECT;

typedef const RECT * LPCRECT;

typedef struct _RECTL
{
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECTL, *PRECTL, *LPRECTL;

typedef const RECTL * LPCRECTL;

typedef struct tagPOINT
{
    LONG x;
    LONG y;
} POINT, *PPOINT, *NPPOINT, *LPPOINT;

typedef struct _POINTL
{
    LONG x;
    LONG y;
} POINTL, *PPOINTL;

typedef struct tagSIZE
{
    LONG cx;
    LONG cy;
} SIZE, *PSIZE, *LPSIZE;

typedef SIZE SIZEL;
typedef SIZE *PSIZEL, *LPSIZEL;

typedef struct tagPOINTS
{

    SHORT x;
    SHORT y;




} POINTS, *PPOINTS, *LPPOINTS;
#line 241 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\windef.h"
}
#line 164 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\windows.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
#line 19 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
#pragma warning(push)

#pragma warning(disable: 4001)
#pragma warning(disable: 4201)
#pragma warning(disable: 4214)







#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\apisetcconv.h"
#line 30 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\minwinbase.h"
#line 13 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\minwinbase.h"
#pragma warning(disable: 4514)

#pragma warning(disable: 4103)


#pragma warning(push)

#pragma warning(disable: 4001)
#pragma warning(disable: 4201)
#pragma warning(disable: 4214)






extern "C" {
#line 45 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\minwinbase.h"
typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        } ;
        PVOID Pointer;
    } ;

    HANDLE hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _OVERLAPPED_ENTRY {
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;
#line 89 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\minwinbase.h"
typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;


typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
              CHAR cFileName[ 260 ];
              CHAR cAlternateFileName[ 14 ];





} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
              WCHAR cFileName[ 260 ];
              WCHAR cAlternateFileName[ 14 ];





} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;

typedef WIN32_FIND_DATAW WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAW PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAW LPWIN32_FIND_DATA;
#line 147 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\minwinbase.h"
typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;




typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;


typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;


typedef enum _FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo,
    FileStandardInfo,
    FileNameInfo,
    FileRenameInfo,
    FileDispositionInfo,
    FileAllocationInfo,
    FileEndOfFileInfo,
    FileStreamInfo,
    FileCompressionInfo,
    FileAttributeTagInfo,
    FileIdBothDirectoryInfo,
    FileIdBothDirectoryRestartInfo,
    FileIoPriorityHintInfo,
    FileRemoteProtocolInfo,
    FileFullDirectoryInfo,
    FileFullDirectoryRestartInfo,

    FileStorageInfo,
    FileAlignmentInfo,
    FileIdInfo,
    FileIdExtdDirectoryInfo,
    FileIdExtdDirectoryRestartInfo,

    MaximumFileInfoByHandleClass
} FILE_INFO_BY_HANDLE_CLASS, *PFILE_INFO_BY_HANDLE_CLASS;


typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

typedef
void
(__stdcall *LPOVERLAPPED_COMPLETION_ROUTINE)(
            DWORD dwErrorCode,
            DWORD dwNumberOfBytesTransfered,
            LPOVERLAPPED lpOverlapped
    );




typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    } ;
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;
#line 244 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\minwinbase.h"
typedef struct _REASON_CONTEXT {
    ULONG Version;
    DWORD Flags;
    union {
        struct {
            HMODULE LocalizedReasonModule;
            ULONG LocalizedReasonId;
            ULONG ReasonStringCount;
            LPWSTR *ReasonStrings;

        } Detailed;

        LPWSTR SimpleReasonString;
    } Reason;
} REASON_CONTEXT, *PREASON_CONTEXT;
#line 273 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\minwinbase.h"
typedef DWORD (__stdcall *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;


typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;







typedef PCONTEXT LPCONTEXT;
#line 417 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\minwinbase.h"
}






#pragma warning(pop)
#line 31 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"






#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processenv.h"
#line 38 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processenv.h"
extern "C" {
#line 50 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processenv.h"
__declspec(dllimport)

LPCH
__stdcall
GetEnvironmentStrings(
    void
    );


__declspec(dllimport)

LPWCH
__stdcall
GetEnvironmentStringsW(
    void
    );
#line 74 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processenv.h"
__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsW(
                                     LPWCH NewEnvironment
    );





__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsA(
                                     LPCH penv
    );

__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsW(
                                     LPWCH penv
    );







__declspec(dllimport)
HANDLE
__stdcall
GetStdHandle(
         DWORD nStdHandle
    );


__declspec(dllimport)
BOOL
__stdcall
SetStdHandle(
         DWORD nStdHandle,
         HANDLE hHandle
    );





__declspec(dllimport)
BOOL
__stdcall
SetStdHandleEx(
         DWORD nStdHandle,
         HANDLE hHandle,
              PHANDLE phPrevValue
    );
#line 148 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processenv.h"
__declspec(dllimport)
LPSTR
__stdcall
GetCommandLineA(
    void
    );

__declspec(dllimport)
LPWSTR
__stdcall
GetCommandLineW(
    void
    );
#line 179 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processenv.h"
__declspec(dllimport)

DWORD
__stdcall
GetEnvironmentVariableA(
             LPCSTR lpName,
                                           LPSTR lpBuffer,
         DWORD nSize
    );

__declspec(dllimport)

DWORD
__stdcall
GetEnvironmentVariableW(
             LPCWSTR lpName,
                                           LPWSTR lpBuffer,
         DWORD nSize
    );







__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableA(
         LPCSTR lpName,
             LPCSTR lpValue
    );

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableW(
         LPCWSTR lpName,
             LPCWSTR lpValue
    );







__declspec(dllimport)

DWORD
__stdcall
ExpandEnvironmentStringsA(
         LPCSTR lpSrc,
                                       LPSTR lpDst,
         DWORD nSize
    );

__declspec(dllimport)

DWORD
__stdcall
ExpandEnvironmentStringsW(
         LPCWSTR lpSrc,
                                       LPWSTR lpDst,
         DWORD nSize
    );







__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryA(
         LPCSTR lpPathName
    );

__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryW(
         LPCWSTR lpPathName
    );







__declspec(dllimport)

DWORD
__stdcall
GetCurrentDirectoryA(
         DWORD nBufferLength,
                                                   LPSTR lpBuffer
    );

__declspec(dllimport)

DWORD
__stdcall
GetCurrentDirectoryW(
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer
    );







__declspec(dllimport)
DWORD
__stdcall
SearchPathW(
             LPCWSTR lpPath,
         LPCWSTR lpFileName,
             LPCWSTR lpExtension,
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer,
              LPWSTR * lpFilePart
    );
#line 323 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processenv.h"
__declspec(dllimport)
DWORD
__stdcall
SearchPathA(
             LPCSTR lpPath,
         LPCSTR lpFileName,
             LPCSTR lpExtension,
         DWORD nBufferLength,
                                                   LPSTR lpBuffer,
              LPSTR * lpFilePart
    );





__declspec(dllimport)
BOOL
__stdcall
NeedCurrentDirectoryForExePathA(
         LPCSTR ExeName
    );

__declspec(dllimport)
BOOL
__stdcall
NeedCurrentDirectoryForExePathW(
         LPCWSTR ExeName
    );
#line 372 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processenv.h"
}
#line 37 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
#line 41 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
extern "C" {
#line 74 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
LONG
__stdcall
CompareFileTime(
         const FILETIME * lpFileTime1,
         const FILETIME * lpFileTime2
    );
#line 90 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryA(
         LPCSTR lpPathName,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryW(
         LPCWSTR lpPathName,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#line 119 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
HANDLE
__stdcall
CreateFileA(
         LPCSTR lpFileName,
         DWORD dwDesiredAccess,
         DWORD dwShareMode,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         DWORD dwCreationDisposition,
         DWORD dwFlagsAndAttributes,
             HANDLE hTemplateFile
    );

__declspec(dllimport)
HANDLE
__stdcall
CreateFileW(
         LPCWSTR lpFileName,
         DWORD dwDesiredAccess,
         DWORD dwShareMode,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes,
         DWORD dwCreationDisposition,
         DWORD dwFlagsAndAttributes,
             HANDLE hTemplateFile
    );







__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceW(
         DWORD dwFlags,
         LPCWSTR lpDeviceName,
             LPCWSTR lpTargetPath
    );
#line 172 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
DeleteFileA(
         LPCSTR lpFileName
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteFileW(
         LPCWSTR lpFileName
    );
#line 199 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointW(
         LPCWSTR lpszVolumeMountPoint
    );






__declspec(dllimport)
BOOL
__stdcall
FileTimeToLocalFileTime(
         const FILETIME * lpFileTime,
          LPFILETIME lpLocalFileTime
    );
#line 230 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
FindClose(
            HANDLE hFindFile
    );
#line 245 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
FindCloseChangeNotification(
         HANDLE hChangeHandle
    );


__declspec(dllimport)
HANDLE
__stdcall
FindFirstChangeNotificationA(
         LPCSTR lpPathName,
         BOOL bWatchSubtree,
         DWORD dwNotifyFilter
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstChangeNotificationW(
         LPCWSTR lpPathName,
         BOOL bWatchSubtree,
         DWORD dwNotifyFilter
    );







__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileA(
         LPCSTR lpFileName,
          LPWIN32_FIND_DATAA lpFindFileData
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileW(
         LPCWSTR lpFileName,
          LPWIN32_FIND_DATAW lpFindFileData
    );
#line 309 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileExA(
         LPCSTR lpFileName,
         FINDEX_INFO_LEVELS fInfoLevelId,
                                                 LPVOID lpFindFileData,
         FINDEX_SEARCH_OPS fSearchOp,
               LPVOID lpSearchFilter,
         DWORD dwAdditionalFlags
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileExW(
         LPCWSTR lpFileName,
         FINDEX_INFO_LEVELS fInfoLevelId,
                                                 LPVOID lpFindFileData,
         FINDEX_SEARCH_OPS fSearchOp,
               LPVOID lpSearchFilter,
         DWORD dwAdditionalFlags
    );
#line 348 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeW(
                                  LPWSTR lpszVolumeName,
         DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindNextChangeNotification(
         HANDLE hChangeHandle
    );
#line 376 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
FindNextFileA(
         HANDLE hFindFile,
          LPWIN32_FIND_DATAA lpFindFileData
    );

__declspec(dllimport)
BOOL
__stdcall
FindNextFileW(
         HANDLE hFindFile,
          LPWIN32_FIND_DATAW lpFindFileData
    );
#line 405 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeW(
            HANDLE hFindVolume,
                                  LPWSTR lpszVolumeName,
         DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindVolumeClose(
         HANDLE hFindVolume
    );
#line 434 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
FlushFileBuffers(
         HANDLE hFile
    );
#line 449 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceA(
             LPCSTR lpRootPathName,
              LPDWORD lpSectorsPerCluster,
              LPDWORD lpBytesPerSector,
              LPDWORD lpNumberOfFreeClusters,
              LPDWORD lpTotalNumberOfClusters
    );

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceW(
             LPCWSTR lpRootPathName,
              LPDWORD lpSectorsPerCluster,
              LPDWORD lpBytesPerSector,
              LPDWORD lpNumberOfFreeClusters,
              LPDWORD lpTotalNumberOfClusters
    );
#line 484 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExA(
             LPCSTR lpDirectoryName,
              PULARGE_INTEGER lpFreeBytesAvailableToCaller,
              PULARGE_INTEGER lpTotalNumberOfBytes,
              PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExW(
             LPCWSTR lpDirectoryName,
              PULARGE_INTEGER lpFreeBytesAvailableToCaller,
              PULARGE_INTEGER lpTotalNumberOfBytes,
              PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
#line 517 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
UINT
__stdcall
GetDriveTypeA(
             LPCSTR lpRootPathName
    );

__declspec(dllimport)
UINT
__stdcall
GetDriveTypeW(
             LPCWSTR lpRootPathName
    );







__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesA(
         LPCSTR lpFileName
    );

__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesW(
         LPCWSTR lpFileName
    );
#line 564 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;
#line 580 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExA(
         LPCSTR lpFileName,
         GET_FILEEX_INFO_LEVELS fInfoLevelId,
                                                          LPVOID lpFileInformation
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExW(
         LPCWSTR lpFileName,
         GET_FILEEX_INFO_LEVELS fInfoLevelId,
                                                          LPVOID lpFileInformation
    );
#line 611 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetFileInformationByHandle(
         HANDLE hFile,
          LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );


__declspec(dllimport)
DWORD
__stdcall
GetFileSize(
         HANDLE hFile,
              LPDWORD lpFileSizeHigh
    );


__declspec(dllimport)
BOOL
__stdcall
GetFileSizeEx(
         HANDLE hFile,
          PLARGE_INTEGER lpFileSize
    );


__declspec(dllimport)
BOOL
__stdcall
GetFileTime(
         HANDLE hFile,
              LPFILETIME lpCreationTime,
              LPFILETIME lpLastAccessTime,
              LPFILETIME lpLastWriteTime
    );


__declspec(dllimport)
DWORD
__stdcall
GetFileType(
         HANDLE hFile
    );





__declspec(dllimport)
DWORD
__stdcall
GetFinalPathNameByHandleA(
         HANDLE hFile,
                              LPSTR lpszFilePath,
         DWORD cchFilePath,
         DWORD dwFlags
    );

__declspec(dllimport)
DWORD
__stdcall
GetFinalPathNameByHandleW(
         HANDLE hFile,
                              LPWSTR lpszFilePath,
         DWORD cchFilePath,
         DWORD dwFlags
    );
#line 701 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameA(
         LPCSTR lpFileName,
         DWORD nBufferLength,
                                                   LPSTR lpBuffer,
                 LPSTR * lpFilePart
    );

__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameW(
         LPCWSTR lpFileName,
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer,
                 LPWSTR * lpFilePart
    );







__declspec(dllimport)
DWORD
__stdcall
GetLogicalDrives(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetLogicalDriveStringsW(
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer
    );






__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameA(
         LPCSTR lpszShortPath,
                                               LPSTR lpszLongPath,
         DWORD cchBuffer
    );

__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameW(
         LPCWSTR lpszShortPath,
                                               LPWSTR lpszLongPath,
         DWORD cchBuffer
    );







__declspec(dllimport)

DWORD
__stdcall
GetShortPathNameW(
         LPCWSTR lpszLongPath,
                                               LPWSTR lpszShortPath,
         DWORD cchBuffer
    );






__declspec(dllimport)
UINT
__stdcall
GetTempFileNameW(
         LPCWSTR lpPathName,
         LPCWSTR lpPrefixString,
         UINT uUnique,
                           LPWSTR lpTempFileName
    );
#line 809 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationByHandleW(
         HANDLE hFile,
                                      LPWSTR lpVolumeNameBuffer,
         DWORD nVolumeNameSize,
              LPDWORD lpVolumeSerialNumber,
              LPDWORD lpMaximumComponentLength,
              LPDWORD lpFileSystemFlags,
                                          LPWSTR lpFileSystemNameBuffer,
         DWORD nFileSystemNameSize
    );




__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationW(
             LPCWSTR lpRootPathName,
                                      LPWSTR lpVolumeNameBuffer,
         DWORD nVolumeNameSize,
              LPDWORD lpVolumeSerialNumber,
              LPDWORD lpMaximumComponentLength,
              LPDWORD lpFileSystemFlags,
                                          LPWSTR lpFileSystemNameBuffer,
         DWORD nFileSystemNameSize
    );






__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameW(
         LPCWSTR lpszFileName,
                                  LPWSTR lpszVolumePathName,
         DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
LocalFileTimeToFileTime(
         const FILETIME * lpLocalFileTime,
          LPFILETIME lpFileTime
    );


__declspec(dllimport)
BOOL
__stdcall
LockFile(
         HANDLE hFile,
         DWORD dwFileOffsetLow,
         DWORD dwFileOffsetHigh,
         DWORD nNumberOfBytesToLockLow,
         DWORD nNumberOfBytesToLockHigh
    );
#line 887 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
LockFileEx(
         HANDLE hFile,
         DWORD dwFlags,
               DWORD dwReserved,
         DWORD nNumberOfBytesToLockLow,
         DWORD nNumberOfBytesToLockHigh,
            LPOVERLAPPED lpOverlapped
    );
#line 907 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceW(
             LPCWSTR lpDeviceName,
                                         LPWSTR lpTargetPath,
         DWORD ucchMax
    );
#line 928 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)

BOOL
__stdcall
ReadFile(
         HANDLE hFile,
                                                                                                  LPVOID lpBuffer,
         DWORD nNumberOfBytesToRead,
              LPDWORD lpNumberOfBytesRead,
                LPOVERLAPPED lpOverlapped
    );
#line 948 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)

BOOL
__stdcall
ReadFileEx(
         HANDLE hFile,
                                                                         LPVOID lpBuffer,
         DWORD nNumberOfBytesToRead,
            LPOVERLAPPED lpOverlapped,
         LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


__declspec(dllimport)

BOOL
__stdcall
ReadFileScatter(
         HANDLE hFile,
         FILE_SEGMENT_ELEMENT aSegmentArray[],
         DWORD nNumberOfBytesToRead,
               LPDWORD lpReserved,
            LPOVERLAPPED lpOverlapped
    );
#line 981 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryA(
         LPCSTR lpPathName
    );

__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryW(
         LPCWSTR lpPathName
    );







__declspec(dllimport)
BOOL
__stdcall
SetEndOfFile(
         HANDLE hFile
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesA(
         LPCSTR lpFileName,
         DWORD dwFileAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesW(
         LPCWSTR lpFileName,
         DWORD dwFileAttributes
    );
#line 1034 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
SetFileInformationByHandle(
         HANDLE hFile,
         FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
                                   LPVOID lpFileInformation,
         DWORD dwBufferSize
    );
#line 1054 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
DWORD
__stdcall
SetFilePointer(
         HANDLE hFile,
         LONG lDistanceToMove,
                PLONG lpDistanceToMoveHigh,
         DWORD dwMoveMethod
    );
#line 1072 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
SetFilePointerEx(
         HANDLE hFile,
         LARGE_INTEGER liDistanceToMove,
              PLARGE_INTEGER lpNewFilePointer,
         DWORD dwMoveMethod
    );
#line 1090 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
SetFileTime(
         HANDLE hFile,
             const FILETIME * lpCreationTime,
             const FILETIME * lpLastAccessTime,
             const FILETIME * lpLastWriteTime
    );





__declspec(dllimport)
BOOL
__stdcall
SetFileValidData(
         HANDLE hFile,
         LONGLONG ValidDataLength
    );




__declspec(dllimport)
BOOL
__stdcall
UnlockFile(
         HANDLE hFile,
         DWORD dwFileOffsetLow,
         DWORD dwFileOffsetHigh,
         DWORD nNumberOfBytesToUnlockLow,
         DWORD nNumberOfBytesToUnlockHigh
    );
#line 1134 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
UnlockFileEx(
         HANDLE hFile,
               DWORD dwReserved,
         DWORD nNumberOfBytesToUnlockLow,
         DWORD nNumberOfBytesToUnlockHigh,
            LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
WriteFile(
         HANDLE hFile,
                                                LPCVOID lpBuffer,
         DWORD nNumberOfBytesToWrite,
              LPDWORD lpNumberOfBytesWritten,
                LPOVERLAPPED lpOverlapped
    );
#line 1165 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
WriteFileEx(
         HANDLE hFile,
                                                LPCVOID lpBuffer,
         DWORD nNumberOfBytesToWrite,
            LPOVERLAPPED lpOverlapped,
         LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


__declspec(dllimport)
BOOL
__stdcall
WriteFileGather(
         HANDLE hFile,
         FILE_SEGMENT_ELEMENT aSegmentArray[],
         DWORD nNumberOfBytesToWrite,
               LPDWORD lpReserved,
            LPOVERLAPPED lpOverlapped
    );
#line 1203 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
DWORD
__stdcall
GetTempPathW(
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer
    );






__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointW(
         LPCWSTR lpszVolumeMountPoint,
                                  LPWSTR lpszVolumeName,
         DWORD cchBufferLength
    );
#line 1233 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameW(
         LPCWSTR lpszVolumeName,
                                                                                          LPWCH lpszVolumePathNames,
         DWORD cchBufferLength,
          PDWORD lpcchReturnLength
    );
#line 1260 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
    DWORD dwSize;
    DWORD dwFileAttributes;
    DWORD dwFileFlags;
    DWORD dwSecurityQosFlags;
    LPSECURITY_ATTRIBUTES lpSecurityAttributes;
    HANDLE hTemplateFile;
} CREATEFILE2_EXTENDED_PARAMETERS, *PCREATEFILE2_EXTENDED_PARAMETERS, *LPCREATEFILE2_EXTENDED_PARAMETERS;

__declspec(dllimport)
HANDLE
__stdcall
CreateFile2(
         LPCWSTR lpFileName,
         DWORD dwDesiredAccess,
         DWORD dwShareMode,
         DWORD dwCreationDisposition,
             LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams
    );
#line 1301 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
BOOL
__stdcall
SetFileIoOverlappedRange(
         HANDLE FileHandle,
         PUCHAR OverlappedRangeStart,
         ULONG Length
    );
#line 1323 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeA(
         LPCSTR lpFileName,
              LPDWORD lpFileSizeHigh
    );

__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeW(
         LPCWSTR lpFileName,
              LPDWORD lpFileSizeHigh
    );
#line 1358 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fileapi.h"
}
#line 38 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\debugapi.h"
#line 37 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\debugapi.h"
extern "C" {
#line 51 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\debugapi.h"
__declspec(dllimport)
BOOL
__stdcall
IsDebuggerPresent(
    void
    );
#line 67 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\debugapi.h"
__declspec(dllimport)
void
__stdcall
DebugBreak(
    void
    );
#line 82 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\debugapi.h"
__declspec(dllimport)
void
__stdcall
OutputDebugStringA(
             LPCSTR lpOutputString
    );

__declspec(dllimport)
void
__stdcall
OutputDebugStringW(
             LPCWSTR lpOutputString
    );
#line 114 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\debugapi.h"
__declspec(dllimport)
BOOL
__stdcall
ContinueDebugEvent(
         DWORD dwProcessId,
         DWORD dwThreadId,
         DWORD dwContinueStatus
    );


__declspec(dllimport)
BOOL
__stdcall
WaitForDebugEvent(
          LPDEBUG_EVENT lpDebugEvent,
         DWORD dwMilliseconds
    );


__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcess(
         DWORD dwProcessId
    );


__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcessStop(
         DWORD dwProcessId
    );





__declspec(dllimport)
BOOL
__stdcall
CheckRemoteDebuggerPresent(
         HANDLE hProcess,
          PBOOL pbDebuggerPresent
    );
#line 173 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\debugapi.h"
}
#line 39 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\utilapiset.h"
#line 32 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\utilapiset.h"
extern "C" {






__declspec(dllimport)

PVOID
__stdcall
EncodePointer(
             PVOID Ptr
    );


__declspec(dllimport)

PVOID
__stdcall
DecodePointer(
             PVOID Ptr
    );
#line 64 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\utilapiset.h"
__declspec(dllimport)

PVOID
__stdcall
EncodeSystemPointer(
             PVOID Ptr
    );


__declspec(dllimport)

PVOID
__stdcall
DecodeSystemPointer(
             PVOID Ptr
    );


__declspec(dllimport)
BOOL
__stdcall
Beep(
         DWORD dwFreq,
         DWORD dwDuration
    );






}
#line 40 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\handleapi.h"
#line 32 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\handleapi.h"
extern "C" {
#line 47 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\handleapi.h"
__declspec(dllimport)
BOOL
__stdcall
CloseHandle(
         HANDLE hObject
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateHandle(
         HANDLE hSourceProcessHandle,
         HANDLE hSourceHandle,
         HANDLE hTargetProcessHandle,
             LPHANDLE lpTargetHandle,
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         DWORD dwOptions
    );
#line 76 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\handleapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetHandleInformation(
         HANDLE hObject,
          LPDWORD lpdwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
SetHandleInformation(
         HANDLE hObject,
         DWORD dwMask,
         DWORD dwFlags
    );






}
#line 41 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\errhandlingapi.h"
#line 36 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\errhandlingapi.h"
extern "C" {
#line 52 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\errhandlingapi.h"
typedef LONG (__stdcall *PTOP_LEVEL_EXCEPTION_FILTER)(
         struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;
#line 69 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\errhandlingapi.h"
__declspec(dllimport)

void
__stdcall
RaiseException(
         DWORD dwExceptionCode,
         DWORD dwExceptionFlags,
         DWORD nNumberOfArguments,
                                       const ULONG_PTR * lpArguments
    );
#line 89 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\errhandlingapi.h"
__declspec(dllimport)
LONG
__stdcall
UnhandledExceptionFilter(
         struct _EXCEPTION_POINTERS * ExceptionInfo
    );


__declspec(dllimport)
LPTOP_LEVEL_EXCEPTION_FILTER
__stdcall
SetUnhandledExceptionFilter(
             LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );
#line 114 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\errhandlingapi.h"
__declspec(dllimport)

DWORD
__stdcall
GetLastError(
    void
    );




__declspec(dllimport)
void
__stdcall
SetLastError(
         DWORD dwErrCode
    );
#line 143 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\errhandlingapi.h"
__declspec(dllimport)
UINT
__stdcall
GetErrorMode(
    void
    );




__declspec(dllimport)
UINT
__stdcall
SetErrorMode(
         UINT uMode
    );
#line 175 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\errhandlingapi.h"
__declspec(dllimport)

PVOID
__stdcall
AddVectoredExceptionHandler(
         ULONG First,
         PVECTORED_EXCEPTION_HANDLER Handler
    );


__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredExceptionHandler(
         PVOID Handle
    );


__declspec(dllimport)

PVOID
__stdcall
AddVectoredContinueHandler(
         ULONG First,
         PVECTORED_EXCEPTION_HANDLER Handler
    );


__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredContinueHandler(
         PVOID Handle
    );
#line 249 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\errhandlingapi.h"
}
#line 42 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fibersapi.h"
#line 36 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fibersapi.h"
extern "C" {
#line 55 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fibersapi.h"
__declspec(dllimport)
DWORD
__stdcall
FlsAlloc(
             PFLS_CALLBACK_FUNCTION lpCallback
    );


__declspec(dllimport)
PVOID
__stdcall
FlsGetValue(
         DWORD dwFlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
FlsSetValue(
         DWORD dwFlsIndex,
             PVOID lpFlsData
    );


__declspec(dllimport)
BOOL
__stdcall
FlsFree(
         DWORD dwFlsIndex
    );
#line 104 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fibersapi.h"
__declspec(dllimport)
BOOL
__stdcall
IsThreadAFiber(
    void
    );
#line 123 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\fibersapi.h"
}
#line 43 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\namedpipeapi.h"
#line 37 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\namedpipeapi.h"
extern "C" {
#line 47 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\namedpipeapi.h"
__declspec(dllimport)
BOOL
__stdcall
CreatePipe(
          PHANDLE hReadPipe,
          PHANDLE hWritePipe,
             LPSECURITY_ATTRIBUTES lpPipeAttributes,
         DWORD nSize
    );


__declspec(dllimport)
BOOL
__stdcall
ConnectNamedPipe(
         HANDLE hNamedPipe,
                LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
DisconnectNamedPipe(
         HANDLE hNamedPipe
    );


__declspec(dllimport)
BOOL
__stdcall
SetNamedPipeHandleState(
         HANDLE hNamedPipe,
             LPDWORD lpMode,
             LPDWORD lpMaxCollectionCount,
             LPDWORD lpCollectDataTimeout
    );


__declspec(dllimport)
BOOL
__stdcall
PeekNamedPipe(
         HANDLE hNamedPipe,
                                                         LPVOID lpBuffer,
         DWORD nBufferSize,
              LPDWORD lpBytesRead,
              LPDWORD lpTotalBytesAvail,
              LPDWORD lpBytesLeftThisMessage
    );


__declspec(dllimport)
BOOL
__stdcall
TransactNamedPipe(
         HANDLE hNamedPipe,
                                        LPVOID lpInBuffer,
         DWORD nInBufferSize,
                                                            LPVOID lpOutBuffer,
         DWORD nOutBufferSize,
          LPDWORD lpBytesRead,
                LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateNamedPipeW(
         LPCWSTR lpName,
         DWORD dwOpenMode,
         DWORD dwPipeMode,
         DWORD nMaxInstances,
         DWORD nOutBufferSize,
         DWORD nInBufferSize,
         DWORD nDefaultTimeOut,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );






__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeW(
         LPCWSTR lpNamedPipeName,
         DWORD nTimeOut
    );
#line 148 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\namedpipeapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientComputerNameW(
         HANDLE Pipe,
                                                 LPWSTR ClientComputerName,
         ULONG ClientComputerNameLength
    );
#line 171 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\namedpipeapi.h"
__declspec(dllimport)

BOOL
__stdcall
ImpersonateNamedPipeClient(
         HANDLE hNamedPipe
    );






}
#line 44 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\profileapi.h"
#line 32 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\profileapi.h"
extern "C" {






__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceCounter(
          LARGE_INTEGER * lpPerformanceCount
    );


__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceFrequency(
          LARGE_INTEGER * lpFrequency
    );



}
#line 45 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\heapapi.h"
#line 35 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\heapapi.h"
extern "C" {
#line 46 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\heapapi.h"
typedef struct _HEAP_SUMMARY {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
} HEAP_SUMMARY, *PHEAP_SUMMARY;
typedef PHEAP_SUMMARY LPHEAP_SUMMARY;
#line 66 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\heapapi.h"
__declspec(dllimport)

HANDLE
__stdcall
HeapCreate(
         DWORD flOptions,
         SIZE_T dwInitialSize,
         SIZE_T dwMaximumSize
    );


__declspec(dllimport)
BOOL
__stdcall
HeapDestroy(
         HANDLE hHeap
    );
#line 92 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\heapapi.h"
__declspec(dllimport)


LPVOID
__stdcall
HeapAlloc(
         HANDLE hHeap,
         DWORD dwFlags,
         SIZE_T dwBytes
    );


__declspec(dllimport)



LPVOID
__stdcall
HeapReAlloc(
            HANDLE hHeap,
         DWORD dwFlags,
                    LPVOID lpMem,
         SIZE_T dwBytes
    );


__declspec(dllimport)

BOOL
__stdcall
HeapFree(
            HANDLE hHeap,
         DWORD dwFlags,
                                        LPVOID lpMem
    );


__declspec(dllimport)
SIZE_T
__stdcall
HeapSize(
         HANDLE hHeap,
         DWORD dwFlags,
         LPCVOID lpMem
    );
#line 146 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\heapapi.h"
__declspec(dllimport)
BOOL
__stdcall
HeapValidate(
         HANDLE hHeap,
         DWORD dwFlags,
             LPCVOID lpMem
    );


__declspec(dllimport)
SIZE_T
__stdcall
HeapCompact(
         HANDLE hHeap,
         DWORD dwFlags
    );





BOOL
__stdcall
HeapSummary(
         HANDLE hHeap,
         DWORD dwFlags,
          LPHEAP_SUMMARY lpSummary
    );
#line 186 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\heapapi.h"
__declspec(dllimport)
HANDLE
__stdcall
GetProcessHeap(
    void
    );
#line 201 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\heapapi.h"
__declspec(dllimport)
DWORD
__stdcall
GetProcessHeaps(
         DWORD NumberOfHeaps,
                                           PHANDLE ProcessHeaps
    );


__declspec(dllimport)
BOOL
__stdcall
HeapLock(
         HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapUnlock(
         HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapWalk(
         HANDLE hHeap,
            LPPROCESS_HEAP_ENTRY lpEntry
    );


__declspec(dllimport)
BOOL
__stdcall
HeapSetInformation(
             HANDLE HeapHandle,
         HEAP_INFORMATION_CLASS HeapInformationClass,
                                                PVOID HeapInformation,
         SIZE_T HeapInformationLength
    );


__declspec(dllimport)
BOOL
__stdcall
HeapQueryInformation(
             HANDLE HeapHandle,
         HEAP_INFORMATION_CLASS HeapInformationClass,
                                                                    PVOID HeapInformation,
         SIZE_T HeapInformationLength,
              PSIZE_T ReturnLength
    );
#line 266 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\heapapi.h"
}
#line 46 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\ioapiset.h"
#line 37 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\ioapiset.h"
extern "C" {
#line 49 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\ioapiset.h"
__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResult(
         HANDLE hFile,
         LPOVERLAPPED lpOverlapped,
          LPDWORD lpNumberOfBytesTransferred,
         BOOL bWait
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateIoCompletionPort(
         HANDLE FileHandle,
             HANDLE ExistingCompletionPort,
         ULONG_PTR CompletionKey,
         DWORD NumberOfConcurrentThreads
    );


__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatus(
         HANDLE CompletionPort,
          LPDWORD lpNumberOfBytesTransferred,
          PULONG_PTR lpCompletionKey,
          LPOVERLAPPED * lpOverlapped,
         DWORD dwMilliseconds
    );





__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatusEx(
         HANDLE CompletionPort,
                                                   LPOVERLAPPED_ENTRY lpCompletionPortEntries,
         ULONG ulCount,
          PULONG ulNumEntriesRemoved,
         DWORD dwMilliseconds,
         BOOL fAlertable
    );




__declspec(dllimport)
BOOL
__stdcall
PostQueuedCompletionStatus(
         HANDLE CompletionPort,
         DWORD dwNumberOfBytesTransferred,
         ULONG_PTR dwCompletionKey,
             LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
DeviceIoControl(
         HANDLE hDevice,
         DWORD dwIoControlCode,
                                        LPVOID lpInBuffer,
         DWORD nInBufferSize,
                                                                LPVOID lpOutBuffer,
         DWORD nOutBufferSize,
              LPDWORD lpBytesReturned,
                LPOVERLAPPED lpOverlapped
    );





__declspec(dllimport)
BOOL
__stdcall
CancelIoEx(
         HANDLE hFile,
             LPOVERLAPPED lpOverlapped
    );
#line 156 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\ioapiset.h"
__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResultEx(
         HANDLE hFile,
         LPOVERLAPPED lpOverlapped,
          LPDWORD lpNumberOfBytesTransferred,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );
#line 175 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\ioapiset.h"
__declspec(dllimport)
BOOL
__stdcall
CancelIo(
         HANDLE hFile
    );





__declspec(dllimport)
BOOL
__stdcall
CancelSynchronousIo(
         HANDLE hThread
    );
#line 207 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\ioapiset.h"
}
#line 47 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
#line 38 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
extern "C" {
#line 57 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;
#line 74 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
void
__stdcall
InitializeSRWLock(
          PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
ReleaseSRWLockExclusive(
            PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
ReleaseSRWLockShared(
            PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
AcquireSRWLockExclusive(
            PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
AcquireSRWLockShared(
            PSRWLOCK SRWLock
    );


__declspec(dllimport)

BOOLEAN
__stdcall
TryAcquireSRWLockExclusive(
            PSRWLOCK SRWLock
    );


__declspec(dllimport)

BOOLEAN
__stdcall
TryAcquireSRWLockShared(
            PSRWLOCK SRWLock
    );
#line 159 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
void
__stdcall
InitializeCriticalSection(
          LPCRITICAL_SECTION lpCriticalSection
    );
#line 176 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
void
__stdcall
EnterCriticalSection(
            LPCRITICAL_SECTION lpCriticalSection
    );


__declspec(dllimport)
void
__stdcall
LeaveCriticalSection(
            LPCRITICAL_SECTION lpCriticalSection
    );
#line 199 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)

BOOL
__stdcall
InitializeCriticalSectionAndSpinCount(
          LPCRITICAL_SECTION lpCriticalSection,
         DWORD dwSpinCount
    );
#line 219 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
BOOL
__stdcall
InitializeCriticalSectionEx(
          LPCRITICAL_SECTION lpCriticalSection,
         DWORD dwSpinCount,
         DWORD Flags
    );
#line 238 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
DWORD
__stdcall
SetCriticalSectionSpinCount(
            LPCRITICAL_SECTION lpCriticalSection,
         DWORD dwSpinCount
    );
#line 257 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
BOOL
__stdcall
TryEnterCriticalSection(
            LPCRITICAL_SECTION lpCriticalSection
    );




__declspec(dllimport)
void
__stdcall
DeleteCriticalSection(
            LPCRITICAL_SECTION lpCriticalSection
    );
#line 283 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;
#line 304 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
typedef
BOOL
(__stdcall *PINIT_ONCE_FN) (
            PINIT_ONCE InitOnce,
                PVOID Parameter,
                                  PVOID *Context
    );




__declspec(dllimport)
void
__stdcall
InitOnceInitialize(
          PINIT_ONCE InitOnce
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceExecuteOnce(
            PINIT_ONCE InitOnce,
                    PINIT_ONCE_FN InitFn,
                PVOID Parameter,
                                  LPVOID * Context
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceBeginInitialize(
            LPINIT_ONCE lpInitOnce,
         DWORD dwFlags,
          PBOOL fPending,
                                  LPVOID * lpContext
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceComplete(
            LPINIT_ONCE lpInitOnce,
         DWORD dwFlags,
             LPVOID lpContext
    );
#line 361 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;
#line 378 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
void
__stdcall
InitializeConditionVariable(
          PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
void
__stdcall
WakeConditionVariable(
            PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
void
__stdcall
WakeAllConditionVariable(
            PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
BOOL
__stdcall
SleepConditionVariableCS(
            PCONDITION_VARIABLE ConditionVariable,
            PCRITICAL_SECTION CriticalSection,
         DWORD dwMilliseconds
    );


__declspec(dllimport)
BOOL
__stdcall
SleepConditionVariableSRW(
            PCONDITION_VARIABLE ConditionVariable,
            PSRWLOCK SRWLock,
         DWORD dwMilliseconds,
         ULONG Flags
    );
#line 429 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
BOOL
__stdcall
SetEvent(
         HANDLE hEvent
    );


__declspec(dllimport)
BOOL
__stdcall
ResetEvent(
         HANDLE hEvent
    );


__declspec(dllimport)
BOOL
__stdcall
ReleaseSemaphore(
         HANDLE hSemaphore,
         LONG lReleaseCount,
              LPLONG lpPreviousCount
    );


__declspec(dllimport)
BOOL
__stdcall
ReleaseMutex(
         HANDLE hMutex
    );
#line 470 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObject(
         HANDLE hHandle,
         DWORD dwMilliseconds
    );


__declspec(dllimport)
DWORD
__stdcall
SleepEx(
         DWORD dwMilliseconds,
         BOOL bAlertable
    );
#line 495 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObjectEx(
         HANDLE hHandle,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjectsEx(
         DWORD nCount,
                       const HANDLE * lpHandles,
         BOOL bWaitAll,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );
#line 531 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)

HANDLE
__stdcall
CreateMutexA(
             LPSECURITY_ATTRIBUTES lpMutexAttributes,
         BOOL bInitialOwner,
             LPCSTR lpName
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateMutexW(
             LPSECURITY_ATTRIBUTES lpMutexAttributes,
         BOOL bInitialOwner,
             LPCWSTR lpName
    );
#line 564 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)

HANDLE
__stdcall
OpenMutexW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );
#line 586 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)

HANDLE
__stdcall
CreateEventA(
             LPSECURITY_ATTRIBUTES lpEventAttributes,
         BOOL bManualReset,
         BOOL bInitialState,
             LPCSTR lpName
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateEventW(
             LPSECURITY_ATTRIBUTES lpEventAttributes,
         BOOL bManualReset,
         BOOL bInitialState,
             LPCWSTR lpName
    );
#line 621 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)

HANDLE
__stdcall
OpenEventA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );

__declspec(dllimport)

HANDLE
__stdcall
OpenEventW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );







__declspec(dllimport)

HANDLE
__stdcall
OpenSemaphoreW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );
#line 672 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
typedef
void
(__stdcall *PTIMERAPCROUTINE)(
             LPVOID lpArgToCompletionRoutine,
             DWORD dwTimerLowValue,
             DWORD dwTimerHighValue
    );

__declspec(dllimport)

HANDLE
__stdcall
OpenWaitableTimerW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpTimerName
    );
#line 698 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
BOOL
__stdcall
SetWaitableTimerEx(
         HANDLE hTimer,
         const LARGE_INTEGER * lpDueTime,
         LONG lPeriod,
             PTIMERAPCROUTINE pfnCompletionRoutine,
             LPVOID lpArgToCompletionRoutine,
             PREASON_CONTEXT WakeContext,
         ULONG TolerableDelay
    );




__declspec(dllimport)
BOOL
__stdcall
SetWaitableTimer(
         HANDLE hTimer,
         const LARGE_INTEGER * lpDueTime,
         LONG lPeriod,
             PTIMERAPCROUTINE pfnCompletionRoutine,
             LPVOID lpArgToCompletionRoutine,
         BOOL fResume
    );


__declspec(dllimport)
BOOL
__stdcall
CancelWaitableTimer(
         HANDLE hTimer
    );
#line 746 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)

HANDLE
__stdcall
CreateMutexExA(
             LPSECURITY_ATTRIBUTES lpMutexAttributes,
             LPCSTR lpName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateMutexExW(
             LPSECURITY_ATTRIBUTES lpMutexAttributes,
             LPCWSTR lpName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );
#line 777 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)

HANDLE
__stdcall
CreateEventExA(
             LPSECURITY_ATTRIBUTES lpEventAttributes,
             LPCSTR lpName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );

__declspec(dllimport)

HANDLE
__stdcall
CreateEventExW(
             LPSECURITY_ATTRIBUTES lpEventAttributes,
             LPCWSTR lpName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );







__declspec(dllimport)

HANDLE
__stdcall
CreateSemaphoreExW(
             LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
         LONG lInitialCount,
         LONG lMaximumCount,
             LPCWSTR lpName,
               DWORD dwFlags,
         DWORD dwDesiredAccess
    );
#line 832 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerExW(
             LPSECURITY_ATTRIBUTES lpTimerAttributes,
             LPCWSTR lpTimerName,
         DWORD dwFlags,
         DWORD dwDesiredAccess
    );
#line 866 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
typedef RTL_BARRIER SYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER;





BOOL
__stdcall
EnterSynchronizationBarrier(
            LPSYNCHRONIZATION_BARRIER lpBarrier,
         DWORD dwFlags
    );


BOOL
__stdcall
InitializeSynchronizationBarrier(
          LPSYNCHRONIZATION_BARRIER lpBarrier,
         LONG lTotalThreads,
         LONG lSpinCount
    );


BOOL
__stdcall
DeleteSynchronizationBarrier(
            LPSYNCHRONIZATION_BARRIER lpBarrier
    );


__declspec(dllimport)
void
__stdcall
Sleep(
         DWORD dwMilliseconds
    );
#line 913 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
BOOL
__stdcall
WaitOnAddress(
                                  volatile void * Address,
                                  PVOID CompareAddress,
         SIZE_T AddressSize,
             DWORD dwMilliseconds
    );


void
__stdcall
WakeByAddressSingle(
         PVOID Address
    );


void
__stdcall
WakeByAddressAll(
         PVOID Address
    );
#line 946 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
         HANDLE hObjectToSignal,
         HANDLE hObjectToWaitOn,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );
#line 969 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\synchapi.h"
}
#line 48 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\interlockedapi.h"
#line 36 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\interlockedapi.h"
extern "C" {
#line 47 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\interlockedapi.h"
__declspec(dllimport)
void
__stdcall
InitializeSListHead(
          PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPopEntrySList(
            PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPushEntrySList(
            PSLIST_HEADER ListHead,
            PSLIST_ENTRY ListEntry
    );







__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPushListSListEx(
            PSLIST_HEADER ListHead,
            PSLIST_ENTRY List,
            PSLIST_ENTRY ListEnd,
         ULONG Count
    );




__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedFlushSList(
            PSLIST_HEADER ListHead
    );


__declspec(dllimport)
USHORT
__stdcall
QueryDepthSList(
         PSLIST_HEADER ListHead
    );
#line 116 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\interlockedapi.h"
}
#line 49 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
#line 40 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
extern "C" {
#line 53 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

typedef struct _STARTUPINFOA {
    DWORD cb;
    LPSTR lpReserved;
    LPSTR lpDesktop;
    LPSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD cb;
    LPWSTR lpReserved;
    LPWSTR lpDesktop;
    LPWSTR lpTitle;
    DWORD dwX;
    DWORD dwY;
    DWORD dwXSize;
    DWORD dwYSize;
    DWORD dwXCountChars;
    DWORD dwYCountChars;
    DWORD dwFillAttribute;
    DWORD dwFlags;
    WORD wShowWindow;
    WORD cbReserved2;
    LPBYTE lpReserved2;
    HANDLE hStdInput;
    HANDLE hStdOutput;
    HANDLE hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;

typedef STARTUPINFOW STARTUPINFO;
typedef LPSTARTUPINFOW LPSTARTUPINFO;
#line 111 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
DWORD
__stdcall
QueueUserAPC(
         PAPCFUNC pfnAPC,
         HANDLE hThread,
         ULONG_PTR dwData
    );




__declspec(dllimport)
BOOL
__stdcall
GetProcessTimes(
         HANDLE hProcess,
          LPFILETIME lpCreationTime,
          LPFILETIME lpExitTime,
          LPFILETIME lpKernelTime,
          LPFILETIME lpUserTime
    );
#line 142 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
HANDLE
__stdcall
GetCurrentProcess(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessId(
    void
    );
#line 165 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitProcess(
         UINT uExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
TerminateProcess(
         HANDLE hProcess,
         UINT uExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
GetExitCodeProcess(
         HANDLE hProcess,
          LPDWORD lpExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
SwitchToThread(
    void
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateThread(
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         SIZE_T dwStackSize,
         LPTHREAD_START_ROUTINE lpStartAddress,
                              LPVOID lpParameter,
         DWORD dwCreationFlags,
              LPDWORD lpThreadId
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateRemoteThread(
         HANDLE hProcess,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         SIZE_T dwStackSize,
         LPTHREAD_START_ROUTINE lpStartAddress,
             LPVOID lpParameter,
         DWORD dwCreationFlags,
              LPDWORD lpThreadId
    );
#line 236 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
HANDLE
__stdcall
GetCurrentThread(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetCurrentThreadId(
    void
    );
#line 259 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)

HANDLE
__stdcall
OpenThread(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         DWORD dwThreadId
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadPriority(
         HANDLE hThread,
         int nPriority
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadPriorityBoost(
         HANDLE hThread,
         BOOL bDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadPriorityBoost(
         HANDLE hThread,
          PBOOL pDisablePriorityBoost
    );


__declspec(dllimport)
int
__stdcall
GetThreadPriority(
         HANDLE hThread
    );


__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitThread(
         DWORD dwExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
TerminateThread(
         HANDLE hThread,
         DWORD dwExitCode
    );


__declspec(dllimport)

BOOL
__stdcall
GetExitCodeThread(
         HANDLE hThread,
          LPDWORD lpExitCode
    );


__declspec(dllimport)
DWORD
__stdcall
SuspendThread(
         HANDLE hThread
    );


__declspec(dllimport)
DWORD
__stdcall
ResumeThread(
         HANDLE hThread
    );
#line 356 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
DWORD
__stdcall
TlsAlloc(
    void
    );


__declspec(dllimport)
LPVOID
__stdcall
TlsGetValue(
         DWORD dwTlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
TlsSetValue(
         DWORD dwTlsIndex,
             LPVOID lpTlsValue
    );


__declspec(dllimport)
BOOL
__stdcall
TlsFree(
         DWORD dwTlsIndex
    );




__declspec(dllimport)
BOOL
__stdcall
CreateProcessA(
             LPCSTR lpApplicationName,
                LPSTR lpCommandLine,
             LPSECURITY_ATTRIBUTES lpProcessAttributes,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         BOOL bInheritHandles,
         DWORD dwCreationFlags,
             LPVOID lpEnvironment,
             LPCSTR lpCurrentDirectory,
         LPSTARTUPINFOA lpStartupInfo,
          LPPROCESS_INFORMATION lpProcessInformation
    );

__declspec(dllimport)
BOOL
__stdcall
CreateProcessW(
             LPCWSTR lpApplicationName,
                LPWSTR lpCommandLine,
             LPSECURITY_ATTRIBUTES lpProcessAttributes,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         BOOL bInheritHandles,
         DWORD dwCreationFlags,
             LPVOID lpEnvironment,
             LPCWSTR lpCurrentDirectory,
         LPSTARTUPINFOW lpStartupInfo,
          LPPROCESS_INFORMATION lpProcessInformation
    );
#line 431 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
BOOL
__stdcall
SetProcessShutdownParameters(
         DWORD dwLevel,
         DWORD dwFlags
    );


__declspec(dllimport)
DWORD
__stdcall
GetProcessVersion(
         DWORD ProcessId
    );


__declspec(dllimport)
void
__stdcall
GetStartupInfoW(
          LPSTARTUPINFOW lpStartupInfo
    );
#line 470 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserW(
             HANDLE hToken,
             LPCWSTR lpApplicationName,
                LPWSTR lpCommandLine,
             LPSECURITY_ATTRIBUTES lpProcessAttributes,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         BOOL bInheritHandles,
         DWORD dwCreationFlags,
             LPVOID lpEnvironment,
             LPCWSTR lpCurrentDirectory,
         LPSTARTUPINFOW lpStartupInfo,
          LPPROCESS_INFORMATION lpProcessInformation
    );
#line 501 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)

BOOL
__stdcall
SetThreadToken(
             PHANDLE Thread,
             HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
OpenProcessToken(
         HANDLE ProcessHandle,
         DWORD DesiredAccess,
             PHANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
OpenThreadToken(
         HANDLE ThreadHandle,
         DWORD DesiredAccess,
         BOOL OpenAsSelf,
             PHANDLE TokenHandle
    );
#line 541 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
BOOL
__stdcall
SetPriorityClass(
         HANDLE hProcess,
         DWORD dwPriorityClass
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadStackGuarantee(
            PULONG StackSizeInBytes
    );


__declspec(dllimport)
DWORD
__stdcall
GetPriorityClass(
         HANDLE hProcess
    );


__declspec(dllimport)
BOOL
__stdcall
ProcessIdToSessionId(
         DWORD dwProcessId,
          DWORD * pSessionId
    );






__declspec(dllimport)
DWORD
__stdcall
GetProcessId(
         HANDLE Process
    );







__declspec(dllimport)
DWORD
__stdcall
GetThreadId(
         HANDLE Thread
    );





typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;
#line 615 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
void
__stdcall
FlushProcessWriteBuffers(
    void
    );
#line 630 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
DWORD
__stdcall
GetProcessIdOfThread(
         HANDLE Thread
    );


__declspec(dllimport)

BOOL
__stdcall
InitializeProcThreadAttributeList(
                                                LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
         DWORD dwAttributeCount,
               DWORD dwFlags,
                                                                                          PSIZE_T lpSize
    );


__declspec(dllimport)
void
__stdcall
DeleteProcThreadAttributeList(
            LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
    );




__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityUpdateMode(
         HANDLE hProcess,
         DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProcessAffinityUpdateMode(
         HANDLE hProcess,
              LPDWORD lpdwFlags
    );




__declspec(dllimport)
BOOL
__stdcall
UpdateProcThreadAttribute(
            LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
         DWORD dwFlags,
         DWORD_PTR Attribute,
                                 PVOID lpValue,
         SIZE_T cbSize,
                                   PVOID lpPreviousValue,
             PSIZE_T lpReturnSize
    );
#line 703 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)

HANDLE
__stdcall
CreateRemoteThreadEx(
         HANDLE hProcess,
             LPSECURITY_ATTRIBUTES lpThreadAttributes,
         SIZE_T dwStackSize,
         LPTHREAD_START_ROUTINE lpStartAddress,
             LPVOID lpParameter,
         DWORD dwCreationFlags,
             LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
              LPDWORD lpThreadId
    );
#line 737 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
void
__stdcall
GetCurrentThreadStackLimits(
          PULONG_PTR LowLimit,
          PULONG_PTR HighLimit
    );




__declspec(dllimport)
BOOL
__stdcall
GetThreadContext(
         HANDLE hThread,
            LPCONTEXT lpContext
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadContext(
         HANDLE hThread,
         const CONTEXT * lpContext
    );





__declspec(dllimport)
BOOL
__stdcall
SetProcessMitigationPolicy(
         PROCESS_MITIGATION_POLICY MitigationPolicy,
                               PVOID lpBuffer,
         SIZE_T dwLength
    );


__declspec(dllimport)
BOOL
__stdcall
GetProcessMitigationPolicy(
         HANDLE hProcess,
         PROCESS_MITIGATION_POLICY MitigationPolicy,
                                 PVOID lpBuffer,
         SIZE_T dwLength
    );
#line 805 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
BOOL
__stdcall
FlushInstructionCache(
         HANDLE hProcess,
                                 LPCVOID lpBaseAddress,
         SIZE_T dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadTimes(
         HANDLE hThread,
          LPFILETIME lpCreationTime,
          LPFILETIME lpExitTime,
          LPFILETIME lpKernelTime,
          LPFILETIME lpUserTime
    );


__declspec(dllimport)
HANDLE
__stdcall
OpenProcess(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         DWORD dwProcessId
    );
#line 844 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
BOOL
__stdcall
IsProcessorFeaturePresent(
         DWORD ProcessorFeature
    );
#line 863 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetProcessHandleCount(
         HANDLE hProcess,
          PDWORD pdwHandleCount
    );
#line 884 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessorNumber(
    void
    );
#line 904 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
BOOL
__stdcall
SetThreadIdealProcessorEx(
         HANDLE hThread,
         PPROCESSOR_NUMBER lpIdealProcessor,
              PPROCESSOR_NUMBER lpPreviousIdealProcessor
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadIdealProcessorEx(
         HANDLE hThread,
          PPROCESSOR_NUMBER lpIdealProcessor
    );


__declspec(dllimport)
void
__stdcall
GetCurrentProcessorNumberEx(
          PPROCESSOR_NUMBER ProcNumber
    );
#line 949 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetProcessPriorityBoost(
         HANDLE hProcess,
          PBOOL pDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
SetProcessPriorityBoost(
         HANDLE hProcess,
         BOOL bDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadIOPendingFlag(
         HANDLE hThread,
          PBOOL lpIOIsPending
    );


__declspec(dllimport)
BOOL
__stdcall
GetSystemTimes(
              PFILETIME lpIdleTime,
              PFILETIME lpKernelTime,
              PFILETIME lpUserTime
    );
#line 992 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
typedef enum _THREAD_INFORMATION_CLASS {
    ThreadMemoryPriority,
    ThreadAbsoluteCpuPriority,
    ThreadInformationClassMax
} THREAD_INFORMATION_CLASS;




__declspec(dllimport)
BOOL
__stdcall
GetThreadInformation(
         HANDLE hThread,
         THREAD_INFORMATION_CLASS ThreadInformationClass,
                                              LPVOID ThreadInformation,
         DWORD ThreadInformationSize
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadInformation(
         HANDLE hThread,
         THREAD_INFORMATION_CLASS ThreadInformationClass,
                                            LPVOID ThreadInformation,
         DWORD ThreadInformationSize
    );
#line 1034 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
typedef struct _MEMORY_PRIORITY_INFORMATION {
    ULONG MemoryPriority;
} MEMORY_PRIORITY_INFORMATION, *PMEMORY_PRIORITY_INFORMATION;






__declspec(dllimport)
BOOL
__stdcall
IsProcessCritical(
         HANDLE hProcess,
          PBOOL Critical
    );
#line 1065 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processthreadsapi.h"
}
#line 50 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
#line 28 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
#pragma warning(disable: 4514)

#pragma warning(disable: 4103)



#pragma warning(push)

#pragma warning(disable: 4001)
#pragma warning(disable: 4201)
#pragma warning(disable: 4214)
#line 62 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
extern "C" {
#line 75 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        } ;
    } ;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;
#line 105 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(deprecated)
__declspec(dllimport)

DWORD
__stdcall
GetVersion(
    void
    );


typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;

__declspec(dllimport)
BOOL
__stdcall
GlobalMemoryStatusEx(
          LPMEMORYSTATUSEX lpBuffer
    );
#line 142 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(dllimport)
void
__stdcall
GetSystemTime(
          LPSYSTEMTIME lpSystemTime
    );


__declspec(dllimport)
void
__stdcall
GetSystemTimeAsFileTime(
          LPFILETIME lpSystemTimeAsFileTime
    );


__declspec(dllimport)
void
__stdcall
GetLocalTime(
          LPSYSTEMTIME lpSystemTime
    );
#line 173 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(dllimport)
BOOL
__stdcall
SetLocalTime(
         const SYSTEMTIME * lpSystemTime
    );


__declspec(dllimport)
void
__stdcall
GetSystemInfo(
          LPSYSTEM_INFO lpSystemInfo
    );
#line 200 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(dllimport)
DWORD
__stdcall
GetTickCount(
    void
    );
#line 218 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(dllimport)
ULONGLONG
__stdcall
GetTickCount64(
    void
    );
#line 235 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(dllimport)

BOOL
__stdcall
GetSystemTimeAdjustment(
          PDWORD lpTimeAdjustment,
          PDWORD lpTimeIncrement,
          PBOOL lpTimeAdjustmentDisabled
    );


__declspec(dllimport)

UINT
__stdcall
GetSystemDirectoryA(
                                           LPSTR lpBuffer,
         UINT uSize
    );

__declspec(dllimport)

UINT
__stdcall
GetSystemDirectoryW(
                                           LPWSTR lpBuffer,
         UINT uSize
    );







__declspec(dllimport)


UINT
__stdcall
GetWindowsDirectoryA(
                                           LPSTR lpBuffer,
         UINT uSize
    );

__declspec(dllimport)


UINT
__stdcall
GetWindowsDirectoryW(
                                           LPWSTR lpBuffer,
         UINT uSize
    );







__declspec(dllimport)

UINT
__stdcall
GetSystemWindowsDirectoryA(
                                           LPSTR lpBuffer,
         UINT uSize
    );

__declspec(dllimport)

UINT
__stdcall
GetSystemWindowsDirectoryW(
                                           LPWSTR lpBuffer,
         UINT uSize
    );
#line 332 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;
#line 356 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(dllimport)

BOOL
__stdcall
GetComputerNameExA(
         COMPUTER_NAME_FORMAT NameType,
                                            LPSTR lpBuffer,
            LPDWORD nSize
    );

__declspec(dllimport)

BOOL
__stdcall
GetComputerNameExW(
         COMPUTER_NAME_FORMAT NameType,
                                            LPWSTR lpBuffer,
            LPDWORD nSize
    );
#line 395 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExW(
         COMPUTER_NAME_FORMAT NameType,
         LPCWSTR lpBuffer
    );






__declspec(dllimport)
BOOL
__stdcall
SetSystemTime(
         const SYSTEMTIME * lpSystemTime
    );
#line 428 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(deprecated)
__declspec(dllimport)

BOOL
__stdcall
GetVersionExA(
            LPOSVERSIONINFOA lpVersionInformation
    );

__declspec(deprecated)
__declspec(dllimport)

BOOL
__stdcall
GetVersionExW(
            LPOSVERSIONINFOW lpVersionInformation
    );







__declspec(dllimport)
BOOL
__stdcall
GetLogicalProcessorInformation(
                                                                PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
            PDWORD ReturnedLength
    );





__declspec(dllimport)
BOOL
__stdcall
GetLogicalProcessorInformationEx(
         LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
                                                                PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
            PDWORD ReturnedLength
    );
#line 492 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(dllimport)
void
__stdcall
GetNativeSystemInfo(
          LPSYSTEM_INFO lpSystemInfo
    );
#line 512 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetProductInfo(
         DWORD dwOSMajorVersion,
         DWORD dwOSMinorVersion,
         DWORD dwSpMajorVersion,
         DWORD dwSpMinorVersion,
          PDWORD pdwReturnedProductType
    );







__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
         ULONGLONG ConditionMask,
         ULONG TypeMask,
         UCHAR Condition
    );







__declspec(dllimport)
BOOL
__stdcall
GetOsSafeBootMode(
          PDWORD Flags
    );




__declspec(dllimport)
void
__stdcall
GetSystemTimePreciseAsFileTime(
          LPFILETIME lpSystemTimeAsFileTime
    );


__declspec(dllimport)
UINT
__stdcall
EnumSystemFirmwareTables(
         DWORD FirmwareTableProviderSignature,
                                                  PVOID pFirmwareTableEnumBuffer,
         DWORD BufferSize
    );


__declspec(dllimport)
UINT
__stdcall
GetSystemFirmwareTable(
         DWORD FirmwareTableProviderSignature,
         DWORD FirmwareTableID,
                                                  PVOID pFirmwareTableBuffer,
         DWORD BufferSize
    );
#line 598 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
__declspec(dllimport)

BOOL
__stdcall
DnsHostnameToComputerNameExW(
         LPCWSTR Hostname,
                                            LPWSTR ComputerName,
            LPDWORD nSize
    );


__declspec(dllimport)

BOOL
__stdcall
GetPhysicallyInstalledSystemMemory(
          PULONGLONG TotalMemoryInKilobytes
    );




__declspec(dllimport)
BOOL
__stdcall
SetComputerNameEx2W(
         COMPUTER_NAME_FORMAT NameType,
         DWORD Flags,
         LPCWSTR lpBuffer
    );






__declspec(dllimport)

BOOL
__stdcall
SetSystemTimeAdjustment(
         DWORD dwTimeAdjustment,
         BOOL bTimeAdjustmentDisabled
    );


__declspec(dllimport)
BOOL
__stdcall
InstallELAMCertificateInfo(
         HANDLE ELAMFile
    );
#line 663 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\sysinfoapi.h"
}






#pragma warning(pop)
#line 51 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
#line 41 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
extern "C" {
#line 86 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)

LPVOID
__stdcall
VirtualAlloc(
             LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD flAllocationType,
         DWORD flProtect
    );
#line 107 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)
BOOL
__stdcall
VirtualFree(
                                                                                                                           LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD dwFreeType
    );


__declspec(dllimport)

BOOL
__stdcall
VirtualProtect(
         LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD flNewProtect,
          PDWORD lpflOldProtect
    );
#line 136 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)
SIZE_T
__stdcall
VirtualQuery(
             LPCVOID lpAddress,
                                            PMEMORY_BASIC_INFORMATION lpBuffer,
         SIZE_T dwLength
    );
#line 153 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)

LPVOID
__stdcall
VirtualAllocEx(
         HANDLE hProcess,
             LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD flAllocationType,
         DWORD flProtect
    );
#line 178 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)
BOOL
__stdcall
VirtualFreeEx(
         HANDLE hProcess,
                                                                                                                           LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD dwFreeType
    );


__declspec(dllimport)

BOOL
__stdcall
VirtualProtectEx(
         HANDLE hProcess,
         LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD flNewProtect,
          PDWORD lpflOldProtect
    );


__declspec(dllimport)
SIZE_T
__stdcall
VirtualQueryEx(
         HANDLE hProcess,
             LPCVOID lpAddress,
                                            PMEMORY_BASIC_INFORMATION lpBuffer,
         SIZE_T dwLength
    );


__declspec(dllimport)

BOOL
__stdcall
ReadProcessMemory(
         HANDLE hProcess,
         LPCVOID lpBaseAddress,
                                                       LPVOID lpBuffer,
         SIZE_T nSize,
              SIZE_T * lpNumberOfBytesRead
    );


__declspec(dllimport)

BOOL
__stdcall
WriteProcessMemory(
         HANDLE hProcess,
         LPVOID lpBaseAddress,
                            LPCVOID lpBuffer,
         SIZE_T nSize,
              SIZE_T * lpNumberOfBytesWritten
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingW(
         HANDLE hFile,
             LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
         DWORD flProtect,
         DWORD dwMaximumSizeHigh,
         DWORD dwMaximumSizeLow,
             LPCWSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
OpenFileMappingW(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCWSTR lpName
    );






__declspec(dllimport)

LPVOID
__stdcall
MapViewOfFile(
         HANDLE hFileMappingObject,
         DWORD dwDesiredAccess,
         DWORD dwFileOffsetHigh,
         DWORD dwFileOffsetLow,
         SIZE_T dwNumberOfBytesToMap
    );


__declspec(dllimport)

LPVOID
__stdcall
MapViewOfFileEx(
         HANDLE hFileMappingObject,
         DWORD dwDesiredAccess,
         DWORD dwFileOffsetHigh,
         DWORD dwFileOffsetLow,
         SIZE_T dwNumberOfBytesToMap,
             LPVOID lpBaseAddress
    );
#line 306 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)
BOOL
__stdcall
FlushViewOfFile(
         LPCVOID lpBaseAddress,
         SIZE_T dwNumberOfBytesToFlush
    );


__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFile(
         LPCVOID lpBaseAddress
    );
#line 336 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)
SIZE_T
__stdcall
GetLargePageMinimum(
    void
    );


__declspec(dllimport)

BOOL
__stdcall
GetProcessWorkingSetSizeEx(
         HANDLE hProcess,
          PSIZE_T lpMinimumWorkingSetSize,
          PSIZE_T lpMaximumWorkingSetSize,
          PDWORD Flags
    );


__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSizeEx(
         HANDLE hProcess,
         SIZE_T dwMinimumWorkingSetSize,
         SIZE_T dwMaximumWorkingSetSize,
         DWORD Flags
    );


__declspec(dllimport)
BOOL
__stdcall
VirtualLock(
         LPVOID lpAddress,
         SIZE_T dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
VirtualUnlock(
         LPVOID lpAddress,
         SIZE_T dwSize
    );


__declspec(dllimport)

UINT
__stdcall
GetWriteWatch(
         DWORD dwFlags,
         PVOID lpBaseAddress,
         SIZE_T dwRegionSize,
                                                PVOID * lpAddresses,
                ULONG_PTR * lpdwCount,
              LPDWORD lpdwGranularity
    );


__declspec(dllimport)
UINT
__stdcall
ResetWriteWatch(
         LPVOID lpBaseAddress,
         SIZE_T dwRegionSize
    );





typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
} MEMORY_RESOURCE_NOTIFICATION_TYPE;

__declspec(dllimport)

HANDLE
__stdcall
CreateMemoryResourceNotification(
         MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
    );


__declspec(dllimport)

BOOL
__stdcall
QueryMemoryResourceNotification(
         HANDLE ResourceNotificationHandle,
          PBOOL ResourceState
    );
#line 446 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)

BOOL
__stdcall
GetSystemFileCacheSize(
          PSIZE_T lpMinimumFileCacheSize,
          PSIZE_T lpMaximumFileCacheSize,
          PDWORD lpFlags
    );


__declspec(dllimport)
BOOL
__stdcall
SetSystemFileCacheSize(
         SIZE_T MinimumFileCacheSize,
         SIZE_T MaximumFileCacheSize,
         DWORD Flags
    );







__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingNumaW(
         HANDLE hFile,
             LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
         DWORD flProtect,
         DWORD dwMaximumSizeHigh,
         DWORD dwMaximumSizeLow,
             LPCWSTR lpName,
         DWORD nndPreferred
    );
#line 496 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
typedef struct _WIN32_MEMORY_RANGE_ENTRY {
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} WIN32_MEMORY_RANGE_ENTRY, *PWIN32_MEMORY_RANGE_ENTRY;

__declspec(dllimport)
BOOL
__stdcall
PrefetchVirtualMemory(
         HANDLE hProcess,
         ULONG_PTR NumberOfEntries,
                                PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses,
         ULONG Flags
    );


__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFileEx(
         PVOID BaseAddress,
         ULONG UnmapFlags
    );
#line 533 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingFromApp(
         HANDLE hFile,
             PSECURITY_ATTRIBUTES SecurityAttributes,
         ULONG PageProtection,
         ULONG64 MaximumSize,
             PCWSTR Name
    );


__declspec(dllimport)

PVOID
__stdcall
MapViewOfFileFromApp(
         HANDLE hFileMappingObject,
         ULONG DesiredAccess,
         ULONG64 FileOffset,
         SIZE_T NumberOfBytesToMap
    );
#line 578 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)

BOOL
__stdcall
AllocateUserPhysicalPages(
         HANDLE hProcess,
            PULONG_PTR NumberOfPages,
                                                    PULONG_PTR PageArray
    );


__declspec(dllimport)

BOOL
__stdcall
FreeUserPhysicalPages(
         HANDLE hProcess,
            PULONG_PTR NumberOfPages,
                               PULONG_PTR PageArray
    );


__declspec(dllimport)

BOOL
__stdcall
MapUserPhysicalPages(
         PVOID VirtualAddress,
         ULONG_PTR NumberOfPages,
                                  PULONG_PTR PageArray
    );







__declspec(dllimport)

BOOL
__stdcall
AllocateUserPhysicalPagesNuma(
         HANDLE hProcess,
            PULONG_PTR NumberOfPages,
                                                    PULONG_PTR PageArray,
         DWORD nndPreferred
    );


__declspec(dllimport)

LPVOID
__stdcall
VirtualAllocExNuma(
         HANDLE hProcess,
             LPVOID lpAddress,
         SIZE_T dwSize,
         DWORD flAllocationType,
         DWORD flProtect,
         DWORD nndPreferred
    );
#line 649 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
__declspec(dllimport)

BOOL
__stdcall
GetMemoryErrorHandlingCapabilities(
          PULONG Capabilities
    );



typedef
void
__stdcall
BAD_MEMORY_CALLBACK_ROUTINE(
    void
    );

typedef BAD_MEMORY_CALLBACK_ROUTINE *PBAD_MEMORY_CALLBACK_ROUTINE;

__declspec(dllimport)

PVOID
__stdcall
RegisterBadMemoryNotification(
         PBAD_MEMORY_CALLBACK_ROUTINE Callback
    );


__declspec(dllimport)

BOOL
__stdcall
UnregisterBadMemoryNotification(
         PVOID RegistrationHandle
    );
#line 699 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\memoryapi.h"
}
#line 52 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\threadpoollegacyapiset.h"
#line 33 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\threadpoollegacyapiset.h"
extern "C" {
#line 44 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\threadpoollegacyapiset.h"
__declspec(dllimport)
BOOL
__stdcall
QueueUserWorkItem(
         LPTHREAD_START_ROUTINE Function,
             PVOID Context,
         ULONG Flags
    );


__declspec(dllimport)

BOOL
__stdcall
UnregisterWaitEx(
         HANDLE WaitHandle,
             HANDLE CompletionEvent
    );


__declspec(dllimport)

HANDLE
__stdcall
CreateTimerQueue(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
CreateTimerQueueTimer(
             PHANDLE phNewTimer,
             HANDLE TimerQueue,
         WAITORTIMERCALLBACK Callback,
             PVOID Parameter,
         DWORD DueTime,
         DWORD Period,
         ULONG Flags
    );


__declspec(dllimport)

BOOL
__stdcall
ChangeTimerQueueTimer(
             HANDLE TimerQueue,
            HANDLE Timer,
         ULONG DueTime,
         ULONG Period
    );


__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueueTimer(
             HANDLE TimerQueue,
         HANDLE Timer,
             HANDLE CompletionEvent
    );


__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueueEx(
         HANDLE TimerQueue,
             HANDLE CompletionEvent
    );






}
#line 53 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\threadpoolapiset.h"
#line 36 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\threadpoolapiset.h"
extern "C" {
#line 47 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\threadpoolapiset.h"
typedef
void
(__stdcall *PTP_WIN32_IO_CALLBACK)(
                PTP_CALLBACK_INSTANCE Instance,
                PVOID Context,
                PVOID Overlapped,
                ULONG IoResult,
                ULONG_PTR NumberOfBytesTransferred,
                PTP_IO Io
    );




__declspec(dllimport)

PTP_POOL
__stdcall
CreateThreadpool(
               PVOID reserved
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolThreadMaximum(
            PTP_POOL ptpp,
         DWORD cthrdMost
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolThreadMinimum(
            PTP_POOL ptpp,
         DWORD cthrdMic
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolStackInformation(
            PTP_POOL ptpp,
         PTP_POOL_STACK_INFORMATION ptpsi
    );


__declspec(dllimport)
BOOL
__stdcall
QueryThreadpoolStackInformation(
         PTP_POOL ptpp,
          PTP_POOL_STACK_INFORMATION ptpsi
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpool(
            PTP_POOL ptpp
    );


__declspec(dllimport)

PTP_CLEANUP_GROUP
__stdcall
CreateThreadpoolCleanupGroup(
    void
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolCleanupGroupMembers(
            PTP_CLEANUP_GROUP ptpcg,
         BOOL fCancelPendingCallbacks,
                PVOID pvCleanupContext
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolCleanupGroup(
            PTP_CLEANUP_GROUP ptpcg
    );


__declspec(dllimport)
void
__stdcall
SetEventWhenCallbackReturns(
            PTP_CALLBACK_INSTANCE pci,
         HANDLE evt
    );


__declspec(dllimport)
void
__stdcall
ReleaseSemaphoreWhenCallbackReturns(
            PTP_CALLBACK_INSTANCE pci,
         HANDLE sem,
         DWORD crel
    );


__declspec(dllimport)
void
__stdcall
ReleaseMutexWhenCallbackReturns(
            PTP_CALLBACK_INSTANCE pci,
         HANDLE mut
    );


__declspec(dllimport)
void
__stdcall
LeaveCriticalSectionWhenCallbackReturns(
            PTP_CALLBACK_INSTANCE pci,
            PCRITICAL_SECTION pcs
    );


__declspec(dllimport)
void
__stdcall
FreeLibraryWhenCallbackReturns(
            PTP_CALLBACK_INSTANCE pci,
         HMODULE mod
    );


__declspec(dllimport)
BOOL
__stdcall
CallbackMayRunLong(
            PTP_CALLBACK_INSTANCE pci
    );


__declspec(dllimport)
void
__stdcall
DisassociateCurrentThreadFromCallback(
            PTP_CALLBACK_INSTANCE pci
    );


__declspec(dllimport)

BOOL
__stdcall
TrySubmitThreadpoolCallback(
         PTP_SIMPLE_CALLBACK pfns,
                PVOID pv,
             PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)

PTP_WORK
__stdcall
CreateThreadpoolWork(
         PTP_WORK_CALLBACK pfnwk,
                PVOID pv,
             PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SubmitThreadpoolWork(
            PTP_WORK pwk
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolWorkCallbacks(
            PTP_WORK pwk,
         BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolWork(
            PTP_WORK pwk
    );


__declspec(dllimport)

PTP_TIMER
__stdcall
CreateThreadpoolTimer(
         PTP_TIMER_CALLBACK pfnti,
                PVOID pv,
             PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolTimer(
            PTP_TIMER pti,
             PFILETIME pftDueTime,
         DWORD msPeriod,
             DWORD msWindowLength
    );


__declspec(dllimport)
BOOL
__stdcall
IsThreadpoolTimerSet(
            PTP_TIMER pti
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolTimerCallbacks(
            PTP_TIMER pti,
         BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolTimer(
            PTP_TIMER pti
    );


__declspec(dllimport)

PTP_WAIT
__stdcall
CreateThreadpoolWait(
         PTP_WAIT_CALLBACK pfnwa,
                PVOID pv,
             PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolWait(
            PTP_WAIT pwa,
             HANDLE h,
             PFILETIME pftTimeout
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolWaitCallbacks(
            PTP_WAIT pwa,
         BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolWait(
            PTP_WAIT pwa
    );


__declspec(dllimport)

PTP_IO
__stdcall
CreateThreadpoolIo(
         HANDLE fl,
         PTP_WIN32_IO_CALLBACK pfnio,
                PVOID pv,
             PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
StartThreadpoolIo(
            PTP_IO pio
    );


__declspec(dllimport)
void
__stdcall
CancelThreadpoolIo(
            PTP_IO pio
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolIoCallbacks(
            PTP_IO pio,
         BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolIo(
            PTP_IO pio
    );





__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolTimerEx(
            PTP_TIMER pti,
             PFILETIME pftDueTime,
         DWORD msPeriod,
             DWORD msWindowLength
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolWaitEx(
            PTP_WAIT pwa,
             HANDLE h,
             PFILETIME pftTimeout,
               PVOID Reserved
    );
#line 414 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\threadpoolapiset.h"
}
#line 54 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\bemapiset.h"
#line 33 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\bemapiset.h"
extern "C" {
#line 43 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\bemapiset.h"
typedef struct _CONTRACT_DESCRIPTION CONTRACT_DESCRIPTION;

typedef struct _BEM_REFERENCE BEM_REFERENCE;

typedef void (__stdcall* BEM_FREE_INTERFACE_CALLBACK)( void* interfaceInstance);

HRESULT
__stdcall
BemCreateReference(
         const GUID & iid,
         void * interfaceInstance,
         BEM_FREE_INTERFACE_CALLBACK freeCallback,
             BEM_REFERENCE ** reference
    );


HRESULT
__stdcall
BemCreateContractFrom(
         LPCWSTR dllPath,
         const GUID & extensionId,
         const CONTRACT_DESCRIPTION * contractDescription,
         void * hostContract,
             void ** contract
    );


HRESULT
__stdcall
BemCopyReference(
         BEM_REFERENCE * reference,
             BEM_REFERENCE ** copiedReference
    );


void
__stdcall
BemFreeReference(
             BEM_REFERENCE * reference
    );


void
__stdcall
BemFreeContract(
             void * contract
    );
#line 98 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\bemapiset.h"
}
#line 55 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\jobapi.h"
#line 33 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\jobapi.h"
extern "C" {
#line 43 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\jobapi.h"
__declspec(dllimport)
BOOL
__stdcall
IsProcessInJob(
         HANDLE ProcessHandle,
             HANDLE JobHandle,
          PBOOL Result
    );
#line 59 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\jobapi.h"
}
#line 56 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\wow64apiset.h"
#line 33 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\wow64apiset.h"
extern "C" {
#line 46 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\wow64apiset.h"
__declspec(dllimport)
BOOL
__stdcall
Wow64DisableWow64FsRedirection(
          PVOID * OldValue
    );


__declspec(dllimport)
BOOL
__stdcall
Wow64RevertWow64FsRedirection(
         PVOID OlValue
    );
#line 69 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\wow64apiset.h"
__declspec(dllimport)
BOOL
__stdcall
IsWow64Process(
         HANDLE hProcess,
          PBOOL Wow64Process
    );
#line 84 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\wow64apiset.h"
}
#line 57 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
#line 40 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
extern "C" {
#line 59 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
typedef struct tagENUMUILANG {
    ULONG NumOfEnumUILang;
    ULONG SizeOfEnumUIBuffer;
    LANGID *pEnumUIBuffer;
} ENUMUILANG, *PENUMUILANG;



typedef BOOL (__stdcall* ENUMRESLANGPROCA)(
             HMODULE hModule,
         LPCSTR lpType,
         LPCSTR lpName,
         WORD wLanguage,
         LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESLANGPROCW)(
             HMODULE hModule,
         LPCWSTR lpType,
         LPCWSTR lpName,
         WORD wLanguage,
         LONG_PTR lParam);






typedef BOOL (__stdcall* ENUMRESNAMEPROCA)(
             HMODULE hModule,
         LPCSTR lpType,
         LPSTR lpName,
         LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESNAMEPROCW)(
             HMODULE hModule,
         LPCWSTR lpType,
         LPWSTR lpName,
         LONG_PTR lParam);






typedef BOOL (__stdcall* ENUMRESTYPEPROCA)(
             HMODULE hModule,
         LPSTR lpType,
         LONG_PTR lParam
    );
typedef BOOL (__stdcall* ENUMRESTYPEPROCW)(
             HMODULE hModule,
         LPWSTR lpType,
         LONG_PTR lParam
    );
#line 154 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
__declspec(dllimport)
BOOL
__stdcall
DisableThreadLibraryCalls(
         HMODULE hLibModule
    );
#line 169 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
__declspec(dllimport)

HRSRC
__stdcall
FindResourceExW(
             HMODULE hModule,
         LPCWSTR lpType,
         LPCWSTR lpName,
         WORD wLanguage
    );
#line 195 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
__declspec(dllimport)
int
__stdcall
FindStringOrdinal(
         DWORD dwFindStringOrdinalFlags,
                          LPCWSTR lpStringSource,
         int cchSource,
                         LPCWSTR lpStringValue,
         int cchValue,
         BOOL bIgnoreCase
    );




__declspec(dllimport)
BOOL
__stdcall
FreeLibrary(
         HMODULE hLibModule
    );
#line 225 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
FreeLibraryAndExitThread(
         HMODULE hLibModule,
         DWORD dwExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
FreeResource(
         HGLOBAL hResData
    );


__declspec(dllimport)


DWORD
__stdcall
GetModuleFileNameA(
             HMODULE hModule,
                                                                      LPSTR lpFilename,
         DWORD nSize
    );

__declspec(dllimport)


DWORD
__stdcall
GetModuleFileNameW(
             HMODULE hModule,
                                                                      LPWSTR lpFilename,
         DWORD nSize
    );







__declspec(dllimport)


HMODULE
__stdcall
GetModuleHandleA(
             LPCSTR lpModuleName
    );

__declspec(dllimport)


HMODULE
__stdcall
GetModuleHandleW(
             LPCWSTR lpModuleName
    );
#line 302 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
typedef
BOOL
(__stdcall*
PGET_MODULE_HANDLE_EXA)(
                DWORD dwFlags,
                LPCSTR lpModuleName,
             HMODULE* phModule
    );
typedef
BOOL
(__stdcall*
PGET_MODULE_HANDLE_EXW)(
                DWORD dwFlags,
                LPCWSTR lpModuleName,
             HMODULE* phModule
    );






__declspec(dllimport)
BOOL
__stdcall
GetModuleHandleExA(
         DWORD dwFlags,
             LPCSTR lpModuleName,
          HMODULE * phModule
    );

__declspec(dllimport)
BOOL
__stdcall
GetModuleHandleExW(
         DWORD dwFlags,
             LPCWSTR lpModuleName,
          HMODULE * phModule
    );
#line 357 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
__declspec(dllimport)
FARPROC
__stdcall
GetProcAddress(
         HMODULE hModule,
         LPCSTR lpProcName
    );
#line 373 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryExA(
         LPCSTR lpLibFileName,
               HANDLE hFile,
         DWORD dwFlags
    );

__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryExW(
         LPCWSTR lpLibFileName,
               HANDLE hFile,
         DWORD dwFlags
    );
#line 413 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
__declspec(dllimport)

HGLOBAL
__stdcall
LoadResource(
             HMODULE hModule,
         HRSRC hResInfo
    );
#line 432 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
__declspec(dllimport)
int
__stdcall
LoadStringA(
             HINSTANCE hInstance,
         UINT uID,
                                              LPSTR lpBuffer,
         int cchBufferMax
    );

__declspec(dllimport)
int
__stdcall
LoadStringW(
             HINSTANCE hInstance,
         UINT uID,
                                              LPWSTR lpBuffer,
         int cchBufferMax
    );
#line 467 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
__declspec(dllimport)
LPVOID
__stdcall
LockResource(
         HGLOBAL hResData
    );


__declspec(dllimport)
DWORD
__stdcall
SizeofResource(
             HMODULE hModule,
         HRSRC hResInfo
    );
#line 493 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
typedef PVOID DLL_DIRECTORY_COOKIE, *PDLL_DIRECTORY_COOKIE;

__declspec(dllimport)
DLL_DIRECTORY_COOKIE
__stdcall
AddDllDirectory(
         PCWSTR NewDirectory
    );


__declspec(dllimport)
BOOL
__stdcall
RemoveDllDirectory(
         DLL_DIRECTORY_COOKIE Cookie
    );


__declspec(dllimport)
BOOL
__stdcall
SetDefaultDllDirectories(
         DWORD DirectoryFlags
    );
#line 534 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesExA(
             HMODULE hModule,
         LPCSTR lpType,
         LPCSTR lpName,
         ENUMRESLANGPROCA lpEnumFunc,
             LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesExW(
             HMODULE hModule,
         LPCWSTR lpType,
         LPCWSTR lpName,
         ENUMRESLANGPROCW lpEnumFunc,
             LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );







__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesExA(
             HMODULE hModule,
         LPCSTR lpType,
         ENUMRESNAMEPROCA lpEnumFunc,
         LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesExW(
             HMODULE hModule,
         LPCWSTR lpType,
         ENUMRESNAMEPROCW lpEnumFunc,
         LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );







__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesExA(
             HMODULE hModule,
         ENUMRESTYPEPROCA lpEnumFunc,
         LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesExW(
             HMODULE hModule,
         ENUMRESTYPEPROCW lpEnumFunc,
         LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );
#line 636 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\libloaderapi.h"
}
#line 58 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\securitybaseapi.h"
#line 37 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\securitybaseapi.h"
extern "C" {
#line 53 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\securitybaseapi.h"
__declspec(dllimport)
BOOL
__stdcall
AccessCheck(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         PGENERIC_MAPPING GenericMapping,
                                                                        PPRIVILEGE_SET PrivilegeSet,
            LPDWORD PrivilegeSetLength,
          LPDWORD GrantedAccess,
          LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmW(
         LPCWSTR SubsystemName,
             LPVOID HandleId,
         LPWSTR ObjectTypeName,
             LPWSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
         DWORD DesiredAccess,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
          LPDWORD GrantedAccess,
          LPBOOL AccessStatus,
          LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByType(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID PrincipalSelfSid,
         HANDLE ClientToken,
         DWORD DesiredAccess,
                                              POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
                                                                        PPRIVILEGE_SET PrivilegeSet,
            LPDWORD PrivilegeSetLength,
          LPDWORD GrantedAccess,
          LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultList(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID PrincipalSelfSid,
         HANDLE ClientToken,
         DWORD DesiredAccess,
                                              POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
                                                                        PPRIVILEGE_SET PrivilegeSet,
            LPDWORD PrivilegeSetLength,
                                       LPDWORD GrantedAccessList,
                                       LPDWORD AccessStatusList
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         LPCWSTR ObjectTypeName,
             LPCWSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
         DWORD DesiredAccess,
         AUDIT_EVENT_TYPE AuditType,
         DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
          LPDWORD GrantedAccess,
          LPBOOL AccessStatus,
          LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         LPCWSTR ObjectTypeName,
             LPCWSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
         DWORD DesiredAccess,
         AUDIT_EVENT_TYPE AuditType,
         DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
                                       LPDWORD GrantedAccessList,
                                       LPDWORD AccessStatusList,
          LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         HANDLE ClientToken,
         LPCWSTR ObjectTypeName,
             LPCWSTR ObjectName,
         PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
         DWORD DesiredAccess,
         AUDIT_EVENT_TYPE AuditType,
         DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
         DWORD ObjectTypeListLength,
         PGENERIC_MAPPING GenericMapping,
         BOOL ObjectCreation,
                                       LPDWORD GrantedAccessList,
                                       LPDWORD AccessStatusList,
          LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AccessMask,
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAceEx(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedObjectAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
             GUID * ObjectTypeGuid,
             GUID * InheritedObjectTypeGuid,
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AccessMask,
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAceEx(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedObjectAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
             GUID * ObjectTypeGuid,
             GUID * InheritedObjectTypeGuid,
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD dwStartingAceIndex,
                                     LPVOID pAceList,
         DWORD nAceListLength
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD dwAccessMask,
         PSID pSid,
         BOOL bAuditSuccess,
         BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAceEx(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD dwAccessMask,
         PSID pSid,
         BOOL bAuditSuccess,
         BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessObjectAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
             GUID * ObjectTypeGuid,
             GUID * InheritedObjectTypeGuid,
         PSID pSid,
         BOOL bAuditSuccess,
         BOOL bAuditFailure
    );





__declspec(dllimport)
BOOL
__stdcall
AddMandatoryAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD MandatoryPolicy,
         PSID pLabelSid
    );
#line 359 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\securitybaseapi.h"
__declspec(dllimport)
BOOL
__stdcall
AddResourceAttributeAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
         PSID pSid,
         PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo,
          PDWORD pReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AddScopedPolicyIDAce(
            PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         DWORD AccessMask,
         PSID pSid
    );






__declspec(dllimport)
BOOL
__stdcall
AdjustTokenGroups(
         HANDLE TokenHandle,
         BOOL ResetToDefault,
             PTOKEN_GROUPS NewState,
         DWORD BufferLength,
                                                           PTOKEN_GROUPS PreviousState,
              PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AdjustTokenPrivileges(
         HANDLE TokenHandle,
         BOOL DisableAllPrivileges,
             PTOKEN_PRIVILEGES NewState,
         DWORD BufferLength,
                                                           PTOKEN_PRIVILEGES PreviousState,
              PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateAndInitializeSid(
         PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
         BYTE nSubAuthorityCount,
         DWORD nSubAuthority0,
         DWORD nSubAuthority1,
         DWORD nSubAuthority2,
         DWORD nSubAuthority3,
         DWORD nSubAuthority4,
         DWORD nSubAuthority5,
         DWORD nSubAuthority6,
         DWORD nSubAuthority7,
             PSID * pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateLocallyUniqueId(
          PLUID Luid
    );


__declspec(dllimport)
BOOL
__stdcall
AreAllAccessesGranted(
         DWORD GrantedAccess,
         DWORD DesiredAccess
    );


__declspec(dllimport)
BOOL
__stdcall
AreAnyAccessesGranted(
         DWORD GrantedAccess,
         DWORD DesiredAccess
    );


__declspec(dllimport)
BOOL
__stdcall
CheckTokenMembership(
             HANDLE TokenHandle,
         PSID SidToCheck,
          PBOOL IsMember
    );







__declspec(dllimport)
BOOL
__stdcall
CheckTokenCapability(
             HANDLE TokenHandle,
         PSID CapabilitySidToCheck,
          PBOOL HasCapability
    );


__declspec(dllimport)
BOOL
__stdcall
GetAppContainerAce(
         PACL Acl,
         DWORD StartingAceIndex,
             PVOID * AppContainerAce,
              DWORD * AppContainerAceIndex
    );


__declspec(dllimport)
BOOL
__stdcall
CheckTokenMembershipEx(
             HANDLE TokenHandle,
         PSID SidToCheck,
         DWORD Flags,
          PBOOL IsMember
    );






__declspec(dllimport)
BOOL
__stdcall
ConvertToAutoInheritPrivateObjectSecurity(
             PSECURITY_DESCRIPTOR ParentDescriptor,
         PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
             PSECURITY_DESCRIPTOR * NewSecurityDescriptor,
             GUID * ObjectType,
         BOOLEAN IsDirectoryObject,
         PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CopySid(
         DWORD nDestinationSidLength,
                                              PSID pDestinationSid,
         PSID pSourceSid
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurity(
             PSECURITY_DESCRIPTOR ParentDescriptor,
             PSECURITY_DESCRIPTOR CreatorDescriptor,
             PSECURITY_DESCRIPTOR * NewDescriptor,
         BOOL IsDirectoryObject,
             HANDLE Token,
         PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityEx(
             PSECURITY_DESCRIPTOR ParentDescriptor,
             PSECURITY_DESCRIPTOR CreatorDescriptor,
             PSECURITY_DESCRIPTOR * NewDescriptor,
             GUID * ObjectType,
         BOOL IsContainerObject,
         ULONG AutoInheritFlags,
             HANDLE Token,
         PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityWithMultipleInheritance(
             PSECURITY_DESCRIPTOR ParentDescriptor,
             PSECURITY_DESCRIPTOR CreatorDescriptor,
             PSECURITY_DESCRIPTOR * NewDescriptor,
                              GUID ** ObjectTypes,
         ULONG GuidCount,
         BOOL IsContainerObject,
         ULONG AutoInheritFlags,
             HANDLE Token,
         PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreateRestrictedToken(
         HANDLE ExistingTokenHandle,
         DWORD Flags,
         DWORD DisableSidCount,
                                    PSID_AND_ATTRIBUTES SidsToDisable,
         DWORD DeletePrivilegeCount,
                                         PLUID_AND_ATTRIBUTES PrivilegesToDelete,
         DWORD RestrictedSidCount,
                                       PSID_AND_ATTRIBUTES SidsToRestrict,
             PHANDLE NewTokenHandle
    );





__declspec(dllimport)

BOOL
__stdcall
CreateWellKnownSid(
         WELL_KNOWN_SID_TYPE WellKnownSidType,
             PSID DomainSid,
                                              PSID pSid,
            DWORD * cbSid
    );


__declspec(dllimport)

BOOL
__stdcall
EqualDomainSid(
         PSID pSid1,
         PSID pSid2,
          BOOL * pfEqual
    );




__declspec(dllimport)
BOOL
__stdcall
DeleteAce(
            PACL pAcl,
         DWORD dwAceIndex
    );


__declspec(dllimport)
BOOL
__stdcall
DestroyPrivateObjectSecurity(
                               PSECURITY_DESCRIPTOR * ObjectDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateToken(
         HANDLE ExistingTokenHandle,
         SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
             PHANDLE DuplicateTokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateTokenEx(
         HANDLE hExistingToken,
         DWORD dwDesiredAccess,
             LPSECURITY_ATTRIBUTES lpTokenAttributes,
         SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
         TOKEN_TYPE TokenType,
             PHANDLE phNewToken
    );


__declspec(dllimport)
BOOL
__stdcall
EqualPrefixSid(
         PSID pSid1,
         PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
EqualSid(
         PSID pSid1,
         PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
FindFirstFreeAce(
         PACL pAcl,
             LPVOID * pAce
    );


__declspec(dllimport)
PVOID
__stdcall
FreeSid(
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
GetAce(
         PACL pAcl,
         DWORD dwAceIndex,
             LPVOID * pAce
    );


__declspec(dllimport)
BOOL
__stdcall
GetAclInformation(
         PACL pAcl,
                                              LPVOID pAclInformation,
         DWORD nAclInformationLength,
         ACL_INFORMATION_CLASS dwAclInformationClass
    );


__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityW(
         LPCWSTR lpFileName,
         SECURITY_INFORMATION RequestedInformation,
                                                         PSECURITY_DESCRIPTOR pSecurityDescriptor,
         DWORD nLength,
          LPDWORD lpnLengthNeeded
    );






__declspec(dllimport)
BOOL
__stdcall
GetKernelObjectSecurity(
         HANDLE Handle,
         SECURITY_INFORMATION RequestedInformation,
                                    PSECURITY_DESCRIPTOR pSecurityDescriptor,
         DWORD nLength,
          LPDWORD lpnLengthNeeded
    );


__declspec(dllimport)


DWORD
__stdcall
GetLengthSid(
                                           PSID pSid
    );


__declspec(dllimport)

BOOL
__stdcall
GetPrivateObjectSecurity(
         PSECURITY_DESCRIPTOR ObjectDescriptor,
         SECURITY_INFORMATION SecurityInformation,
                                                               PSECURITY_DESCRIPTOR ResultantDescriptor,
         DWORD DescriptorLength,
          PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorControl(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
          PSECURITY_DESCRIPTOR_CONTROL pControl,
          LPDWORD lpdwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorDacl(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
          LPBOOL lpbDaclPresent,
             PACL * pDacl,
          LPBOOL lpbDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorGroup(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID * pGroup,
          LPBOOL lpbGroupDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorLength(
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorOwner(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID * pOwner,
          LPBOOL lpbOwnerDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorRMControl(
         PSECURITY_DESCRIPTOR SecurityDescriptor,
          PUCHAR RMControl
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorSacl(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
          LPBOOL lpbSaclPresent,
             PACL * pSacl,
          LPBOOL lpbSaclDefaulted
    );


__declspec(dllimport)
PSID_IDENTIFIER_AUTHORITY
__stdcall
GetSidIdentifierAuthority(
         PSID pSid
    );


__declspec(dllimport)
DWORD
__stdcall
GetSidLengthRequired(
         UCHAR nSubAuthorityCount
    );


__declspec(dllimport)
PDWORD
__stdcall
GetSidSubAuthority(
         PSID pSid,
         DWORD nSubAuthority
    );


__declspec(dllimport)
PUCHAR
__stdcall
GetSidSubAuthorityCount(
         PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
GetTokenInformation(
         HANDLE TokenHandle,
         TOKEN_INFORMATION_CLASS TokenInformationClass,
                                                                     LPVOID TokenInformation,
         DWORD TokenInformationLength,
          PDWORD ReturnLength
    );





__declspec(dllimport)

BOOL
__stdcall
GetWindowsAccountDomainSid(
         PSID pSid,
                                                          PSID pDomainSid,
            DWORD * cbDomainSid
    );




__declspec(dllimport)
BOOL
__stdcall
ImpersonateAnonymousToken(
         HANDLE ThreadHandle
    );



__declspec(dllimport)
BOOL
__stdcall
ImpersonateLoggedOnUser(
         HANDLE hToken
    );



__declspec(dllimport)
BOOL
__stdcall
ImpersonateSelf(
         SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeAcl(
                                   PACL pAcl,
         DWORD nAclLength,
         DWORD dwAclRevision
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSecurityDescriptor(
          PSECURITY_DESCRIPTOR pSecurityDescriptor,
         DWORD dwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSid(
                                                                                  PSID Sid,
         PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
         BYTE nSubAuthorityCount
    );


__declspec(dllimport)
BOOL
__stdcall
IsTokenRestricted(
         HANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidAcl(
         PACL pAcl
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSecurityDescriptor(
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSid(
         PSID pSid
    );





__declspec(dllimport)
BOOL
__stdcall
IsWellKnownSid(
         PSID pSid,
         WELL_KNOWN_SID_TYPE WellKnownSidType
    );




__declspec(dllimport)

BOOL
__stdcall
MakeAbsoluteSD(
         PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
                                                                                                        PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
            LPDWORD lpdwAbsoluteSecurityDescriptorSize,
                                                            PACL pDacl,
            LPDWORD lpdwDaclSize,
                                                            PACL pSacl,
            LPDWORD lpdwSaclSize,
                                                              PSID pOwner,
            LPDWORD lpdwOwnerSize,
                                                                            PSID pPrimaryGroup,
            LPDWORD lpdwPrimaryGroupSize
    );


__declspec(dllimport)

BOOL
__stdcall
MakeSelfRelativeSD(
         PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
                                                                    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
            LPDWORD lpdwBufferLength
    );


__declspec(dllimport)
void
__stdcall
MapGenericMask(
            PDWORD AccessMask,
         PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         LPWSTR ObjectTypeName,
             LPWSTR ObjectName,
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         DWORD GrantedAccess,
             PPRIVILEGE_SET Privileges,
         BOOL ObjectCreation,
         BOOL AccessGranted,
          LPBOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmW(
         LPCWSTR SubsystemName,
         LPVOID HandleId,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );






__declspec(dllimport)
BOOL
__stdcall
PrivilegeCheck(
         HANDLE ClientToken,
            PPRIVILEGE_SET RequiredPrivileges,
          LPBOOL pfResult
    );


__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmW(
         LPCWSTR SubsystemName,
         LPCWSTR ServiceName,
         HANDLE ClientToken,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );
#line 1135 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\securitybaseapi.h"
__declspec(dllimport)
void
__stdcall
QuerySecurityAccessMask(
         SECURITY_INFORMATION SecurityInformation,
          LPDWORD DesiredAccess
    );




__declspec(dllimport)
BOOL
__stdcall
RevertToSelf(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetAclInformation(
            PACL pAcl,
                                            LPVOID pAclInformation,
         DWORD nAclInformationLength,
         ACL_INFORMATION_CLASS dwAclInformationClass
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityW(
         LPCWSTR lpFileName,
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );





__declspec(dllimport)
BOOL
__stdcall
SetKernelObjectSecurity(
         HANDLE Handle,
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR SecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurity(
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR ModificationDescriptor,
            PSECURITY_DESCRIPTOR * ObjectsSecurityDescriptor,
         PGENERIC_MAPPING GenericMapping,
             HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurityEx(
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR ModificationDescriptor,
            PSECURITY_DESCRIPTOR * ObjectsSecurityDescriptor,
         ULONG AutoInheritFlags,
         PGENERIC_MAPPING GenericMapping,
             HANDLE Token
    );





__declspec(dllimport)
void
__stdcall
SetSecurityAccessMask(
         SECURITY_INFORMATION SecurityInformation,
          LPDWORD DesiredAccess
    );




__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorControl(
         PSECURITY_DESCRIPTOR pSecurityDescriptor,
         SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
         SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorDacl(
            PSECURITY_DESCRIPTOR pSecurityDescriptor,
         BOOL bDaclPresent,
             PACL pDacl,
         BOOL bDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorGroup(
            PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID pGroup,
         BOOL bGroupDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorOwner(
            PSECURITY_DESCRIPTOR pSecurityDescriptor,
             PSID pOwner,
         BOOL bOwnerDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
SetSecurityDescriptorRMControl(
            PSECURITY_DESCRIPTOR SecurityDescriptor,
             PUCHAR RMControl
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorSacl(
            PSECURITY_DESCRIPTOR pSecurityDescriptor,
         BOOL bSaclPresent,
             PACL pSacl,
         BOOL bSaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetTokenInformation(
         HANDLE TokenHandle,
         TOKEN_INFORMATION_CLASS TokenInformationClass,
                                             LPVOID TokenInformation,
         DWORD TokenInformationLength
    );







__declspec(dllimport)
BOOL
__stdcall
SetCachedSigningLevel(
                                PHANDLE SourceFiles,
         ULONG SourceFileCount,
         ULONG Flags,
             HANDLE TargetFile
    );


__declspec(dllimport)
BOOL
__stdcall
GetCachedSigningLevel(
         HANDLE File,
          PULONG Flags,
          PULONG SigningLevel,
                                                                PUCHAR Thumbprint,
                PULONG ThumbprintSize,
              PULONG ThumbprintAlgorithm
    );
#line 1336 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\securitybaseapi.h"
}
#line 59 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\namespaceapi.h"
#line 33 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\namespaceapi.h"
extern "C" {
#line 42 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\namespaceapi.h"
__declspec(dllimport)
HANDLE
__stdcall
CreatePrivateNamespaceW(
             LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
         LPVOID lpBoundaryDescriptor,
         LPCWSTR lpAliasPrefix
    );


__declspec(dllimport)
HANDLE
__stdcall
OpenPrivateNamespaceW(
         LPVOID lpBoundaryDescriptor,
         LPCWSTR lpAliasPrefix
    );


__declspec(dllimport)
BOOLEAN
__stdcall
ClosePrivateNamespace(
         HANDLE Handle,
         ULONG Flags
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateBoundaryDescriptorW(
         LPCWSTR Name,
         ULONG Flags
    );


__declspec(dllimport)
BOOL
__stdcall
AddSIDToBoundaryDescriptor(
            HANDLE * BoundaryDescriptor,
         PSID RequiredSid
    );


__declspec(dllimport)
void
__stdcall
DeleteBoundaryDescriptor(
         HANDLE BoundaryDescriptor
    );






}
#line 60 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\systemtopologyapi.h"
#line 33 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\systemtopologyapi.h"
extern "C" {






__declspec(dllimport)
BOOL
__stdcall
GetNumaHighestNodeNumber(
          PULONG HighestNodeNumber
    );





__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeProcessorMaskEx(
         USHORT Node,
          PGROUP_AFFINITY ProcessorMask
    );
#line 66 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\systemtopologyapi.h"
}
#line 61 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processtopologyapi.h"
#line 36 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processtopologyapi.h"
extern "C" {
#line 46 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processtopologyapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetProcessGroupAffinity(
         HANDLE hProcess,
            PUSHORT GroupCount,
                              PUSHORT GroupArray
    );
#line 69 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processtopologyapi.h"
__declspec(dllimport)
BOOL
__stdcall
GetThreadGroupAffinity(
         HANDLE hThread,
          PGROUP_AFFINITY GroupAffinity
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadGroupAffinity(
         HANDLE hThread,
         const GROUP_AFFINITY * GroupAffinity,
              PGROUP_AFFINITY PreviousGroupAffinity
    );
#line 94 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\processtopologyapi.h"
}
#line 62 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\securityappcontainer.h"
#line 39 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\securityappcontainer.h"
extern "C" {
#line 49 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\securityappcontainer.h"
BOOL
__stdcall
GetAppContainerNamedObjectPath(
             HANDLE Token,
             PSID AppContainerSid,
         ULONG ObjectPathLength,
                                       LPWSTR ObjectPath,
          PULONG ReturnLength
    );





}
#line 63 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\realtimeapiset.h"
#line 32 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\realtimeapiset.h"
extern "C" {
#line 42 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\realtimeapiset.h"
__declspec(dllimport)
BOOL
__stdcall
QueryThreadCycleTime(
         HANDLE ThreadHandle,
          PULONG64 CycleTime
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProcessCycleTime(
         HANDLE ProcessHandle,
          PULONG64 CycleTime
    );


__declspec(dllimport)
BOOL
__stdcall
QueryIdleProcessorCycleTime(
            PULONG BufferLength,
                                          PULONG64 ProcessorIdleCycleTime
    );







__declspec(dllimport)
BOOL
__stdcall
QueryIdleProcessorCycleTimeEx(
         USHORT Group,
            PULONG BufferLength,
                                          PULONG64 ProcessorIdleCycleTime
    );
#line 96 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\realtimeapiset.h"
__declspec(dllimport)
BOOL
__stdcall
QueryUnbiasedInterruptTime(
          PULONGLONG UnbiasedTime
    );
#line 110 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\realtimeapiset.h"
}
#line 64 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"



extern "C" {
#line 280 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef void (__stdcall *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;

typedef LPVOID (__stdcall *PFIBER_CALLOUT_ROUTINE)(
    LPVOID lpParameter
    );
#line 298 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef PLDT_ENTRY LPLDT_ENTRY;
#line 403 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;







typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;
#line 458 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef struct _DCB {
    DWORD DCBlength;
    DWORD BaudRate;
    DWORD fBinary: 1;
    DWORD fParity: 1;
    DWORD fOutxCtsFlow:1;
    DWORD fOutxDsrFlow:1;
    DWORD fDtrControl:2;
    DWORD fDsrSensitivity:1;
    DWORD fTXContinueOnXoff: 1;
    DWORD fOutX: 1;
    DWORD fInX: 1;
    DWORD fErrorChar: 1;
    DWORD fNull: 1;
    DWORD fRtsControl:2;
    DWORD fAbortOnError:1;
    DWORD fDummy2:17;
    WORD wReserved;
    WORD XonLim;
    WORD XoffLim;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    char XonChar;
    char XoffChar;
    char ErrorChar;
    char EofChar;
    char EvtChar;
    WORD wReserved1;
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;
    DWORD ReadTotalTimeoutMultiplier;
    DWORD ReadTotalTimeoutConstant;
    DWORD WriteTotalTimeoutMultiplier;
    DWORD WriteTotalTimeoutConstant;
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize;
    WORD wVersion;
    WORD wReserved;
    DCB dcb;
    DWORD dwProviderSubType;

    DWORD dwProviderOffset;

    DWORD dwProviderSize;
    WCHAR wcProviderData[1];
} COMMCONFIG,*LPCOMMCONFIG;
#line 545 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;
#line 646 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef struct _JIT_DEBUG_INFO {
    DWORD dwSize;
    DWORD dwProcessorArchitecture;
    DWORD dwThreadID;
    DWORD dwReserved0;
    ULONG64 lpExceptionAddress;
    ULONG64 lpExceptionRecord;
    ULONG64 lpContextRecord;
} JIT_DEBUG_INFO, *LPJIT_DEBUG_INFO;

typedef JIT_DEBUG_INFO JIT_DEBUG_INFO32, *LPJIT_DEBUG_INFO32;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO64, *LPJIT_DEBUG_INFO64;


typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
#line 875 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;
#line 895 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
int




__stdcall




WinMain (
         HINSTANCE hInstance,
             HINSTANCE hPrevInstance,
         LPSTR lpCmdLine,
         int nShowCmd
    );

int



__stdcall

wWinMain(
         HINSTANCE hInstance,
             HINSTANCE hPrevInstance,
         LPWSTR lpCmdLine,
         int nShowCmd
    );

__declspec(dllimport)


HGLOBAL
__stdcall
GlobalAlloc(
         UINT uFlags,
         SIZE_T dwBytes
    );

__declspec(dllimport)

HGLOBAL
__stdcall
GlobalReAlloc (
                HGLOBAL hMem,
         SIZE_T dwBytes,
         UINT uFlags
    );

__declspec(dllimport)
SIZE_T
__stdcall
GlobalSize (
         HGLOBAL hMem
    );

__declspec(dllimport)
UINT
__stdcall
GlobalFlags (
         HGLOBAL hMem
    );

__declspec(dllimport)

LPVOID
__stdcall
GlobalLock (
         HGLOBAL hMem
    );

__declspec(dllimport)

HGLOBAL
__stdcall
GlobalHandle (
         LPCVOID pMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnlock(
         HGLOBAL hMem
    );

__declspec(dllimport)


HGLOBAL
__stdcall
GlobalFree(
                    HGLOBAL hMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
GlobalCompact(
         DWORD dwMinFree
    );

__declspec(dllimport)
void
__stdcall
GlobalFix(
         HGLOBAL hMem
    );

__declspec(dllimport)
void
__stdcall
GlobalUnfix(
         HGLOBAL hMem
    );

__declspec(dllimport)
LPVOID
__stdcall
GlobalWire(
         HGLOBAL hMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnWire(
         HGLOBAL hMem
    );


__declspec(dllimport)
void
__stdcall
GlobalMemoryStatus(
          LPMEMORYSTATUS lpBuffer
    );

__declspec(dllimport)


HLOCAL
__stdcall
LocalAlloc(
         UINT uFlags,
         SIZE_T uBytes
    );

__declspec(dllimport)

HLOCAL
__stdcall
LocalReAlloc(
                    HLOCAL hMem,
         SIZE_T uBytes,
         UINT uFlags
    );

__declspec(dllimport)

LPVOID
__stdcall
LocalLock(
         HLOCAL hMem
    );

__declspec(dllimport)

HLOCAL
__stdcall
LocalHandle(
         LPCVOID pMem
    );

__declspec(dllimport)
BOOL
__stdcall
LocalUnlock(
         HLOCAL hMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalSize(
         HLOCAL hMem
    );

__declspec(dllimport)
UINT
__stdcall
LocalFlags(
         HLOCAL hMem
    );

__declspec(dllimport)


HLOCAL
__stdcall
LocalFree(
                    HLOCAL hMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalShrink(
         HLOCAL hMem,
         UINT cbNewSize
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalCompact(
         UINT uMinFree
    );



__declspec(dllimport)
BOOL
__stdcall
GetProcessorSystemCycleTime (
         USHORT Group,
                                                                PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer,
            PDWORD ReturnedLength
    );
#line 1144 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeA(
          LPCSTR lpApplicationName,
          LPDWORD lpBinaryType
    );
__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeW(
          LPCWSTR lpApplicationName,
          LPDWORD lpBinaryType
    );






__declspec(dllimport)

DWORD
__stdcall
GetShortPathNameA(
         LPCSTR lpszLongPath,
                                               LPSTR lpszShortPath,
         DWORD cchBuffer
    );






__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameTransactedA(
             LPCSTR lpszShortPath,
                                               LPSTR lpszLongPath,
             DWORD cchBuffer,
             HANDLE hTransaction
    );
__declspec(dllimport)

DWORD
__stdcall
GetLongPathNameTransactedW(
             LPCWSTR lpszShortPath,
                                               LPWSTR lpszLongPath,
             DWORD cchBuffer,
             HANDLE hTransaction
    );
#line 1207 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
GetProcessAffinityMask(
          HANDLE hProcess,
          PDWORD_PTR lpProcessAffinityMask,
          PDWORD_PTR lpSystemAffinityMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityMask(
         HANDLE hProcess,
         DWORD_PTR dwProcessAffinityMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessIoCounters(
          HANDLE hProcess,
          PIO_COUNTERS lpIoCounters
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessWorkingSetSize(
          HANDLE hProcess,
          PSIZE_T lpMinimumWorkingSetSize,
          PSIZE_T lpMaximumWorkingSetSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSize(
         HANDLE hProcess,
         SIZE_T dwMinimumWorkingSetSize,
         SIZE_T dwMaximumWorkingSetSize
    );

__declspec(dllimport)

void
__stdcall
FatalExit(
         int ExitCode
    );

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsA(
                                     LPCH NewEnvironment
    );
#line 1274 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
void
__stdcall
RaiseFailFastException(
             PEXCEPTION_RECORD pExceptionRecord,
             PCONTEXT pContextRecord,
         DWORD dwFlags
    );
#line 1297 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
void
__stdcall
SwitchToFiber(
         LPVOID lpFiber
    );

__declspec(dllimport)
void
__stdcall
DeleteFiber(
         LPVOID lpFiber
    );



__declspec(dllimport)
BOOL
__stdcall
ConvertFiberToThread(
    void
    );





__declspec(dllimport)

PVOID
__stdcall
CalloutOnFiberStack(
         PVOID lpFiber,
         PFIBER_CALLOUT_ROUTINE lpStartAddress,
             PVOID lpParameter
    );



__declspec(dllimport)

LPVOID
__stdcall
CreateFiberEx(
             SIZE_T dwStackCommitSize,
             SIZE_T dwStackReserveSize,
             DWORD dwFlags,
             LPFIBER_START_ROUTINE lpStartAddress,
             LPVOID lpParameter
    );

__declspec(dllimport)

LPVOID
__stdcall
ConvertThreadToFiberEx(
             LPVOID lpParameter,
             DWORD dwFlags
    );







__declspec(dllimport)

LPVOID
__stdcall
CreateFiber(
             SIZE_T dwStackSize,
             LPFIBER_START_ROUTINE lpStartAddress,
             LPVOID lpParameter
    );

__declspec(dllimport)

LPVOID
__stdcall
ConvertThreadToFiber(
             LPVOID lpParameter
    );
#line 1399 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef void *PUMS_CONTEXT;

typedef void *PUMS_COMPLETION_LIST;

typedef enum _RTL_UMS_THREAD_INFO_CLASS UMS_THREAD_INFO_CLASS, *PUMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;

typedef PRTL_UMS_SCHEDULER_ENTRY_POINT PUMS_SCHEDULER_ENTRY_POINT;

typedef struct _UMS_SCHEDULER_STARTUP_INFO {




    ULONG UmsVersion;




    PUMS_COMPLETION_LIST CompletionList;





    PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;




    PVOID SchedulerParam;

} UMS_SCHEDULER_STARTUP_INFO, *PUMS_SCHEDULER_STARTUP_INFO;

typedef struct _UMS_SYSTEM_THREAD_INFORMATION {
    ULONG UmsVersion;
    union {
        struct {
            ULONG IsUmsSchedulerThread : 1;
            ULONG IsUmsWorkerThread : 1;
        } ;
        ULONG ThreadUmsFlags;
    } ;
} UMS_SYSTEM_THREAD_INFORMATION, *PUMS_SYSTEM_THREAD_INFORMATION;


__declspec(dllimport)
BOOL
__stdcall
CreateUmsCompletionList(
             PUMS_COMPLETION_LIST* UmsCompletionList
    );

__declspec(dllimport)
BOOL
__stdcall
DequeueUmsCompletionListItems(
         PUMS_COMPLETION_LIST UmsCompletionList,
         DWORD WaitTimeOut,
          PUMS_CONTEXT* UmsThreadList
    );

__declspec(dllimport)
BOOL
__stdcall
GetUmsCompletionListEvent(
         PUMS_COMPLETION_LIST UmsCompletionList,
            PHANDLE UmsCompletionEvent
    );

__declspec(dllimport)
BOOL
__stdcall
ExecuteUmsThread(
            PUMS_CONTEXT UmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
UmsThreadYield(
         PVOID SchedulerParam
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteUmsCompletionList(
         PUMS_COMPLETION_LIST UmsCompletionList
    );

__declspec(dllimport)
PUMS_CONTEXT
__stdcall
GetCurrentUmsThread(
    void
    );

__declspec(dllimport)
PUMS_CONTEXT
__stdcall
GetNextUmsListItem(
            PUMS_CONTEXT UmsContext
    );

__declspec(dllimport)
BOOL
__stdcall
QueryUmsThreadInformation(
         PUMS_CONTEXT UmsThread,
         UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
                                                                     PVOID UmsThreadInformation,
         ULONG UmsThreadInformationLength,
              PULONG ReturnLength
    );

__declspec(dllimport)
BOOL
__stdcall
SetUmsThreadInformation(
         PUMS_CONTEXT UmsThread,
         UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
         PVOID UmsThreadInformation,
         ULONG UmsThreadInformationLength
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteUmsThreadContext(
         PUMS_CONTEXT UmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
CreateUmsThreadContext(
             PUMS_CONTEXT *lpUmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
EnterUmsSchedulingMode(
         PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo
    );

__declspec(dllimport)
BOOL
__stdcall
GetUmsSystemThreadInformation(
         HANDLE ThreadHandle,
            PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo
    );
#line 1569 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
DWORD_PTR
__stdcall
SetThreadAffinityMask(
         HANDLE hThread,
         DWORD_PTR dwThreadAffinityMask
    );


__declspec(dllimport)
DWORD
__stdcall
SetThreadIdealProcessor(
         HANDLE hThread,
         DWORD dwIdealProcessor
    );






typedef enum _PROCESS_INFORMATION_CLASS {
    ProcessMemoryPriority,
    ProcessInformationClassMax
} PROCESS_INFORMATION_CLASS;



__declspec(dllimport)
BOOL
__stdcall
GetProcessInformation (
         HANDLE hProcess,
         PROCESS_INFORMATION_CLASS ProcessInformationClass,
                                               LPVOID ProcessInformation,
         DWORD ProcessInformationSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessInformation (
         HANDLE hProcess,
         PROCESS_INFORMATION_CLASS ProcessInformationClass,
                                             LPVOID ProcessInformation,
         DWORD ProcessInformationSize
    );
#line 1625 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
SetProcessDEPPolicy(
         DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessDEPPolicy(
         HANDLE hProcess,
          LPDWORD lpFlags,
          PBOOL lpPermanent
    );



__declspec(dllimport)
BOOL
__stdcall
RequestWakeupLatency(
         LATENCY_TIME latency
    );

__declspec(dllimport)
BOOL
__stdcall
IsSystemResumeAutomatic(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
GetThreadSelectorEntry(
          HANDLE hThread,
          DWORD dwSelector,
          LPLDT_ENTRY lpSelectorEntry
    );

__declspec(dllimport)
EXECUTION_STATE
__stdcall
SetThreadExecutionState(
         EXECUTION_STATE esFlags
    );







typedef REASON_CONTEXT POWER_REQUEST_CONTEXT, *PPOWER_REQUEST_CONTEXT, *LPPOWER_REQUEST_CONTEXT;

__declspec(dllimport)
HANDLE
__stdcall
PowerCreateRequest (
         PREASON_CONTEXT Context
    );

__declspec(dllimport)
BOOL
__stdcall
PowerSetRequest (
         HANDLE PowerRequest,
         POWER_REQUEST_TYPE RequestType
    );

__declspec(dllimport)
BOOL
__stdcall
PowerClearRequest (
         HANDLE PowerRequest,
         POWER_REQUEST_TYPE RequestType
    );
#line 1761 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
SetFileCompletionNotificationModes(
         HANDLE FileHandle,
         UCHAR Flags
    );
#line 1780 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
DWORD
__stdcall
GetThreadErrorMode(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
SetThreadErrorMode(
         DWORD dwNewMode,
             LPDWORD lpOldMode
    );





__declspec(dllimport)
BOOL
__stdcall
Wow64GetThreadContext(
            HANDLE hThread,
            PWOW64_CONTEXT lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
Wow64SetThreadContext(
         HANDLE hThread,
         const WOW64_CONTEXT *lpContext
    );





__declspec(dllimport)
BOOL
__stdcall
Wow64GetThreadSelectorEntry(
         HANDLE hThread,
         DWORD dwSelector,
          PWOW64_LDT_ENTRY lpSelectorEntry
    );







__declspec(dllimport)
DWORD
__stdcall
Wow64SuspendThread(
         HANDLE hThread
    );



__declspec(dllimport)
BOOL
__stdcall
DebugSetProcessKillOnExit(
         BOOL KillOnExit
    );

__declspec(dllimport)
BOOL
__stdcall
DebugBreakProcess (
         HANDLE Process
    );
#line 1873 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
PulseEvent(
         HANDLE hEvent
    );

__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjects(
         DWORD nCount,
                       const HANDLE *lpHandles,
         BOOL bWaitAll,
         DWORD dwMilliseconds
    );

__declspec(dllimport)
ATOM
__stdcall
GlobalDeleteAtom(
         ATOM nAtom
    );

__declspec(dllimport)
BOOL
__stdcall
InitAtomTable(
         DWORD nSize
    );

__declspec(dllimport)
ATOM
__stdcall
DeleteAtom(
         ATOM nAtom
    );

__declspec(dllimport)
UINT
__stdcall
SetHandleCount(
         UINT uNumber
    );

__declspec(dllimport)
BOOL
__stdcall
RequestDeviceWakeup(
         HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
CancelDeviceWakeupRequest(
         HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
GetDevicePowerState(
          HANDLE hDevice,
          BOOL *pfOn
    );

__declspec(dllimport)
BOOL
__stdcall
SetMessageWaitingIndicator(
         HANDLE hMsgIndicator,
         ULONG ulMsgCount
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameA(
         HANDLE hFile,
         LPCSTR lpShortName
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameW(
         HANDLE hFile,
         LPCWSTR lpShortName
    );
#line 1974 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
DWORD
__stdcall
LoadModule(
         LPCSTR lpModuleName,
         LPVOID lpParameterBlock
    );



__declspec(dllimport)
UINT
__stdcall
WinExec(
         LPCSTR lpCmdLine,
         UINT uCmdShow
    );

__declspec(dllimport)
BOOL
__stdcall
ClearCommBreak(
         HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
ClearCommError(
              HANDLE hFile,
              LPDWORD lpErrors,
              LPCOMSTAT lpStat
    );

__declspec(dllimport)
BOOL
__stdcall
SetupComm(
         HANDLE hFile,
         DWORD dwInQueue,
         DWORD dwOutQueue
    );

__declspec(dllimport)
BOOL
__stdcall
EscapeCommFunction(
         HANDLE hFile,
         DWORD dwFunc
    );

__declspec(dllimport)

BOOL
__stdcall
GetCommConfig(
              HANDLE hCommDev,
                                      LPCOMMCONFIG lpCC,
              LPDWORD lpdwSize
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommMask(
          HANDLE hFile,
          LPDWORD lpEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommProperties(
            HANDLE hFile,
            LPCOMMPROP lpCommProp
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommModemStatus(
          HANDLE hFile,
          LPDWORD lpModemStat
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommState(
          HANDLE hFile,
          LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommTimeouts(
          HANDLE hFile,
          LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
PurgeComm(
         HANDLE hFile,
         DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommBreak(
         HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommConfig(
         HANDLE hCommDev,
                             LPCOMMCONFIG lpCC,
         DWORD dwSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommMask(
         HANDLE hFile,
         DWORD dwEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommState(
         HANDLE hFile,
         LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommTimeouts(
         HANDLE hFile,
         LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
TransmitCommChar(
         HANDLE hFile,
         char cChar
    );

__declspec(dllimport)
BOOL
__stdcall
WaitCommEvent(
                HANDLE hFile,
                LPDWORD lpEvtMask,
                LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
DWORD
__stdcall
SetTapePosition(
         HANDLE hDevice,
         DWORD dwPositionMethod,
         DWORD dwPartition,
         DWORD dwOffsetLow,
         DWORD dwOffsetHigh,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapePosition(
          HANDLE hDevice,
          DWORD dwPositionType,
          LPDWORD lpdwPartition,
          LPDWORD lpdwOffsetLow,
          LPDWORD lpdwOffsetHigh
    );

__declspec(dllimport)
DWORD
__stdcall
PrepareTape(
         HANDLE hDevice,
         DWORD dwOperation,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
EraseTape(
         HANDLE hDevice,
         DWORD dwEraseType,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
CreateTapePartition(
         HANDLE hDevice,
         DWORD dwPartitionMethod,
         DWORD dwCount,
         DWORD dwSize
    );

__declspec(dllimport)
DWORD
__stdcall
WriteTapemark(
         HANDLE hDevice,
         DWORD dwTapemarkType,
         DWORD dwTapemarkCount,
         BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeStatus(
         HANDLE hDevice
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeParameters(
            HANDLE hDevice,
            DWORD dwOperation,
            LPDWORD lpdwSize,
                                  LPVOID lpTapeInformation
    );




__declspec(dllimport)
DWORD
__stdcall
SetTapeParameters(
         HANDLE hDevice,
         DWORD dwOperation,
         LPVOID lpTapeInformation
    );
#line 2240 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
int
__stdcall
MulDiv(
         int nNumber,
         int nNumerator,
         int nDenominator
    );







typedef enum _DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;



__declspec(dllimport)
DEP_SYSTEM_POLICY_TYPE
__stdcall
GetSystemDEPPolicy(
    void
    );





__declspec(dllimport)
BOOL
__stdcall
GetSystemRegistryQuota(
              PDWORD pdwQuotaAllowed,
              PDWORD pdwQuotaUsed
    );







__declspec(dllimport)
BOOL
__stdcall
FileTimeToDosDateTime(
          const FILETIME *lpFileTime,
          LPWORD lpFatDate,
          LPWORD lpFatTime
    );

__declspec(dllimport)
BOOL
__stdcall
DosDateTimeToFileTime(
          WORD wFatDate,
          WORD wFatTime,
          LPFILETIME lpFileTime
    );
#line 2316 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)

DWORD
__stdcall
FormatMessageA(
             DWORD dwFlags,
             LPCVOID lpSource,
             DWORD dwMessageId,
             DWORD dwLanguageId,
             LPSTR lpBuffer,
             DWORD nSize,
             va_list *Arguments
    );
__declspec(dllimport)

DWORD
__stdcall
FormatMessageW(
             DWORD dwFlags,
             LPCVOID lpSource,
             DWORD dwMessageId,
             DWORD dwLanguageId,
             LPWSTR lpBuffer,
             DWORD nSize,
             va_list *Arguments
    );
#line 2400 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeInfo(
              HANDLE hNamedPipe,
              LPDWORD lpFlags,
              LPDWORD lpOutBufferSize,
              LPDWORD lpInBufferSize,
              LPDWORD lpMaxInstances
    );

__declspec(dllimport)
HANDLE
__stdcall
CreateMailslotA(
             LPCSTR lpName,
             DWORD nMaxMessageSize,
             DWORD lReadTimeout,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateMailslotW(
             LPCWSTR lpName,
             DWORD nMaxMessageSize,
             DWORD lReadTimeout,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );






__declspec(dllimport)
BOOL
__stdcall
GetMailslotInfo(
              HANDLE hMailslot,
              LPDWORD lpMaxMessageSize,
              LPDWORD lpNextSize,
              LPDWORD lpMessageCount,
              LPDWORD lpReadTimeout
    );

__declspec(dllimport)
BOOL
__stdcall
SetMailslotInfo(
         HANDLE hMailslot,
         DWORD lReadTimeout
    );





__declspec(dllimport)
BOOL
__stdcall
EncryptFileA(
         LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
EncryptFileW(
         LPCWSTR lpFileName
    );






__declspec(dllimport)
BOOL
__stdcall
DecryptFileA(
               LPCSTR lpFileName,
               DWORD dwReserved
    );
__declspec(dllimport)
BOOL
__stdcall
DecryptFileW(
               LPCWSTR lpFileName,
               DWORD dwReserved
    );
#line 2511 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusA(
          LPCSTR lpFileName,
          LPDWORD lpStatus
    );
__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusW(
          LPCWSTR lpFileName,
          LPDWORD lpStatus
    );
#line 2537 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef
DWORD
(__stdcall *PFE_EXPORT_FUNC)(
                               PBYTE pbData,
             PVOID pvCallbackContext,
             ULONG ulLength
    );

typedef
DWORD
(__stdcall *PFE_IMPORT_FUNC)(
                                                PBYTE pbData,
             PVOID pvCallbackContext,
             PULONG ulLength
    );
#line 2564 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawA(
                LPCSTR lpFileName,
                ULONG ulFlags,
             PVOID *pvContext
    );
__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawW(
                LPCWSTR lpFileName,
                ULONG ulFlags,
             PVOID *pvContext
    );






__declspec(dllimport)
DWORD
__stdcall
ReadEncryptedFileRaw(
             PFE_EXPORT_FUNC pfExportCallback,
             PVOID pvCallbackContext,
             PVOID pvContext
    );

__declspec(dllimport)
DWORD
__stdcall
WriteEncryptedFileRaw(
             PFE_IMPORT_FUNC pfImportCallback,
             PVOID pvCallbackContext,
             PVOID pvContext
    );

__declspec(dllimport)
void
__stdcall
CloseEncryptedFileRaw(
         PVOID pvContext
    );





__declspec(dllimport)
int
__stdcall
lstrcmpA(
         LPCSTR lpString1,
         LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpW(
         LPCWSTR lpString1,
         LPCWSTR lpString2
    );






__declspec(dllimport)
int
__stdcall
lstrcmpiA(
         LPCSTR lpString1,
         LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpiW(
         LPCWSTR lpString1,
         LPCWSTR lpString2
    );






__declspec(dllimport)




LPSTR
__stdcall
lstrcpynA(
                             LPSTR lpString1,
         LPCSTR lpString2,
         int iMaxLength
    );
__declspec(dllimport)




LPWSTR
__stdcall
lstrcpynW(
                             LPWSTR lpString1,
         LPCWSTR lpString2,
         int iMaxLength
    );







#pragma warning(push)
#pragma warning(disable: 4995)


__declspec(dllimport)
LPSTR
__stdcall
lstrcpyA(
                                                 LPSTR lpString1,
          LPCSTR lpString2
    );
__declspec(dllimport)
LPWSTR
__stdcall
lstrcpyW(
                                                 LPWSTR lpString1,
          LPCWSTR lpString2
    );






__declspec(dllimport)
LPSTR
__stdcall
lstrcatA(
                                                                                   LPSTR lpString1,
            LPCSTR lpString2
    );
__declspec(dllimport)
LPWSTR
__stdcall
lstrcatW(
                                                                                   LPWSTR lpString1,
            LPCWSTR lpString2
    );







#pragma warning(pop)


__declspec(dllimport)
int
__stdcall
lstrlenA(
         LPCSTR lpString
    );
__declspec(dllimport)
int
__stdcall
lstrlenW(
         LPCWSTR lpString
    );






__declspec(dllimport)
HFILE
__stdcall
OpenFile(
            LPCSTR lpFileName,
            LPOFSTRUCT lpReOpenBuff,
            UINT uStyle
    );

__declspec(dllimport)
HFILE
__stdcall
_lopen(
         LPCSTR lpPathName,
         int iReadWrite
    );

__declspec(dllimport)
HFILE
__stdcall
_lcreat(
         LPCSTR lpPathName,
         int iAttribute
    );

__declspec(dllimport)
UINT
__stdcall
_lread(
         HFILE hFile,
                                          LPVOID lpBuffer,
         UINT uBytes
    );

__declspec(dllimport)
UINT
__stdcall
_lwrite(
         HFILE hFile,
                             LPCCH lpBuffer,
         UINT uBytes
    );

__declspec(dllimport)
long
__stdcall
_hread(
         HFILE hFile,
                                          LPVOID lpBuffer,
         long lBytes
    );

__declspec(dllimport)
long
__stdcall
_hwrite(
         HFILE hFile,
                             LPCCH lpBuffer,
         long lBytes
    );

__declspec(dllimport)
HFILE
__stdcall
_lclose(
         HFILE hFile
    );

__declspec(dllimport)
LONG
__stdcall
_llseek(
         HFILE hFile,
         LONG lOffset,
         int iOrigin
    );

__declspec(dllimport)
BOOL
__stdcall
IsTextUnicode(
                            const void* lpv,
                int iSize,
                LPINT lpiResult
    );


__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
         HANDLE hObjectToSignal,
         HANDLE hObjectToWaitOn,
         DWORD dwMilliseconds,
         BOOL bAlertable
    );


__declspec(dllimport)
BOOL
__stdcall
BackupRead(
            HANDLE hFile,
                                                                      LPBYTE lpBuffer,
            DWORD nNumberOfBytesToRead,
            LPDWORD lpNumberOfBytesRead,
            BOOL bAbort,
            BOOL bProcessSecurity,
            LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupSeek(
            HANDLE hFile,
            DWORD dwLowBytesToSeek,
            DWORD dwHighBytesToSeek,
            LPDWORD lpdwLowByteSeeked,
            LPDWORD lpdwHighByteSeeked,
            LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupWrite(
            HANDLE hFile,
                                            LPBYTE lpBuffer,
            DWORD nNumberOfBytesToWrite,
            LPDWORD lpNumberOfBytesWritten,
            BOOL bAbort,
            BOOL bProcessSecurity,
            LPVOID *lpContext
    );




typedef struct _WIN32_STREAM_ID {
        DWORD dwStreamId ;
        DWORD dwStreamAttributes ;
        LARGE_INTEGER Size ;
        DWORD dwStreamNameSize ;
        WCHAR cStreamName[ 1 ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;
#line 2950 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef struct _STARTUPINFOEXA {
    STARTUPINFOA StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;
typedef struct _STARTUPINFOEXW {
    STARTUPINFOW StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;

typedef STARTUPINFOEXW STARTUPINFOEX;
typedef LPSTARTUPINFOEXW LPSTARTUPINFOEX;
#line 2976 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)

HANDLE
__stdcall
OpenMutexA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );




__declspec(dllimport)

HANDLE
__stdcall
CreateSemaphoreA(
             LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
             LONG lInitialCount,
             LONG lMaximumCount,
             LPCSTR lpName
    );
__declspec(dllimport)

HANDLE
__stdcall
CreateSemaphoreW(
             LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
             LONG lInitialCount,
             LONG lMaximumCount,
             LPCWSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
OpenSemaphoreA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerA(
             LPSECURITY_ATTRIBUTES lpTimerAttributes,
             BOOL bManualReset,
             LPCSTR lpTimerName
    );
__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerW(
             LPSECURITY_ATTRIBUTES lpTimerAttributes,
             BOOL bManualReset,
             LPCWSTR lpTimerName
    );






__declspec(dllimport)

HANDLE
__stdcall
OpenWaitableTimerA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpTimerName
    );






__declspec(dllimport)

HANDLE
__stdcall
CreateSemaphoreExA(
                LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
                LONG lInitialCount,
                LONG lMaximumCount,
                LPCSTR lpName,
                DWORD dwFlags,
                DWORD dwDesiredAccess
    );




__declspec(dllimport)

HANDLE
__stdcall
CreateWaitableTimerExA(
             LPSECURITY_ATTRIBUTES lpTimerAttributes,
             LPCSTR lpTimerName,
             DWORD dwFlags,
             DWORD dwDesiredAccess
    );
#line 3103 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingA(
             HANDLE hFile,
             LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
             DWORD flProtect,
             DWORD dwMaximumSizeHigh,
             DWORD dwMaximumSizeLow,
             LPCSTR lpName
    );






__declspec(dllimport)

HANDLE
__stdcall
CreateFileMappingNumaA(
             HANDLE hFile,
             LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
             DWORD flProtect,
             DWORD dwMaximumSizeHigh,
             DWORD dwMaximumSizeLow,
             LPCSTR lpName,
             DWORD nndPreferred
    );







__declspec(dllimport)
HANDLE
__stdcall
OpenFileMappingA(
         DWORD dwDesiredAccess,
         BOOL bInheritHandle,
         LPCSTR lpName
    );




__declspec(dllimport)

DWORD
__stdcall
GetLogicalDriveStringsA(
         DWORD nBufferLength,
                                                   LPSTR lpBuffer
    );





__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryA(
         LPCSTR lpLibFileName
    );
__declspec(dllimport)

HMODULE
__stdcall
LoadLibraryW(
         LPCWSTR lpLibFileName
    );
#line 3194 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)

HMODULE
__stdcall
LoadPackagedLibrary (
               LPCWSTR lpwLibFileName,
               DWORD Reserved
    );
#line 3215 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
QueryFullProcessImageNameA(
         HANDLE hProcess,
         DWORD dwFlags,
                                          LPSTR lpExeName,
            PDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
QueryFullProcessImageNameW(
         HANDLE hProcess,
         DWORD dwFlags,
                                          LPWSTR lpExeName,
            PDWORD lpdwSize
    );
#line 3256 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef enum _PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeHandleList = 2,

    ProcThreadAttributeGroupAffinity = 3,
    ProcThreadAttributePreferredNode = 4,
    ProcThreadAttributeIdealProcessor = 5,
    ProcThreadAttributeUmsThread = 6,
    ProcThreadAttributeMitigationPolicy = 7,


    ProcThreadAttributeSecurityCapabilities = 9,

    ProcThreadAttributeProtectionLevel = 11,
} PROC_THREAD_ATTRIBUTE_NUM;
#line 3434 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
GetProcessShutdownParameters(
          LPDWORD lpdwLevel,
          LPDWORD lpdwFlags
    );

__declspec(dllimport)
void
__stdcall
FatalAppExitA(
         UINT uAction,
         LPCSTR lpMessageText
    );
__declspec(dllimport)
void
__stdcall
FatalAppExitW(
         UINT uAction,
         LPCWSTR lpMessageText
    );






__declspec(dllimport)
void
__stdcall
GetStartupInfoA(
          LPSTARTUPINFOA lpStartupInfo
    );
#line 3526 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableA(
         LPCSTR lpName,
         LPCSTR lpGuid,
                                             PVOID pBuffer,
         DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableW(
         LPCWSTR lpName,
         LPCWSTR lpGuid,
                                             PVOID pBuffer,
         DWORD nSize
    );
#line 3552 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableExA(
         LPCSTR lpName,
         LPCSTR lpGuid,
                                             PVOID pBuffer,
         DWORD nSize,
              PDWORD pdwAttribubutes
    );
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableExW(
         LPCWSTR lpName,
         LPCWSTR lpGuid,
                                             PVOID pBuffer,
         DWORD nSize,
              PDWORD pdwAttribubutes
    );
#line 3580 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableA(
         LPCSTR lpName,
         LPCSTR lpGuid,
                                PVOID pValue,
         DWORD nSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableW(
         LPCWSTR lpName,
         LPCWSTR lpGuid,
                                PVOID pValue,
         DWORD nSize
    );
#line 3606 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableExA(
         LPCSTR lpName,
         LPCSTR lpGuid,
                                PVOID pValue,
         DWORD nSize,
         DWORD dwAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableExW(
         LPCWSTR lpName,
         LPCWSTR lpGuid,
                                PVOID pValue,
         DWORD nSize,
         DWORD dwAttributes
    );
#line 3636 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
GetFirmwareType (
            PFIRMWARE_TYPE FirmwareType
    );


__declspec(dllimport)
BOOL
__stdcall
IsNativeVhdBoot (
          PBOOL NativeVhdBoot
    );



__declspec(dllimport)

HRSRC
__stdcall
FindResourceA(
             HMODULE hModule,
             LPCSTR lpName,
             LPCSTR lpType
    );
__declspec(dllimport)

HRSRC
__stdcall
FindResourceW(
             HMODULE hModule,
             LPCWSTR lpName,
             LPCWSTR lpType
    );






__declspec(dllimport)

HRSRC
__stdcall
FindResourceExA(
             HMODULE hModule,
             LPCSTR lpType,
             LPCSTR lpName,
             WORD wLanguage
    );




__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesA(
             HMODULE hModule,
             ENUMRESTYPEPROCA lpEnumFunc,
             LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesW(
             HMODULE hModule,
             ENUMRESTYPEPROCW lpEnumFunc,
             LONG_PTR lParam
    );






__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesA(
             HMODULE hModule,
             LPCSTR lpType,
             ENUMRESNAMEPROCA lpEnumFunc,
             LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesW(
             HMODULE hModule,
             LPCWSTR lpType,
             ENUMRESNAMEPROCW lpEnumFunc,
             LONG_PTR lParam
    );






__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesA(
             HMODULE hModule,
             LPCSTR lpType,
             LPCSTR lpName,
             ENUMRESLANGPROCA lpEnumFunc,
             LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesW(
             HMODULE hModule,
             LPCWSTR lpType,
             LPCWSTR lpName,
             ENUMRESLANGPROCW lpEnumFunc,
             LONG_PTR lParam
    );






__declspec(dllimport)
HANDLE
__stdcall
BeginUpdateResourceA(
         LPCSTR pFileName,
         BOOL bDeleteExistingResources
    );
__declspec(dllimport)
HANDLE
__stdcall
BeginUpdateResourceW(
         LPCWSTR pFileName,
         BOOL bDeleteExistingResources
    );






__declspec(dllimport)
BOOL
__stdcall
UpdateResourceA(
         HANDLE hUpdate,
         LPCSTR lpType,
         LPCSTR lpName,
         WORD wLanguage,
                             LPVOID lpData,
         DWORD cb
    );
__declspec(dllimport)
BOOL
__stdcall
UpdateResourceW(
         HANDLE hUpdate,
         LPCWSTR lpType,
         LPCWSTR lpName,
         WORD wLanguage,
                             LPVOID lpData,
         DWORD cb
    );






__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceA(
         HANDLE hUpdate,
         BOOL fDiscard
    );
__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceW(
         HANDLE hUpdate,
         BOOL fDiscard
    );
#line 3833 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomA(
             LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomW(
             LPCWSTR lpString
    );






__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomExA(
             LPCSTR lpString,
         DWORD Flags
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomExW(
             LPCWSTR lpString,
         DWORD Flags
    );






__declspec(dllimport)
ATOM
__stdcall
GlobalFindAtomA(
             LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalFindAtomW(
             LPCWSTR lpString
    );






__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameA(
         ATOM nAtom,
                                       LPSTR lpBuffer,
         int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameW(
         ATOM nAtom,
                                       LPWSTR lpBuffer,
         int nSize
    );






__declspec(dllimport)
ATOM
__stdcall
AddAtomA(
             LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
AddAtomW(
             LPCWSTR lpString
    );






__declspec(dllimport)
ATOM
__stdcall
FindAtomA(
             LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
FindAtomW(
             LPCWSTR lpString
    );






__declspec(dllimport)
UINT
__stdcall
GetAtomNameA(
         ATOM nAtom,
                                       LPSTR lpBuffer,
         int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GetAtomNameW(
         ATOM nAtom,
                                       LPWSTR lpBuffer,
         int nSize
    );






__declspec(dllimport)
UINT
__stdcall
GetProfileIntA(
         LPCSTR lpAppName,
         LPCSTR lpKeyName,
         INT nDefault
    );
__declspec(dllimport)
UINT
__stdcall
GetProfileIntW(
         LPCWSTR lpAppName,
         LPCWSTR lpKeyName,
         INT nDefault
    );






__declspec(dllimport)
DWORD
__stdcall
GetProfileStringA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             LPCSTR lpDefault,
                                           LPSTR lpReturnedString,
             DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileStringW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             LPCWSTR lpDefault,
                                           LPWSTR lpReturnedString,
             DWORD nSize
    );






__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             LPCWSTR lpString
    );






__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionA(
         LPCSTR lpAppName,
                                           LPSTR lpReturnedString,
         DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionW(
         LPCWSTR lpAppName,
                                           LPWSTR lpReturnedString,
         DWORD nSize
    );






__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionA(
         LPCSTR lpAppName,
         LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionW(
         LPCWSTR lpAppName,
         LPCWSTR lpString
    );






__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             INT nDefault,
             LPCSTR lpFileName
    );
__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             INT nDefault,
             LPCWSTR lpFileName
    );
#line 4129 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             LPCSTR lpDefault,
                                           LPSTR lpReturnedString,
             DWORD nSize,
             LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             LPCWSTR lpDefault,
                                           LPWSTR lpReturnedString,
             DWORD nSize,
             LPCWSTR lpFileName
    );
#line 4185 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringA(
             LPCSTR lpAppName,
             LPCSTR lpKeyName,
             LPCSTR lpString,
             LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringW(
             LPCWSTR lpAppName,
             LPCWSTR lpKeyName,
             LPCWSTR lpString,
             LPCWSTR lpFileName
    );






__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionA(
             LPCSTR lpAppName,
                                           LPSTR lpReturnedString,
             DWORD nSize,
             LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionW(
             LPCWSTR lpAppName,
                                           LPWSTR lpReturnedString,
             DWORD nSize,
             LPCWSTR lpFileName
    );
#line 4257 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionA(
             LPCSTR lpAppName,
             LPCSTR lpString,
             LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionW(
             LPCWSTR lpAppName,
             LPCWSTR lpString,
             LPCWSTR lpFileName
    );







__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesA(
                                           LPSTR lpszReturnBuffer,
             DWORD nSize,
             LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesW(
                                           LPWSTR lpszReturnBuffer,
             DWORD nSize,
             LPCWSTR lpFileName
    );
#line 4324 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructA(
             LPCSTR lpszSection,
             LPCSTR lpszKey,
                                        LPVOID lpStruct,
             UINT uSizeStruct,
             LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructW(
             LPCWSTR lpszSection,
             LPCWSTR lpszKey,
                                        LPVOID lpStruct,
             UINT uSizeStruct,
             LPCWSTR szFile
    );
#line 4376 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructA(
             LPCSTR lpszSection,
             LPCSTR lpszKey,
                                      LPVOID lpStruct,
             UINT uSizeStruct,
             LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructW(
             LPCWSTR lpszSection,
             LPCWSTR lpszKey,
                                      LPVOID lpStruct,
             UINT uSizeStruct,
             LPCWSTR szFile
    );






__declspec(dllimport)
DWORD
__stdcall
GetTempPathA(
         DWORD nBufferLength,
                                                   LPSTR lpBuffer
    );




__declspec(dllimport)
UINT
__stdcall
GetTempFileNameA(
         LPCSTR lpPathName,
         LPCSTR lpPrefixString,
         UINT uUnique,
                           LPSTR lpTempFileName
    );
#line 4453 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)

UINT
__stdcall
GetSystemWow64DirectoryA(
                                           LPSTR lpBuffer,
         UINT uSize
    );
__declspec(dllimport)

UINT
__stdcall
GetSystemWow64DirectoryW(
                                           LPWSTR lpBuffer,
         UINT uSize
    );






__declspec(dllimport)
BOOLEAN
__stdcall
Wow64EnableWow64FsRedirection (
         BOOLEAN Wow64FsEnableRedirection
    );




typedef UINT (__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_A)( LPSTR lpBuffer, UINT uSize);
typedef UINT (__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_W)( LPWSTR lpBuffer, UINT uSize);
#line 4553 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
SetDllDirectoryA(
             LPCSTR lpPathName
    );
__declspec(dllimport)
BOOL
__stdcall
SetDllDirectoryW(
             LPCWSTR lpPathName
    );






__declspec(dllimport)

DWORD
__stdcall
GetDllDirectoryA(
         DWORD nBufferLength,
                                                   LPSTR lpBuffer
    );
__declspec(dllimport)

DWORD
__stdcall
GetDllDirectoryW(
         DWORD nBufferLength,
                                                   LPWSTR lpBuffer
    );
#line 4600 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
SetSearchPathMode (
         DWORD Flags
    );
#line 4639 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExA(
             LPCSTR lpTemplateDirectory,
             LPCSTR lpNewDirectory,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExW(
             LPCWSTR lpTemplateDirectory,
             LPCWSTR lpNewDirectory,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#line 4663 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryTransactedA(
             LPCSTR lpTemplateDirectory,
             LPCSTR lpNewDirectory,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryTransactedW(
             LPCWSTR lpTemplateDirectory,
             LPCWSTR lpNewDirectory,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes,
             HANDLE hTransaction
    );






__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryTransactedA(
         LPCSTR lpPathName,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryTransactedW(
         LPCWSTR lpPathName,
             HANDLE hTransaction
    );






__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameTransactedA(
                    LPCSTR lpFileName,
                    DWORD nBufferLength,
                                                   LPSTR lpBuffer,
                 LPSTR *lpFilePart,
                    HANDLE hTransaction
    );
__declspec(dllimport)

DWORD
__stdcall
GetFullPathNameTransactedW(
                    LPCWSTR lpFileName,
                    DWORD nBufferLength,
                                                   LPWSTR lpBuffer,
                 LPWSTR *lpFilePart,
                    HANDLE hTransaction
    );
#line 4743 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceA(
             DWORD dwFlags,
             LPCSTR lpDeviceName,
             LPCSTR lpTargetPath
    );




__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceA(
             LPCSTR lpDeviceName,
                                         LPSTR lpTargetPath,
             DWORD ucchMax
    );
#line 4771 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
HANDLE
__stdcall
CreateFileTransactedA(
               LPCSTR lpFileName,
               DWORD dwDesiredAccess,
               DWORD dwShareMode,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
               DWORD dwCreationDisposition,
               DWORD dwFlagsAndAttributes,
               HANDLE hTemplateFile,
               HANDLE hTransaction,
               PUSHORT pusMiniVersion,
               PVOID lpExtendedParameter
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateFileTransactedW(
               LPCWSTR lpFileName,
               DWORD dwDesiredAccess,
               DWORD dwShareMode,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
               DWORD dwCreationDisposition,
               DWORD dwFlagsAndAttributes,
               HANDLE hTemplateFile,
               HANDLE hTransaction,
               PUSHORT pusMiniVersion,
               PVOID lpExtendedParameter
    );
#line 4812 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
HANDLE
__stdcall
ReOpenFile(
         HANDLE hOriginalFile,
         DWORD dwDesiredAccess,
         DWORD dwShareMode,
         DWORD dwFlagsAndAttributes
    );






__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesTransactedA(
             LPCSTR lpFileName,
             DWORD dwFileAttributes,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesTransactedW(
             LPCWSTR lpFileName,
             DWORD dwFileAttributes,
             HANDLE hTransaction
    );






__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesTransactedA(
          LPCSTR lpFileName,
          GET_FILEEX_INFO_LEVELS fInfoLevelId,
                                                          LPVOID lpFileInformation,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesTransactedW(
          LPCWSTR lpFileName,
          GET_FILEEX_INFO_LEVELS fInfoLevelId,
                                                          LPVOID lpFileInformation,
             HANDLE hTransaction
    );






__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeTransactedA(
              LPCSTR lpFileName,
              LPDWORD lpFileSizeHigh,
              HANDLE hTransaction
    );
__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeTransactedW(
              LPCWSTR lpFileName,
              LPDWORD lpFileSizeHigh,
              HANDLE hTransaction
    );






__declspec(dllimport)
BOOL
__stdcall
DeleteFileTransactedA(
             LPCSTR lpFileName,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
DeleteFileTransactedW(
             LPCWSTR lpFileName,
             HANDLE hTransaction
    );
#line 4949 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
CheckNameLegalDOS8Dot3A(
              LPCSTR lpName,
                                  LPSTR lpOemName,
              DWORD OemNameSize,
              PBOOL pbNameContainsSpaces ,
              PBOOL pbNameLegal
    );
__declspec(dllimport)
BOOL
__stdcall
CheckNameLegalDOS8Dot3W(
              LPCWSTR lpName,
                                  LPSTR lpOemName,
              DWORD OemNameSize,
              PBOOL pbNameContainsSpaces ,
              PBOOL pbNameLegal
    );
#line 4987 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileTransactedA(
               LPCSTR lpFileName,
               FINDEX_INFO_LEVELS fInfoLevelId,
                                                 LPVOID lpFindFileData,
               FINDEX_SEARCH_OPS fSearchOp,
               LPVOID lpSearchFilter,
               DWORD dwAdditionalFlags,
               HANDLE hTransaction
    );
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileTransactedW(
               LPCWSTR lpFileName,
               FINDEX_INFO_LEVELS fInfoLevelId,
                                                 LPVOID lpFindFileData,
               FINDEX_SEARCH_OPS fSearchOp,
               LPVOID lpSearchFilter,
               DWORD dwAdditionalFlags,
               HANDLE hTransaction
    );
#line 5028 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
CopyFileA(
         LPCSTR lpExistingFileName,
         LPCSTR lpNewFileName,
         BOOL bFailIfExists
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileW(
         LPCWSTR lpExistingFileName,
         LPCWSTR lpNewFileName,
         BOOL bFailIfExists
    );
#line 5080 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef
DWORD
(__stdcall *LPPROGRESS_ROUTINE)(
             LARGE_INTEGER TotalFileSize,
             LARGE_INTEGER TotalBytesTransferred,
             LARGE_INTEGER StreamSize,
             LARGE_INTEGER StreamBytesTransferred,
             DWORD dwStreamNumber,
             DWORD dwCallbackReason,
             HANDLE hSourceFile,
             HANDLE hDestinationFile,
             LPVOID lpData
    );

__declspec(dllimport)
BOOL
__stdcall
CopyFileExA(
                LPCSTR lpExistingFileName,
                LPCSTR lpNewFileName,
                LPPROGRESS_ROUTINE lpProgressRoutine,
                LPVOID lpData,

                LPBOOL pbCancel,
                DWORD dwCopyFlags
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileExW(
                LPCWSTR lpExistingFileName,
                LPCWSTR lpNewFileName,
                LPPROGRESS_ROUTINE lpProgressRoutine,
                LPVOID lpData,

                LPBOOL pbCancel,
                DWORD dwCopyFlags
    );
#line 5126 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
CopyFileTransactedA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             LPBOOL pbCancel,
             DWORD dwCopyFlags,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileTransactedW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             LPBOOL pbCancel,
             DWORD dwCopyFlags,
             HANDLE hTransaction
    );
#line 5170 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef enum _COPYFILE2_MESSAGE_TYPE {
     COPYFILE2_CALLBACK_NONE = 0,
     COPYFILE2_CALLBACK_CHUNK_STARTED,
     COPYFILE2_CALLBACK_CHUNK_FINISHED,
     COPYFILE2_CALLBACK_STREAM_STARTED,
     COPYFILE2_CALLBACK_STREAM_FINISHED,
     COPYFILE2_CALLBACK_POLL_CONTINUE,
     COPYFILE2_CALLBACK_ERROR,
     COPYFILE2_CALLBACK_MAX,
} COPYFILE2_MESSAGE_TYPE;

typedef enum _COPYFILE2_MESSAGE_ACTION {
    COPYFILE2_PROGRESS_CONTINUE = 0,
    COPYFILE2_PROGRESS_CANCEL,
    COPYFILE2_PROGRESS_STOP,
    COPYFILE2_PROGRESS_QUIET,
    COPYFILE2_PROGRESS_PAUSE,
} COPYFILE2_MESSAGE_ACTION;

typedef enum _COPYFILE2_COPY_PHASE {
    COPYFILE2_PHASE_NONE = 0,
    COPYFILE2_PHASE_PREPARE_SOURCE,
    COPYFILE2_PHASE_PREPARE_DEST,
    COPYFILE2_PHASE_READ_SOURCE,
    COPYFILE2_PHASE_WRITE_DESTINATION,
    COPYFILE2_PHASE_SERVER_COPY,
    COPYFILE2_PHASE_NAMEGRAFT_COPY,

    COPYFILE2_PHASE_MAX,
} COPYFILE2_COPY_PHASE;



typedef struct COPYFILE2_MESSAGE {

    COPYFILE2_MESSAGE_TYPE Type;
    DWORD dwPadding;

    union {

        struct {
            DWORD dwStreamNumber;
            DWORD dwReserved;
            HANDLE hSourceFile;
            HANDLE hDestinationFile;
            ULARGE_INTEGER uliChunkNumber;
            ULARGE_INTEGER uliChunkSize;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliTotalFileSize;
        } ChunkStarted;

        struct {
            DWORD dwStreamNumber;
            DWORD dwFlags;
            HANDLE hSourceFile;
            HANDLE hDestinationFile;
            ULARGE_INTEGER uliChunkNumber;
            ULARGE_INTEGER uliChunkSize;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliStreamBytesTransferred;
            ULARGE_INTEGER uliTotalFileSize;
            ULARGE_INTEGER uliTotalBytesTransferred;
        } ChunkFinished;

        struct {
            DWORD dwStreamNumber;
            DWORD dwReserved;
            HANDLE hSourceFile;
            HANDLE hDestinationFile;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliTotalFileSize;
        } StreamStarted;

        struct {
            DWORD dwStreamNumber;
            DWORD dwReserved;
            HANDLE hSourceFile;
            HANDLE hDestinationFile;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliStreamBytesTransferred;
            ULARGE_INTEGER uliTotalFileSize;
            ULARGE_INTEGER uliTotalBytesTransferred;
        } StreamFinished;

        struct {
            DWORD dwReserved;
        } PollContinue;

        struct {
            COPYFILE2_COPY_PHASE CopyPhase;
            DWORD dwStreamNumber;
            HRESULT hrFailure;
            DWORD dwReserved;
            ULARGE_INTEGER uliChunkNumber;
            ULARGE_INTEGER uliStreamSize;
            ULARGE_INTEGER uliStreamBytesTransferred;
            ULARGE_INTEGER uliTotalFileSize;
            ULARGE_INTEGER uliTotalBytesTransferred;
        } Error;

    } Info;

} COPYFILE2_MESSAGE;

typedef
COPYFILE2_MESSAGE_ACTION (__stdcall *PCOPYFILE2_PROGRESS_ROUTINE)(
            const COPYFILE2_MESSAGE *pMessage,
            PVOID pvCallbackContext
);

typedef struct COPYFILE2_EXTENDED_PARAMETERS {
  DWORD dwSize;
  DWORD dwCopyFlags;
  BOOL *pfCancel;
  PCOPYFILE2_PROGRESS_ROUTINE pProgressRoutine;
  PVOID pvCallbackContext;
} COPYFILE2_EXTENDED_PARAMETERS;

__declspec(dllimport)
HRESULT
__stdcall
CopyFile2(
            PCWSTR pwszExistingFileName,
            PCWSTR pwszNewFileName,
            COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters
);
#line 5307 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
MoveFileA(
         LPCSTR lpExistingFileName,
         LPCSTR lpNewFileName
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileW(
         LPCWSTR lpExistingFileName,
         LPCWSTR lpNewFileName
    );
#line 5353 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
MoveFileExA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
             DWORD dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileExW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
             DWORD dwFlags
    );
#line 5382 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             DWORD dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             DWORD dwFlags
    );
#line 5410 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
MoveFileTransactedA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             DWORD dwFlags,
             HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileTransactedW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
             LPPROGRESS_ROUTINE lpProgressRoutine,
             LPVOID lpData,
             DWORD dwFlags,
             HANDLE hTransaction
    );
#line 5463 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
ReplaceFileA(
               LPCSTR lpReplacedFileName,
               LPCSTR lpReplacementFileName,
               LPCSTR lpBackupFileName,
               DWORD dwReplaceFlags,
               LPVOID lpExclude,
               LPVOID lpReserved
    );
__declspec(dllimport)
BOOL
__stdcall
ReplaceFileW(
               LPCWSTR lpReplacedFileName,
               LPCWSTR lpReplacementFileName,
               LPCWSTR lpBackupFileName,
               DWORD dwReplaceFlags,
               LPVOID lpExclude,
               LPVOID lpReserved
    );
#line 5498 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkA(
               LPCSTR lpFileName,
               LPCSTR lpExistingFileName,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkW(
               LPCWSTR lpFileName,
               LPCWSTR lpExistingFileName,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
#line 5527 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkTransactedA(
               LPCSTR lpFileName,
               LPCSTR lpExistingFileName,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
               HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkTransactedW(
               LPCWSTR lpFileName,
               LPCWSTR lpExistingFileName,
               LPSECURITY_ATTRIBUTES lpSecurityAttributes,
               HANDLE hTransaction
    );
#line 5560 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef enum _STREAM_INFO_LEVELS {

    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel

} STREAM_INFO_LEVELS;

typedef struct _WIN32_FIND_STREAM_DATA {

    LARGE_INTEGER StreamSize;
    WCHAR cStreamName[ 260 + 36 ];

} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;

__declspec(dllimport)
HANDLE
__stdcall
FindFirstStreamW(
               LPCWSTR lpFileName,
               STREAM_INFO_LEVELS InfoLevel,
                                                       LPVOID lpFindStreamData,
               DWORD dwFlags
    );


__declspec(dllimport)
HANDLE
__stdcall
FindFirstStreamTransactedW (
               LPCWSTR lpFileName,
               STREAM_INFO_LEVELS InfoLevel,
                                                       LPVOID lpFindStreamData,
               DWORD dwFlags,
               HANDLE hTransaction
    );


__declspec(dllimport)
BOOL
__stdcall
FindNextStreamW(
          HANDLE hFindStream,
                                                       LPVOID lpFindStreamData
    );




__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileNameW (
            LPCWSTR lpFileName,
            DWORD dwFlags,
            LPDWORD StringLength,
                                PWSTR LinkName
    );

__declspec(dllimport)
BOOL
__stdcall
FindNextFileNameW (
            HANDLE hFindStream,
            LPDWORD StringLength,
                                PWSTR LinkName
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileNameTransactedW (
             LPCWSTR lpFileName,
             DWORD dwFlags,
             LPDWORD StringLength,
                                PWSTR LinkName,
             HANDLE hTransaction
    );



__declspec(dllimport)
HANDLE
__stdcall
CreateNamedPipeA(
             LPCSTR lpName,
             DWORD dwOpenMode,
             DWORD dwPipeMode,
             DWORD nMaxInstances,
             DWORD nOutBufferSize,
             DWORD nInBufferSize,
             DWORD nDefaultTimeOut,
             LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateA(
              HANDLE hNamedPipe,
              LPDWORD lpState,
              LPDWORD lpCurInstances,
              LPDWORD lpMaxCollectionCount,
              LPDWORD lpCollectDataTimeout,
                                       LPSTR lpUserName,
              DWORD nMaxUserNameSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateW(
              HANDLE hNamedPipe,
              LPDWORD lpState,
              LPDWORD lpCurInstances,
              LPDWORD lpMaxCollectionCount,
              LPDWORD lpCollectDataTimeout,
                                       LPWSTR lpUserName,
              DWORD nMaxUserNameSize
    );






__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeA(
          LPCSTR lpNamedPipeName,
                                        LPVOID lpInBuffer,
          DWORD nInBufferSize,
                                                            LPVOID lpOutBuffer,
          DWORD nOutBufferSize,
          LPDWORD lpBytesRead,
          DWORD nTimeOut
    );
__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeW(
          LPCWSTR lpNamedPipeName,
                                        LPVOID lpInBuffer,
          DWORD nInBufferSize,
                                                            LPVOID lpOutBuffer,
          DWORD nOutBufferSize,
          LPDWORD lpBytesRead,
          DWORD nTimeOut
    );






__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeA(
         LPCSTR lpNamedPipeName,
         DWORD nTimeOut
    );







__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientComputerNameA(
         HANDLE Pipe,
                                                  LPSTR ClientComputerName,
         ULONG ClientComputerNameLength
    );





__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientProcessId(
         HANDLE Pipe,
          PULONG ClientProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientSessionId(
         HANDLE Pipe,
          PULONG ClientSessionId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeServerProcessId(
         HANDLE Pipe,
          PULONG ServerProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeServerSessionId(
         HANDLE Pipe,
          PULONG ServerSessionId
    );



__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelA(
             LPCSTR lpRootPathName,
             LPCSTR lpVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelW(
             LPCWSTR lpRootPathName,
             LPCWSTR lpVolumeName
    );






__declspec(dllimport)
void
__stdcall
SetFileApisToOEM( void );

__declspec(dllimport)
void
__stdcall
SetFileApisToANSI( void );

__declspec(dllimport)
BOOL
__stdcall
AreFileApisANSI( void );

__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationA(
              LPCSTR lpRootPathName,
                                      LPSTR lpVolumeNameBuffer,
              DWORD nVolumeNameSize,
              LPDWORD lpVolumeSerialNumber,
              LPDWORD lpMaximumComponentLength,
              LPDWORD lpFileSystemFlags,
                                          LPSTR lpFileSystemNameBuffer,
              DWORD nFileSystemNameSize
    );







__declspec(dllimport)
BOOL
__stdcall
SetFileBandwidthReservation(
          HANDLE hFile,
          DWORD nPeriodMilliseconds,
          DWORD nBytesPerPeriod,
          BOOL bDiscardable,
          LPDWORD lpTransferSize,
          LPDWORD lpNumOutstandingRequests
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileBandwidthReservation(
          HANDLE hFile,
          LPDWORD lpPeriodMilliseconds,
          LPDWORD lpBytesPerPeriod,
          LPBOOL pDiscardable,
          LPDWORD lpTransferSize,
          LPDWORD lpNumOutstandingRequests
    );







__declspec(dllimport)
BOOL
__stdcall
ClearEventLogA (
             HANDLE hEventLog,
             LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
ClearEventLogW (
             HANDLE hEventLog,
             LPCWSTR lpBackupFileName
    );






__declspec(dllimport)
BOOL
__stdcall
BackupEventLogA (
         HANDLE hEventLog,
         LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
BackupEventLogW (
         HANDLE hEventLog,
         LPCWSTR lpBackupFileName
    );






__declspec(dllimport)
BOOL
__stdcall
CloseEventLog (
         HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
DeregisterEventSource (
         HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
NotifyChangeEventLog(
         HANDLE hEventLog,
         HANDLE hEvent
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumberOfEventLogRecords (
          HANDLE hEventLog,
          PDWORD NumberOfRecords
    );

__declspec(dllimport)
BOOL
__stdcall
GetOldestEventLogRecord (
          HANDLE hEventLog,
          PDWORD OldestRecord
    );

__declspec(dllimport)
HANDLE
__stdcall
OpenEventLogA (
             LPCSTR lpUNCServerName,
             LPCSTR lpSourceName
    );
__declspec(dllimport)
HANDLE
__stdcall
OpenEventLogW (
             LPCWSTR lpUNCServerName,
             LPCWSTR lpSourceName
    );






__declspec(dllimport)
HANDLE
__stdcall
RegisterEventSourceA (
             LPCSTR lpUNCServerName,
             LPCSTR lpSourceName
    );
__declspec(dllimport)
HANDLE
__stdcall
RegisterEventSourceW (
             LPCWSTR lpUNCServerName,
             LPCWSTR lpSourceName
    );






__declspec(dllimport)
HANDLE
__stdcall
OpenBackupEventLogA (
             LPCSTR lpUNCServerName,
             LPCSTR lpFileName
    );
__declspec(dllimport)
HANDLE
__stdcall
OpenBackupEventLogW (
             LPCWSTR lpUNCServerName,
             LPCWSTR lpFileName
    );






__declspec(dllimport)
BOOL
__stdcall
ReadEventLogA (
          HANDLE hEventLog,
          DWORD dwReadFlags,
          DWORD dwRecordOffset,
                                                              LPVOID lpBuffer,
          DWORD nNumberOfBytesToRead,
          DWORD *pnBytesRead,
          DWORD *pnMinNumberOfBytesNeeded
    );
__declspec(dllimport)
BOOL
__stdcall
ReadEventLogW (
          HANDLE hEventLog,
          DWORD dwReadFlags,
          DWORD dwRecordOffset,
                                                              LPVOID lpBuffer,
          DWORD nNumberOfBytesToRead,
          DWORD *pnBytesRead,
          DWORD *pnMinNumberOfBytesNeeded
    );






__declspec(dllimport)
BOOL
__stdcall
ReportEventA (
             HANDLE hEventLog,
             WORD wType,
             WORD wCategory,
             DWORD dwEventID,
             PSID lpUserSid,
             WORD wNumStrings,
             DWORD dwDataSize,
                                LPCSTR *lpStrings,
                                     LPVOID lpRawData
    );
__declspec(dllimport)
BOOL
__stdcall
ReportEventW (
             HANDLE hEventLog,
             WORD wType,
             WORD wCategory,
             DWORD dwEventID,
             PSID lpUserSid,
             WORD wNumStrings,
             DWORD dwDataSize,
                                LPCWSTR *lpStrings,
                                     LPVOID lpRawData
    );
#line 6068 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef struct _EVENTLOG_FULL_INFORMATION
{
    DWORD dwFull;
}
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetEventLogInformation (
          HANDLE hEventLog,
          DWORD dwInfoLevel,
                                                      LPVOID lpBuffer,
          DWORD cbBufSize,
          LPDWORD pcbBytesNeeded
    );
#line 6092 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef ULONG OPERATION_ID;





typedef struct _OPERATION_START_PARAMETERS {
    ULONG Version;
    OPERATION_ID OperationId;
    ULONG Flags;
} OPERATION_START_PARAMETERS, *POPERATION_START_PARAMETERS;







typedef struct _OPERATION_END_PARAMETERS {
    ULONG Version;
    OPERATION_ID OperationId;
    ULONG Flags;
} OPERATION_END_PARAMETERS, *POPERATION_END_PARAMETERS;



__declspec(dllimport)
BOOL
__stdcall
OperationStart (
         OPERATION_START_PARAMETERS* OperationStartParams
    );

__declspec(dllimport)
BOOL
__stdcall
OperationEnd (
         OPERATION_END_PARAMETERS* OperationEndParams
    );
#line 6140 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPSTR ObjectTypeName,
             LPSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
             DWORD DesiredAccess,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
             LPDWORD GrantedAccess,
             LPBOOL AccessStatus,
             LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPCSTR ObjectTypeName,
             LPCSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
             LPDWORD GrantedAccess,
             LPBOOL AccessStatus,
             LPBOOL pfGenerateOnClose
    );




__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPCSTR ObjectTypeName,
             LPCSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
                                             LPDWORD GrantedAccess,
                                             LPDWORD AccessStatusList,
             LPBOOL pfGenerateOnClose
    );




__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             HANDLE ClientToken,
             LPCSTR ObjectTypeName,
             LPCSTR ObjectName,
             PSECURITY_DESCRIPTOR SecurityDescriptor,
             PSID PrincipalSelfSid,
             DWORD DesiredAccess,
             AUDIT_EVENT_TYPE AuditType,
             DWORD Flags,
                                              POBJECT_TYPE_LIST ObjectTypeList,
             DWORD ObjectTypeListLength,
             PGENERIC_MAPPING GenericMapping,
             BOOL ObjectCreation,
                                             LPDWORD GrantedAccess,
                                             LPDWORD AccessStatusList,
             LPBOOL pfGenerateOnClose
    );





__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmA (
             LPCSTR SubsystemName,
             LPVOID HandleId,
             LPSTR ObjectTypeName,
             LPSTR ObjectName,
             PSECURITY_DESCRIPTOR pSecurityDescriptor,
             HANDLE ClientToken,
             DWORD DesiredAccess,
             DWORD GrantedAccess,
             PPRIVILEGE_SET Privileges,
             BOOL ObjectCreation,
             BOOL AccessGranted,
             LPBOOL GenerateOnClose
    );




__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         HANDLE ClientToken,
         DWORD DesiredAccess,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );




__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );




__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmA (
         LPCSTR SubsystemName,
         LPVOID HandleId,
         BOOL GenerateOnClose
    );




__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmA (
         LPCSTR SubsystemName,
         LPCSTR ServiceName,
         HANDLE ClientToken,
         PPRIVILEGE_SET Privileges,
         BOOL AccessGranted
    );





__declspec(dllimport)
BOOL
__stdcall
AddConditionalAce (
            PACL pAcl,
            DWORD dwAceRevision,
            DWORD AceFlags,
            UCHAR AceType,
            DWORD AccessMask,
            PSID pSid,
                           PWCHAR ConditionStr,
          DWORD *ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityA (
         LPCSTR lpFileName,
         SECURITY_INFORMATION SecurityInformation,
         PSECURITY_DESCRIPTOR pSecurityDescriptor
    );




__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityA (
          LPCSTR lpFileName,
          SECURITY_INFORMATION RequestedInformation,
                                                         PSECURITY_DESCRIPTOR pSecurityDescriptor,
          DWORD nLength,
          LPDWORD lpnLengthNeeded
    );





__declspec(dllimport)
BOOL
__stdcall
ReadDirectoryChangesW(
                HANDLE hDirectory,
                                                           LPVOID lpBuffer,
                DWORD nBufferLength,
                BOOL bWatchSubtree,
                DWORD dwNotifyFilter,
                LPDWORD lpBytesReturned,
                LPOVERLAPPED lpOverlapped,
                LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );




__declspec(dllimport)

LPVOID
__stdcall
MapViewOfFileExNuma(
             HANDLE hFileMappingObject,
             DWORD dwDesiredAccess,
             DWORD dwFileOffsetHigh,
             DWORD dwFileOffsetLow,
             SIZE_T dwNumberOfBytesToMap,
             LPVOID lpBaseAddress,
             DWORD nndPreferred
    );



__declspec(dllimport)
BOOL
__stdcall
IsBadReadPtr(
             const void *lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadWritePtr(
             LPVOID lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeReadPtr(
             const void *lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeWritePtr(
             LPVOID lp,
             UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadCodePtr(
             FARPROC lpfn
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrA(
             LPCSTR lpsz,
             UINT_PTR ucchMax
    );
__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrW(
             LPCWSTR lpsz,
             UINT_PTR ucchMax
    );






__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountSidA(
             LPCSTR lpSystemName,
         PSID Sid,
                                                LPSTR Name,
             LPDWORD cchName,
                                                                                LPSTR ReferencedDomainName,
            LPDWORD cchReferencedDomainName,
          PSID_NAME_USE peUse
    );
__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountSidW(
             LPCWSTR lpSystemName,
         PSID Sid,
                                                LPWSTR Name,
             LPDWORD cchName,
                                                                                LPWSTR ReferencedDomainName,
            LPDWORD cchReferencedDomainName,
          PSID_NAME_USE peUse
    );






__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountNameA(
             LPCSTR lpSystemName,
             LPCSTR lpAccountName,
                                              PSID Sid,
             LPDWORD cbSid,
                                                                                LPSTR ReferencedDomainName,
             LPDWORD cchReferencedDomainName,
             PSID_NAME_USE peUse
    );
__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountNameW(
             LPCWSTR lpSystemName,
             LPCWSTR lpAccountName,
                                              PSID Sid,
             LPDWORD cbSid,
                                                                                LPWSTR ReferencedDomainName,
             LPDWORD cchReferencedDomainName,
             PSID_NAME_USE peUse
    );
#line 6510 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountNameLocalA(
             LPCSTR lpAccountName,
                                              PSID Sid,
             LPDWORD cbSid,
                                                                                LPSTR ReferencedDomainName,
             LPDWORD cchReferencedDomainName,
             PSID_NAME_USE peUse
    );
__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountNameLocalW(
             LPCWSTR lpAccountName,
                                              PSID Sid,
             LPDWORD cbSid,
                                                                                LPWSTR ReferencedDomainName,
             LPDWORD cchReferencedDomainName,
             PSID_NAME_USE peUse
    );






__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountSidLocalA(
         PSID Sid,
                                                LPSTR Name,
             LPDWORD cchName,
                                                                                LPSTR ReferencedDomainName,
            LPDWORD cchReferencedDomainName,
          PSID_NAME_USE peUse
    );
__declspec(dllimport)
                           BOOL
__stdcall
LookupAccountSidLocalW(
         PSID Sid,
                                                LPWSTR Name,
             LPDWORD cchName,
                                                                                LPWSTR ReferencedDomainName,
            LPDWORD cchReferencedDomainName,
          PSID_NAME_USE peUse
    );
#line 6590 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueA(
             LPCSTR lpSystemName,
             LPCSTR lpName,
             PLUID lpLuid
    );
__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueW(
             LPCWSTR lpSystemName,
             LPCWSTR lpName,
             PLUID lpLuid
    );






__declspec(dllimport)
                           BOOL
__stdcall
LookupPrivilegeNameA(
             LPCSTR lpSystemName,
             PLUID lpLuid,
                                                LPSTR lpName,
             LPDWORD cchName
    );
__declspec(dllimport)
                           BOOL
__stdcall
LookupPrivilegeNameW(
             LPCWSTR lpSystemName,
             PLUID lpLuid,
                                                LPWSTR lpName,
             LPDWORD cchName
    );






__declspec(dllimport)
                           BOOL
__stdcall
LookupPrivilegeDisplayNameA(
             LPCSTR lpSystemName,
             LPCSTR lpName,
                                                              LPSTR lpDisplayName,
             LPDWORD cchDisplayName,
             LPDWORD lpLanguageId
    );
__declspec(dllimport)
                           BOOL
__stdcall
LookupPrivilegeDisplayNameW(
             LPCWSTR lpSystemName,
             LPCWSTR lpName,
                                                              LPWSTR lpDisplayName,
             LPDWORD cchDisplayName,
             LPDWORD lpLanguageId
    );






__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBA(
          LPCSTR lpDef,
          LPDCB lpDCB
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBW(
          LPCWSTR lpDef,
          LPDCB lpDCB
    );






__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsA(
          LPCSTR lpDef,
          LPDCB lpDCB,
          LPCOMMTIMEOUTS lpCommTimeouts
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsW(
          LPCWSTR lpDef,
          LPDCB lpDCB,
          LPCOMMTIMEOUTS lpCommTimeouts
    );






__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogA(
             LPCSTR lpszName,
             HWND hWnd,
             LPCOMMCONFIG lpCC
    );
__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogW(
             LPCWSTR lpszName,
             HWND hWnd,
             LPCOMMCONFIG lpCC
    );






__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigA(
            LPCSTR lpszName,
                                                LPCOMMCONFIG lpCC,
            LPDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigW(
            LPCWSTR lpszName,
                                                LPCOMMCONFIG lpCC,
            LPDWORD lpdwSize
    );






__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigA(
         LPCSTR lpszName,
                             LPCOMMCONFIG lpCC,
         DWORD dwSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigW(
         LPCWSTR lpszName,
                             LPCOMMCONFIG lpCC,
         DWORD dwSize
    );
#line 6776 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)

BOOL
__stdcall
GetComputerNameA (
                                            LPSTR lpBuffer,
            LPDWORD nSize
    );
__declspec(dllimport)

BOOL
__stdcall
GetComputerNameW (
                                            LPWSTR lpBuffer,
            LPDWORD nSize
    );






__declspec(dllimport)
BOOL
__stdcall
SetComputerNameA (
         LPCSTR lpComputerName
    );
__declspec(dllimport)
BOOL
__stdcall
SetComputerNameW (
         LPCWSTR lpComputerName
    );
#line 6819 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExA (
         COMPUTER_NAME_FORMAT NameType,
         LPCSTR lpBuffer
    );





__declspec(dllimport)

BOOL
__stdcall
DnsHostnameToComputerNameA (
            LPCSTR Hostname,
                                            LPSTR ComputerName,
            LPDWORD nSize
    );
__declspec(dllimport)

BOOL
__stdcall
DnsHostnameToComputerNameW (
            LPCWSTR Hostname,
                                            LPWSTR ComputerName,
            LPDWORD nSize
    );
#line 6857 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
GetUserNameA (
                                                LPSTR lpBuffer,
            LPDWORD pcbBuffer
    );
__declspec(dllimport)
BOOL
__stdcall
GetUserNameW (
                                                LPWSTR lpBuffer,
            LPDWORD pcbBuffer
    );
#line 6905 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
LogonUserA (
                LPCSTR lpszUsername,
                LPCSTR lpszDomain,
                LPCSTR lpszPassword,
                DWORD dwLogonType,
                DWORD dwLogonProvider,
             PHANDLE phToken
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserW (
                LPCWSTR lpszUsername,
                LPCWSTR lpszDomain,
                LPCWSTR lpszPassword,
                DWORD dwLogonType,
                DWORD dwLogonProvider,
             PHANDLE phToken
    );






__declspec(dllimport)
BOOL
__stdcall
LogonUserExA (
                    LPCSTR lpszUsername,
                    LPCSTR lpszDomain,
                    LPCSTR lpszPassword,
                    DWORD dwLogonType,
                    DWORD dwLogonProvider,
                 PHANDLE phToken,
                 PSID *ppLogonSid,
                                                          PVOID *ppProfileBuffer,
                    LPDWORD pdwProfileLength,
                    PQUOTA_LIMITS pQuotaLimits
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserExW (
                    LPCWSTR lpszUsername,
                    LPCWSTR lpszDomain,
                    LPCWSTR lpszPassword,
                    DWORD dwLogonType,
                    DWORD dwLogonProvider,
                 PHANDLE phToken,
                 PSID *ppLogonSid,
                                                          PVOID *ppProfileBuffer,
                    LPDWORD pdwProfileLength,
                    PQUOTA_LIMITS pQuotaLimits
    );
#line 6975 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserA (
                HANDLE hToken,
                LPCSTR lpApplicationName,
                LPSTR lpCommandLine,
                LPSECURITY_ATTRIBUTES lpProcessAttributes,
                LPSECURITY_ATTRIBUTES lpThreadAttributes,
                BOOL bInheritHandles,
                DWORD dwCreationFlags,
                LPVOID lpEnvironment,
                LPCSTR lpCurrentDirectory,
                LPSTARTUPINFOA lpStartupInfo,
                LPPROCESS_INFORMATION lpProcessInformation
    );
#line 7005 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
                      BOOL
__stdcall
CreateProcessWithLogonW(
                LPCWSTR lpUsername,
                LPCWSTR lpDomain,
                LPCWSTR lpPassword,
                DWORD dwLogonFlags,
                LPCWSTR lpApplicationName,
                LPWSTR lpCommandLine,
                DWORD dwCreationFlags,
                LPVOID lpEnvironment,
                LPCWSTR lpCurrentDirectory,
                LPSTARTUPINFOW lpStartupInfo,
                LPPROCESS_INFORMATION lpProcessInformation
      );

__declspec(dllimport)
                      BOOL
__stdcall
CreateProcessWithTokenW(
                HANDLE hToken,
                DWORD dwLogonFlags,
                LPCWSTR lpApplicationName,
                LPWSTR lpCommandLine,
                DWORD dwCreationFlags,
                LPVOID lpEnvironment,
                LPCWSTR lpCurrentDirectory,
                LPSTARTUPINFOW lpStartupInfo,
                LPPROCESS_INFORMATION lpProcessInformation
      );



__declspec(dllimport)
BOOL
__stdcall
IsTokenUntrusted(
         HANDLE TokenHandle
    );







__declspec(dllimport)
BOOL
__stdcall
RegisterWaitForSingleObject(
             PHANDLE phNewWaitObject,
                HANDLE hObject,
                WAITORTIMERCALLBACK Callback,
                PVOID Context,
                ULONG dwMilliseconds,
                ULONG dwFlags
    );

__declspec(dllimport)

BOOL
__stdcall
UnregisterWait(
         HANDLE WaitHandle
    );

__declspec(dllimport)
BOOL
__stdcall
BindIoCompletionCallback (
         HANDLE FileHandle,
         LPOVERLAPPED_COMPLETION_ROUTINE Function,
         ULONG Flags
    );

__declspec(dllimport)
HANDLE
__stdcall
SetTimerQueueTimer(
             HANDLE TimerQueue,
             WAITORTIMERCALLBACK Callback,
             PVOID Parameter,
             DWORD DueTime,
             DWORD Period,
             BOOL PreferIo
    );

__declspec(dllimport)

BOOL
__stdcall
CancelTimerQueueTimer(
             HANDLE TimerQueue,
             HANDLE Timer
    );

__declspec(dllimport)

BOOL
__stdcall
DeleteTimerQueue(
         HANDLE TimerQueue
    );





__forceinline
void
InitializeThreadpoolEnvironment(
          PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpInitializeCallbackEnviron(pcbe);
}

__forceinline
void
SetThreadpoolCallbackPool(
            PTP_CALLBACK_ENVIRON pcbe,
            PTP_POOL ptpp
    )
{
    TpSetCallbackThreadpool(pcbe, ptpp);
}

__forceinline
void
SetThreadpoolCallbackCleanupGroup(
             PTP_CALLBACK_ENVIRON pcbe,
             PTP_CLEANUP_GROUP ptpcg,
             PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng
    )
{
    TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
}

__forceinline
void
SetThreadpoolCallbackRunsLong(
            PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackLongFunction(pcbe);
}

__forceinline
void
SetThreadpoolCallbackLibrary(
            PTP_CALLBACK_ENVIRON pcbe,
            PVOID mod
    )
{
    TpSetCallbackRaceWithDll(pcbe, mod);
}



__forceinline
void
SetThreadpoolCallbackPriority(
            PTP_CALLBACK_ENVIRON pcbe,
            TP_CALLBACK_PRIORITY Priority
    )
{
    TpSetCallbackPriority(pcbe, Priority);
}



__forceinline
void
SetThreadpoolCallbackPersistent(
            PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackPersistent(pcbe);
}

__forceinline
void
DestroyThreadpoolEnvironment(
            PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpDestroyCallbackEnviron(pcbe);
}







__declspec(dllimport)

HANDLE
__stdcall
CreatePrivateNamespaceA(
             LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
             LPVOID lpBoundaryDescriptor,
             LPCSTR lpAliasPrefix
    );







__declspec(dllimport)

HANDLE
__stdcall
OpenPrivateNamespaceA(
             LPVOID lpBoundaryDescriptor,
             LPCSTR lpAliasPrefix
    );
#line 7237 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)

HANDLE
__stdcall
CreateBoundaryDescriptorA(
         LPCSTR Name,
         ULONG Flags
    );
#line 7253 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
__declspec(dllimport)
BOOL
__stdcall
AddIntegrityLabelToBoundaryDescriptor(
            HANDLE * BoundaryDescriptor,
         PSID IntegrityLabel
    );
#line 7281 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
typedef struct tagHW_PROFILE_INFOA {
    DWORD dwDockInfo;
    CHAR szHwProfileGuid[39];
    CHAR szHwProfileName[80];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
    DWORD dwDockInfo;
    WCHAR szHwProfileGuid[39];
    WCHAR szHwProfileName[80];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;

typedef HW_PROFILE_INFOW HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOW LPHW_PROFILE_INFO;






__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileA (
          LPHW_PROFILE_INFOA lpHwProfileInfo
    );
__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileW (
          LPHW_PROFILE_INFOW lpHwProfileInfo
    );







__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoA(
            LPOSVERSIONINFOEXA lpVersionInformation,
            DWORD dwTypeMask,
            DWORDLONG dwlConditionMask
    );
__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoW(
            LPOSVERSIONINFOEXW lpVersionInformation,
            DWORD dwTypeMask,
            DWORDLONG dwlConditionMask
    );
#line 7349 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"
#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\winerror.h"
#line 26219 "C:/Program Files (x86)/Windows Kits/8.1/Include/shared\\winerror.h"
__forceinline HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (7 << 16) | 0x80000000);}
#line 7349 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\winbase.h"

#line 1 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\timezoneapi.h"
#line 34 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\timezoneapi.h"
extern "C" {
#line 47 "C:/Program Files (x86)/Windows Kits/8.1/Include/um\\timezoneapi.h"
typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[ 128 ];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;

__declspec(dllimport)

BOOL
__stdcall
SystemTimeToTzSpecificLocalTime(
             const TIME_ZONE_INFORMATION * lpTimeZoneInformation,
         const SYSTEMTIME * lpUniversalTime,
          LPSYSTEMTIME lpLocalTime
    );


__declspec(dllimport)

BOOL
__stdcall
TzSpecificLocalTimeToSystemTime(
             const TIME_ZONE_INFORMATION * lpTimeZoneInformation,
         const SYSTEMTIME * lpLocalTime,
          LPSYSTEMTIME lpUniversalTime
    );


__declspec(dllimport)

BOOL
__stdcall
Fi